{
    "007bbfb7.json": "1. Create a 9x9 output grid, initialized with all 0s.\n2. Iterate through each cell (r, c) of the 3x3 input grid, where r is the row index and c is the column index, both starting from 0.\n3. If the value at input grid cell (r, c) is V (V can be any digit from 0-9):\n    a.  Copy the value V to the corresponding 3x3 block in the output grid. The top-left corner of this block is located at (3*r, 3*c) in the output grid.\n    b. Specifically, assign output[3*r][3*c] = V, output[3*r+1][3*c] = V, output[3*r+2][3*c] = V, output[3*r][3*c+1] = V, output[3*r+1][3*c+1] = V, output[3*r+2][3*c+1] = V, output[3*r][3*c+2] = V, output[3*r+1][3*c+2] = V, and output[3*r+2][3*c+2] = V.",
    "00d62c1b.json": "1. Copy the input grid to the output grid. 2. For each pixel in the output grid: 3. If a pixel with value 0 is completely surrounded by pixels with value 3, change the value of that pixel to 4.",
    "017c7c7b.json": "1. Take the input grid.\n2. Create an output grid. The output grid has a height equal to 1.5 times the height of the input grid, rounded up to the nearest integer. The width of the output grid is the same as the width of the input grid.\n3. Copy the values from the input grid to the top rows of the output grid, maintaining the same row and column indices.\n4. Calculate the number of remaining rows to fill in the output grid (output height - input height).\n5. Copy the top rows from the input grid to the remaining rows of the output grid. Specifically, copy rows 0, 1, and 2 of the input grid to rows that are more than the original height. Do this until the output grid is full.\n6. In the output grid, change all pixel values equal to 1 to 2.",
    "025d127b.json": "1. Copy the input grid to the output grid.\n2. Find the lowest row (R) containing a non-zero value.\n3. For each row from the second row from the bottom row (R+1) to the top row:\n    a. Shift all non-zero values in that row one column to the left, filling the vacated space with 0.",
    "045e512c.json": "1. Analyze the input grid and identify all non-zero shapes present.\n2. For each non-zero shape, determine its color (represented by a digit from 1-9).\n3. Identify the largest shape in the input grid.\n4. For each of the smaller shapes, replicate the shape of the largest shape, using the color of the smaller shape. The replicated shape should be placed such that it expands outwards from the existing smaller shape.\n5. Continue replicating the shape with the same color and spacing until the edge of the grid is reached in all directions.\n6. Fill the grid with the new shapes.",
    "0520fde7.json": "1. Divide the input grid into two sub-grids by splitting it along the column containing the value 5. The left sub-grid contains the columns to the left of the 5, and the right sub-grid contains the columns to the right of the 5. Do not include the column with 5 in either subgrid.\n2. Create an output grid. The output grid's dimensions are equal to the dimensions of one of the subgrids.\n3. Iterate through each cell in the output grid, indexed by row R and column C.\n4. Compare the pixel value at (R, C) in the left sub-grid with the pixel value at (R, C) in the right sub-grid.\n5. If the pixel value at (R, C) in the left sub-grid is 1 AND the pixel value at (R, C) in the right sub-grid is 1, then set the pixel value at (R, C) in the output grid to 2.\n6. Otherwise, set the pixel value at (R, C) in the output grid to 0.",
    "05269061.json": "1. Get the input grid.\n2. Create an output grid with the same dimensions as the input grid.\n3. For each row in the output grid, repeat the row pattern `R` obtained from the input grid until the row is filled. Where the pattern `R` is defined by the non-zero elements on the diagonal of the input, from top-left to bottom-right.\n4. Output the modified grid.",
    "05f2a901.json": "1. Locate the shape consisting of pixel value 8.\n2. Locate the shape consisting of pixel value 2.\n3. Move the shape consisting of pixel value 2 directly towards the shape consisting of pixel value 8 until they are touching. The shape consisting of pixel value 8 stays in the same location.",
    "06df4c85.json": "1. The output grid has the same dimensions as the input grid.\n2. If a 2x2 square in the input grid is filled with the same non-0 color, then fill the corresponding 2x2 square in the output grid with that same color. Specifically, consider the 2x2 block at row R and column C. If input[R][C] == input[R+1][C] == input[R][C+1] == input[R+1][C+1] and input[R][C] != 0, then set output[R][C] = output[R+1][C] = output[R][C+1] = output[R+1][C+1] = input[R][C].\n3. If a pixel at (R,C) in the input grid has value 8, the output grid pixel at (R,C) will also have value 8.\n",
    "08ed6ac7.json": "1. Maintain the input grid's dimensions.\n2. Identify columns containing the value 5. Treat each such column as a \"bar\".\n3. Within each \"bar\" column, determine the number of contiguous 5s starting from the top. This represents the height of the bar.\n4. Within each pair of bars, rank the bar heights from tallest to shortest.\n5. In each pair of bars, change the pixel values in each column from top to bottom, where the tallest bar's original values are changed to 1, the second tallest bar's original values are changed to 2, the third tallest bar's original values are changed to 3, and the shortest bar's original values are changed to 4. If a bar's height is 0, leave the column unchanged.",
    "09629e4f.json": "1. Locate the central 3x3 subgrid within the input grid, starting at row and column index 4, and ending at row and column index 6. The central element of this subgrid is always 5. The rows above and below and the columns to the left and right of this 3x3 grid will be referred to as the surrounding rows and columns, respectively.\n2. For each 3x3 subgrid in the input which is not already fully comprised of the value 5, locate the corresponding 3x3 subgrid in the output. Set the value of each cell in the output 3x3 subgrid to the color value of the corresponding cell in the surrounding rows and columns of the central 3x3 subgrid in the input.\n3. Copy the row and column of 5's from the input to the output.",
    "0962bcdd.json": "1. Find all locations of non-zero pixel values in the input grid. Treat each of these as the center of a cross pattern.\n2. For each center (R, C) with value V, set the pixel values at the following coordinates to V: (R-2, C), (R-1, C-1), (R-1, C), (R-1, C+1), (R, C-2), (R, C-1), (R, C), (R, C+1), (R, C+2), (R+1, C-1), (R+1, C), (R+1, C+1), (R+2, C).\n3. If any coordinate falls outside the grid boundaries, skip setting the pixel value for that coordinate.",
    "0a938d79.json": "1. Find the first non-zero pixel value in the input grid. Let this value be 'A'.\n2. Find the second non-zero pixel value in the input grid. Let this value be 'B'.\n3. Iterate through the rows of the output grid, starting from the first row.\n4. In each row, repeat the sequence 'A', then 'B', filling the row from left to right.",
    "0b148d64.json": "1. Identify four distinct areas in the input grid. Three areas share one color, and one area has a different color.\n2. Determine the color of the area that differs from the other three. Let this color be 'X'.\n3. Determine the dimensions (rows 'R' and columns 'C') of the area with color 'X'.\n4. Create an output grid with dimensions R rows and C columns.\n5. Copy the contents of the area with color 'X' from the input grid to the output grid, maintaining the relative positions of the pixel values.",
    "0ca9ddb6.json": "1. Create an output grid with the same dimensions as the input grid. Initialize all values in the output grid to 0.\n2. Iterate through each cell (R, C) in the input grid.\n3. If the pixel value at (R, C) in the input grid is 2, then set the pixel values at the following locations in the output grid to 4:\n    a. (R-1, C-1)\n    b. (R-1, C+1)\n    c. (R+1, C-1)\n    d. (R+1, C+1)\n4. If the pixel value at (R, C) in the input grid is 1, then set the pixel values at the following locations in the output grid to 7:\n    a. (R-1, C)\n    b. (R+1, C)\n    c. (R, C-1)\n    d. (R, C+1)\n5. Copy the original pixel values from the input grid to the output grid.\n",
    "0d3d703e.json": "1. Input is a 3x3 grid of numbers 0-9.\n2. Output is a 3x3 grid of numbers 0-9.\n3. Examine the values in the first column. If the value is 3, change it to 4. If the value is 2, change it to 6. If the value is 5, change it to 1. If the value is 9, change it to 8. If the value is 8, change it to 9.\n4. Examine the values in the second column. If the value is 1, change it to 5. If the value is 3, change it to 4. If the value is 8, change it to 9. If the value is 4, change it to 3.\n5. Examine the values in the third column. If the value is 2, change it to 6. If the value is 8, change it to 9. If the value is 6, change it to 2.",
    "0dfd9992.json": "1. Copy the input grid to the output grid.\n2. For each black pixel (pixel value 0) in the output grid, fill it with a value based on the repeating pattern in the column above. Specifically, set the pixel value at (R, C) to the pixel value at (R-N, C), where N is the height of the repeating pattern, determined empirically for each column. For example, if column C repeats every 5 rows, then pixel (R, C) gets the value of pixel (R-5, C). If R-N < 0, find a positive integer k such that R + k*N is a valid index. In effect, loop vertically within each column to propagate/fill the initial pattern.",
    "0e206a2e.json": "1. The output grid has the same dimensions as the input grid.\n2. Identify the non-zero pixel values in the input grid.\n3. For each non-zero pixel value in the input at location (R, C), copy that pixel value to a new location in the output grid. The new location's row and column depend on the specific example.\n4. Example 1: Pixel values 1, 3, 4 and 8 in the input are transferred to the output to create the output shape, retaining their original values.\n5. Example 2: Pixel values 1, 2, 3 and 4 in the input are transferred to the output to create the output shape, retaining their original values.\n6. Example 3: Pixel values 1, 2, 4 and 8 in the input are transferred to the output to create the output shape, retaining their original values.",
    "10fcaaa3.json": "1. Let the input grid have dimensions H x W.\n2. Create an output grid with dimensions 2H x 2W.\n3. For each pixel value X (where X is not 0) in the input grid at row R and column C:\n    a. Set the output grid pixel at (R, C) to X.\n    b. Set the output grid pixel at (R, C + W) to X.\n    c. Set the output grid pixel at (R + H, C) to X.\n    d. Set the output grid pixel at (R + H, C + W) to X.\n4. For each pixel value X (where X is not 0) in the output grid at row R and column C:\n    a. If the pixel at (R - 1, C - 1) is within the bounds of the output grid and has a value of 0, set the pixel at (R - 1, C - 1) to 8.\n    b. If the pixel at (R - 1, C + 1) is within the bounds of the output grid and has a value of 0, set the pixel at (R - 1, C + 1) to 8.\n    c. If the pixel at (R + 1, C - 1) is within the bounds of the output grid and has a value of 0, set the pixel at (R + 1, C - 1) to 8.\n    d. If the pixel at (R + 1, C + 1) is within the bounds of the output grid and has a value of 0, set the pixel at (R + 1, C + 1) to 8.",
    "11852cab.json": "1. The output grid has the same dimensions as the input grid.\n2. Iterate through each row in the input grid.\n3. If a row contains non-zero numbers, then copy the content of the row to a new row that is symmetric about the center. For example, if the input row is \"0|1|0|4|0|1|0|0|0|0\", the new row will be \"0|1|0|4|0|1|0|1|0|0\".\n4. The center of symmetry is between column (width / 2 - 1) and column (width / 2) if the width of the grid is even.\n5. If a row contains only zero numbers, then fill the corresponding row in the output grid with zeros.",
    "1190e5a7.json": "1. Identify horizontal lines. A horizontal line is a row where all values are the same.\n2. Identify vertical lines. A vertical line is a column where all values are the same.\n3. Determine the height of the output grid. The height is the number of horizontal lines in the input grid minus 1.\n4. Determine the width of the output grid. The width is the number of vertical lines in the input grid minus 1.\n5. Determine the dominant color. The dominant color is the non-line color.\n6. Create the output grid with the determined width and height.\n7. Fill the entire output grid with the dominant color.",
    "137eaa0f.json": "1. Find all distinct non-zero objects in the input grid.\n2. For each distinct non-zero object, locate the pixel with value 5 (grey). If multiple pixels have value 5, choose only one of them.\n3. Create a 3x3 output grid for each located pixel with value 5.\n4. Place each distinct non-zero object to the corresponding 3x3 grid so that the pixel with value 5 (grey) from the input is at the center (1, 1) of the 3x3 output grid.\n5. If any part of the object goes beyond the grid boundaries, clip it.\n6. The background of the 3x3 grid should be 0 (black).",
    "150deff5.json": "1. Read the input grid.\n2. Iterate through each pixel in the input grid.\n3. If a pixel value is 5, check for 2x2 squares of value 5. If a 2x2 square of 5s is found, change the 2x2 square to 8.\n4. After checking for 2x2 squares, iterate through the grid again.\n5. If a pixel value is 5, change it to 2.",
    "178fcbfb.json": "1. Read the input grid dimensions (rows and columns). Let the number of rows be R and the number of columns be C.\n2. Create an output grid with the same dimensions (R x C) as the input grid.\n3. Iterate through each cell in the input grid, row by row, from top to bottom, and column by column, from left to right. Let the current cell's row index be r and the column index be c.\n4. If the value of the cell at (r, c) in the input grid is 2, set all the cells in column c of the output grid to 2.\n5. If the value of the cell at (r, c) in the input grid is 3, set all the cells in row r of the output grid to 3.\n6. If the value of the cell at (r, c) in the input grid is 1, set all the cells in row r of the output grid to 1.\n7. The order in which 1, 2 and 3 are processed matters. Row-wise (1,3) is processed before column-wise (2).\n8. Return the output grid.",
    "1a07d186.json": "1. Identify horizontal or vertical lines of the same non-zero pixel value in the input grid. A 'line' is defined as a contiguous sequence of the same pixel value with length greater than 1.\n2. Identify single, isolated non-zero pixels in the input grid. A 'single pixel' is a non-zero pixel that is not part of a line (as defined in step 1), meaning it has zero-valued neighbors directly above, below, to the left and to the right.\n3. For each 'single pixel', move its value horizontally or vertically until it touches a line of the same pixel value.\n4. If a 'single pixel' is moved, the original location of the 'single pixel' is set to 0.\n5. Any other non-zero pixels that are not part of the lines of the first color identified in the input grid, or that are not part of lines with the same value of the original single squares, are set to 0. ",
    "1b2d62fb.json": "1. Divide the input grid into two subgrids by splitting it at the column where the value is 1. The input grid has a vertical line of 1s separating the two patterns.\n2. Compare the two subgrids row by row.\n3. Create an output grid. The output grid has the same number of rows as the input subgrids and 3 columns.\n4. For each row, if the values at the corresponding positions in both subgrids are 0, set the value in the output grid to 0.\n5. For each row, if either of the values at the corresponding positions in the two subgrids is not 0, set the corresponding value in the output grid to 8.",
    "1b60fb0c.json": "1. Iterate through each row of the input grid. Let R be the current row index (starting from 0). Let C be the column index (starting from 0).\n2. Identify pixels with value 1 in the input grid.\n3. For each pixel with value 1 at position (R, C) in the input grid, if there are no other 1 values to the left of that pixel in the same row, create corresponding pixel(s) with value 2 in the output grid.\n4. Determine the coordinates of the new pixel(s) with value 2 based on the location of the existing pixel with value 1, copying the pattern to the left.\n5. Copy all other pixel values (including 0 and original 1's) from the input to the output.\n6. Maintain the same grid dimensions from the input to the output.",
    "1bfc4729.json": "1. Identify the first non-zero pixel value in the input grid. Store this value as the 'top_color'.\n2. Identify the last non-zero pixel value in the input grid. Store this value as the 'bottom_color'.\n3. Create a 10x10 output grid.\n4. Fill the first row of the output grid with the 'top_color'.\n5. Fill the last row of the output grid with the 'bottom_color'.\n6. Set the pixel value at (0, 0) and (0, 9) to 'top_color'.\n7. Set the pixel value at (1, 0) and (1, 9) to 'top_color'.\n8. Fill the third row of the output grid with 'top_color'.\n9. Set the pixel value at (3, 0) and (3, 9) to 'top_color'.\n10. Set the pixel value at (4, 0) and (4, 9) to 'top_color'.\n11. Set the pixel value at (5, 0) and (5, 9) to 'bottom_color'.\n12. Set the pixel value at (6, 0) and (6, 9) to 'bottom_color'.\n13. Fill the eighth row of the output grid with 'bottom_color'.\n14. Set the pixel value at (8, 0) and (8, 9) to 'bottom_color'.\n15. Set the pixel value at (9, 0) and (9, 9) to 'bottom_color'.",
    "1c786137.json": "1. Find the minimum row R_min and maximum row R_max such that all pixels in the range [R_min, R_max] of a single column C have the same color.\n2. Find the minimum column C_min and maximum column C_max such that all pixels in the range [C_min, C_max] of a single row R have the same color.\n3. The output grid is the subgrid of the input grid bounded by R_min, R_max, C_min, and C_max.",
    "1caeab9d.json": "1. Find the topmost row containing a value of 1. Store this row index as the target row. If no 1 is present, proceed as if row 0 contains 1.\n2. For each other color (2 and 4 in the examples), find the topmost row containing that color.\n3. For each color other than 1 (2 and 4):\n    a. Calculate the difference between the target row and the topmost row of that color.\n    b. Move the shape of that color up or down by that difference so that it's located vertically at the target row.\n4. The grid size remains the same.",
    "1cf80156.json": "1. Find the bounding box of the non-zero pixels in the input grid. The bounding box is defined by the top-most row (R1), bottom-most row (R2), left-most column (C1), and right-most column (C2) that contain non-zero pixel values.\n2. Create an output grid. The height of the output grid is R2 - R1 + 1. The width of the output grid is C2 - C1 + 1.\n3. For each row R and column C in the output grid:\n4. Copy the pixel value from the input grid at row R1 + R, column C1 + C to the output grid at row R, column C.",
    "1e0a9b12.json": "1. Analyze the input grid. The grid contains integer values from 0-9.\n2. For each column in the input grid:\n3. Move all non-0 values to the bottom of the column, preserving their original order within the column.\n4. Fill the remaining empty cells (top of the column) with 0.",
    "1e32b0e9.json": "1. Divide the input grid into nine 5x5 subgrids, separated by lines of color 9.\n2. Examine the top-left 5x5 subgrid.\n3. For each of the remaining eight 5x5 subgrids, do the following:\n    a. For each pixel within the subgrid, if the pixel value in the input subgrid is 0, change the corresponding pixel in the output subgrid to 0.\n    b. If the pixel value is non-zero in the input top-left 5x5 subgrid, retain the original pixel value of the corresponding pixel from the *input* grid in the output grid.",
    "1f0c79e5.json": "1. Identify all locations (R, C) where the pixel value is 2.\n2. Identify all locations (R, C) where the pixel value is not 2.\n3. Change the pixel values at locations not containing 2 to be the pixel value of the location diagonally up and to the right from the location containing 2. Extrapolate these values beyond the original boundaries of the 2 values.\n4. If a location is equidistant from multiple 2's, choose the uppermost and leftmost 2.",
    "1f642eb9.json": "1. Find the contiguous region of value 8. This region's boundary is defined as the area to be filled.\n2. For each non-zero value located outside the region of 8, copy that value to a location on the boundary of the 8 region, closest to the original location.\n3. Specifically, if a non-zero value N is at location (R, C) outside the 8-region, locate the nearest cell with value 8 on the border. Change the value of the neighboring cell outside of the 8-region border with value N.",
    "1f85a75f.json": "1. Find the largest connected region of a single color in the input grid. A connected region consists of cells with the same value that are horizontally or vertically adjacent.\n2. Create an output grid. The width and height of the output grid are equal to the width and height of the bounding box of the identified largest connected region.\n3. Copy the pixels of the largest connected region from the input grid to the corresponding location in the output grid. All other pixels in the output grid retain their original value from the largest connected region.",
    "1f876c06.json": "1. Copy the input grid to the output grid.\n2. For each unique non-zero value 'V' in the input grid, find all coordinates (R1, C1) and (R2, C2) where the pixel value is equal to V.\n3. For each pair of coordinates (R1, C1) and (R2, C2) found in step 2, draw a diagonal line of value 'V' between these two points. The diagonal line consists of all the points (R, C) where R increases/decreases from R1 to R2 and C increases/decreases from C1 to C2 such that the absolute difference between (R2 - R1) is equal to the absolute difference between (C2 - C1), and the points form a diagonal line.\n4. If the points (R1, C1) and (R2, C2) coincide, no diagonal line needs to be drawn.",
    "1fad071e.json": "1. Create a 1x5 output grid, filled with 0s.\n2. Examine the input grid for 2x2 blocks of 1s (blue).\n3. Count the number of distinct, non-overlapping 2x2 blocks of 1s in the input grid. A 2x2 block must have the value 1 in all four cells.\n4. Starting from the left, set the first N cells of the output grid to 1, where N is the count of 2x2 blocks of 1s found in the input.",
    "2013d3e2.json": "1. Define the input grid. The input grid size is 10x10.\n2. Define the output grid. The output grid size is 3x3.\n3. Extract a 3x3 subgrid from the top-left corner of the colored shape in the input grid.\n4. Identify the topmost row and leftmost column containing non-zero values in the input grid.\n5. Extract the 3x3 subgrid starting at the identified row and column from the input grid.\n6. Assign the values of this extracted 3x3 subgrid to the corresponding cells of the output grid.",
    "2204b7a8.json": "1. Get the input grid.\n2. Create an output grid with the same dimensions as the input grid.\n3. Iterate through each pixel in the input grid, row by row, column by column.\n4. For each pixel at (R, C) in the input grid, if the pixel value is not 0, copy the value from the input grid at (R, C) to the output grid at (R, C).\n5. If the pixel value at (R, C) in the input grid is 0:\n    a. Check the color of the pixels on the left and right borders of the grid at row R. Let color of the left border be L and right border be R.\n    b. Check the color of the pixels on the top and bottom borders of the grid at column C. Let color of the top border be T and bottom border be B.\n    c. If the color of the pixel on the left border (L) is not 0, copy it to the output grid at (R, C).\n    d. If the color of the pixel on the right border (R) is not 0, copy it to the output grid at (R, C).\n    e. If the color of the pixel on the top border (T) is not 0, copy it to the output grid at (R, C).\n    f. If the color of the pixel on the bottom border (B) is not 0, copy it to the output grid at (R, C).\n    g. If the color of left border (L) is not 0 and right border (R) is not 0, copy L or R value from input grid to output grid (R, C).\n    h. If the color of top border (T) is not 0 and bottom border (B) is not 0, copy T or B value from input grid to output grid (R, C).\n6. If the pixel at (R, C) in the input grid is 0, and all border pixels (L, R, T, B) are also 0, then copy the value 0 to the output grid at (R, C).\n7. Return the output grid.",
    "22168020.json": "1. Copy the input grid to the output grid.\n2. For each connected region of non-zero pixel values in the input grid:\n    a. Identify the color (pixel value) of the region.\n    b. Fill the region and the area above it with that color until you encounter a 0 or the top edge of the grid. Filling \"above\" means to change the color of 0s directly above each pixel in the region's original location.",
    "22233c11.json": "1. Find all locations of value 3 in the input grid.\n2. For each location (R, C) of value 3, place value 8 at locations (R-1, C-2), (R-2, C-1), (R+1, C+2), and (R+2, C+1) if these locations are within the grid boundaries. If a location is already value 3, do not change it.",
    "2281f1f4.json": "1. Read the input grid. The input grid contains values 0-9.\n2. Create an output grid with the same dimensions as the input grid.\n3. Initialize all values in the output grid to be the same as the corresponding values in the input grid.\n4. Iterate through each cell (R, C) in the input grid, where R is the row index and C is the column index.\n5. Check if the value at input grid cell (0, C) is 5 or the value at input grid cell (R, input grid's last column index) is 5. Note that the last column index is grid width - 1.\n6. If either of the conditions in step 5 is true, then change the value of the output grid cell (R, C) to 2.",
    "228f6490.json": "1. Identify cells with pixel value 5 in the input grid.\n2. For each identified cell with pixel value 5, check the immediately adjacent cells (up, down, left, right) that are not also pixel value 5.\n3. If an adjacent cell (not value 5) is found, replace the pixel value 5 in the original cell with the value of that adjacent cell.",
    "22eb0ac0.json": "1. The output grid has the same dimensions as the input grid.\n2. For each row in the input grid, compare the value of the first pixel (at column 0) and the last pixel (at the last column). Let the row index be R.\n3. If the value of the pixel at (R, 0) is equal to the value of the pixel at (R, last column), then set all the pixel values in row R of the output grid to the value of the pixel at (R, 0).\n4. If the value of the pixel at (R, 0) is not equal to the value of the pixel at (R, last column), then copy row R from the input grid to row R in the output grid.",
    "234bbc79.json": "1. Identify the three distinct blocks of non-0 pixels within the input grid. Treat 5 as a connection point between blocks.\n2. Remove columns containing only 0s from the input grid.\n3. For each block, identify pixels with value 5. Change the value of these pixels to match the value of the non-0 pixel that they are connected to within the same block. If a 5 pixel is connected to different non-0 values, choose one.\n4. Vertically concatenate the three blocks into a single block. Blocks should appear in their original horizontal order from left to right.",
    "23581191.json": "1. For each pixel in the input grid with a value other than 0, perform the following steps:\n2. Let the row and column of that pixel be R and C, and let its value be V.\n3. Create a horizontal line by setting all pixels in row R to value V.\n4. Create a vertical line by setting all pixels in column C to value V.\n5. For each pixel where the horizontal and vertical lines intersect (i.e., where two lines cross), set the pixel value to 2.",
    "239be575.json": "1. Analyze the input grid.\n2. Count the number of pixels with value 2.\n3. If the count of pixels with value 2 is greater than zero, output 8.\n4. Otherwise, output 0.",
    "23b5c85d.json": "1. Find the smallest area of a non-0 object in the input grid.\n2. Create an output grid with the same dimensions as this smallest object.\n3. Fill the output grid with the pixel value corresponding to the color of the smallest object found in the input.",
    "253bf280.json": "1. The output grid has the same dimensions as the input grid.\n2. Identify all locations of pixel value 8 in the input grid.\n3. For each row, if there are at least two pixels with value 8, fill the space between the leftmost and rightmost 8s with value 3.\n4. For each column, if there are at least two pixels with value 8, fill the space between the topmost and bottommost 8s with value 3.",
    "25d487eb.json": "1. Identify a row in the input where a sequence of non-zero numbers is present, and where the center element of this sequence has a different value from the elements on either side.\n2. Extract the value of the center element from that row.\n3. Locate the column index of the center element.\n4. Starting from the row immediately below the identified row, change all pixel values in the extracted column to the extracted center element's value, until the bottom of the grid is reached.",
    "25d8a9c8.json": "1. Analyze each row of the input grid.\n2. If all values in a row are the same, set all values in the corresponding row of the output grid to 5.\n3. Otherwise (if the row contains different values), set all values in the corresponding row of the output grid to 0.",
    "25ff71a9.json": "1. Identify all pixels with value 1 or 2 in the input grid.\n2. Shift all identified pixels with value 1 or 2 down by one row. If a pixel is in the last row, it vanishes.\n3. All empty positions in the grid become 0.",
    "264363fd.json": "1. Identify the background color. Based on the training examples, the background color is likely 8 in the first training example and 1 in the second training example and 8 in the third training example and 4 in the test example. \n2. Identify enclosed regions of colors other than the background color.\n3. Within each enclosed region, if a pixel has a value that isn't the background color, change its color. The new color depends on the training example. Based on the first training example, change pixel value 3 to 2 and pixel value 1 to 2. Based on the second training example, change pixel value 3 to 2. Based on the third training example, change pixel value 3 to 5 or 6, depending on the location relative to pixel value 4. Note specifically for training example 3: change the pixels directly above, below, and to the sides of pixel value 4 to value 5, and change the pixels diagonally adjacent to value 4 to value 6.\n4.  Apply the changes from the training examples to the input grid.",
    "272f95fa.json": "1. Copy the input grid to the output grid.\n2. Let R be the number of rows and C be the number of columns of the grid.\n3. For the first quarter of the columns, starting from the second column, and before the last column, fill the cells in the first quarter of rows after the first row, up to the row before the last row with value 2.\n4. For the first quarter of the rows, starting from the second row, and before the last row, fill the cells in the last quarter of the columns after the first column, up to the column before the last column with value 2.\n5. For the third quarter of the rows, starting from the second row, and before the last row, fill the cells in the first quarter of the columns after the first column, up to the column before the last column with value 4.\n6. For the third quarter of the rows, starting from the second row, and before the last row, fill the cells in the second quarter of the columns after the first column, up to the column before the last column with value 6.\n7. For the third quarter of the rows, starting from the second row, and before the last row, fill the cells in the third quarter of the columns after the first column, up to the column before the last column with value 3.\n8. For the third quarter of the columns, starting from the second column, and before the last column, fill the cells in the third quarter of the rows after the first row, up to the row before the last row with value 1.",
    "27a28665.json": "1. Analyze the input 3x3 grid.\n2. If the input grid has the following pattern: pixel value 5 at (0,0), pixel value 5 at (0,1), pixel value 0 at (0,2), pixel value 5 at (1,0), pixel value 0 at (1,1), pixel value 5 at (1,2), pixel value 0 at (2,0), pixel value 5 at (2,1), pixel value 0 at (2,2), then the output is 1.\n3. If the input grid has a cross pattern where the non-cross pixels are 0, and the cross pixels are 8, then the output is 2.\n4. If the input grid has a cross pattern where the non-cross pixels are 0, and the cross pixels are 5, then the output is 2.\n5. If the input grid has pixel value 0 at (0,0), pixel value 1 at (0,1), pixel value 1 at (0,2), pixel value 0 at (1,0), pixel value 1 at (1,1), pixel value 1 at (1,2), pixel value 1 at (2,0), pixel value 0 at (2,1), pixel value 0 at (2,2), then the output is 3.\n6. If the input grid has pixel value 0 at (0,0), pixel value 8 at (0,1), pixel value 8 at (0,2), pixel value 0 at (1,0), pixel value 8 at (1,1), pixel value 8 at (1,2), pixel value 8 at (2,0), pixel value 0 at (2,1), pixel value 0 at (2,2), then the output is 3.\n7. If the input grid has the following pattern: pixel value 4 at (0,0), pixel value 4 at (0,1), pixel value 0 at (0,2), pixel value 4 at (1,0), pixel value 0 at (1,1), pixel value 4 at (1,2), pixel value 0 at (2,0), pixel value 4 at (2,1), pixel value 0 at (2,2), then the output is 1.\n8. If the input grid has a cross pattern where the non-cross pixels are 0, and the cross pixels are 5, then the output is 6.",
    "28bf18c6.json": "1. Find the bounding box of the non-zero pixels in the input grid.\n2. Extract the subgrid defined by this bounding box.\n3. Create an output grid with a height equal to the height of the extracted subgrid and a width equal to twice the width of the extracted subgrid.\n4. Copy the extracted subgrid to the left half of the output grid.\n5. Copy the extracted subgrid to the right half of the output grid.",
    "28e73c20.json": "1. Given an input grid of 0s, create an output grid of the same dimensions.\n2. Fill the outer border of the output grid with the value 3.\n3. Fill the next inner border with the value 3, stopping one cell short of completing the border at each corner.\n4. Continue filling subsequent inner borders with the value 3, stopping one cell short of completing each border at each corner, until the center of the grid is reached.\n5. Between each border of 3s, insert a border of 0s.",
    "29623171.json": "1. Divide the input grid into 9 boxes using the locations of the 5's. Specifically, each box is defined by the rows and columns between the consecutive occurrences of the value 5. \n2. For each box, count the number of non-zero pixels. \n3. Find the box or boxes with the maximum count calculated in step 2.\n4. For the box or boxes identified in step 3, fill the corresponding box or boxes in the output grid entirely with the color that is most frequent in that input box (excluding 0 and 5).\n5. Fill the remaining boxes in the output grid with 0.",
    "29c11459.json": "1. For each row in the input grid:\n2. Identify the first non-zero pixel value from the left (first_value) and its row index (R).\n3. Identify the first non-zero pixel value from the right (second_value) and its row index (R).\n4. In the output grid, for row R, set the pixels from column 0 to column 4 to first_value.\n5. In the output grid, for row R, set the pixel at column 5 to 5.\n6. In the output grid, for row R, set the pixels from column 6 to column 10 to second_value.\n7. If a row contains only 0s, the output row should also contain only 0s.",
    "29ec7d0e.json": "1. The output grid has the same dimensions as the input grid.\n2. For each cell (R, C) in the output grid, copy the value from the corresponding cell (R, C) in the input grid.\n3. If an input cell value is 0, replace it with the correct corresponding non-zero digit.",
    "2bcee788.json": "1. Create an output grid with the same dimensions as the input grid.\n2. Set the background color of the output grid to 3.\n3. Identify the largest connected region of non-zero pixels in the input grid. If there are two regions that are the same size, pick the region that is not adjacent to pixel value 2.\n4. Copy the pixel values of the largest connected region from the input grid to the corresponding locations in the output grid.\n5. Determine the location of the region that contains pixel value 2. Reflect the largest region about the region containing pixel value 2, placing the mirrored region adjacent to the original.\n",
    "2bee17df.json": "1. Copy the input grid to the output grid.\n2. Find the contiguous regions of 0s in the input grid.\n3. In the output grid, change the pixel values within these contiguous 0 regions based on the following rule:\n4. Starting from the second row from the top and continuing until the second row from the bottom, in each row, change the pixel values of a contiguous group of 0s to 3. The contiguous group starts at the column index after a non-zero number and continues until the column index before a non-zero number.",
    "2c608aff.json": "1. The output grid has the same dimensions as the input grid.\n2. Identify horizontal sequences of identical values in the input grid that contain a value different from their surrounding background.\n3. For each such sequence, extend the value horizontally to the left and right until you meet a different value or the edge of the grid.\n4. Identify vertical sequences of identical values in the input grid that contain a value different from their surrounding background.\n5. For each such sequence, extend the value vertically upwards and downwards until you meet a different value or the edge of the grid.",
    "2dc579da.json": "1. Divide the input grid into four quadrants of equal size.\n2. Identify the quadrant that contains a cell with a value different from the majority value in that quadrant.\n3. Extract the identified quadrant.\n4. Output the extracted quadrant as the final grid.",
    "2dd70a9a.json": "1. The output grid has the same dimensions as the input grid.\n2. Identify the locations of pixel value 3 (green) and pixel value 2 (red) in the input grid.\n3. For each pixel with value 3 (green), fill a path of value 3 (green) to the nearest pixel with value 2 (red), avoiding changing any other original value other than 0 (black).\n4. The path must only change pixels that had value 0 (black) into value 3 (green).",
    "2dee498d.json": "1. Identify a repeating pattern within the input grid. The pattern repeats horizontally.\n2. Determine the width and height of the repeating pattern.\n3. Create an output grid. Set its width to the width of the identified repeating pattern. Set its height to the height of the identified repeating pattern.\n4. Extract the repeating pattern from the top-left corner of the input grid.\n5. Populate the output grid with the extracted repeating pattern.",
    "31aa019c.json": "1. Create an output grid with the same dimensions as the input grid.\n2. Initialize all pixel values in the output grid to 0.\n3. Identify the unique color (numerical value) present only once in the input grid. Let's call this unique value 'U'.\n4. Locate the coordinates (R, C) of the pixel with value 'U' in the input grid.\n5. In the output grid, set the pixel at coordinates (R, C) to the value 'U'.\n6. In the output grid, set the values of the surrounding pixels (R-1, C), (R+1, C), (R, C-1), and (R, C+1) to 2, as long as they are within the bounds of the grid.\n7. In the output grid, set the values of the surrounding diagonal pixels (R-1, C-1), (R-1, C+1), (R+1, C-1), and (R+1, C+1) to 2, as long as they are within the bounds of the grid.",
    "321b1fc6.json": "1. Identify the single multi-colored structure in the input grid. A structure is a set of connected non-zero pixels. Store the relative positions and pixel values of this structure. Call this the target structure.\n2. Identify all single-colored structures in the input grid. A single-colored structure is a set of connected pixels with the same non-zero value. \n3. For each single-colored structure, replace the pixel values with the corresponding pixel values from the target structure, maintaining the relative positions. Use 0 for positions outside the bounds of the target structure.\n4. Replace all pixels in the original target structure with 0.",
    "32597951.json": "1. The input and output grids have the same dimensions.\n2. Identify all pixels with value 8 in the input grid.\n3. Change the value of some adjacent pixels with value 1 to 3, only if these pixels are adjacent to 8.\n4. Specifically, change pixel value 1 to 3 if it is horizontally or vertically adjacent to a pixel with value 8.",
    "3345333e.json": "1. Identify the largest connected region of a single color (other than 0). This region will be referred to as the primary region.\n2. Identify any separate enclosed or connected regions of a different color (other than 0) that intersect or are located on the primary region. Call this the secondary region.\n3. Replace the pixels of the secondary region with the color of the closest pixel in the primary region, considering only horizontal symmetry relative to the vertical center axis of the input grid.",
    "3428a4f5.json": "1. Find the row in the input grid that contains all pixels with value 4. Designate this as the separator row.\n2. Divide the input grid into two subgrids: a top subgrid consisting of all rows above the separator row, and a bottom subgrid consisting of all rows below the separator row.\n3. The output grid has the same dimensions (height and width) as the top subgrid.\n4. Overlay the top subgrid and the bottom subgrid. For each pixel at position (R, C) in the output grid:\n    a. If the pixel value at (R, C) in the top subgrid is 2 AND the pixel value at (R, C) in the bottom subgrid is 2, set the pixel value at (R, C) in the output grid to 0.\n    b. If the pixel value at (R, C) in the top subgrid is 2 AND the pixel value at (R, C) in the bottom subgrid is 0, set the pixel value at (R, C) in the output grid to 3.\n    c. If the pixel value at (R, C) in the top subgrid is 0 AND the pixel value at (R, C) in the bottom subgrid is 2, set the pixel value at (R, C) in the output grid to 3.\n    d. If the pixel value at (R, C) in the top subgrid is 0 AND the pixel value at (R, C) in the bottom subgrid is 0, set the pixel value at (R, C) in the output grid to 0.",
    "3618c87e.json": "1. The output grid has the same dimensions as the input grid.\n2. Identify all locations (R, C) in the input grid where the pixel value is 1.\n3. Change the pixel value at location (R, C) in the input grid to 0.\n4. Identify all locations (R, C) in the input grid where the pixel value is 5 in row R.\n5. Set the pixel value at location (R+2, C) in the output grid to 1, where (R, C) was identified in the input grid as being value 1.\n6. Set the pixel value at location (R, C) in the output grid to 5, where (R, C) was identified in the input grid as being value 5.\n7. Set all other pixel values to 0.",
    "3631a71a.json": "1. Create an output grid that is the same size as the input grid. Each cell in the output grid is initialized to the corresponding cell value from the input grid.\n2. Identify \"blocks\" of contiguous non-zero pixels in the input grid. Specifically, consider contiguous regions composed of pixel values 1, 2, 3, 4, 5, 6, 7, 8, or 9.\n3. For each identified block, find the corresponding block mirrored across both the horizontal and vertical center of the entire grid.\n4. Replace the pixel values within the original block with the pixel values from the mirrored block.",
    "363442ee.json": "1. Define the input grid and the output grid, both of the same dimensions.\n2. Identify a 3x3 pattern located at the top-left corner of the input grid. Specifically, extract the subgrid from row 0 to 2 and column 0 to 2.\n3. Locate all pixels with value 1 in the input grid.\n4. For each pixel with value 1 found in the input grid at coordinate (R, C), copy the 3x3 pattern extracted in step 2 to the output grid, such that the center of the 3x3 pattern is placed at (R, C). The center of the 3x3 pattern is the element at row 1 and column 1 of the extracted subgrid.\n5. Place the resulting transformed grid into the output grid.",
    "36d67576.json": "1. The output grid has the same dimensions as the input grid.\n2. For each yellow pixel (value 4) in the input grid, examine its neighbors.\n3. If a yellow pixel (value 4) has a blue pixel (value 1) two positions to its right, and is vertically aligned, then add a blue pixel (value 1) to the location one space below the blue pixel, relative to the input grid.\n4. If a yellow pixel (value 4) has a green pixel (value 3) immediately above it, then add a green pixel (value 3) one space to the left of the green pixel. \n",
    "36fdfd69.json": "1. Copy the input grid to the output grid.\n2. Identify groups of connected pixels with value 2.\n3. For each group of connected pixels with value 2, identify all pixels with values not equal to 2 or 0 that are directly adjacent (horizontally or vertically) to the connected pixels with value 2.\n4. Change the value of the identified adjacent pixels to 4.",
    "3906de3d.json": "1. Analyze the input grid. The input grid contains values 0, 1, and 2.\n2. Create an output grid with the same dimensions as the input grid.\n3. Iterate through the input grid from top to bottom, left to right.\n4. For each column C, move all values of 2 upwards, replacing any 0 values until the top of the column or another non-zero value (1 or 2) is encountered. Specifically: \n   a. Find all locations of value 2 in column C.\n   b. For each location (R, C) where the value is 2, move the value 2 upwards, swapping it with the value directly above it, as long as the value above is 0. Repeat until the value above is not 0, or the top of the column is reached.\n5. Set the output grid cell values to the modified input grid cell values.",
    "39a8645d.json": "1. Identify all distinct 3x3 blocks within the input grid.\n2. Count the occurrences of each distinct 3x3 block.\n3. Identify the 3x3 block with the highest count.\n4. If there are multiple blocks with the same highest count, arbitrarily select one of them.\n5. Extract the selected 3x3 block.\n6. Output the extracted 3x3 block as the output grid.",
    "39e1d7f9.json": "1. Copy the input grid to the output grid. \n2. Locate all instances of pixel value 4 on the input grid.\n3. For each pixel with value 4 found in step 2:\n   a. If the adjacent pixel directly to the left is out of bound or its value is not 4, change the pixel value at the same location to 6.\n   b. If the adjacent pixel directly to the right is out of bound or its value is not 4, change the pixel value at the same location to 6.\n",
    "3aa6fb7a.json": "1. Identify locations in the input grid where two adjacent pixels are 8 and the pixel diagonally adjacent to them is 0. The adjacency can be horizontal, vertical, or diagonal.\n2. At each identified location, change the value of the diagonally adjacent pixel from 0 to 1.",
    "3ac3eb23.json": "1. Take the input grid. The output grid has the same dimensions as the input grid.\n2. For each column in the input grid, identify the non-zero values in the first row. Store these values and their corresponding column indices.\n3. For each stored value and its column index, create a repeating pattern in the output grid, starting from the second row. The pattern consists of alternating the stored value and 0 in that column. Specifically, if the stored value is at column C, then:\n    a. Set the pixel value at output grid (1, C) to the stored value.\n    b. Set the pixel value at output grid (2, C) to 0.\n    c. Set the pixel value at output grid (3, C) to the stored value.\n    d. Continue alternating 0 and the stored value until the last row of the output grid is reached.\n4. The first row of the output grid is identical to the first row of the input grid.",
    "3af2c5a8.json": "1. Take the input grid. Let its dimensions be I_rows x I_cols.\n2. Create an output grid of size O_rows x O_cols, where O_rows = I_rows * 2 and O_cols = I_cols * 2.\n3. Place the input grid in the top-left quadrant of the output grid. For each cell (R, C) in the input grid, copy the value at Input(R, C) to Output(R, C), where R ranges from 0 to I_rows-1 and C ranges from 0 to I_cols-1.\n4. Mirror the top-left quadrant to the top-right quadrant. For each cell (R, C) in the top-left quadrant, copy the value at Output(R, C) to Output(R, I_cols + (I_cols - 1 - C)), where R ranges from 0 to I_rows -1 and C ranges from 0 to I_cols - 1.\n5. Mirror the top-left quadrant to the bottom-left quadrant. For each cell (R, C) in the top-left quadrant, copy the value at Output(R, C) to Output(I_rows + (I_rows - 1 - R), C), where R ranges from 0 to I_rows - 1 and C ranges from 0 to I_cols - 1.\n6. Mirror the top-right quadrant to the bottom-right quadrant. For each cell (R, C) in the top-right quadrant, copy the value at Output(R, C) to Output(I_rows + (I_rows - 1 - R), C), where R ranges from 0 to I_rows - 1 and C ranges from I_cols to O_cols - 1.",
    "3bd67248.json": "1. Copy the input grid to the output grid.\n2. Fill the entire last row of the output grid with the value 4.\n3. Starting from the second column of the last row and moving diagonally up and to the right, draw a line with the value 2 until the edge of the grid is reached. The first pixel of the line will be output[rows-1][1] = 2, then output[rows-2][2] = 2, output[rows-3][3] = 2, and so on.",
    "3bdb4ada.json": "1. The output grid has the same dimensions as the input grid.\n2. Identify continuous regions of the same pixel value in the input grid.\n3. Within each identified region, set every other pixel to 0, creating a checkerboard pattern, alternating with the original pixel value.\n4. Start the checkerboard pattern from the top-left corner of each region. If the top-left corner pixel of the region should remain the original color, leave it unchanged and alternate from there. If it should be replaced by 0, replace it and alternate from there.",
    "3befdf3e.json": "1. Create an output grid with the same dimensions as the input grid.\n2. Copy the input grid to the output grid.\n3. Identify the inner square region in the input grid, which contains a uniform color different from the surrounding area. Let the color of this inner square be 'inner_color' and the color of the surrounding area be 'outer_color'.\n4. In the output grid, swap the 'inner_color' and 'outer_color' within the original inner square region.\n5. Extend the 'outer_color' outwards from each side of the outer square by two cells. The extended regions should form a plus sign shape around the original square.",
    "3c9b0459.json": "1. Read the input grid.\n2. Create an output grid with the same dimensions as the input grid.\n3. Rotate the input grid 180 degrees to generate the output grid. Specifically:\n4. For each pixel at row R and column C in the input grid, copy its value to the pixel at row (height - 1 - R) and column (width - 1 - C) in the output grid, where height is the number of rows and width is the number of columns in the input grid.",
    "3de23699.json": "1. Find the bounding box formed by non-zero pixels that appear at the corners of the input grid. These corner pixels will always be the same value.\n2. Extract the inner region of the input grid, defined by the bounding box found in step 1. This region excludes the corner pixels themselves.\n3. Identify the pixel value of the corner pixels defining the bounding box.\n4. Change all pixel values in the extracted inner region to the pixel value identified in Step 3.\n5. Output the modified inner region as the final grid.",
    "3e980e27.json": "1. Copy the input grid to the output grid.\n2. Identify all locations of value 3 and value 2 in the input grid.\n3. For each location of value 3 that is surrounded by neighbors of different values, find another location of value 3 that has neighbors around it.\n4. Copy the neighbor pattern around the surrounded value 3, and paste it at the location of the alone value 3.\n5. For each location of value 2 that is surrounded by neighbors of different values, find another location of value 2 that has neighbors around it.\n6. Copy the neighbor pattern around the surrounded value 2, and horizontally mirror the copied pattern.\n7. Paste the mirrored pattern at the location of the alone value 2.",
    "3eda0437.json": "1. Identify the largest rectangle of connected 0s or 1s in the input grid.\n2. Create an output grid of the same dimensions as the input grid.\n3. Copy all pixel values from the input grid to the output grid.\n4. In the output grid, change the pixel values within the largest rectangle identified in Step 1 to 6.",
    "3f7978a0.json": "1. Find the columns containing 5 that also have a 8 at the top. There will be two such columns.\n2. Define the \"central pattern\" as all columns between the two columns identified in step 1, inclusive.\n3. Define the output grid width as the width of the central pattern.\n4. Define the output grid height as the height of the central pattern.\n5. Create an output grid of the calculated width and height.\n6. Fill the output grid with the values from the central pattern of the input grid.",
    "40853293.json": "1. The output grid has the same dimensions as the input grid.\n2. For each color value X (where X is an integer from 0 to 9), connect all pixels with value X with lines of value X.\n3. Connect pixels with value X horizontally and vertically.\n4. If lines of different values intersect, the vertical line's value takes precedence.",
    "4093f84a.json": "1. Copy the input grid to the output grid, preserving the original dimensions.\n2. Locate all rows and columns in the input grid where every cell contains the value 5.\n3. In the output grid, for each cell that does not have the value 5, if it is horizontally or vertically adjacent to a row or column where every cell has the value 5, then change the value of that cell to 5.\n4. Change all non-5 values in output grid to 5.",
    "41e4d17e.json": "1. Examine the input grid.\n2. Identify contiguous regions of pixel value 1.\n3. For each region of pixel value 1, find its center pixel. If the region has an even width or height, choose the closest center pixel. \n4. Change the center pixel of each region to pixel value 6.\n5. From each pixel value 6, extend a vertical line (pixel value 6) upwards and downwards until the border of the grid is reached, stopping if the line encounters a pixel value other than 8 or 1.\n6. From each pixel value 6, extend a horizontal line (pixel value 6) leftwards and rightwards until the border of the grid is reached, stopping if the line encounters a pixel value other than 8 or 1.",
    "4258a5f9.json": "1. The output grid has the same dimensions as the input grid.\n2. Examine each pixel in the input grid.\n3. If a pixel in the input grid has a value of 5, then in the output grid, set the values of the surrounding 3x3 area to 1. The 3x3 area is centered on the location of the pixel with value 5 in the input grid. If any part of the 3x3 area extends beyond the boundaries of the grid, only set the values within the grid boundaries.\n4. In the output grid, retain the value of 5 at the same coordinates where the input grid has the value 5, overwriting any 1 that was set in step 3.\n5. In the output grid, retain the value of 0 at all the other locations where the input grid has the value of 0.",
    "4290ef0e.json": "1. Find the largest shape in the input grid. The output grid size will match the bounding box of the largest shape.\n2. Create an empty output grid with the determined size, filled with the most frequent color of the largest shape's background, which in this case is color 1 (blue).\n3. Identify other shapes in the input, and arrange them in the output from largest to smallest. Overlapping regions retain the color of the shape placed later (the smaller shape).\n4. Specifically, look for shapes formed by colors 8 (cyan), 4 (yellow), 2 (red), and 3 (green) in addition to color 1 (blue).\n5. Place the largest shape first (color 1 in test case). Then overlay shapes of decreasing size and priority of 8, 4, 2, and 3.\n6. Preserve colors when overlaying shapes.  Smaller shapes overwrite the color of larger shapes where they overlap.",
    "42a50994.json": "1. Copy the input grid to the output grid.\n2. For each pixel in the input grid, check its neighbors (up, down, left, right, and diagonals).\n3. If a pixel with a value other than 0 has no neighbor with the same value, change the corresponding pixel in the output grid to 0.",
    "4347f46a.json": "1. Iterate through each distinct non-zero value in the input grid.\n2. For each distinct non-zero value, identify connected regions of that value.\n3. For each connected region, change the interior values to 0, leaving only the outline of the region with the original non-zero value.\n4. The output grid has the same dimensions as the input grid.",
    "444801d8.json": "1. Locate all connected regions of non-zero pixels within the input grid.\n2. For each such region, identify the pixel value that is *not* 0.\n3. For each region, replace all pixels with value 0 that are directly connected to a pixel of that region with the non-zero pixel value of that region. Assume 4-way connectivity (up, down, left, right).\n4. Output the modified grid.",
    "445eab21.json": "1. Analyze the input grid.\n2. Identify the color of the topmost distinct pattern. A distinct pattern is a connected region of the same color.\n3. Create a 2x2 output grid.\n4. Fill the entire 2x2 output grid with the color identified in step 2.",
    "447fd412.json": "1. Copy the input grid to the output grid. 2. Identify the coordinates of all non-zero pixel values in the top section of the input grid (rows with smaller row indices). Call this \"TopShape\". 3. Identify the coordinates of all non-zero pixel values in the bottom section of the input grid (rows with larger row indices). Call this \"BottomShape\". 4. For each pixel value at each coordinate in BottomShape, change the pixel value to match the corresponding pixel value at a coordinate in TopShape. The relative spatial relationship between the coordinates in TopShape and BottomShape must be maintained. If the shapes are of different sizes, proportionally scale the BottomShape to match the TopShape when copying.",
    "44d8ac46.json": "1. Iterate through each gray (5) object in the input grid.\n2. Within each gray (5) object, identify any fully enclosed black (0) square regions.\n3. For each identified black (0) square region, change the color of all pixels within that square to red (2).",
    "44f52bb0.json": "1. Input is a 3x3 grid of integers.\n2. Count the number of pixels with value 2 in the input grid.\n3. If the count is 3 or 4, output 1.\n4. If the count is 2, 5, or 6, output 7.",
    "4522001f.json": "1. Create a 9x9 output grid initialized with 0s.\n2. Identify the location of the 2x2 square in the top-left, top-right, bottom-left, or bottom-right corner of the 3x3 input grid that contains at least one pixel with the value 3 and one pixel with the value 2.\n3. If the 2x2 square is in the top-left corner of the input, create a 4x4 square filled with the value 3 in the top-left corner of the output grid. Create a second 4x4 square filled with the value 3 in the output grid such that the bottom-right corners of the two 4x4 squares touch.\n4. If the 2x2 square is in the top-right corner of the input, create a 4x4 square filled with the value 3 in the top-right corner of the output grid. Create a second 4x4 square filled with the value 3 in the output grid such that the bottom-left corners of the two 4x4 squares touch.\n5. If the 2x2 square is in the bottom-left corner of the input, create a 4x4 square filled with the value 3 in the bottom-left corner of the output grid. Create a second 4x4 square filled with the value 3 in the output grid such that the top-right corners of the two 4x4 squares touch.\n6. If the 2x2 square is in the bottom-right corner of the input, create a 4x4 square filled with the value 3 in the bottom-right corner of the output grid. Create a second 4x4 square filled with the value 3 in the output grid such that the top-left corners of the two 4x4 squares touch.",
    "4612dd53.json": "1. Analyze the input grid to identify locations of pixel value 1.\n2. For each pixel with value 1 at location (R, C), examine its neighbors (up, down, left, right) to determine if there are any discontinuities in the 'blue' (1) pattern.\n3. If a neighbor of a 'blue' (1) pixel at (R, C) has a value of 0, and connecting that 0-valued pixel to the 'blue' (1) pixel would create a straight line to another 'blue' (1) pixel, then change the 0-valued pixel to 2 (red).\n4. The output grid has the same dimensions as the input grid.\n5. All pixels not modified in step 3 retain their original values from the input grid.",
    "46442a0e.json": "1. Determine the dimensions (rows and columns) of the input grid. Let the number of rows be R and the number of columns be C.\n2. Create an output grid with dimensions 2R rows and 2C columns.\n3. Divide the output grid into four quadrants: top-left, top-right, bottom-left, and bottom-right. Each quadrant will have dimensions R x C.\n4. Populate the top-left quadrant of the output grid with the input grid's values.\n5. Populate the top-right quadrant of the output grid with the input grid's values.\n6. Populate the bottom-left quadrant of the output grid with the input grid's values.\n7. Populate the bottom-right quadrant of the output grid with the input grid's values.",
    "469497ad.json": "1. Find the unique non-0 colors present in the input grid. Count the number of unique colors; call this N.\n2. Create an output grid of size (5 * N) x (5 * N).\n3. Enlarge the 2x2 square in the input by a factor of N. Place the enlarged square in the corresponding location in the output grid.\n4. Enlarge the right-side column and bottom row in the input by a factor of N. Place the enlarged borders in the corresponding location in the output grid.\n5. Identify the coordinates of the corners of the enlarged square.\n6. From each corner of the enlarged square, extend a diagonal line of pixel value 2 until it reaches either a border of another color, or the edge of the output grid.",
    "46f33fce.json": "1. Input: Start with an input grid of integers 0-9.\n2. Output: Create an output grid. The height and width of the output grid are four times the height and width of the input grid.\n3. Iterate through each cell (R, C) in the input grid.\n4. If the value at input grid cell (R, C) is V and V is not 0, create a 4x4 block of value V in the output grid. The top-left corner of this block should be located at output grid cell (R*4, C*4).\n5. Specifically: Assign the value V to the output grid cells (R*4, C*4), (R*4, C*4 + 1), (R*4, C*4 + 2), (R*4, C*4 + 3), (R*4 + 1, C*4), (R*4 + 1, C*4 + 1), (R*4 + 1, C*4 + 2), (R*4 + 1, C*4 + 3), (R*4 + 2, C*4), (R*4 + 2, C*4 + 1), (R*4 + 2, C*4 + 2), (R*4 + 2, C*4 + 3), (R*4 + 3, C*4), (R*4 + 3, C*4 + 1), (R*4 + 3, C*4 + 2), (R*4 + 3, C*4 + 3).\n6. If the value at input grid cell (R, C) is 0, leave the corresponding 4x4 block in the output grid as 0.",
    "47c1f68c.json": "1. Identify the delimiter color. In the input grid, find the color of the horizontal and vertical line that divides the grid into quadrants. Let this color be D. From the examples, D is located at the center row and center column. Translate the color to its number representation (0-9).\n2. Extract the top-left quadrant. Define the top-left quadrant as all cells located at row < center row and column < center column.\n3. Determine the dimensions of the top-left quadrant. Let this be R rows and C columns.\n4. Create an output grid with dimensions (2 * R) rows and (2 * C) columns, initialized with 0s.\n5. Copy the top-left quadrant to the top-left quadrant of the output grid.\n6. Reflect the top-left quadrant horizontally across the vertical center of the output grid. This means for each cell (r, c) in the top-left quadrant of the input copied to the output, copy the value at (r, c) to the location (r, 2*C - 1 - c) in the output grid.\n7. Reflect the top-left quadrant vertically across the horizontal center of the output grid. This means for each cell (r, c) in the top-left quadrant of the input copied to the output, copy the value at (r, c) to the location (2*R - 1 - r, c) in the output grid.\n8. Reflect the top-left quadrant both horizontally AND vertically. For each cell (r, c) in the top-left quadrant of the input copied to the output, copy the value at (r, c) to the location (2*R - 1 - r, 2*C - 1 - c) in the output grid.",
    "484b58aa.json": "1. The output grid has the same dimensions as the input grid.\n2. Iterate through each cell (R, C) in the input grid.\n3. If the pixel value at (R, C) in the input grid is 0, change the pixel value at (R, C) in the output grid to the corresponding pixel value from the original pattern in the input grid.\n4. If the pixel value at (R, C) in the input grid is not 0, keep the pixel value in output grid the same as the pixel value in the input grid.",
    "48d8fb45.json": "1. Find the coordinates (R, C) of the pixel with value 5 in the input grid. If multiple pixels have value 5, select the one with the smallest row and column index. Let this pixel be P. If no pixel has value 5, the task cannot be completed.\n2. Extract a 3x3 subgrid from the input grid, such that pixel P is at the center of the subgrid. If pixel P is near the edge of the input grid, use the available values and pad the rest with 0 to complete the 3x3 grid.\n3. Create a 3x3 output grid.\n4. In the 3x3 subgrid, set the value of any pixel with value 5 to 0.\n5. Assign the values from the modified 3x3 subgrid to the 3x3 output grid.",
    "4938f0c2.json": "1. Identify the locations of all groups of connected 2s and 3s. Treat other numbers as background (0).\n2. For each identified connected component of 2s, reflect this connected component across the center of the grid, placing 2s in symmetrical positions relative to the original shape's center.\n3. Leave connected components of 3s unchanged.",
    "496994bd.json": "1. Copy the input grid to the output grid. 2. Let 'H' be the height of the input grid. 3. Starting from the bottom row of the output grid (row H-1) and going up, mirror the values from the corresponding row from the top of the input grid. For instance, the last row of the output grid will have the same values as the first row of the input grid, and the second to last row of the output grid will have the same values as the second row of the input grid, and so on, until the row reaches row H/2. The first H/2 rows of the grid remain unchanged.",
    "49d1d64f.json": "1. Given an input grid of size M x N, create an output grid of size (M+2) x (N+2). \n2. Copy the input grid to the center of the output grid. Thus, input grid element at (R, C) is copied to output grid element at (R+1, C+1).\n3. Copy the top row of the input grid to the row directly above it in the output grid. Specifically, for each column C from 0 to N-1, set output[0][C+1] = input[0][C].\n4. Copy the bottom row of the input grid to the row directly below it in the output grid. Specifically, for each column C from 0 to N-1, set output[M+1][C+1] = input[M-1][C].\n5. Copy the leftmost column of the input grid to the column directly to the left of it in the output grid. Specifically, for each row R from 0 to M-1, set output[R+1][0] = input[R][0].\n6. Copy the rightmost column of the input grid to the column directly to the right of it in the output grid. Specifically, for each row R from 0 to M-1, set output[R+1][N+1] = input[R][N-1].\n7. Set the four corner elements of the output grid to 0. Specifically, set output[0][0] = 0, output[0][N+1] = 0, output[M+1][0] = 0, and output[M+1][N+1] = 0.",
    "4be741c5.json": "1. Identify the distinct numbers present in the input grid from top to bottom or left to right.\n2. Create an output grid. The width or height of the output grid equals the number of distinct numbers identified in step 1.\n3. If the distinct numbers appear in vertical columns in the input, create a horizontal output. If the distinct numbers appear in horizontal rows, create a vertical output.\n4. Populate the output grid. Fill each cell with the corresponding distinct number, in the order they appear in the input, either from top to bottom or left to right.",
    "4c4377d9.json": "1. Get the input grid. Let the number of rows be R and the number of columns be C.\n2. Create an output grid with dimensions 2R rows and C columns.\n3. Copy the input grid to the bottom half of the output grid (rows R to 2R-1).\n4. Copy the input grid to the top half of the output grid (rows 0 to R-1).",
    "4c5c2cf0.json": "1. Identify the shape consisting of value 7 and value 4 in the input grid. This shape is located in one corner of a larger, implied 'X' shape.\n2. Mirror this shape across the vertical axis of symmetry of the 'X'.\n3. Mirror the original shape across the horizontal axis of symmetry of the 'X'.\n4. Mirror the original shape across both the horizontal and vertical axes of symmetry of the 'X'.",
    "50846271.json": "1. Identify all pixels with value 2 in the input grid.\n2. For each pixel with value 2 at coordinate (R, C), change the values of the surrounding pixels to 8 as follows:\n3. Change the pixel at (R-2, C) to 8, if it is within the grid bounds.\n4. Change the pixel at (R-1, C) to 8, if it is within the grid bounds.\n5. Change the pixel at (R+1, C) to 8, if it is within the grid bounds.\n6. Change the pixel at (R+2, C) to 8, if it is within the grid bounds.\n7. Change the pixel at (R, C-2) to 8, if it is within the grid bounds.\n8. Change the pixel at (R, C-1) to 8, if it is within the grid bounds.\n9. Change the pixel at (R, C+1) to 8, if it is within the grid bounds.\n10. Change the pixel at (R, C+2) to 8, if it is within the grid bounds.\n11. The output grid has the same dimensions as the input grid. All other pixel values remain unchanged.",
    "508bd3b6.json": "1. Locate all pixels with value 8 (cyan) in the input grid.\n2. For each pixel with value 8 (cyan), trace a diagonal line until it hits a pixel with value 2 (red) or the edge of the grid.\n3. The diagonal line starts at the location of the pixel with value 8 (cyan).\n4. Change the value of pixels along the diagonal line (excluding the initial pixel with value 8) to 3 (green) until a pixel with value 2 (red) or the edge of the grid is reached.\n5. If a pixel with value 2 is encountered, do not change its value.\n6. The diagonal movement is always in the direction down and to the right or up and to the right relative to the 8 pixel.",
    "50cb2852.json": "1. The output grid has the same dimensions as the input grid.\n2. For each distinct non-zero value in the input grid, identify the connected region(s) of that value.\n3. For each connected region, fill the inner area of the region with the value 8. The boundary pixels of the region retain their original value from the input grid. Specifically, if a pixel with a value other than 0 is surrounded by the same value, change the surrounded pixel to 8. Apply this rule iteratively until no more pixels can be changed to 8 within the region.",
    "5117e062.json": "1. Find a shape containing pixel value 8.\n2. Define the output grid dimensions to be the same as the dimensions of the shape containing pixel value 8.\n3. Copy the shape containing pixel value 8 from the input grid to the output grid.\n4. In the output grid, replace pixel value 8 with the pixel value that surrounds it within the shape.",
    "5168d44c.json": "1. Identify a 3x3 block of pixels containing the pattern '2 2 2, 2 3 2, 2 2 2'. Call this the 'red block'.\n2. Identify the location of the '3' pixels. These will serve as the guide for movement of the 'red block'.\n3. If the '3' pixels form a vertical line, move the 'red block' down until the central '3' pixel in the red block aligns with the next '3' pixel in the vertical line of '3's.\n4. If the '3' pixels form a horizontal line, move the 'red block' to the right until the central '3' pixel in the red block aligns with the next '3' pixel in the horizontal line of '3's.\n5. Preserve all '3' pixels in their original locations. Only the 'red block' should be shifted.",
    "539a4f51.json": "1. Create a 10x10 output grid.\n2. Take the input grid.\n3. Repeat the input grid pattern to fill the entire 10x10 output grid. This means copying the input grid and placing it adjacent to the original, repeating until the output grid is full.",
    "53b68214.json": "1. The output grid is 10x10.\n2. Copy the input grid to the top portion of the output grid.\n3. Extend the pattern vertically to fill the rest of the output grid.",
    "543a7ed5.json": "1. Copy the input grid to the output grid. 2. Find all areas of connected pixels with value 6. 3. For each such area of 6, change the color of all pixels inside the border of that area to color 4. 4. For each such area of 6, outline the border of the area with color 3.",
    "54d82841.json": "1. Find all shapes in the input grid that have at least one non-zero pixel.\n2. For each shape found, identify the column index C of the shape's center.\n3. Let R be the row index of the last row of the input grid.\n4. Set the pixel at location (R, C) to 4 in the output grid.\n5. All other pixels in the output grid retain the same values as the input grid.",
    "54d9e175.json": "1. The output grid has the same dimensions as the input grid.\n2. Divide the input grid into 3x3 blocks. \n3. For each 3x3 block, if the center pixel has a value of:\n    a. 1, set all the pixels in the corresponding 3x3 output block to 6.\n    b. 2, set all the pixels in the corresponding 3x3 output block to 7.\n    c. 3, set all the pixels in the corresponding 3x3 output block to 8.\n    d. 4, set all the pixels in the corresponding 3x3 output block to 9.\n    e. 0, set all the pixels in the corresponding 3x3 output block to the value specified in rules 3a-3d corresponding to the value in the training examples.\n4. If a pixel in the input is 5, the corresponding pixel in the output is also 5.",
    "5521c0d9.json": "1. The output grid has the same dimensions as the input grid.\n2. For each distinct object (contiguous non-zero region) in the input grid, perform the following steps:\n3. Identify the object's color (pixel value).\n4. Count the number of rows the object occupies in the input grid.\n5. Move the entire object down by the number of rows counted in step 4. If an object already occupies a position, overwrite it. If moving an object off the bottom of the grid, wrap the object to the bottom rows.",
    "5582e5ca.json": "1. Analyze the input grid, which is 3x3.\n2. Count the occurrences of each distinct number (0-9) within the input grid.\n3. Identify the number with the highest occurrence count. If there are ties, choose the smallest of the tied numbers.\n4. Create an output grid of the same size (3x3) as the input grid.\n5. Set every cell in the output grid to the number identified in step 3.",
    "5614dbcf.json": "1. Divide the input grid into 3x3 subgrids.\n2. For each 3x3 subgrid, determine the most frequent non-5 (grey) number. If all numbers in the subgrid are 5, then the resulting value should be 0.\n3. Assign the most frequent non-5 number to the corresponding cell in the 3x3 output grid.",
    "56dc2b01.json": "1. Identify the location of a continuous line of pixel value 2 in the input grid. Determine if this line is horizontal or vertical.\n2. Identify a pattern of pixel value 3 in the input grid.\n3. Move the identified pattern of pixel value 3 such that it is adjacent to the line of pixel value 2. Maintain the relative position of the 3s to each other.\n4. Place a line of pixel value 8 parallel to the line of pixel value 2, on the opposite side of the pixel value 3 pattern from the line of pixel value 2, creating a boundary.\n5. The lines of pixel value 2 and 8 must be parallel and have same length.",
    "56ff96f3.json": "1. Create an output grid that is an exact copy of the input grid.\n2. Find all pairs of pixels with the same non-zero value.\n3. For each pair of pixels with value V at coordinates (R1, C1) and (R2, C2), consider these two pixels as opposite corners of a rectangle.\n4. Fill all the pixels within that rectangle with the value V.",
    "57aa92db.json": "1. Copy the input grid to the output grid.\n2. Identify groups of connected cells with the same non-zero value in the input grid.\n3. For each group, find another group of the same size and different color.\n4. Replicate the shape formed by the first group with the color of the second group.",
    "5ad4f10b.json": "1. Create a 3x3 output grid initialized with 0s.\n2. For the first example, set output[0][0] to 8, output[0][2] to 8, output[1][1] to 8, output[2][0] to 8, output[2][1] to 8, and output[2][2] to 8. Note that the color 8 pattern is a smaller version of the input.\n3. For the second example, set output[0][0] to 2, output[0][2] to 2, output[1][1] to 2, output[2][0] to 2.\n4. For the third example, set output[0][1] to 3, output[1][1] to 3, output[1][2] to 3, output[2][0] to 3, output[2][2] to 3.",
    "5bd6f4ac.json": "1. Take the input grid. The input grid has a size of 9x9.\n2. Create an output grid of size 3x3.\n3. Copy the pixel values from the top right 3x3 corner of the input grid to the output grid. More specifically, for each row i from 0 to 2 inclusive and column j from 0 to 2 inclusive of the output grid, copy the pixel value from row i and column j+6 from the input grid to row i and column j of the output grid.",
    "5c0a986e.json": "1. Find the 2x2 blue box (value 1). The top-left corner of this box is (R1, C1). If the box is not found, do nothing.\n2. Find the 2x2 red box (value 2). The bottom-right corner of this box is (R2, C2). If the box is not found, do nothing.\n3. Starting from (R1, C1), extend a line of value 1 diagonally towards the top-left corner of the grid, setting the value of each pixel in the path to 1. Stop when you reach the edge of the grid.\n4. Starting from (R2, C2), extend a line of value 2 diagonally towards the bottom-right corner of the grid, setting the value of each pixel in the path to 2. Stop when you reach the edge of the grid.",
    "5c2c9af4.json": "1. Take the input grid.\n2. Create an output grid with the same dimensions as the input grid.\n3. Identify the coordinates of all pixels with a value other than 0 in the input grid. These are the seed points.\n4. For each seed point in the input, generate concentric squares around that point in the output grid, expanding outwards until the square reaches the boundary of the output grid.\n5. The value of the pixels forming these squares should be the same as the pixel value of the seed point in the input grid.",
    "5daaa586.json": "1. Find the bounding box formed by non-0 pixels. The bounding box is defined by the minimum and maximum row and column indices where pixel values are not 0.\n2. Extract the subgrid within the bounding box (inclusive of the boundary pixels).\n3. For each pixel with a non-zero, non-bounding box value inside the subgrid, extend a line to the nearest border pixel of the same color, horizontally or vertically. If the subgrid's width is greater than its height, extend horizontally to the closest same color border.\n4. If the width is less than the height, extend vertically to the closest same color border. If the width is equal to the height extend vertically to the closest same color border.",
    "60b61512.json": "1. Analyze the input grid. The input grid is 9x9.\n2. Identify contiguous regions of pixel value 4.\n3. Within each region of 4s, fill any enclosed empty spaces (pixel value 0) with pixel value 7, until the region forms a square or rectangular shape with no holes.",
    "6150a2bd.json": "1. The output grid has the same dimensions as the input grid.\n2. To generate the output grid, flip the input grid horizontally and vertically.\n3. Specifically, the pixel value at row R, column C in the input grid becomes the pixel value at row (height - 1 - R), column (width - 1 - C) in the output grid, where height is the number of rows and width is the number of columns in the grid. R and C start from 0.",
    "623ea044.json": "1. Find the coordinates (R, C) of the non-zero pixel value in the input grid. This pixel represents the center of the transformation.\n2. Create an output grid with the same dimensions as the input grid, initialized with all pixel values set to 0.\n3. Place the original non-zero pixel value from the input grid at the same coordinates (R, C) in the output grid.\n4. From each corner formed diagonally from the initial non-zero pixel value, extend the same non-zero pixel value in a straight line until the edge of the grid is reached.\n5. Specifically:\n    a. From coordinate (R, C), extend the non-zero pixel value diagonally up and to the left until either the top (row 0) or left (column 0) edge of the grid is reached.\n    b. From coordinate (R, C), extend the non-zero pixel value diagonally up and to the right until either the top (row 0) or rightmost column edge of the grid is reached.\n    c. From coordinate (R, C), extend the non-zero pixel value diagonally down and to the left until either the bottommost row or left (column 0) edge of the grid is reached.\n    d. From coordinate (R, C), extend the non-zero pixel value diagonally down and to the right until either the bottommost row or rightmost column edge of the grid is reached.",
    "62c24649.json": "1. Take the input grid (3x3). Let this be called Subgrid A.\n2. Create an output grid of size 6x6.\n3. Place Subgrid A in the top-left corner (coordinates (0,0) to (2,2)) of the output grid.\n4. Place a horizontally reflected version of Subgrid A in the top-right corner (coordinates (0,3) to (2,5)) of the output grid. For example, the pixel at (R, C) in Subgrid A is placed at (R, 5-C) in the top-right corner of the output grid.\n5. Place a vertically reflected version of Subgrid A in the bottom-left corner (coordinates (3,0) to (5,2)) of the output grid. For example, the pixel at (R, C) in Subgrid A is placed at (5-R, C) in the bottom-left corner of the output grid.\n6. Place a horizontally and vertically reflected version of Subgrid A in the bottom-right corner (coordinates (3,3) to (5,5)) of the output grid. For example, the pixel at (R, C) in Subgrid A is placed at (5-R, 5-C) in the bottom-right corner of the output grid.",
    "63613498.json": "1. Find the object on the rightmost column that is not 0. Call this the 'target object'.\n2. Change the color of the 'target object' to 5.",
    "6430c8c4.json": "1. Divide the input grid into two subgrids of size 4x4, separated by a row of 4s (yellow, or numerical value 4). The first subgrid is located at the top of the input grid, and the second subgrid is located at the bottom of the input grid. The intermediate row of 4s is not included in either subgrid.\n2. Create an output grid of size 4x4, initially filled with 0s.\n3. For each cell (R, C) in the output grid:\n4. If the pixel value at (R, C) in the top 4x4 subgrid is 7, then change the pixel value at (R, C) in the output grid to 3.\n5. If the pixel value at (R, C) in the bottom 4x4 subgrid is 2, then change the pixel value at (R, C) in the output grid to 3.",
    "6455b5f5.json": "1. Identify connected regions of 0s (black). Treat the input grid as a graph where adjacent 0s are neighbors.\n2. Find the largest connected region of 0s. Fill this region with 8 (cyan).\n3. Find the smallest connected region(s) of 0s. If there are multiple regions with the same smallest size, find all of them. Fill these region(s) with 1 (blue).",
    "662c240a.json": "1. Divide the input grid into three 3x3 subgrids, stacked vertically.\n2. Attempt to copy the top 3x3 subgrid of the input to the output.\n3. If the result of step 2 matches the expected output, stop.\n4. If the result of step 2 does not match the expected output, attempt to copy the middle 3x3 subgrid of the input to the output.\n5. If the result of step 4 matches the expected output, stop.\n6. If the result of step 4 does not match the expected output, copy the bottom 3x3 subgrid of the input to the output.",
    "67385a82.json": "1. Maintain the input grid dimensions for the output grid.\n2. Examine each connected region of value 3 (green) in the input grid.\n3. If a connected region of 3 (green) contains more than one pixel, change the value of all pixels within that connected region to 8 (cyan) in the output grid.\n4. Pixels not part of a connected region of 3 (green) with size greater than one should retain their original values from the input grid in the output grid.",
    "673ef223.json": "1. Identify the coordinates of all pixels with value 8 (cyan/light blue). Let's call this set of coordinates 'light_blue_pixels'.\n2. Identify the coordinates of all pixels with value 2 (red). Let's call this set of coordinates 'red_pixels'. The red pixels are located on the left and right edges of the grid.\n3. For each coordinate (R, C) in 'light_blue_pixels' located above the horizontal center of the grid: Change the value of the pixel at (R, C) to 4 (yellow).\n4. For each coordinate (R, C) that was originally value 8 (cyan/light blue) and now has value 4 (yellow): Extend a line of pixels with value 8 (cyan/light blue) horizontally from (R, C) towards the nearest pixel with value 2 (red) in the same row. Stop when a pixel with value 2 (red) is reached.\n5. For each coordinate (R, C) in 'light_blue_pixels' located below the horizontal center of the grid: Extend a line of pixels with value 8 (cyan/light blue) horizontally from (R, C) towards the nearest pixel with value 2 (red) in the same row, but continue until the edge of the grid is reached.\n6. For rows with pixels value 2 (red) at the bottom of the grid. If there is a pixel value 8 (cyan/light blue) extend this pixel value 8 (cyan/light blue) to the edges of the grid",
    "6773b310.json": "1. Divide the input grid into 3x3 subgrids, ignoring the rows and columns containing all 8's.\n2. For each 3x3 subgrid, count the number of pixels with value 6.\n3. Create an output grid of size 3x3.\n4. If a 3x3 subgrid from the input contains exactly two pixels with value 6, set the corresponding pixel in the output grid to 1.\n5. Otherwise, set the corresponding pixel in the output grid to 0.",
    "67a3c6ac.json": "1. Get the input grid.\n2. Create an output grid with the same dimensions as the input grid.\n3. Iterate through each row R from top to bottom (starting at row 0).\n4. Iterate through each column C from left to right (starting at column 0).\n5. For each pixel at (R, C) in the input grid, copy the value from input grid (R, C) to the output grid (R, input grid width - 1 - C).",
    "67a423a3.json": "1. Find the intersection point of the lines. The intersection point is defined as the pixel where two lines of different values meet.\n2. For each intersection point found in the input grid:\n3. Define a 3x3 square centered on the intersection point (R, C).\n4. Change the values of all the pixels within the 3x3 square to 4 (yellow), except for the central pixel at (R, C). Keep the value of the central pixel at (R, C) unchanged.",
    "67e8384a.json": "1. Take a 3x3 input grid. Let (R, C) represent row and column indices, starting from 0. The output grid will be 6x6.\n2. Copy the input grid into the top-left 3x3 quadrant of the output grid. This means output(R, C) = input(R, C) for R from 0 to 2, and C from 0 to 2.\n3. Copy the input grid, but reverse the order of rows, into the bottom-left 3x3 quadrant of the output grid. This means output(R, C) = input(2 - R, C) for R from 3 to 5, and C from 0 to 2.\n4. Copy the input grid, but reverse the order of columns, into the top-right 3x3 quadrant of the output grid. This means output(R, C) = input(R, 2 - (C - 3)) for R from 0 to 2, and C from 3 to 5.\n5. Copy the input grid, reverse both row and column order, and place it in the bottom-right 3x3 quadrant of the output grid. This means output(R, C) = input(2 - R, 2 - (C - 3)) for R from 3 to 5, and C from 3 to 5.",
    "681b3aeb.json": "1. Create a 3x3 output grid, initialized with zeros (0).\n2. Identify the two distinct non-zero values in the input grid. Let's call them value A and value B.\n3. Place the shape consisting of value A in the output grid.\n4. Place the shape consisting of value B in the output grid, adjacent to the shape of value A.\n5. Ensure that the combined shapes fit within the 3x3 output grid.",
    "6855a6e4.json": "1. Copy the input grid to the output grid.\n2. Identify the regions of value 5 and value 2 in the input grid.\n3. Move each region of value 5 to the interior of the regions of value 2.\n4. Ensure there is a single column of value 0 between each region of value 5 and the nearest region of value 2.\n5. Vertically flip each region of value 5 after moving it to the interior of the regions of value 2. Vertical flip means the top row of the original shape becomes the bottom row of the new shape, and vice-versa.",
    "68b16354.json": "1. Take the input grid.\n2. Create an output grid with the same dimensions as the input grid.\n3. Iterate through each row of the input grid from top to bottom, with row index R starting from 0.\n4. Iterate through each column of the input grid from left to right, with column index C starting from 0.\n5. For each pixel at (R, C) in the input grid, copy the pixel value to the pixel at (output_height - 1 - R, C) in the output grid, where output_height is the number of rows in the input grid.",
    "694f12f3.json": "1. The input is a 10x10 grid of numbers (0-9).\n2. The output is a 10x10 grid of numbers (0-9).\n3. Identify distinct regions of 4s in the input grid.\n4. For each region of 4s, if the region is a rectangle with a width and height greater than 2, fill the inner part of the region with either 1 or 2. The inner part is defined by removing the outer layer of 4s. \n5. If the region is the top one, fill the inner part with 2s.\n6. If the region is the bottom one, fill the inner part with 1s.\n7. Copy all other values (non-4) from the input to the corresponding positions in the output grid.",
    "6a1e5592.json": "1. Copy the input grid to the output grid.\n2. Find all locations in the input grid where the value is 5.\n3. For each location of value 5 found in step 2, identify the largest connected region of 0s above it in the input grid.\n4. For each such region of 0s identified in step 3, change the 0s in the corresponding region of the output grid to 1.",
    "6aa20dc0.json": "1. Identify a cluster of connected cells, often a 3x3 block, containing multiple distinct values. Consider this the reference cluster.\n2. Locate other clusters in the input grid that share at least two values with the reference cluster.\n3. For each of these other clusters, determine the missing value(s) from the reference cluster that are *not* already present in the cluster.\n4. Fill in the missing value(s) in the cluster. The placement should visually complete the pattern observed in the reference cluster. Note: The target cluster may need to be rotated or flipped before filling to match the reference.",
    "6b9890af.json": "1. Find the smallest bounding box containing all non-zero pixels in the input grid.\n2. Create an output grid with the same height and width as the bounding box found in step 1.\n3. For each row R and column C in the output grid:\n4. If there is pixel value 2 at the borders of the input grid, copy the design inside the square with pixel 2 (red color) and paste it with pixel 8 (cyan color) on the output grid.\n5. Otherwise, copy the design inside the square with pixel 2 (red color) and paste it with the other colors on the output grid.\n6. Output the generated grid.",
    "6c434453.json": "1. Analyze the input grid. The input grid contains values 0 and 1.\n2. Identify all 3x3 blocks of 1s within the input grid that form a solid square.\n3. For each such 3x3 block found, change the center value (the pixel in the middle) to 2.\n4. The output grid has the same dimensions as the input grid. All other values remain unchanged.",
    "6cdd2623.json": "1. Identify the color (number) that appears exactly four times in the input grid. Let this color be 'X'.\n2. Locate the four coordinates (R1, C1), (R2, C2), (R3, C3), and (R4, C4) of the pixels with value 'X' in the input grid.\n3. Create an output grid with the same dimensions as the input grid, initialized with all cells set to 0.\n4. Draw a straight line with value 'X' between two of the identified coordinates and extend this line to the edge of the grid. Determine the coordinate pairs to connect:\n    a. Find two coordinates where the row indices are identical. Fill all the pixels in that row with the value X, between the first column and last column index.\n    b. Find another two coordinates where the column indices are identical. Fill all the pixels in that column with the value X, between the first row and last row index.\n",
    "6cf79266.json": "1. The output grid has the same dimensions as the input grid.\n2. Examine each 3x3 subgrid in the input grid.\n3. If a 3x3 subgrid contains all pixel values of 0, then change the corresponding 3x3 subgrid in the output to pixel value 1.",
    "6d0160f0.json": "1. Divide the input grid into 3x3 subgrids, separated by rows and columns of value 5.\n2. Identify the 3x3 subgrid containing a pixel with value 4.\n3. Create a new grid with the same dimensions as the input grid.\n4. Fill all 3x3 subgrids in the new grid with value 0, except for the subgrid corresponding to the location of the subgrid found in step 2.\n5. Copy the identified 3x3 subgrid from the input grid (containing the pixel with value 4) to the corresponding 3x3 subgrid location in the new grid.\n6. Retain all rows and columns with value 5 from the original input grid in the new grid.",
    "6d0aefbc.json": "1. Take the input grid. The input grid is 3x3.\n2. Create an output grid that is 3x6.\n3. Copy the input grid to the left half of the output grid (columns 0, 1, and 2).\n4. Reflect the input grid horizontally and place it on the right half of the output grid (columns 3, 4, and 5). Specifically, for each row R:\n    a. Output[R][3] = Input[R][2]\n    b. Output[R][4] = Input[R][1]\n    c. Output[R][5] = Input[R][0]",
    "6d58a25d.json": "1. Scan each column of the input grid from top to bottom. \n2. In each column, identify the first non-zero pixel value.\n3. If a non-zero pixel value is found at row R and column C, copy that pixel value from (R, C) downwards to all pixels in the column C below row R. Keep the original value at (R,C).\n4. If no non-zero pixel value is found in column C, leave the column unchanged.",
    "6d75e8bb.json": "1. Iterate through all pixels in the input grid.\n2. Identify contiguous regions of pixels with value 8.\n3. For each region of 8s, find the minimum and maximum row indices (R_min, R_max) and the minimum and maximum column indices (C_min, C_max) that enclose the region.\n4. Iterate through the rectangle defined by (R_min, C_min) and (R_max, C_max).\n5. If a pixel within this rectangle does not have the value 8, change its value to 2.",
    "6e02f1e3.json": "1. Determine the number of distinct values in the input grid.\n2. Create a 3x3 grid filled with the value 0.\n3. If the number of distinct values in the input grid is 1, set the pixel values at (0,0), (0,1), and (0,2) to 5.\n4. If the number of distinct values in the input grid is 2, set the pixel values at (0,0), (1,1), and (2,2) to 5.\n5. If the number of distinct values in the input grid is 3, set the pixel values at (0,2), (1,1), and (2,0) to 5.\n6. The resulting 3x3 grid is the output.",
    "6e19193c.json": "1. Find all L-shaped regions composed of three connected pixels of the same non-zero value. The L-shape consists of two adjacent segments of length 2.\n2. For each L-shape, identify the empty pixel that would complete a 2x2 square containing the L-shape. Change that empty pixel to 0 (black).\n3. From the 0 (black) pixel, extend a diagonal line. The direction of the diagonal is determined by the orientation of the L-shape; the diagonal should extend away from the 'inside' corner of the L.\n4. Fill the pixels along the diagonal line with the same value as the original L-shape, until the edge of the grid is reached.",
    "6e82a1ae.json": "1. Scan the input grid for connected groups of pixels with value 5.\n2. If a connected group of 5s has a size of 2, change the color of the group to 3.\n3. If a connected group of 5s has a size of 3, change the color of the group to 2.\n4. If a connected group of 5s has a size of 4, change the color of the group to 1.",
    "6ecd11f4.json": "1. Find the smaller grid within the input grid. This grid is composed of non-zero values. Determine its dimensions (rows, columns). Call this the \"small grid\".\n2. Find the larger grid within the input grid. This grid is composed of values that are not all 0. Determine its dimensions (rows, columns). Call this the \"large grid\".\n3. Create an output grid with the same dimensions (rows, columns) as the small grid.\n4. Copy the values from the small grid to the corresponding positions in the output grid.\n5. Iterate through each cell (R, C) in the output grid. \n6. If the corresponding cell (R, C) in the large grid has value 0, then set the value of the cell (R, C) in the output grid to 0.",
    "6f8cd79b.json": "1. Take the input grid.\n2. Create an output grid with the same dimensions as the input grid.\n3. For each pixel on the border of the output grid, set the pixel value to 8.\n4. For each pixel not on the border of the output grid, set the pixel value to 0.",
    "6fa7a44f.json": "1. Take the input grid, which is 3x3.\n2. Create an output grid of size 3x6.\n3. Copy the 3x3 input grid to the top 3x3 portion of the output grid.\n4. Copy the 3x3 input grid, reverse the order of rows, and place it into the bottom 3x3 portion of the output grid.",
    "72322fa7.json": "1. Copy the input grid to the output grid.\n2. For each pixel in the input grid that has a non-zero value:\n3. Find all other pixels in the input grid that have the same non-zero value.\n4. For each of these found pixels, compare the pattern of adjacent non-zero pixels around it to the original pixel.\n5. Replicate the arrangement of colored pixels around the originally identified pixel around each of the other found pixels of the same color. Specifically, if a pixel with value 'X' is found, and a neighboring pixel at a relative coordinate (dR, dC) has value 'Y' in the source exemplar, then set the corresponding neighboring pixel at (dR, dC) relative to the found pixel to value 'Y' in the output. If the neighboring pixel has value 0 in the source exemplar, do not modify the value in the output grid.",
    "72ca375d.json": "1. Find a non-zero figure within the input grid. A figure is a contiguous block of the same non-zero number.\n2. Extract one of the figures from the input grid.\n3. The output grid has the same height and width as the extracted figure.\n4. Copy the extracted figure to the output grid.",
    "73251a56.json": "1. The output grid has the same dimensions as the input grid.\n2. Identify the top-left corner of the input grid, call it (0, 0).\n3. Replicate the color pattern originating from the top-left corner throughout the entire output grid. Specifically, for each pixel in the output grid:\n    a. Calculate the row offset from the top-left corner: row_offset = row % height_of_pattern\n    b. Calculate the column offset from the top-left corner: col_offset = column % width_of_pattern\n    c. Assign the value of the pixel at (row_offset, col_offset) in the input grid to the pixel at (row, column) in the output grid.",
    "7447852a.json": "1. Identify pixels with value 0 in the input grid.\n2. Process each row of the grid from top to bottom.\n3. In each row, locate the contiguous sequences of 0s.\n4. Within each sequence of 0s, starting from the leftmost 0, change the value of every third 0 to 4. The indices of the 0s being considered are 0, 3, 6, 9, and so on within the sequence.",
    "7468f01a.json": "1. Identify the bounding box of the non-zero values in the input grid.\n2. Create an output grid with the same dimensions as the bounding box.\n3. Invert the horizontal order of the columns within the bounding box.\n4. Copy the pixel values from the input bounding box, with inverted column order, to the output grid.",
    "746b3537.json": "1. Read the input grid.\n2. For each column in the input grid:\n    a. Extract the value from the first row of that column.\n3. Create an output grid with a single row.\n4. Fill the output grid with the extracted values, maintaining their column order from the input grid.",
    "74dd1130.json": "1. For each column in the input grid, examine the values from top to bottom.\n2. In the output grid, replace the value at the top of the column with the value that was originally at the bottom of the corresponding column in the input grid. The other values remain the same as the input. Specifically, output[0][c] = input[rows-1][c], for all columns c, and rows equals to the number of rows in the input grid. Other output values are equal to the corresponding input values: output[r][c] = input[r][c], for r > 0.",
    "75b8110e.json": "1. Create a 4x4 output grid.\n2. Divide the 8x8 input grid into four 4x4 quadrants: top-left, top-right, bottom-left, bottom-right.\n3. Copy the values from the top-left quadrant (yellow, value 4) of the input grid to the corresponding positions in the output grid.\n4. Superimpose the bottom-right quadrant (brown, value 9) of the input grid onto the output grid. When a cell in the bottom-right quadrant has a non-zero value, replace the corresponding cell value in the output grid with this value.\n5. Superimpose the bottom-left quadrant (pink, value 6) of the input grid onto the output grid. When a cell in the bottom-left quadrant has a non-zero value, replace the corresponding cell value in the output grid with this value.\n6. Superimpose the top-right quadrant (grey, value 5) of the input grid onto the output grid. When a cell in the top-right quadrant has a non-zero value, replace the corresponding cell value in the output grid with this value.",
    "760b3cac.json": "1. Get the input grid.\n2. Create an output grid with the same dimensions as the input grid.\n3. Identify the coordinates (R, C) of all pixels with value 8 in the input grid.\n4. For each identified coordinate (R, C) with value 8, set the pixel at (R, mirrored_C) in the output grid to 8. mirrored_C = Input Grid Width - 1 - C.\n5. Copy all pixels with value 4 from the input grid to the corresponding positions in the output grid.\n6. Copy all pixels with value 0 from the input grid to the corresponding positions in the output grid.",
    "776ffc46.json": "1.  Examine the input grid.\n2.  Identify shapes surrounded by a complete border of color 5.\n3.  For each shape surrounded by the border of color 5: \n    a. Identify other shapes in the input grid with the same size and dimensions as the shape within the color 5 border.\n    b. Change the color of these identical shapes to the color of the shape within the color 5 border.\n4. Output the modified grid.",
    "77fdfe62.json": "1. Find the bounding box of the inner region of pixel value 8. The inner region is surrounded by pixels of value 1.\n2. Extract the four corner pixel values from the input grid. The corners are defined as top-left, top-right, bottom-left, and bottom-right.\n3. Determine the output grid dimensions based on the dimensions of the 8-filled region in the input.\n4. Create the output grid with the determined dimensions.\n5.  Assign the top-left corner pixel value from the input to the top-left cell of the output grid.\n6.  Assign the top-right corner pixel value from the input to the top-right cell of the output grid.\n7.  Assign the bottom-left corner pixel value from the input to the bottom-left cell of the output grid.\n8.  Assign the bottom-right corner pixel value from the input to the bottom-right cell of the output grid.",
    "780d0b14.json": "1. Find all distinct values other than 0 in the input grid. Let N be the number of distinct values.\n2. Create an output grid with dimensions N x 2.\n3. For each distinct value V (other than 0) found in the input grid:\n    a. Find the first occurrence of V in the input grid (scan row-wise, then column-wise).\n    b. Determine the index I of V based on the order it was found (first distinct value is index 0, second is index 1, and so on).\n    c. Place V at output grid position (I, 0).\n    d. If there is a value V2 that appears in the same input example, and it is the second value found with the algorithm, store it at (I,1).",
    "7837ac64.json": "1. The output grid is 3x3.\n2. For each cell in the 3x3 output grid, consider a corresponding square of input pixels.\n3.  The top-left output cell (0,0) corresponds to the square formed by the four corner pixels of the input: the top-left, top-right, bottom-left, and bottom-right pixels.\n4.  The top-middle output cell (0,1) corresponds to the square formed by the corner pixels of the input: the top-left, top-right, bottom-left, and bottom-right of a different square region.\n5. Determine the value of the output cell (0,0) by checking the color of the four corner pixels of the input grid: input[0][0], input[0][N-1], input[N-1][0], input[N-1][N-1] where N is the width or height of the input grid.\n6. If all four corner pixels have the same value, then assign this value to the output cell (0,0).\n7. Repeat the process to determine the color of the other output cells based on the color of four corner pixels",
    "794b24be.json": "1. Input: a 3x3 grid of integers from 0 to 9.\n2. Output: a 3x3 grid of integers from 0 to 9.\n3. Count the number of pixels with value 1 in the input grid.\n4. Create a new 3x3 grid, initialized with value 0 everywhere.\n5. Fill the output grid with value 2, based on the count from step 3:\n    a. If the count is 1, set the pixel at (0, 0) to 2.\n    b. If the count is 2, set the pixels at (0, 0) and (0, 1) to 2.\n    c. If the count is 3, set the pixels at (0, 0), (0, 1), and (0, 2) to 2.\n    d. If the count is 4, set the pixels at (0, 0), (0, 1), (0, 2), and (1, 1) to 2.",
    "7b6016b9.json": "1. Take the input grid. The output grid has the same dimensions as the input grid.\n2. Copy the pixel values from the input grid to the output grid.\n3. Find the connected regions of value 7. The surrounding connected regions of 7 will have interior regions of other values which are connected.\n4. Fill any connected region surrounded by 7 with value 2.\n5. Fill the background (connected region of value 0) with value 3.",
    "7b7f7511.json": "1. Halve the width or height of the input grid, whichever is larger.\n2. Copy the first half of the rows or columns from the input grid to the output grid.\n",
    "7c008303.json": "1. Create a 6x6 output grid. Initialize all cells to 0.\n2. In the input grid, identify the 2x2 color block in the upper-right corner. These colors will be used to recolor quadrants of the output grid.\n3. In the input grid, identify the 6x6 block located at rows 4-9 and columns 1-6. This block contains a pattern composed of 3s and 0s.\n4. Copy the 6x6 block of 3s and 0s from the input to the output grid.\n5. Recolor the upper-left 3x3 section of the output grid. Replace all 3s in this section with the color of the upper-left pixel in the 2x2 color block from the input.\n6. Recolor the upper-right 3x3 section of the output grid. Replace all 3s in this section with the color of the upper-right pixel in the 2x2 color block from the input.\n7. Recolor the lower-left 3x3 section of the output grid. Replace all 3s in this section with the color of the lower-left pixel in the 2x2 color block from the input.\n8. Recolor the lower-right 3x3 section of the output grid. Replace all 3s in this section with the color of the lower-right pixel in the 2x2 color block from the input.",
    "7ddcd7ec.json": "1. The output grid has the same dimensions as the input grid.\n2. Identify all non-zero pixel values adjacent to a square block of the same non-zero value, located diagonally from the square's corner.\n3. Extend the identified non-zero pixel value diagonally until the edge of the grid is reached, setting all intermediate pixels along the diagonal to that same non-zero value.",
    "7df24a62.json": "1. Take the input grid.\n2. Create the output grid with the same dimensions as the input grid.\n3. For each cell in the input grid: if the cell has value 4, check its surrounding cells (up, down, left, right).\n4. If a cell with value 4 has neighbors with value 1, set the corresponding cell in the output grid to 1.\n5. If a cell in the input grid is not changed by the previous step, copy the value from the input grid to the corresponding cell in the output grid.",
    "7e0986d6.json": "1. Take the input grid.\n2. The output grid has the same dimensions as the input grid.\n3. For each pixel value 1 (blue), replace it with the pixel value that is the majority of its surrounding pixels.",
    "7f4411dc.json": "1. Analyze the input grid and identify all single, isolated pixels of a color other than 0. A single pixel is defined as a non-0 value surrounded by 0s on all four sides (up, down, left, right). Consider pixels on the edge of the grid to have an implied 0 surrounding them if they lack a neighbor on that side. \n2. Set the value of these identified single, isolated pixels to 0.\n3. Retain the original grid dimensions and all other pixel values.",
    "7fe24cdd.json": "1. Take a 3x3 input grid. \n2. Create a 6x6 output grid.\n3. Copy the input grid to the top-left 3x3 section of the output grid (rows 0-2, columns 0-2).\n4. Rotate the input grid 90 degrees clockwise.\n5. Copy the rotated grid to the top-right 3x3 section of the output grid (rows 0-2, columns 3-5).\n6. Rotate the input grid 180 degrees.\n7. Copy the rotated grid to the bottom-right 3x3 section of the output grid (rows 3-5, columns 3-5).\n8. Rotate the input grid 270 degrees clockwise (or 90 degrees counter-clockwise).\n9. Copy the rotated grid to the bottom-left 3x3 section of the output grid (rows 3-5, columns 0-2).",
    "80af3007.json": "1. Create a 9x9 output grid. \n2. Examine the input grid to identify a 9x9 block containing a pattern on a background of 0. The input grid is larger than 9x9 but the repeating pattern is always found within a 9x9 grid.\n3. Replicate the identified 9x9 pattern within the 9x9 output grid. Specifically, for each cell (R, C) in the output grid, set its value to the corresponding value found at location (R, C) in the identified 9x9 pattern from the input grid.",
    "810b9b61.json": "1. Create an output grid that is identical to the input grid. 2. Identify closed shapes consisting of pixel value 1. A closed shape is fully enclosed. 3. Change the pixel value of the identified closed shapes from 1 to 3 in the output grid.",
    "82819916.json": "1. Get the input grid.\n2. Create an output grid with the same dimensions as the input grid.\n3. Iterate through each row of the input grid.\n4. If a row contains any non-zero values, identify the first, second, and third non-zero values in that row, denoted as A, A, and I respectively. If there are not at least three non-zero values in the row, copy the row from input to output.\n5. If there are at least three non-zero values, populate the rest of the row in the output grid with the pattern A A I I I A I A, repeating the pattern as necessary to fill the entire row.\n6. If the row contains only zero values, copy the row from the input grid to the output grid.\n7. Return the output grid.",
    "83302e8f.json": "1. For each pixel in the input grid, examine its neighboring pixels.\n2. If a pixel has value 0, check its four immediate neighbors (up, down, left, right).\n3. If all four neighbors of a pixel with value 0 have values greater than 0, change the pixel's value to 3.\n4. If a pixel has value 0, and at least one of its four immediate neighbors has a value of 0, change the pixel's value to 4.",
    "834ec97d.json": "1. Locate the non-zero pixel in the input grid. Let its coordinates be (R, C). The input grid contains only one non-zero pixel.\n2. Create an output grid with the same dimensions as the input grid.\n3. Copy the input grid to the output grid.\n4. Move the pixel value at (R, C) in the output grid to (R+1, C).\n5. Starting from row 0 up to (but not including) row R, fill the output grid with the pattern '4, 0, 4, 0, ...' in each row. The first pixel in row 0, column C will be 4.  The pattern alternates every column.",
    "8403a5d5.json": "1. Copy the input grid to the output grid.\n2. Identify the first non-zero pixel value in the bottom row of the input grid. Let its column index be C.\n3. For each column C' starting from C, incrementing by 2:\n    a. Change all pixel values in column C' of the output grid to the pixel value found in the input grid at (bottom row, column C').\n4. For each column C' starting from C+1, incrementing by 2:\n    a. If C' is within the grid's bounds, change the pixel at the top row of column C' in the output grid to 5 if C' is the first such column. Then set every other such column's top row to 5.\n    b. If C' is within the grid's bounds, change the pixel at the bottom row of column C' in the output grid to 5 if C' is the second such column. Then set every other such column's bottom row to 5.",
    "846bdb03.json": "1. Find the bounding box of non-zero pixels in the input grid. This defines the relevant region.\n2. Identify the vertical 'pillar' structures consisting of repeating values along vertical lines. These pillars are located at the left and right edges of the bounding box.\n3. Identify the repeating values (color) at the top and bottom of each pillar. These values are always 4 (yellow).\n4. Create an output grid. The width is equal to the width of the relevant region in the input. The height is equal to the height of the relevant region in the input.\n5. Copy the leftmost pillar from the input bounding box to the leftmost part of the output grid.\n6. Copy the rightmost pillar from the input bounding box to the rightmost part of the output grid.\n7. Copy the values between the pillars from the input to the space between the pillars in the output.",
    "855e0971.json": "1. Locate all pixels with value 0 in the input grid.\n2. For each pixel with value 0 at coordinate (R, C), change all pixels in the same row (R) to 0.\n3. Return the modified grid.",
    "85c4e7cd.json": "1. Define the input grid. The output grid has the same dimensions as the input grid.\n2. Iterate through the layers of the grid, starting from the outermost layer and moving inwards.\n3. In each layer, identify the unique number present on the outer border of that layer in the input grid. \n4. In the output grid, replace the numbers in the current layer with the number that was on the outermost border of the corresponding layer in the input grid, but in reverse order relative to the center. Specifically, the outermost layer of the input becomes the innermost layer of the output, and so on. This effectively reverses the order of the numbers from the outermost layer to the center.",
    "868de0fa.json": "1. Identify all connected regions of pixel value 1.\n2. For each connected region of pixel value 1:\n 2.1. Identify the bounding box of the region.\n 2.2. Fill the interior of the bounding box with pixel value 7, excluding the border pixels that have value 1.\n 2.3. Within the bounding box, change the pixel value to 2 at cells adjacent to the border.",
    "8731374e.json": "1. Find a subgrid within the input grid that contains a value other than the background color. Assume the background color is 8.\n2. Determine the dimensions of this subgrid. Let the height and width of this subgrid be H and W.\n3. Create an output grid of size H x W.\n4. Identify all locations (R, C) within the input subgrid where the pixel value is not equal to 8.\n5. For each identified location (R, C) in the input subgrid, get the value V at that location.\n6. In the output grid, fill the entire row R with the value V.\n7. In the output grid, fill the entire column C with the value V.",
    "88a10436.json": "1. Identify the 3x3 subgrid within the input grid. This subgrid contains non-zero values other than 5. It represents the shape to be copied.\n2. Identify the location of the pixel with value 5 in the input grid. Let its row and column indices be R and C respectively.\n3. Copy the identified 3x3 subgrid to the output grid, such that the center pixel of the 3x3 subgrid overlaps with the pixel with value 5 in the input grid. Specifically, the pixel at (row, col) in the 3x3 subgrid is copied to the location (R + row - 1, C + col - 1) in the output grid, where (1,1) is the index of the center pixel of the 3x3 subgrid.\n4. Copy all the other pixels from the input grid to the output grid.",
    "88a62173.json": "1. Take the input grid. It has dimensions 5x5.\n2. Create an output grid with dimensions 2x2.\n3. Extract the 2x2 subgrid from the bottom-left corner of the input grid.\n4. Assign the values from this 2x2 subgrid to the output grid, row by row, from top to bottom.",
    "890034e9.json": "1. Identify the shape in the input grid containing a central area filled with the value 0.\n2. Count the number of 0s within the central area of the identified shape.\n3. Find another location in the input grid that contains a connected region of 0s equal in number to the count from Step 2. This region of 0s may have additional adjacent 0s.\n4. Replicate the original shape, using the center of the connected 0s region found in Step 3 as the new center location within the output grid.\n5. The output grid contains the original input grid and the replicated shape.",
    "8a004b2b.json": "1. Find the coordinates of the four pixels with value 4. These define the corners of a rectangle.\n2. Determine the dimensions of the output grid. The width is the horizontal distance between the two 4's on the top or bottom, plus one. The height is the vertical distance between the two 4's on the left or right, plus one.\n3. Create an empty output grid with the determined dimensions, filled with 0s.\n4. Copy the pattern outside the four 4's in the input grid to the area bounded by the four 4's in the output grid.",
    "8be77c9e.json": "1. Take the input grid. The input grid has a height of 3 and width of 3.\n2. Create an output grid. The output grid has a height of 6 and the same width as the input grid (3).\n3. Copy the input grid to the top half of the output grid (rows 0, 1, 2 of the output grid are identical to rows 0, 1, 2 of the input grid).\n4. Reverse the order of the rows of the input grid.\n5. Copy the reversed input grid to the bottom half of the output grid (rows 3, 4, 5 of the output grid are the reversed rows 2, 1, 0 of the input grid).",
    "8d5021e8.json": "1. Take the input grid.\n2. Create an output grid with width equal to four times the input grid width.\n3. Create an output grid with height equal to three times the input grid height.\n4. For each row in the input grid, create three copies of that row in the output grid, one after the other.\n5. For each column in the input grid, create a reversed copy (order of pixel values is flipped) of that column next to it, for a total of four copies of each column.\n6. The output grid consists of repeating the input grid and its vertically and horizontally flipped version.",
    "8d510a79.json": "1. For each column C in the input grid, locate all pixel locations with value 1 (blue) or 2 (red).\n2. For each located pixel value 1 (blue) at row R, change all pixel values below row R in the same column C, until the bottom of the grid, to 1.\n3. For each located pixel value 2 (red) at row R, change all pixel values above row R in the same column C, until the top of the grid, to 2.",
    "8e1813be.json": "1. Find the rows in the input grid that contain non-zero values other than background value 0. These rows define the color stripes.\n2. Extract the unique non-zero values from these rows, preserving their order.\n3. Determine the height and width of the output grid. The output grid's height should equal the number of extracted unique non-zero row values. The output grid's width should equal the width of the stripe colors in the input grid.\n4. Fill the output grid. For each row in the output grid, repeat the extracted color value for that row across the entire width of the output grid.\n",
    "8e5a5113.json": "1. Divide the input grid into three 3x3 squares horizontally. Call them square A, square B, and square C, from left to right.\n2. Create the output grid with the same dimensions as the input grid.\n3. Copy square A to the leftmost 3x3 portion of the output grid.\n4. Rotate the values in square B clockwise by 90 degrees and place in the center 3x3 portion of the output grid. Specifically: The value at (R, C) in square B becomes the value at (C, 2-R) in the corresponding location in the output grid.\n5. Rotate the values in square C clockwise by 180 degrees and place in the rightmost 3x3 portion of the output grid. Specifically: The value at (R, C) in square C becomes the value at (2-R, 2-C) in the corresponding location in the output grid.\n6. Copy any other values that are not part of the 3x3 squares directly from the input grid to the corresponding locations in the output grid.",
    "8eb1be9a.json": "1. Examine the input grid.\n2. Copy a sub-grid pattern from the center of the input grid.\n3. Tile the entire output grid with this copied pattern. The output grid has the same dimensions as the input grid.",
    "8efcae92.json": "1. Find the shapes that contain the color 1 and color 2 on a background color 0.\n2. Identify ONE of these shapes.\n3. Set the output grid dimensions to match the width and height of the identified shape from step 2.\n4. Copy the color pattern from the identified shape to the output grid. Each pixel in the shape corresponds to the pixel at the same location in the output grid.",
    "8f2ea7aa.json": "1. Initialize the output grid as a copy of the input grid.\n2. Iterate through each cell (R, C) in the input grid.\n3. If the value at input grid cell (R, C) is not 0, then:\n4. Replicate the value at input grid cell (R, C) to the corresponding 3x3 block in the output grid. Specifically, for each non-zero value V at input grid cell (R, C), set the 3x3 block in the output grid, starting at the row (R % 3) * 3 and column (C % 3) * 3, to the value V.",
    "90c28cc7.json": "1. Identify the repeating colored blocks, ignoring the background color 0. A colored block is a group of same-colored, adjacent pixels. Each block is a rectangle.\n2. Extract the colors of the blocks from left to right and from top to bottom.\n3. Create the output grid using these extracted colors.",
    "90f3ed37.json": "1. Read the input grid.\n2. For each row in the input grid, if there is a sequence of 8s, fill the empty cells to the right of that sequence with 1s until the end of the row.\n3. The output grid has the same dimensions as the input grid.",
    "913fb3ed.json": "1. The output grid has the same dimensions as the input grid.\n2. For each pixel value 3 (green) in the input grid at coordinate (R, C), change the surrounding pixels in the output grid to the value 6 (pink). The surrounding pixels are defined as (R-1, C-1), (R-1, C), (R-1, C+1), (R, C-1), (R, C+1), (R+1, C-1), (R+1, C), and (R+1, C+1).\n3. For each pixel value 8 (cyan/light blue) in the input grid at coordinate (R, C), change the surrounding pixels in the output grid to the value 4 (yellow). The surrounding pixels are defined as (R-1, C-1), (R-1, C), (R-1, C+1), (R, C-1), (R, C+1), (R+1, C-1), (R+1, C), and (R+1, C+1).\n4. For each pixel value 2 (red) in the input grid at coordinate (R, C), change the surrounding pixels in the output grid to the value 1 (blue). The surrounding pixels are defined as (R-1, C-1), (R-1, C), (R-1, C+1), (R, C-1), (R, C+1), (R+1, C-1), (R+1, C), and (R+1, C+1).\n5. If a pixel is out of bounds, skip it.\n6. After applying the color changes, if the input pixel value is not 0, retain the original input pixel value in the output grid at the corresponding location. Specifically, if the pixel at location (R,C) in the input grid is 3, 8, or 2, copy that value into the output grid at (R,C).",
    "91413438.json": "1. Count the number of non-zero pixels in the input grid.\n2. Let this count be N.\n3. Determine the output grid size based on N. If N is 1, the output grid size is 18x18. If N is 2, the output grid size is 15x15. If N is 3, the output grid size is 12x12. If N is 4, the output grid size is 9x9.\n4. Create a black (0) output grid of the determined size.\n5. Copy the input 3x3 grid into the top-left corner of the output grid.\n6. Horizontally repeat the top 3 rows of the output grid, N times.",
    "91714a58.json": "1. Find the largest solid block of a single color in the input grid that has at least two rows.\n2. Create an output grid of the same dimensions as the input grid, filled with 0.\n3. Copy the solid block to the output grid, preserving its original size, position, and color.",
    "9172f3a0.json": "1. Take the input, which is a 3x3 grid.\n2. Create an output grid of size 9x9.\n3. Iterate through each cell (R, C) in the input grid (where R and C range from 0 to 2).\n4. For each cell (R, C) in the input grid, get the pixel value at that cell.\n5. In the output grid, fill a 3x3 block with the pixel value from the input cell (R, C). The top-left corner of this 3x3 block in the output grid should be located at (R*3, C*3).\n6. Each cell in the 3x3 block at the output grid is assigned the same pixel value that was present in the input cell (R, C).",
    "928ad970.json": "1. Copy the input grid to the output grid.\n2. Find the four pixels with value 5. These pixels define the corners used for creating the new rectangle.\n3. Determine the color of the rectangle inside the four 5 pixels in the input.\n4. Draw a rectangle using the color determined in step 3. The sides of the rectangle should touch the inside of the four 5 pixels.",
    "93b581b8.json": "1. Copy the input grid to the output grid.\n2. Locate the 2x2 square within the grid. The 2x2 square is defined as a contiguous block of four non-zero values.\n3. Determine the values at the four corners of the 2x2 square. Let these values be A, B, C, and D, where A is the top-left, B is the top-right, C is the bottom-left, and D is the bottom-right.\n4. Create four 2x2 blocks to add to the output grid, each filled with a single color.\n5. Place the first 2x2 block (filled with the value of D) at the top-left corner of the output grid.\n6. Place the second 2x2 block (filled with the value of C) at the top-right corner of the output grid. If the block extends beyond the grid boundaries, only the portion within the boundaries is retained. Coordinates must be respected.\n7. Place the third 2x2 block (filled with the value of B) at the bottom-left corner of the output grid. If the block extends beyond the grid boundaries, only the portion within the boundaries is retained. Coordinates must be respected.\n8. Place the fourth 2x2 block (filled with the value of A) at the bottom-right corner of the output grid. If the block extends beyond the grid boundaries, only the portion within the boundaries is retained. Coordinates must be respected.",
    "941d9a10.json": "1. Copy the input grid to the output grid.\n2. Fill the top-left area, which are contiguous 0s bounded by 5s, with 1.\n3. Fill the center area, which are contiguous 0s bounded by 5s, with 2.\n4. Fill the bottom-right area, which are contiguous 0s bounded by 5s, with 3.",
    "94f9d214.json": "1. Create a 4x4 output grid.\n2. Overlay the top 4x4 subgrid of the input onto the bottom 4x4 subgrid. Specifically, for each cell (R, C) in the output grid (where R and C range from 0 to 3): if the pixel value at (R, C) in the top 4x4 subgrid of the input is not 0, set the output grid cell (R, C) to that value. Otherwise, set the output grid cell (R, C) to the pixel value at (R, C) in the bottom 4x4 subgrid of the input.\n3. For each cell (R, C) in the output grid: if the pixel value at (R, C) is 0, change it to 2.\n4. For each cell (R, C) in the output grid: if the pixel value at (R, C) is not 2, change it to 0.",
    "952a094c.json": "1. Find the bounding box of a connected region of non-zero pixel values. Let this be the \"border\".\n2. Identify the four corner pixels within the \"border\". These will have values other than the value of the \"border\". Let these be corner pixels A, B, C, and D.\n3. Create a new grid with the same dimensions as the input grid.\n4. Copy the \"border\" from the input grid to the output grid.\n5. Move the corner pixel A to the opposite corner of the border in the output grid.\n6. Move the corner pixel B to the opposite corner of the border in the output grid.\n7. Move the corner pixel C to the opposite corner of the border in the output grid.\n8. Move the corner pixel D to the opposite corner of the border in the output grid.\n9. Fill all other cells in the new grid with 0.",
    "9565186b.json": "1. Analyze the input grid and count the occurrences of each unique number.\n2. Identify the number that appears most frequently in the input grid. If there are ties, pick one of the most frequent numbers.\n3. Iterate through each pixel in the input grid.\n4. If the pixel value is not equal to the most frequent number, change the pixel value to 5 (grey). Otherwise, keep the pixel value as is.\n5. Output the modified grid.",
    "95990924.json": "1. Iterate through each cell (R, C) of the input grid.\n2. If the value at cell (R, C) is 5, then:\n3. Set the pixel value at (R-1, C-1) in the output grid to 1.\n4. Set the pixel value at (R-1, C+1) in the output grid to 2.\n5. Set the pixel value at (R+1, C-1) in the output grid to 3.\n6. Set the pixel value at (R+1, C+1) in the output grid to 4.\n7. Set the pixel value at (R, C) in the output grid to 5.\n8. If a coordinate falls outside the grid boundaries, treat it as 0.\n9. Copy the original values from input to output, except for those immediately surrounding a 5. This includes maintaining the same grid size.",
    "963e52fc.json": "1. Get the input grid dimensions: input height and input width.\n2. Create an output grid with the same height as the input grid and twice the width of the input grid.\n3. Iterate through each row R of the input grid from 0 to input height - 1.\n4. Iterate through each column C of the input grid from 0 to input width - 1.\n5. Copy the pixel value at (R, C) from the input grid to the output grid at (R, C).\n6. Copy the pixel value at (R, C) from the input grid to the output grid at (R, C + input width).",
    "97999447.json": "1. For each row in the input grid, locate each non-zero pixel.\n2. For each non-zero pixel found at row R and column C, repeat the following steps until the right edge of the grid is reached in that row.\n3. Starting at the column immediately to the right of C (C+1), set the pixel value to 5.\n4. Move one column to the right (C+2). Set the pixel value to the original non-zero pixel's value.\n5. Move one column to the right (C+3). Set the pixel value to 5.\n6. Continue alternating the original non-zero pixel value and 5, moving one column to the right each time, until the edge of the grid is reached in row R.",
    "97a05b5b.json": "1. Find the bounding box of the largest contiguous region of value 2 in the input grid. This defines the output grid dimensions.\n2. Create an output grid with the dimensions found in step 1, filled with value 2.\n3. Identify all distinct contiguous regions of non-zero values (excluding 0) that are not part of the largest contiguous region of value 2 in the input grid.\n4. For each such region identified in step 3, copy the pixel values from the input grid to the corresponding location in the output grid. Maintain the relative position of the region within the input grid's overall bounding box. If copied values overlap the output grid bounds, values outside are clipped to output grid bounds.",
    "98cf29f8.json": "1. Identify the single horizontal or vertical line segment consisting of a single color. Let this color be denoted as 'X'.\n2. Identify the other shape consisting of color 'X'.\n3. Remove the identified line segment of color 'X'.\n4. Move the other shape consisting of color 'X' to be adjacent to the remaining shape.",
    "995c5fa3.json": "1. Divide the input grid (4x14) into three 4x4 subgrids, separated by columns of 0s. The grid is indexed top-to-bottom, left-to-right.\n2. Create a 3x3 output grid.\n3. For the top row (row 0) of the output grid, determine its color based on the first 4x4 subgrid of the input. Specifically:\n    a. If input subgrid has the pattern shown in training example 1 (rows 2 and 3 contain 0 at columns 1 and 2), set the color of the entire top row to 3.\n    b. If input subgrid has the pattern shown in training example 2 (row 0, column 0 contains 0, and row 1 and 2, column 0 contains 0), set the color of the entire top row to 8.\n    c. If input subgrid has the pattern shown in training example 4 (all same value), set the color of the entire top row to 2.\n4. For the middle row (row 1) of the output grid, determine its color based on the second 4x4 subgrid of the input. Specifically:\n    a. If input subgrid has the pattern shown in training example 1 (rows 2 and 3 contain 0 at columns 1 and 2), set the color of the entire middle row to 8.\n    b. If input subgrid has the pattern shown in training example 2 (row 0, column 0 contains 0, and row 1 and 2, column 0 contains 0), set the color of the entire middle row to 4.\n    c. If input subgrid has the pattern shown in training example 4 (all same value), set the color of the entire middle row to 4.\n5. For the bottom row (row 2) of the output grid, determine its color based on the third 4x4 subgrid of the input. Specifically:\n    a. If input subgrid has the pattern shown in training example 1 (rows 2 and 3 contain 0 at columns 1 and 2), set the color of the entire bottom row to 3.\n    b. If input subgrid has the pattern shown in training example 2 (row 0, column 0 contains 0, and row 1 and 2, column 0 contains 0), set the color of the entire bottom row to 2.\n    c. If input subgrid has the pattern shown in training example 4 (all same value), set the color of the entire bottom row to 2.\n6. Fill the entire row with the determined color.",
    "99b1bc43.json": "1. Divide the input grid into two subgrids separated by a row of value 4. Name the top grid 'grid1' and the bottom grid 'grid2'.\n2. Create an output grid with the same dimensions as 'grid1'.\n3. Iterate through each cell (R, C) of 'grid1' and 'grid2', where R is the row index and C is the column index.\n4. At cell (R, C), compare the value in 'grid1' with the value in 'grid2'.\n5. If the value in 'grid1' at (R, C) is equal to the value in 'grid2' at (R, C), set the value of the output grid at (R, C) to 0.\n6. Otherwise, if the value in 'grid1' at (R, C) is not equal to the value in 'grid2' at (R, C), set the value of the output grid at (R, C) to 3.",
    "99fa7670.json": "1. Read the input grid.\n2. Create an output grid with the same dimensions as the input grid.\n3. Copy the input grid to the output grid.\n4. Iterate through each row of the output grid from top to bottom.\n5. Iterate through each column of the output grid from left to right.\n6. If the current cell (R, C) has a value other than 0, execute the following steps:\n7. Extend the color of the cell (R, C) to the right until the edge of the grid is reached. For each cell to the right (R, C+1), (R, C+2), ... set the value to the color of the original cell (R, C) until the edge is reached.\n8. Extend the color downwards starting from the rightmost cell that was colored in the previous step. Find the rightmost colored cell in the same row. Set the cells directly below this rightmost cell to the same color, until the bottom edge is reached. For each cell below (R+1, C_right), (R+2, C_right), ... set the value to the color of the cell (R, C_right) where C_right is the column index of the rightmost colored cell of row R, until the edge is reached.",
    "9aec4887.json": "1. Get the input grid. Identify the two distinct patterns present in the input grid. One pattern consists of the values 1, 2, 3, and 4. The other consists of the value 8.\n2. Determine the dimensions (rows and columns) of the target output grid. The height and width of the output grid are equal to the dimensions of the pattern with values 1, 2, 3, and 4.\n3. Create an empty output grid with the determined dimensions, initialized with values of 0.\n4. Copy the pattern consisting of the values 1, 2, 3, and 4 into the output grid.\n5. Overlay the pattern with value 8 onto the output grid. For each cell in the output grid, if the corresponding cell in the overlay pattern is 8, and the corresponding cell is currently set to 0, 1, 2, 3, or 4, then update the cell in the output to 8.",
    "9af7a82c.json": "1. Count the occurrences of each distinct number (0-9) in the input grid. \n2. Determine the height of the output grid. This is equal to the largest count from Step 1.\n3. Determine the width of the output grid. This is equal to the number of distinct numbers (0-9) found in the input grid.\n4. Create an output grid of the determined height and width, filled with 0s.\n5. Sort the distinct numbers from the input grid in descending order based on their counts from Step 1. This determines the column order for the next steps.\n6. Iterate through the sorted distinct numbers (colors) and their corresponding counts. For each number, fill a column in the output grid, from top to bottom, with that number. The number of cells filled in each column equals the corresponding count.\n7. The column order in the output grid corresponds to the sorted order from step 5 (most frequent number on the left, least frequent on the right).",
    "9d9215db.json": "1. The output grid has the same dimensions as the input grid.\n2. Identify non-zero pixel values in the input grid.\n3. For each non-zero pixel value at coordinate (R, C) in the input, create a reflected pattern in the output.\n4. Reflect the identified non-zero input pixels across the vertical and horizontal axes, with the center of reflection being the center of the grid.\n5. The reflected pattern maintains the original pixel values.\n6. There are single 0 pixel separations between the original and reflected non-zero pixel values.",
    "9dfd6313.json": "1. Given an input grid of numbers, generate an output grid of the same size.\n2. Rotate the input grid 90 degrees clockwise.\n3. Reflect the rotated grid across the vertical axis (mirror horizontally). The left edge of the rotated grid becomes the right edge of the output grid.",
    "9ecd008a.json": "1. Find the bounding box of the connected region(s) of pixel value 0 in the input grid.\n2. Define the output grid dimensions to be the same as the dimensions of this bounding box.\n3. Extract the subgrid within the bounding box from the input grid.\n4. Assign this extracted subgrid as the output grid.",
    "9edfc990.json": "1. Create an output grid that is a direct copy of the input grid.\n2. Identify all locations in the input grid with value 0.\n3. For each location (R, C) with value 0, perform a flood fill operation, changing connected 0s to 1, but only if this 0 is not surrounded by non-zero numbers. That is, change the connected 0s to 1 only if there is at least one empty direction (up, down, left, right).",
    "9f236235.json": "1. Identify the unique non-zero values present along the central rows and columns of the input grid. These values represent the target values.\n2. Create an output grid where the values are based on the target values found in step 1. The dimensions of the output grid correspond to the number of unique non-zero values found.\n3. Mirror the resulting extracted pattern both horizontally and vertically, placing the mirrored pattern in the output grid.",
    "a1570a43.json": "1. Identify the locations of the four corner pixels with a value of 3. These form a bounding box.\n2. Identify all pixels with a value of 2 in the input grid. These form the shape to be repositioned.\n3. Calculate the center of the bounding box formed by the four 3 pixels.\n4. Calculate the center of the shape formed by the 2 pixels.\n5. Shift the shape of 2 pixels so that its center coincides with the center of the bounding box. Pixels of value 2 should be placed inside the bounding box.\n6. Maintain the original locations of the corner pixels with value 3.",
    "a2fd1cf0.json": "1. Find the coordinates (R1, C1) of the first square with value 2.\n2. Find the coordinates (R2, C2) of the second square with value 3.\n3. Create a path of value 8 connecting the two squares using only horizontal and vertical segments.\n4. The horizontal segment starts from square with value 2 at (R1, C1) and extends to a column C3.\n5. The vertical segment starts from square with value 3 at (R2, C2) and extends to a row R3.\n6. The meeting point of the horizontal and vertical segments is (R3, C3), where R3 equals R2 and C3 equals C1, therefore construct the L shape by filling value 8.\n7. Fill all the grid cells between (R1, C1) and (R1, C2) (exclusive) with value 8.\n8. Fill all the grid cells between (R2, C2) and (R1, C2) (exclusive) with value 8.\n9. If R1 is not equal to R2 and C1 is not equal to C2, form an L-shaped path by setting the cells between the two squares to 8.",
    "a3325580.json": "1. Find all distinct non-zero numbers in the input grid.\n2. For each distinct non-zero number, count the number of connected grid cells that have that number's value. Consider each cell as a separate object.\n3. Find the non-zero numbers that have the largest count.\n4. Generate the output grid. The width of the output grid is equal to the number of non-zero numbers found in step 3.\n5. The height of the output grid is equal to the largest count of connected grid cells (determined in step 2).\n6. Fill each column of the output grid with the non-zero number that has the largest count. The order of the columns corresponds to the order in which the numbers were encountered in the input from left to right, then top to bottom.",
    "a3df8b1e.json": "1. Find the coordinates (R, C) of the pixel with value 1 in the input grid. This is the starting point. It will always be on the bottom row.\n2. Create an output grid with the same dimensions as the input grid, filled with 0s.\n3. Starting from the pixel with value 1 at (R, C) in the input, set the pixel at (R - 1, C + 1) to 1 in the output grid, if (R - 1, C + 1) are within the grid boundaries.\n4. Then set pixel (R - 2, C + 0) to 1, if (R - 2, C + 0) are within the grid boundaries.\n5. Repeat steps alternating +1 to C and +0 to C on odd rows counted upwards from initial position, each time setting a pixel value to 1, until you reach the top row or the boundary of the grid. The R coordinate decreases by 1 on each step, the C alternates between increasing and staying constant.\n6. If C + 1 reaches the right edge, subsequent pairs of points should be placed with C - 1 on the next row instead, alternating between C + 0 and C - 1.\n7. The placement of alternating 1's on the output grid resembles a diagonal staircase pattern originating from the initial 1 in the input grid.",
    "a416b8f3.json": "1. Get the input grid. Let the input grid have width W and height H.\n2. Create an output grid with width 2W and height H. Initialize all cells to 0.\n3. Iterate through each row R from 0 to H-1.\n4. Iterate through each column C from 0 to W-1.\n5. Copy the pixel value at (R, C) in the input grid to (R, C) in the output grid.\n6. Copy the pixel value at (R, C) in the input grid to (R, C+W) in the output grid.",
    "a48eeaf7.json": "1. Identify all pixel locations with value 5 in the input grid.\n2. Identify all pixel locations with value 2 in the input grid.\n3. For each pixel with value 5, move it along its row or column towards the nearest pixel with value 2 until it is adjacent to a pixel with value 2.\n4. If there are multiple pixels with value 2 at the same distance, prioritize moving along the row.\n5. If a pixel with value 5 is already adjacent to a pixel with value 2, leave it in place.\n6. Retain the value 2 pixels in their original locations.\n7. All other cells become 0.",
    "a5313dff.json": "1. Iterate through each pixel in the input grid.\n2. Identify connected regions of non-zero pixels.\n3. For each connected region, examine the pixels within the region that are not on the border of the grid.\n4. Change the value of these interior pixels to 1.",
    "a5f85a15.json": "1. Create an output grid that is an exact copy of the input grid.\n2. Iterate through the diagonals of the grid. A diagonal is defined as all cells where the sum of the row and column indices is constant.\n3. On each diagonal, starting from the second cell, change every other cell's value to 4.",
    "a61ba2ce.json": "1. Create a 4x4 output grid. Initialize all cells to 0.\n2. Locate the first group of connected non-zero pixels in the input grid. Let the pixel values in this group be denoted as 'A'.\n3. Place 'A' in the top-left corner (0,0) and (1,0) and (0,1) locations of the output grid.\n4. Locate the second group of connected non-zero pixels in the input grid. Let the pixel values in this group be denoted as 'B'.\n5. Place 'B' in the top-right corner (0,3) and (1,3) and (0,2) locations of the output grid.\n6. Locate the third group of connected non-zero pixels in the input grid. Let the pixel values in this group be denoted as 'C'.\n7. Place 'C' in the bottom-left corner (3,0) and (2,0) and (3,1) locations of the output grid.\n8. Locate the fourth group of connected non-zero pixels in the input grid. Let the pixel values in this group be denoted as 'D'.\n9. Place 'D' in the bottom-right corner (3,3) and (2,3) and (3,2) locations of the output grid.\n10. Set the pixel values at locations (1,1) and (1,2) and (2,1) and (2,2) to 0.",
    "a61f2674.json": "1. Identify all vertical columns of 5s in the input grid.\n2. Measure the height (number of consecutive 5s) of each identified column.\n3. Find the column with the maximum height.\n4. Change the value of all cells in the column with the maximum height to 1.\n5. Find the column with the minimum height.\n6. Change the value of all cells in the column with the minimum height to 2.\n7. Change the value of all remaining 5s to 0.",
    "a64e4611.json": "1. The output grid has the same dimensions as the input grid. \n2. Identify contiguous regions of 0s in the input grid.\n3. Fill the regions of 0s with the value 3. \n4. Maintain the border values of the original grid.",
    "a65b410d.json": "1. Find the row index R of the first row containing pixel value 2. This row represents the 'red line'.\n2. Let N be the number of consecutive pixels with value 2 in row R, starting from the first column.\n3. Starting from row R-1 and going upwards, for each row with index i (R-1, R-2, ...), create a horizontal line of consecutive pixels with value 3 (green). The number of green pixels in row i is N + (R-1-i). Fill these pixels starting from the first column.\n4. Starting from row R+1 and going downwards, for each row with index j (R+1, R+2, ...), create a horizontal line of consecutive pixels with value 1 (blue). The number of blue pixels in row j is N - (j-R). Fill these pixels starting from the first column. Stop when N - (j - R) is less than or equal to 0.",
    "a68b268e.json": "1. Divide the input grid into four 4x4 subgrids, separated by a row and column of value 1.\n2. Create a 4x4 output grid.\n3. Initialize the output grid with values from the top-left 4x4 subgrid of the input.\n4. Iterate through each cell (R, C) in the output grid (where R and C range from 0 to 3 inclusive).\n5. If the value of the cell (R, C) in the output grid is 0, replace it with the value of the corresponding cell (R, C) from the other three 4x4 subgrids (top-right, bottom-left, and bottom-right) in the input, prioritizing any non-zero value from these subgrids. If all corresponding cells are 0, the output cell remains 0.",
    "a699fb00.json": "1. Iterate through each row of the input grid. Let R be the current row index.\n2. Within row R, iterate through each cell. Let C be the current column index.\n3. Check if the cell at (R, C) has a value of 0.\n4. If the value at (R, C) is 0, check the values of the cells immediately to its left (R, C-1) and right (R, C+1).\n5. If the values at both (R, C-1) and (R, C+1) are 1, then set the value of the cell at (R, C) to 2.",
    "a740d043.json": "1. Find a connected component of non-1 values in the input grid. If there are multiple components, find the one that is closest to the top-left corner (0, 0) of the input grid.\n2. Extract the minimum bounding box that contains this connected component.\n3. The output grid is equal to the extracted bounding box.\n4. Replace all values of 1 in the output grid with 0.",
    "a78176bb.json": "1. Get the input grid.\n2. Identify the diagonal line of a single color (non-zero digit). Let this color be 'X'.\n3. Create a new grid with the same dimensions as the input grid.\n4. Copy the original diagonal line with color 'X' to the new grid.\n5. Locate the grey (5) regions adjacent to the diagonal line.\n6. Extend the diagonal line (color 'X') into the black (0) regions adjacent to the grey (5) regions. The extended diagonal line should mirror the original diagonal line's pattern relative to the grey regions.\n7. Convert all grey (5) cells to black (0).",
    "a79310a0.json": "1. Examine the input grid.\n2. Identify all pixel locations (R, C) where the pixel value is 8.\n3. Create an output grid with the same dimensions as the input grid, initialized with all pixel values set to 0.\n4. For each identified location (R, C) in the input grid where the pixel value is 8, set the pixel value at location (R+1, C) in the output grid to 2.\n5. If R+1 exceeds the grid dimensions, wrap around to the top (R=0). However, based on the training examples, this wrapping is not required, as the shape can go one row below. So, continue when R+1 is a valid index.\n6. Output the modified grid.",
    "a85d4709.json": "1. For each row in the input grid, check the position of pixel value 5.\n2. If pixel value 5 is in the first column of the row, set all pixel values in that row of the output grid to 2.\n3. If pixel value 5 is in the second column of the row, set all pixel values in that row of the output grid to 4.\n4. If pixel value 5 is in the third column of the row, set all pixel values in that row of the output grid to 3.",
    "a87f7484.json": "1. For each distinct value in the input grid, count its occurrences.\n2. Find the value with the highest count.\n3. Extract the 3x3 subgrid from the top-left corner of the input grid.\n4. If the most frequent value from step 2 is present in this 3x3 subgrid from step 3, output that 3x3 subgrid; otherwise, create a 3x3 grid where the center element is '0' and all other elements match the value obtained in step 2.",
    "a8c38be5.json": "1. Divide the input grid into 3x3 subgrids. The input grid size is variable but always divisible by 3.\n2. Create a 9x9 output grid, initialize it with the value 5 (grey).\n3. Place the input 3x3 subgrids into the output grid according to these rules:\n4. The 3x3 subgrid from the center of the input should be placed in the center of the output.\n5. Place other subgrids such that if two subgrids from the input share a common edge with color X, then the corresponding edges in the output grid should align with the same value of X.",
    "a8d7556c.json": "1. The output grid has the same dimensions as the input grid.\n2. Examine each possible square subgrid of size 2x2 or larger within the input grid.\n3. If all the pixel values within a square subgrid are 0, then in the output grid, set the pixel values corresponding to that square subgrid to 2.",
    "a9f96cdd.json": "1. Find the coordinates (R, C) of the pixel with value 2 in the input grid.\n2. Create an output grid with the same dimensions as the input grid.\n3. Set the pixel at (R-1, C-1) in the output grid to 3, if (R-1, C-1) is within the grid boundaries.\n4. Set the pixel at (R-1, C+1) in the output grid to 6, if (R-1, C+1) is within the grid boundaries.\n5. Set the pixel at (R+1, C-1) in the output grid to 8, if (R+1, C-1) is within the grid boundaries.\n6. Set the pixel at (R+1, C+1) in the output grid to 7, if (R+1, C+1) is within the grid boundaries.\n7. All other pixels in the output grid retain a value of 0.",
    "aabf363d.json": "1. Get the grid dimensions: R (number of rows), C (number of columns).\n2. Get the value of the pixel at the bottom-left corner (R-1, 0). Let this value be denoted as V.\n3. For each pixel (r, c) in the input grid where 0 <= r < R-1 and 0 <= c < C, if the pixel value is not 0, replace it with V.\n4. Set the pixel at (R-1, 0) to 0.",
    "aba27056.json": "1. Analyze the input grid to identify a rectangular shape formed by non-zero pixel values, potentially with a hole of zero pixel values inside.\n2. Change the pixel values within the hole of the identified rectangle to 4.\n3. From each inner corner of the filled hole, extend a diagonal line outwards to the edge of the grid, changing the pixel values along the diagonal to 4.\n4. From any horizontal or vertical line extending out of the hole, change the pixel values along the line outwards to the edge of the grid to 4. If a pixel already has value 4, do not change it.",
    "ac0a08a4.json": "1. Read the input grid dimensions (rows and columns).\n2. Create a new output grid filled with 0s (black).\n3. Determine the unique non-0 (colored) values present in the input grid.\n4. Calculate the output grid dimensions: Multiply the input grid's number of rows and columns by the number of unique non-0 values.\n5. For each unique non-0 value in the input grid, determine its coordinates (row and column) in the input grid.\n6. In the output grid, replace a square block of pixels with the current non-0 value. The side length of this square is equal to the number of unique non-0 values in the input grid.\n7. Calculate the starting coordinates of the square block in the output grid by multiplying the input grid coordinates of the non-0 value by the number of unique non-0 values.\n8. Fill the square block in the output grid with the non-0 value.",
    "ae3edfdc.json": "1. Find the locations of pixel value 2 and pixel value 1 in the input grid. These locations will remain the same in the output grid.\n2. For each pixel with value 3, move it horizontally or vertically to be adjacent to the pixel value 2. Specifically, if a pixel with value 3 is above the pixel value 2, place it directly above the pixel value 2 in the output. If a pixel with value 3 is below the pixel value 2, place it directly below the pixel value 2 in the output. If a pixel with value 3 is to the right of the pixel value 2, place it directly to the right of the pixel value 2 in the output. If a pixel with value 3 is to the left of the pixel value 2, place it directly to the left of pixel value 2 in the output.\n3. For each pixel with value 7, move it horizontally or vertically to be adjacent to the pixel value 1. Specifically, if a pixel with value 7 is above the pixel value 1, place it directly above the pixel value 1 in the output. If a pixel with value 7 is below the pixel value 1, place it directly below the pixel value 1 in the output. If a pixel with value 7 is to the right of the pixel value 1, place it directly to the right of the pixel value 1 in the output. If a pixel with value 7 is to the left of the pixel value 1, place it directly to the left of pixel value 1 in the output.\n4. All other locations in the output grid not covered in steps 2-3 will have pixel value 0.",
    "ae4f1146.json": "1. Divide the input grid into four 3x3 subgrids. The top-left subgrid is at (0,0). The top-right subgrid is at (0,6). The bottom-left subgrid is at (6,0). The bottom-right subgrid is at (6,6).\n2. Locate the subgrid that does not have any subgrids above it or to the left of it. This will be the subgrid at (6,6).\n3. Copy the 3x3 pattern from the identified subgrid.\n4. The copied 3x3 pattern is the output.",
    "aedd82e4.json": "1. Copy the input grid to the output grid. 2. Identify all single-pixel objects. A single-pixel object is a pixel with a non-zero value that is not adjacent (horizontally or vertically) to any other pixel with the same non-zero value. 3. Change the value of each single-pixel object to 1.",
    "af902bf9.json": "1. Find all locations of pixel value 4 in the input grid.\n2. For each location (R, C) of pixel value 4, place pixel value 2 in the output grid, according to the pattern below. The pattern describes the relative coordinates from each (R, C) location:\n    - If a 4 is at (R, C) and there is another 4 at (R+1, C), then fill the output grid at locations (R+2, C-2), (R+2, C-1), (R+2, C), (R+2, C+1), (R+2, C+2) with the value 2.\n    - If a 4 is at (R, C) and there is another 4 at (R, C+1), then fill the output grid at locations (R-2, C+2), (R-1, C+2), (R, C+2), (R+1, C+2), (R+2, C+2) with the value 2.\n    - If a 4 is at (R, C) and there is another 4 at (R+1, C+1), then fill the output grid at locations (R+2, C-2), (R+2, C-1), (R+2, C), (R+2, C+1), (R+2, C+2), (R-2, C+2), (R-1, C+2), (R, C+2), (R+1, C+2), (R+2, C+2) with the value 2.\n3. Maintain all other pixel values from the input grid in the output grid.",
    "b0c4d837.json": "1. Create a 3x3 output grid, initialized with 0s.\n2. In the input grid, count the number of pixels with value 8.\n3. If the count of 8 is greater than 0, set the first row of the output grid to 8.\n4. If the input contains a column with only 5 in the first half rows and 8 in the later half rows, change the element (0,2) to 0",
    "b190f7f5.json": "1. Find the dimensions of the input grid: Rows (R) and Columns (C).\n2. Create an output grid with dimensions R*R and C*C.\n3. Iterate through each cell (r, c) in the input grid, where r ranges from 0 to R-1, and c ranges from 0 to C-1.\n4. Get the pixel value at the current cell (r, c) of the input grid.\n5. Iterate through a block of size R*C in the output grid, starting at output grid cell (r*R, c*C).\n6. If the input grid pixel value at (r, c) is not 8, fill this block with the value from input (r, c) into the block.\n7. If the input grid pixel value at (r, c) is 8, leave the block at location (r*R, c*C) filled with 0.",
    "b1948b0a.json": "1. The output grid has the same dimensions as the input grid.\n2. Identify all pixels with value 6 in the input grid.\n3. Change the value of these pixels to 2 in the output grid.\n4. All other pixel values remain unchanged from the input to the output grid.",
    "b230c067.json": "1. Read the input grid.\n2. Identify groups of connected pixels with value 8.\n3. For the leftmost group of connected 8 pixels, change the pixel values to 1.\n4. For the rightmost group of connected 8 pixels, change the pixel values to 2.\n5. Output the modified grid.",
    "b27ca6d3.json": "1. The output grid has the same dimensions as the input grid.\n2. Identify pairs of adjacent pixels with value 2. Two pixels are adjacent if they share a side (horizontally or vertically).\n3. For each identified pair of adjacent pixels with value 2, surround the pair with pixels of value 3.",
    "b2862040.json": "1. The output grid has the same dimensions as the input grid.\n2. For each connected region of value 1 in the input, change the value of all cells in that region to 8 in the output.\n3. All other pixel values remain unchanged.",
    "b527c5c6.json": "1. For each distinct group of connected 3s, find a 2 located at the boundary of that group. A 'group' is defined as a set of connected 3s. A 'boundary' is defined as any immediate neighbor (up, down, left, right). An immediate neighbor can be either a 2 or the boundary of the grid.\n2. From the 2, extend a line of 2s in the direction away from the group of 3s, until reaching the edge of the grid. The extension must stop at the grid boundary.\n3. From the original edge of the group of 3s where the 2 is located, extend the 3s away from the 2s until you reach the edge of the grid. This creates a 'thick' line of 3s and 2s",
    "b548a754.json": "1. Locate a shape consisting of two colors: an outer color and an inner color.\n2. Locate a single pixel of color 8 (cyan).\n3. Expand the shape such that it covers the location of the single pixel of color 8.\n4. The border of the expanded shape retains its original color.\n5. The interior of the expanded shape retains its original color. \n6. The single pixel of color 8 is no longer present in the output.",
    "b60334d2.json": "1. Copy the input grid to the output grid.\n2. Find all locations of pixels with value 5 in the input grid. Call these the center pixels.\n3. For each center pixel at location (R, C) in the output grid, change the pixel value at (R, C) to 0.\n4. For each center pixel at location (R, C) in the output grid:\n    a. Set the pixel value at (R-1, C) to 1, if (R-1, C) is within the grid boundaries.\n    b. Set the pixel value at (R+1, C) to 1, if (R+1, C) is within the grid boundaries.\n    c. Set the pixel value at (R, C-1) to 1, if (R, C-1) is within the grid boundaries.\n    d. Set the pixel value at (R, C+1) to 1, if (R, C+1) is within the grid boundaries.\n    e. Set the pixel value at (R-1, C-1) to 5, if (R-1, C-1) is within the grid boundaries.\n    f. Set the pixel value at (R-1, C+1) to 5, if (R-1, C+1) is within the grid boundaries.\n    g. Set the pixel value at (R+1, C-1) to 5, if (R+1, C-1) is within the grid boundaries.\n    h. Set the pixel value at (R+1, C+1) to 5, if (R+1, C+1) is within the grid boundaries.",
    "b6afb2da.json": "1. Copy the input grid to the output grid. \n2. Locate all squares containing the value 5 in the input grid.\n3. For each square found in step 2, change the pixel value at the corners of the square to 1.\n4. For each square found in step 2, change the pixel value of the edges (excluding the corners) to 4.\n5. For each square found in step 2, change the pixel value of the interior pixels to 2.",
    "b7249182.json": "1. Find the coordinates (R1, C1) of the first non-zero pixel value in the input grid.\n2. Find the coordinates (R2, C2) of the second non-zero pixel value in the input grid.\n3. Let V1 be the pixel value at (R1, C1).\n4. Let V2 be the pixel value at (R2, C2).\n5. Create a horizontal line of pixel value V1, extending 3 units to the right from coordinate (R1, C1-1). Overwrite existing values. The line will thus be at (R1,C1-1), (R1, C1), (R1, C1+1)\n6. Create a horizontal line of pixel value V2, extending 3 units to the left from coordinate (R2, C2+1). Overwrite existing values. The line will thus be at (R2, C2+1), (R2, C2), (R2, C2-1).\n7. Create a vertical line of pixel value V1, extending from (R1-1, C1-1) for three units downwards. Overwrite existing values. The line will thus be at (R1-1, C1-1), (R1, C1-1), (R1+1, C1-1).\n8. Create a vertical line of pixel value V1, extending from (R1-1, C1+1) for three units downwards. Overwrite existing values. The line will thus be at (R1-1, C1+1), (R1, C1+1), (R1+1, C1+1).\n9. Create a vertical line of pixel value V2, extending from (R2-1, C2-1) for three units upwards. Overwrite existing values. The line will thus be at (R2-1, C2-1), (R2, C2-1), (R2+1, C2-1).\n10. Create a vertical line of pixel value V2, extending from (R2-1, C2+1) for three units upwards. Overwrite existing values. The line will thus be at (R2-1, C2+1), (R2, C2+1), (R2+1, C2+1).",
    "b775ac94.json": "1. The input grid and output grid have the same dimensions.\n2. Identify distinct clusters of non-0 pixels in the input grid. Each cluster represents a separate pattern to be mirrored.\n3. For each cluster, find the location of the single pixel or connected group of same color pixels that are separated from the others.\n4. For each distinct color value X (where X is not 0) within a cluster, mirror its position relative to the anchor point from step 3 to generate a symmetrical arrangement in the output grid.\n5. The mirroring should occur both horizontally and vertically, with the anchor point acting as the center of symmetry. The mirrored values must have the same color X as its original location.\n6. All other pixels in the output grid remain 0.",
    "b782dc8a.json": "1. Maintain the grid size.\n2. Locate areas of value 0.\n3. Locate connected regions of value 8 surrounding the 0 areas.\n4. Fill the 0 areas within these regions of 8 with an alternating pattern.\n5. Determine the colors for the alternating pattern from the existing colored boxes. The alternating pattern is composed of colors 2, 3, 1 and 4.",
    "b8825c91.json": "1. The output grid has the same dimensions as the input grid.\n2. Locate the pixels with value 4 in the input grid.\n3. Change the value of some pixels that neighbor pixels with the value 4.\n4. Maintain other pixel values from the input grid in the output grid.",
    "b8cdaf2b.json": "1. Copy the input grid to the output grid.\n2. Identify the row with non-zero values at the bottom of the grid. Let this row be called the 'structure row'.\n3. Identify the color of the inner section of the structure row by identifying the color that is not at the two extremes of the row. Let this color be 'inner color'.\n4. Starting from the row above the structure row, iterate upwards, row by row.\n5. In each row, create diagonal lines from the edge towards the center, setting the pixel values to 'inner color'. The left diagonal starts from the left edge. The right diagonal starts from the right edge. These diagonal lines should extend until they meet either the edge of the structure below, or the edge of the grid.",
    "b91ae062.json": "1. Get the input grid dimensions (rows and columns).\n2. Identify the unique values in the input grid.\n3. Count the number of unique values. Let this count be N.\n4. Calculate the output grid dimensions: output width = input width * N, output height = input height * N.\n5. Create an empty output grid with the calculated dimensions.\n6. Iterate through each cell (R, C) of the input grid, where R is the row index and C is the column index.\n7.  For each cell (R, C) in the input grid, get the value V at that cell.\n8.  In the output grid, create a block of size N x N, starting at the location (R * N, C * N). Fill this block with the value V.",
    "b94a9452.json": "1. Find the non-zero square in the input grid. This square consists of one outer color and one inner color. The background is 0.\n2. Determine the output grid size by finding the size of the non-zero square in the input.\n3. Create an output grid of the determined size.\n4. In the output grid, swap the colors of the outer and inner squares found in the input.",
    "b9b7f026.json": "1. Find an object (contiguous block of same-valued pixels) that contains at least one pixel with a value of 0.\n2. The output grid is 1x1. Fill the 1x1 output grid with the value of the object found in step 1.",
    "ba26e723.json": "1. Analyze the input grid. The input grid consists of rows of alternating 4 and 0. \n2. Create an output grid with the same dimensions as the input grid.\n3. Iterate through the output grid, processing rows of the grid.\n4. In the output grid, every other pair of columns starting from the second pair change the 4 to 6.\n5. Return the modified output grid.",
    "ba97ae07.json": "1. Create an output grid that is a copy of the input grid.\n2. Identify locations in the input grid where two lines of different colors intersect. In these examples, there are two colors involved besides black (0).\n3. At each intersection point, change the pixel value to the value of the intersecting line.",
    "bb43febb.json": "1. Identify contiguous regions of the same color that form rectangles in the input grid.\n2. For each identified rectangle, replace the inner region of the rectangle with color 2 (red), leaving a border of one pixel of the original color around the outside of the red region.\n3. The output grid size remains the same as the input grid size.",
    "bbc9ae5d.json": "1. Define the input grid as a single row of numbers. Let the width of the input grid be W.\n2. Define the output grid. The width of the output grid is W. The height of the output grid is W/2 (integer division, discarding any remainder).\n3. Copy the first row of the input grid to the first row of the output grid.\n4. For each subsequent row R in the output grid (starting from the second row, R=1), iterate from left to right, starting from column C=0:\n5. The value at output grid cell (R, C) is the same as the value at (0, C) in the first row of the output grid if C < R + Number of non-zero elements in the input. Otherwise, the value is 0. Basically, we keep adding the first element of the input grid, till we reach the number of rows or end of the input.",
    "bc1d5164.json": "1. Take the input grid.\n2. Create a 3x3 output grid.\n3. For each cell (R, C) in the output grid (where R and C range from 0 to 2 inclusive), determine its value based on the corresponding section of the input grid.\n4. The output cell (R, C) corresponds to the section of the input grid rows that start at R * floor(input_height / 3) and end at (R+1) * floor(input_height / 3) - 1. And input grid columns that start at C * floor(input_width / 3) and end at (C+1) * floor(input_width / 3) - 1.\n5. Set the output cell (R, C) to the value that appears most frequently within this corresponding section of the input grid. If there is a tie, the examples suggest prioritizing the non-zero value.",
    "bd4472b8.json": "1. Take the input grid. The output grid will be the same size as the input grid.\n2. Copy the first two rows of the input grid to the first two rows of the output grid.\n3. Identify the color sequence in the first row of the input grid. This sequence consists of the unique numbers present in the first row, read from left to right.\n4. Starting from the third row (index 2) of the output grid, repeat the color sequence from step 3. Each row in the output grid from the third row onwards will be filled with a single color from the sequence, cycling through the color sequence. Fill each row with the same color until the end of the grid is reached.",
    "bda2d7a6.json": "1. Identify the outer square's value. Let this value be 'A'.\n2. Identify the inner square's value. Let this value be 'B'.\n3. Identify the innermost square's value. Let this value be 'C'.\n4. Change the value of the outer square to 'B'.\n5. Change the value of the inner square to 'C'.\n6. Change the value of the innermost square to 'A'.",
    "bdad9b1f.json": "1. Identify all pixels with value 2. For each such pixel at coordinate (R, C), extend a horizontal line of value 2 to the left and to the right until the edge of the grid is reached or a non-zero value is encountered.\n2. Identify all pixels with value 8. For each such pixel at coordinate (R, C), extend a vertical line of value 8 upwards and downwards until the edge of the grid is reached or a non-zero value is encountered.\n3. If a pixel has both value 2 from the horizontal line and value 8 from the vertical line, change the pixel value to 4.",
    "be94b721.json": "1. Identify all distinct non-0 pixel values in the input grid.\n2. For each distinct non-0 pixel value, identify all connected regions of that value.\n3. Determine the connected region with the largest number of pixels.\n4. Find the minimum bounding rectangle that encloses this largest connected region.\n5. Extract the subgrid defined by this minimum bounding rectangle from the input grid.\n6. Output this extracted subgrid.",
    "beb8660c.json": "1. For each row in the input grid, count the consecutive non-zero pixels. Treat 0 as background.\n2. Create an output grid with the same dimensions as the input grid, initialized with 0s.\n3. Sort the input rows based on the count calculated in step 1, in descending order (longest to shortest).\n4. Place the sorted rows into the output grid, from top to bottom.\n5. Align the non-zero elements in each row to the right side of the output grid. If a row's length is shorter than the grid width, pad the left side with 0s.",
    "c0f76784.json": "1. The output grid has the same dimensions as the input grid.\n2. Identify the gray (5) outlined squares in the input grid.\n3. For the smallest gray (5) outlined square, fill the inner area with pink (6).\n4. For the medium sized gray (5) outlined square, fill the inner area with orange (7).\n5. For the largest gray (5) outlined square, fill the inner area with cyan (8).",
    "c1d99e64.json": "1. Identify rows and columns that contain only the value 0.\n2. Change the value of all pixels in those identified rows and columns to 2.",
    "c3e719e8.json": "1. Analyze the input 3x3 grid. Count the occurrences of each distinct number (0-9). Determine the most frequent number. If there are ties, pick the smallest tied value.\n2. Create a 9x9 output grid, initialized with 0s.\n3. Iterate through the input 3x3 grid, row by row, and column by column.\n4. For each cell (r, c) in the input grid (where r and c range from 0 to 2):\n    a. If the value at input[r][c] is equal to the most frequent number determined in step 1, copy the entire 3x3 input grid to the corresponding 3x3 block in the output grid, starting at output[r*3][c*3]. Specifically, for i from 0 to 2 and j from 0 to 2, set output[r*3 + i][c*3 + j] = input[i][j].\n    b. If the value at input[r][c] is NOT equal to the most frequent number, leave the corresponding 3x3 block in the output grid as all 0s (as initialized).",
    "c3f564a4.json": "1. Create an output grid with the same dimensions as the input grid. \n2. For each cell (R, C) in the output grid, copy the value from the corresponding cell (R, C) in the input grid. \n3. The output grid is now identical to the input grid.",
    "c444b776.json": "1. The output grid has the same dimensions as the input grid.\n2. Copy the pixel values from the input grid to the corresponding locations in the output grid.\n3. Note: In these specific examples, there are no color changes or other transformations to individual pixel values. The output is a direct copy of the input.",
    "c59eb873.json": "1. Read the input grid. Let its dimensions be R rows and C columns.\n2. Create an output grid with dimensions 2R rows and 2C columns.\n3. Iterate through each cell (r, c) of the input grid, where r ranges from 0 to R-1, and c ranges from 0 to C-1.\n4. Obtain the pixel value at input grid cell (r, c). Call this value 'V'.\n5. In the output grid, set the pixel values of the 2x2 block with top-left corner at (2r, 2c) to V. Specifically:\n   a. Set output grid cell (2r, 2c) to V.\n   b. Set output grid cell (2r, 2c+1) to V.\n   c. Set output grid cell (2r+1, 2c) to V.\n   d. Set output grid cell (2r+1, 2c+1) to V.\n6. The output grid now contains the transformed image.",
    "c8cbb738.json": "1. Find all distinct non-0 pixel values in the input grid. Let these be the \"shape colors\".\n2. For each shape color, identify all connected components of that color.\n3. For each shape color, find the minimum and maximum row and column indices that contain that color in the input grid.\n4. Calculate the width and height of the bounding box for each shape color by subtracting the minimum from the maximum column and row indices, respectively, and adding 1.\n5. Determine the maximum width and maximum height across all shape colors' bounding boxes.\n6. Create an output grid with the maximum width as the width and the maximum height as the height, filled with the most frequent pixel value from the input grid (the background color).\n7. For each shape color:\n    a. Determine the row offset by subtracting the minimum row index of the shape color from 0. \n    b. Determine the column offset by subtracting the minimum column index of the shape color from 0.\n    c. Place the shape color onto the output grid at its original coordinates relative to its minimum row/column, respecting the output grid boundaries. If a location on the output grid is already a non-background pixel value from a previously processed shape, it retains its original value.\n    d. Locations where the shape isn't present should retain the background color of the output grid (from step 6).",
    "c8f0f002.json": "1. Read the input grid.\n2. Create an output grid with the same dimensions as the input grid.\n3. Iterate through each cell in the input grid, identified by row R and column C.\n4. If the pixel value at (R, C) in the input grid is 7, then set the pixel value at (R, C) in the output grid to 5.\n5. Otherwise, set the pixel value at (R, C) in the output grid to the same value as the input grid at (R, C).\n6. Output the output grid.",
    "c909285e.json": "1. Find the smallest rectangular subgrid within the input grid that has a border different from its interior.\n2. The output grid size is the same as the size of this subgrid, including the border.\n3. Copy the pixel values from the identified subgrid in the input to the output without changes.",
    "c9e6f938.json": "1. Get the input grid. Let its width be W and its height be H.\n2. Create an output grid of width 2*W and height H, initialized with all 0s.\n3. Iterate through each row R from 0 to H-1.\n4. Iterate through each column C from 0 to W-1.\n5. Copy the pixel value from the input grid at (R, C) to the output grid at (R, C).\n6. Copy the pixel value from the input grid at (R, C) to the output grid at (R, 2*W - 1 - C).",
    "c9f8e694.json": "1. The input grid and output grid have the same dimensions.\n2. Iterate through each cell in the grid.\n3. If the cell value is 5, replace it with the value of the first column in the same row.\n4. Leave other cell values unchanged.",
    "caa06a1f.json": "1. Get the dimensions of the input grid. Let the number of rows be R and the number of columns be C.\n2. Create an output grid with dimensions R and C.\n3. For each row index r from 0 to R-1:\n4. For each column index c from 0 to C-1:\n5. If (r + c) is even, set the pixel value at (r, c) in the output grid to the value at (0, 1) from the input grid.\n6. If (r + c) is odd, set the pixel value at (r, c) in the output grid to the value at (0, 0) from the input grid.",
    "cbded52d.json": "1. The output grid has the same dimensions as the input grid.\n2. For each row in the input grid:\n   2.1. Examine the values at the first, middle, and last columns, skipping any column with value 0.\n   2.2. If the value at the middle column (column index 3) is different from the value at the first column (column index 0), change the last column (column index 7) value to be the same as the middle column (column index 3).\n   2.3. If the value at the middle column (column index 3) is different from the value at the last column (column index 7), change the first column (column index 0) value to be the same as the middle column (column index 3).\n3. The 0 values in the grid remain unchanged.",
    "cce03e0d.json": "1. Initialize a 9x9 output grid with all values set to 0.\n2. Examine the 3x3 input grid.\n3. For each cell (r, c) in the input grid (where r and c range from 0 to 2):\n4. If the value at input grid cell (r, c) is not 0:\n    a. Copy the entire 3x3 input grid to the corresponding 3x3 block in the output grid, starting at output grid coordinates (r*3, c*3).\n    b. Specifically, for each cell (i, j) in the 3x3 input grid (where i and j range from 0 to 2), set the value of the output grid cell at (r*3 + i, c*3 + j) to the value found at input grid cell (i, j).\n5. The resulting 9x9 grid is the output.",
    "cdecee7f.json": "1. Find all non-zero pixel values in the input grid, reading the input grid from top to bottom, and left to right within each row. Store these pixel values in a list, preserving their original order.\n2. Create a 3x3 output grid.\n3. Populate the output grid with the non-zero values from the list, filling the grid from left to right, row by row, starting from the top row.\n4. If the list contains fewer than 9 non-zero values, fill the remaining cells in the output grid with 0.",
    "ce22a75a.json": "1. Maintain the same grid size as the input grid.\n2. Iterate through each cell (R, C) of the input grid.\n3. If the pixel value at (R, C) is 5, change the pixel value at (R, C) and its surrounding cells to 1.\n4. Specifically, change the pixel values at the following locations to 1: (R-1, C-1), (R-1, C), (R-1, C+1), (R, C-1), (R, C), (R, C+1), (R+1, C-1), (R+1, C), (R+1, C+1).\n5. Handle boundary conditions: If any of the calculated coordinates (R-1, C-1), (R-1, C), (R-1, C+1), (R, C-1), (R, C+1), (R+1, C-1), (R+1, C), (R+1, C+1) are outside the grid boundaries, skip changing the pixel value at that location.",
    "ce4f8723.json": "1. Divide the input grid (4x8) into two 4x4 grids: a top grid (4x4) and a bottom grid (4x4). Number rows from top to bottom as 0 to 3. Number columns from left to right as 0 to 3.\n2. Create an output grid of size 4x4.\n3. For each cell at row R and column C in the output grid:\n4. If the pixel value at (R, C) in the top grid is 0 AND the pixel value at (R, C) in the bottom grid is 0, then set the pixel value at (R, C) in the output grid to 0.\n5. Otherwise, set the pixel value at (R, C) in the output grid to 3.",
    "ce602527.json": "1. Find a connected shape in the input grid that is not the background color.\n2. Extract this shape and use it as the output.\n3. Specifically, in Example 1, the shape composed of the number 2 is extracted from a background of 1.\n4. In Example 2, the shape composed of the number 4 is extracted from a background of 8.\n5. In Example 3, the shape composed of the number 8 is extracted from a background of 2.\n6. In Example 4, the shape composed of the number 3 is extracted from a background of 1.",
    "ce9e57f2.json": "1. For each column in the input grid, identify continuous vertical sections of pixel value 2, starting from the bottom row.\n2. Within each identified section of value 2, determine its height (number of consecutive cells with value 2).\n3. If the height is even, replace the lower half of the section with pixel value 8, keeping the upper half as value 2.\n4. If the height is odd, replace the lower (height - 1) / 2 cells of the section with pixel value 8, keeping the upper (height + 1) / 2 cells as value 2.\n5. All other pixel values in the grid remain unchanged.",
    "cf98881b.json": "1. Take the input grid. The input grid's height and width are both 14.\n2. Create an output grid of size 4x4.\n3. Examine the first four columns of the input grid and copy the values to the first four columns of the output grid. That is, copy the values in the range Input(R, 0:3) to Output(R, 0:3), where R ranges from 0 to 3.\n4. Examine the fifth column of the input grid, Input(:, 4). Note that this column contains only the value 2. This column is NOT directly copied to the output.\n5. Examine columns 5, 7, 8, and 10 of the input grid. When the values in these columns are equal to 9, copy the corresponding values from the input column 5 of the input grid to the output grid.\n6. Examine columns 11 and 12 of the input grid. If the values in these columns are equal to 1, copy these values to the corresponding output grid cells.\n",
    "d037b0a7.json": "1. The output grid has the same dimensions as the input grid.\n2. Iterate through each column C of the input grid, from left to right.\n3. Within each column C, iterate through each row R from top to bottom.\n4. If the pixel value at (R, C) is not 0, set all pixel values below (R, C) in column C to the pixel value at (R, C).\n5. Specifically, for each column C, and each row R, if the pixel value at (R, C) is not 0, then iterate through rows R2 from R+1 to the bottom row of the grid. Set the pixel value at (R2, C) to the pixel value at (R, C).",
    "d06dbe63.json": "1. Find the coordinates (R, C) of the pixel with value 8 in the input grid. This is the 'center pixel'.\n2. Set the pixel value to 5 at (R-1, C-2), (R-1, C-1), and (R-1, C).\n3. Set the pixel value to 5 at (R-2, C-2).\n4. Set the pixel value to 5 at (R+1, C+2), (R+1, C+1), and (R+1, C).\n5. Set the pixel value to 5 at (R+2, C+2).\n6. Set the pixel value to 5 at (R-2, C+2), (R-1, C+2), and (R, C+2).\n7. Set the pixel value to 5 at (R+2, C-2), (R+1, C-2), and (R, C-2).\n8. Retain the original pixel value 8 at (R, C).",
    "d07ae81c.json": "1. Locate each pixel in the input grid that has a value that is different from its neighbors (a \"single pixel\").\n2. For each \"single pixel\" with value V at coordinates (R, C), extend diagonal lines outwards from that pixel.\n3. The diagonal lines extend in all four diagonal directions: up-left, up-right, down-left, and down-right.\n4. The diagonal lines propagate outwards replacing background color (neighbor) values with the single pixel value V, until they encounter a different pixel value than the original neighbors of (R, C). Do not change colors beyond this pixel.",
    "d0f5fe59.json": "1. Find all distinct non-zero pixel values in the input grid. Let 'N' be the count of such distinct values. In this task, N is always 1 and the non-zero pixel value is 8.\n2. Create an output grid of size N x N. In this task, the output grid is always square.\n3. Fill the output grid with 0.\n4. Fill the diagonal of the output grid, from the top-left corner to the bottom-right corner, with the value 8.",
    "d10ecb37.json": "1. Take the input grid. The output grid is 2x2.\n2. In the output grid, assign the value at (0, 0) to the value of the input grid at (0, 0).\n3. In the output grid, assign the value at (0, 1) to the value of the input grid at (0, 1).\n4. In the output grid, assign the value at (1, 0) to the value of the input grid at (1, 0).\n5. In the output grid, assign the value at (1, 1) to the value of the input grid at (1, 1).",
    "d13f3404.json": "1. Let input grid dimensions be I_rows and I_cols.\n2. Let output grid dimensions be O_rows = 2 * I_rows and O_cols = 2 * I_cols.\n3. Initialize the output grid with all 0s.\n4. Iterate through each cell (r, c) of the input grid, where r ranges from 0 to I_rows-1 and c ranges from 0 to I_cols-1.\n5. For each cell (r, c) in the input grid with value V, copy V to the output grid cell (r, c).\n6. Then, copy V from input grid cell (r, c) to the output grid cell (r + I_rows/2, c + I_cols/2), where the coordinates are rounded down to the nearest integer.",
    "d22278a0.json": "1. Get the input grid dimensions (rows, columns).\n2. Create an output grid with the same dimensions as the input grid.\n3. Copy the input grid values to the output grid.\n4. Identify the value of the top-left corner pixel (R0, C0) in the input grid, call it `value1`.\n5. Identify the value of the bottom-left corner pixel (Rlast, C0) in the input grid, call it `value2`.\n6. Starting from the top-left corner (R0, C0) of the output grid, iterate through rows and columns: if the sum of the row and column indices (R + C) is even, set the pixel value to `value1`.\n7. Starting from the bottom-left corner (Rlast, C0) of the output grid, iterate through rows and columns: if the sum of the row and column indices (R + C) is even, set the pixel value to `value2`.",
    "d23f8c26.json": "1. Take the input grid. The output grid will have the same dimensions as the input grid.\n2. For each row in the output grid, set the value of all cells to 0, except for the cell in the center column.\n3. In the center column of the output grid, copy the value from the corresponding cell in the input grid's center column.",
    "d2abd087.json": "1. Copy the input grid to the output grid.\n2. Identify connected regions of value 5 in the input grid.\n3. For each connected region of 5, count the number of cells in that region.\n4. If the count is 6, change all the values in that region to 2 in the output grid.\n5. If the count is not 6, change all the values in that region to 1 in the output grid.",
    "d364b489.json": "1. The output grid has the same dimensions as the input grid.\n2. Locate each pixel with value 1 in the input grid. Let the row and column indices of such a pixel be R and C, respectively.\n3. In the output grid, change the pixel at (R, C-1) to value 7.\n4. In the output grid, change the pixel at (R-1, C) to value 2.\n5. In the output grid, change the pixel at (R, C+1) to value 6.\n6. In the output grid, change the pixel at (R+1, C) to value 8.",
    "d406998b.json": "1. Iterate through each column of the input grid, starting from the second column (index 1). Let the current column index be C.\n2. If C is an odd number, then iterate through each row in column C. Let the current row index be R.\n3. In column C, if the pixel value at (R, C) is 5, change the pixel value at (R, C) to 3.",
    "d43fd935.json": "1. Copy the input grid to the output grid. 2. Find the 2x2 square of value 3. 3. For each corner of the 2x2 square of value 3: a. Check the pixel directly above the corner. If the pixel above the corner has a value other than 0, draw a vertical line of that value from the pixel to the corner, filling all 0's in between. b. Check the pixel directly to the right of the corner. If the pixel to the right of the corner has a value other than 0, draw a horizontal line of that value from the pixel to the corner, filling all 0's in between.",
    "d4469b4b.json": "1. Analyze the input grid. If the input grid contains only the number 1, 2, or 3, proceed. Otherwise, stop.\n2. Create a 3x3 output grid, filled with the value 5.\n3. IF the input grid contains the number 1, set the output grid values at these locations to 0: (0, 0), (0, 2), (2, 0), (2, 2).\n4. IF the input grid contains the number 2, set the output grid values at these locations to 0: (1, 0), (1, 2), (2, 0), (2, 1), (2, 2).\n5. IF the input grid contains the number 3, set the output grid values at these locations to 0: (0, 0), (0, 1), (1, 0), (1, 1).",
    "d4a91cb9.json": "1. Identify the coordinates (R1, C1) of the first non-zero pixel value in the input grid. Assume the pixel value is 8.\n2. Identify the coordinates (R2, C2) of the second non-zero pixel value in the input grid. Assume the pixel value is 2.\n3. Create an output grid with the same dimensions as the input grid, initialized with all pixel values set to 0.\n4. Copy the input grid to the output grid.\n5. Set all pixel values in the column C2 of the output grid, from row R1 down to row R2 inclusive, to 4.\n6. Set all pixel values in the row R2 of the output grid, from column C1 up to column C2 inclusive, to 4.",
    "d4f3cd78.json": "1. Identify the coordinates (R, C) of all pixels with value 0 within the region bounded by pixels with value 5.\n2. For each identified coordinate (R, C), change the pixel value at (R, C) to 8.\n3. For one of the coordinates identified in Step 1, extend a line of value 8 to the nearest edge of the grid.",
    "d511f180.json": "1. Read the input grid.\n2. Create an output grid with the same dimensions as the input grid.\n3. Iterate through each cell (R, C) of the input grid.\n4. If the pixel value at (R, C) in the input grid is 5, set the pixel value at (R, C) in the output grid to 8.\n5. If the pixel value at (R, C) in the input grid is 8, set the pixel value at (R, C) in the output grid to 5.\n6. If the pixel value at (R, C) in the input grid is neither 5 nor 8, copy the pixel value from the input grid to the output grid.\n7. Output the output grid.",
    "d5d6de2d.json": "1. For each input grid, locate groups of connected pixels with value 0 that are completely enclosed by pixels with value 2.\n2. Change the value of those enclosed pixels with value 0 to 3.",
    "d631b094.json": "1. Identify the non-zero pixel value in the input grid. Let this value be 'X'.\n2. Count the number of occurrences of 'X' in the input grid.\n3. Create a new output grid. The output grid will be a 1-dimensional array (a single row).\n4. The width of the output grid equals the count from Step 2.\n5. Fill all pixels in the output grid with the value 'X'.",
    "d687bc17.json": "1. Copy the input grid to the output grid.\n2. For each border color value, identify internal cells with the same color value.\n3. For each border color value, move the identified internal cells with the same value to be adjacent to the border with the same color value, maintaining the original column or row.\n4. After moving the identified internal cells, fill the vacated internal cells with the value 0.",
    "d6ad076f.json": "1. Copy the input grid to the output grid.\n2. Identify two distinct shapes in the input grid.\n3. Find the bounding box of each shape.\n4. Connect the two bounding boxes with a line of value 8 (cyan/light blue).\n5. The width of the connecting line is determined by the dimensions of the smaller shape. Specifically, the line should be one row/column less on each side than the smaller rectangle. For example, if smaller shape width is 3, the connection line will be of width 1. If smaller shape width is 4, the connection line will be of width 2.",
    "d89b689b.json": "1. Find all 2x2 subgrids within the input grid where all four cells have the same value.\n2. For each such 2x2 subgrid, identify the unique values present in the entire input grid.\n3. Replace the values in the 2x2 subgrid with four different values that are present in the input grid, excluding the original value of the 2x2 subgrid.\n4. If the input grid contains fewer than 4 unique values besides the value in the 2x2 grid, use what's available without replacement. Example: if the original value is 8, and the other values available in the input are 0, 1, 2, the 2x2 grid will be filled with these 3 values and one of them repeated.\n5. The output grid has the same dimensions as the input grid.",
    "d8c310e9.json": "1. Take the input grid.\n2. For each row in the input grid, copy the non-zero values to the corresponding row in the output grid.\n3. Extend the row in the output grid by repeating the copied non-zero pattern to fill the row.\n4. Handle rows with all 0s by leaving them as all 0s in the output.",
    "d90796e8.json": "1. The output grid has the same dimensions as the input grid.\n2. Iterate through each pixel in the input grid, denoted by row R and column C.\n3. If the pixel value at (R, C) is 3 (green):\n    a. Check the pixel to the left at (R, C-1). If it exists and has a value of 2 (red), change the pixel value at (R, C) to 8 (cyan).\n    b. Check the pixel to the right at (R, C+1). If it exists and has a value of 2 (red), change the pixel value at (R, C) to 8 (cyan).\n    c. Check the pixel above at (R-1, C). If it exists and has a value of 2 (red), change the pixel value at (R, C) to 8 (cyan).\n    d. Check the pixel below at (R+1, C). If it exists and has a value of 2 (red), change the pixel value at (R, C) to 8 (cyan).\n4. If the pixel value at (R, C) is 2 (red):\n    a. Check the pixel to the left at (R, C-1). If it exists and has a value of 3 (green), change the pixel value at (R, C) to 0 (black).\n    b. Check the pixel to the right at (R, C+1). If it exists and has a value of 3 (green), change the pixel value at (R, C) to 0 (black).\n    c. Check the pixel above at (R-1, C). If it exists and has a value of 3 (green), change the pixel value at (R, C) to 0 (black).\n    d. Check the pixel below at (R+1, C). If it exists and has a value of 3 (green), change the pixel value at (R, C) to 0 (black).\n5. Pixels with values other than those modified above retain their original values.",
    "d9f24cd1.json": "1. For each pixel with value 2 in the input grid, extend a line of value 2 vertically upwards until the top of the grid is reached.\n2. If the upward extension of value 2 encounters a pixel with value 5, change the direction of the extension to the right of the encountered pixel with value 5, then continue the line of value 2 vertically upwards.",
    "d9fac9be.json": "1. Find a 3x3 square within the input grid.\n2. Identify the pixel value located at the center of the 3x3 square.\n3. Set the output grid to a 1x1 grid.\n4. Set the single pixel value of the output grid equal to the pixel value found in step 2.",
    "dae9d2b5.json": "1. Take the input grid, which is 3x6.\n2. Create a 3x3 output grid.\n3. For each cell (R, C) in the output grid (where R is the row and C is the column, both starting from 0):\n   a. If the value in the input grid at (R, C) or (R, C+3) is 4, then set the output grid cell (R, C) to 6.\n   b. Otherwise, set the output grid cell (R, C) to 0.",
    "db3e9e38.json": "1. Find all locations with pixel value 7 in the input grid.\n2. For each location (R, C) with value 7:\n3. Starting from the location (R, C), expand outwards, alternating the pixel value between 7 and 8.\n4. Expand horizontally and vertically, one pixel at a time, on each side of the original location.\n5. In each direction, alternate the color between 8 and 7.\n6. Stop expanding when encountering the boundary of the grid, or a pixel value that is not 0.",
    "db93a21d.json": "1. For each connected region of pixel value 9 in the input grid, create a border of pixel value 3 around it. The border's thickness is half the width of the region of 9. If the width is odd, round the border thickness down. For instance, a region with width 5 gets a border of thickness 2. A region with width 6 gets a border of thickness 3.\n2. Starting from the top of the grid and moving downwards, and for each column, fill all 0 pixels below the regions of 9 and 3 with pixel value 1, until the bottom of the grid. Do not overwrite pixels with value 3.",
    "dbc1a6ce.json": "1. The output grid has the same dimensions as the input grid.\n2. Identify all locations of pixel value 1 in the input grid.\n3. For each pixel with value 1 at location (R, C), examine the row R and the column C.\n4. In row R, change the value of all pixels between any two 1's to 8.\n5. In column C, change the value of all pixels between any two 1's to 8.",
    "dc0a314f.json": "1. Find the largest square composed of value 3. Let its top-left corner be at row R and column C, and let its side length be S.\n2. Create an output grid of size S x S.\n3. For each row r (from 0 to S-1) and column c (from 0 to S-1) in the output grid, copy the value from the input grid at location (R + r, C + c) to the corresponding location (r, c) in the output grid.",
    "dc1df850.json": "1. Scan the input grid to identify the coordinates (R, C) of all pixels with value 2.\n2. For each identified coordinate (R, C) where the pixel value is 2, change the values of all the immediately adjacent pixels to 1. This includes the pixels directly above (R-1, C), below (R+1, C), to the left (R, C-1), to the right (R, C+1), and diagonally adjacent pixels (R-1, C-1), (R-1, C+1), (R+1, C-1), (R+1, C+1), provided these coordinates are within the grid boundaries. If any adjacent pixel has coordinate outside of the grid boundaries, then don't change it.\n3. Ensure that the pixel at (R, C) retains the original value of 2.",
    "dc433765.json": "1. Find the coordinates (R1, C1) of the pixel with value 3.\n2. Find the coordinates (R2, C2) of the pixel with value 4.\n3. Calculate the Manhattan distance between (R1, C1) and (R2, C2), defined as abs(R1 - R2) + abs(C1 - C2).\n4. If the Manhattan distance is greater than 1, move the pixel with value 3 one step closer to the pixel with value 4.\n5. Moving the pixel with value 3 one step closer to the pixel with value 4 means finding an adjacent empty pixel (value 0) that reduces the Manhattan distance between the new location of the pixel with value 3 and the pixel with value 4.\n6. Create the output grid of the same size as the input grid.\n7. Place the pixel with value 4 at (R2, C2) in the output grid.\n8. Place the pixel with value 3 at its new location in the output grid.\n9. All other pixels in the output grid should have the same value as the input grid.",
    "ddf7fa4f.json": "1. Analyze the input grid. The input grid contains values 0-9.\n2. For each column C, examine the value in the first row (row index 0). This value is the 'source color' for that column.\n3. For each column C, identify all 'target pixels' in that column where the value equals 5. Consider only rows below row index 0.\n4. For each 'target pixel' at row R, column C, replace its value (currently 5) with the 'source color' found at row 0, column C.",
    "de1cd16c.json": "1. Analyze the input grid to identify distinct, contiguous regions of the same value. Consider each such region as a separate object.\n2. Count the occurrences of each distinct value within the input grid.\n3. Determine the value with the highest count.\n4. Output a 1x1 grid containing only the value with the highest count.",
    "ded97339.json": "1. Create an output grid with the same dimensions as the input grid.\n2. Iterate through each cell (R, C) in the input grid.\n3. If the pixel value at (R, C) in the input grid is 8, then:\n    a. Set the pixel value at (R, C) in the output grid to 8.\n    b. Extend the value 8 horizontally and vertically from (R, C) until encountering a value other than 8 or the boundary of the grid. Set all intermediate cells to 8 in the output grid.",
    "e179c5f4.json": "1. Input: Assume a grid of integers, where the bottom-left cell has value 1, and all other cells have value 0.\n2. Output Grid Size: The output grid has the same dimensions as the input grid.\n3. Transformation: Create the output grid by the following steps:\n4. Start with the bottom-left cell (R, C) where R is the bottom row and C is the leftmost column. This cell has the value 1 in the input.\n5. Set the value of the output cell at (R, C) to 1.\n6. Move diagonally up and to the right. If the new row and column are within the bounds of the grid, set its value to 1, then to 8. Alternate between 1 and 8 as you progress diagonally.\n7. If the right edge of the grid is reached, continue from the leftmost column of the row above the current cell. Alternate between 1 and 8 as you progress diagonally.\n8. Fill all remaining cells with value 8.",
    "e21d9049.json": "1. Copy the input grid to the output grid.\n2. Find rows that contain non-zero values.\n3. For each such row:\n    a. Identify the sequence of non-zero numbers in that row.\n    b. Repeat this sequence to the left and right, extending the pattern to the edges of the grid.\n4. Find columns that contain non-zero values.\n5. For each such column:\n    a. Identify the sequence of non-zero numbers in that column.\n    b. Repeat this sequence upwards and downwards, extending the pattern to the edges of the grid.",
    "e26a3af2.json": "1. Iterate through each row of the input grid.\n2. Within each row, replace every cell's value with the most frequent value present in that row.\n3. Iterate through each column of the resulting grid.\n4. Within each column, replace every cell's value with the most frequent value present in that column.",
    "e3497940.json": "1. Take the input grid. The input grid has a vertical column of 5s in the middle.\n2. Create the output grid. The output grid's width is equal to the number of columns to the left (or right) of the column of 5s in the input grid. The output grid's height is equal to the height of the input grid.\n3. For each row R from 0 to the height of the input grid minus 1:\n4. For each column C from 0 to the width of the output grid minus 1:\n5. Let `left_value` be the pixel value at (R, C) in the input grid.\n6. Let `right_value` be the pixel value at (R, input_width - C - 1) in the input grid, where input_width is the width of the input grid.\n7. If `left_value` is not 0, then set the pixel at (R, C) in the output grid to `left_value`.\n8. Otherwise, if `right_value` is not 0, then set the pixel at (R, C) in the output grid to `right_value`.\n9. Otherwise, set the pixel at (R, C) in the output grid to 0.",
    "e40b9e2f.json": "1. Find the bounding box of non-zero pixels in the input grid.\n2. Define the center of the bounding box as the rotation center.\n3. For each non-zero pixel value at coordinate (R, C) within the bounding box:\n4. Rotate the pixel value clockwise by 90 degrees around the rotation center, and place the value at the new coordinate.\n5. Rotate the pixel value clockwise by 180 degrees around the rotation center, and place the value at the new coordinate.\n6. Rotate the pixel value clockwise by 270 degrees around the rotation center, and place the value at the new coordinate.\n7. The output grid is the overlay of the original input grid and the three rotated versions.",
    "e48d4e1a.json": "1. Analyze the input grid.\n2. Identify the horizontal line segment composed of a single repeating non-zero digit. \n3. Identify the vertical line segment composed of a single repeating non-zero digit.\n4. In the output grid, move the vertical line such that it intersects the horizontal line. The intersecting point is the same as the input grid.\n5. Maintain the grid size from the input to the output.",
    "e5062a87.json": "1. For each pixel in the input grid, examine its value.\n2. If a pixel has value 0 (black) and another pixel has value 2 (red) in the input grid, check if the surrounding pattern of pixel 0 is same as pattern of pixel 2.\n3. If the patterns are the same, change the pixel with value 0 to value 2.",
    "e509e548.json": "1. Read the input grid.\n2. Create an output grid with the same dimensions as the input grid.\n3. Iterate through each distinct group of connected pixels with value 3 in the input grid.\n4. Count the number of 90-degree corners in the boundary of the connected component.\n5. If the number of 90-degree corners is 1, change all the pixel values in that connected component in the output grid to 1.\n6. If the number of 90-degree corners is 2, change all the pixel values in that connected component in the output grid to 6.\n7. If the number of 90-degree corners is 3, change all the pixel values in that connected component in the output grid to 2.\n8. Any pixel that was not part of a connected component of 3 remains as 0 in the output grid.",
    "e50d258f.json": "1. Identify all distinct contiguous shapes within the input grid.\n2. For each shape, count the number of pixels with value 2.\n3. Select the shape with the maximum count of pixels with value 2.\n4. Copy the selected shape to the output grid.\n5. The output grid size is the same as the selected shape.",
    "e6721834.json": "1. Divide the input grid into two sections, left and right. These sections may or may not have the same background color.\n2. Designate the left section as grid A and the right section as grid B.\n3. Create an output grid with the same dimensions as grid A.\n4. For each pixel at coordinate (R, C) in grid A, copy the pixel value to the corresponding coordinate (R, C) in the output grid.\n5. Examine grid B. For each coordinate (R, C) in grid A, identify the corresponding coordinate (R, C) in grid B.\n6. Identify the neighbors surrounding the pixel at coordinate (R, C) in grid B. Note the values of these neighbor pixels.\n7. Copy the identified neighbor pixel values from grid B to the corresponding neighbor locations around the pixel at coordinate (R, C) in the output grid.",
    "e73095fd.json": "1. Take the input grid. The output grid will have the same dimensions as the input grid.\n2. For each cell in the input grid, if the value is 5, then in the output grid, if any of the immediate horizontal or vertical neighbors of that cell are 0, then the corresponding output cell's value should be set to 4. Otherwise, the output cell value should be copied from the corresponding input cell.",
    "e76a88a6.json": "1. Find all connected regions of pixels in the input grid, 0 is the background color.\n2. Identify the connected region of pixels with non-5 colors. This will serve as the source pattern.\n3. Extract the pattern from this first region. Determine the minimum row (min_row) and minimum column (min_col) of the bounding box containing the source region's pattern. For each pixel in this source region, calculate its relative coordinates as (row - min_row, col - min_col), where row and col are the row and column indices of the pixel.\n4. For each remaining connected region of pixels with value 5 (grey):\n    a. Determine the minimum row (min_row) and minimum column (min_col) of the bounding box containing the target region.\n    b. For each relative coordinate (r_row, r_col) obtained in step 3:\n        i. Calculate the absolute coordinates (target_row, target_col) in the target region as (min_row + r_row, min_col + r_col).\n        ii. Find the original pixel value at the corresponding relative coordinate (r_row, r_col) in the source region defined in Step 3. Copy this original value to the (target_row, target_col) location in the output grid.\n5. For all other pixels (pixels not modified in step 4), copy the corresponding pixel value from the input grid to the output grid.",
    "e8593010.json": "1. Input: A 10x10 grid containing only values 0 (black) and 5 (grey).\n2. Output: A 10x10 grid of the same size as the input grid.\n3. Process the grid as follows:\n4. For each pixel in the input grid, if the pixel value is 5 (grey), copy the value 5 to the corresponding pixel in the output grid.\n5. Identify all connected components of value 0 (black) in the input grid.\n6. For each connected component:\n   a. If the connected component consists of a single pixel (size 1), change the corresponding pixel value in the output grid to 3 (green).\n   b. If the connected component consists of two connected pixels (size 2), change the values of the corresponding pixels in the output grid to 2 (red).\n   c. If the connected component consists of three connected pixels (size 3), change the values of the corresponding pixels in the output grid to 1 (blue).",
    "e8dc4411.json": "1. Read the input grid. The output grid will have the same dimensions as the input grid.\n2. Identify the locations of pixels with value 0 in the input grid.\n3. Identify a single non-zero value, that is not equal to 0, adjacent to the pattern of 0s, call this color 'C'.\n4. Diagonally replicate the shape of the 0 pattern in the direction of color 'C', using color 'C'.\n5. Continue this replication diagonally until the replicated pattern reaches the edge of the grid.\n6. The remaining pixel values stay the same.",
    "e9614598.json": "1. Identify the coordinates (R1, C1) and (R2, C2) of the two pixels with value 1 in the input grid.\n2. Calculate the midpoint row R_mid = R1. If R1 and R2 are not equal, this logic is not applicable, and return the original input.\n3. Calculate the midpoint column C_mid = (C1 + C2) / 2. If C_mid is not an integer, return the original input.\n4. Assign the value 3 to the pixel at (R_mid, C_mid).\n5. Assign the value 3 to the pixel at (R_mid - 1, C_mid), if R_mid - 1 is within the grid bounds.\n6. Assign the value 3 to the pixel at (R_mid + 1, C_mid), if R_mid + 1 is within the grid bounds.\n7. Assign the value 3 to the pixel at (R_mid, C_mid - 1), if C_mid - 1 is within the grid bounds.\n8. Assign the value 3 to the pixel at (R_mid, C_mid + 1), if C_mid + 1 is within the grid bounds.\n9. Output the modified grid.",
    "e98196ab.json": "1. Divide the input grid (11x11) into two sub-grids separated by the row containing all values of 5. This row is at row index 5.\n2. Take the first 5 rows from the top of the input grid (rows 0-4). These are the 'top rows'.\n3. Take the 5 rows from the bottom of the input grid (rows 6-10). These are the 'bottom rows'.\n4. Create the output grid with dimensions 5x11.\n5. Populate the first row (index 0) of the output grid with the first row (index 0) from the top rows.\n6. Populate the second row (index 1) of the output grid with the first row (index 6) from the bottom rows.\n7. Populate the third row (index 2) of the output grid with the second row (index 1) from the top rows.\n8. Populate the fourth row (index 3) of the output grid with the second row (index 7) from the bottom rows.\n9. Populate the fifth row (index 4) of the output grid with the pattern created by combining fifth row (index 4) of the top rows and the fifth row (index 10) from the bottom rows. Concatenate cell by cell.",
    "e9afcf9a.json": "1. Get the pixel value of the input grid at (0, 0). Call this value FIRST_COLOR.\n2. Get the pixel value of the input grid at (1, 0). Call this value SECOND_COLOR.\n3. Create an output grid with the same dimensions as the input grid.\n4. Iterate through each row R of the output grid, starting from row 0.\n5. Iterate through each column C of the output grid, starting from column 0.\n6. If R is even, then if C is even, set the pixel value at (R, C) to FIRST_COLOR; otherwise, set the pixel value at (R, C) to SECOND_COLOR.\n7. If R is odd, then if C is even, set the pixel value at (R, C) to SECOND_COLOR; otherwise, set the pixel value at (R, C) to FIRST_COLOR.",
    "ea32f347.json": "1. Copy the input grid to the output grid.\n2. Find all contiguous lines of pixels with value 5.\n3. Measure the length of each line (number of pixels with value 5).\n4. Identify the longest line, the middle-length line, and the shortest line.\n5. Change the color of the pixels forming the longest line to 1.\n6. Change the color of the pixels forming the middle-length line to 4.\n7. Change the color of the pixels forming the shortest line to 2.",
    "ea786f4a.json": "1. Input grid remains the same size in the output grid.\n2. Find the pixel with value 0 in the input grid. Let its row index be R and column index be C.\n3. Change the pixel value to 0 at the following coordinates:\n    a. (R-1, C-1) if that coordinate is within the grid bounds.\n    b. (R-1, C+1) if that coordinate is within the grid bounds.\n    c. (R+1, C-1) if that coordinate is within the grid bounds.\n    d. (R+1, C+1) if that coordinate is within the grid bounds.",
    "eb281b96.json": "1. Define the input grid. Let the height of the input grid be H and the width be W.\n2. Create an output grid with height 3*H + 1 and width W.\n3. Copy the first H rows of the input grid to the first H rows of the output grid.\n4. For row index R from 0 to H-1, copy row R of the input to row R of the output.\n5. For row index R from 0 to H-1, copy row R of the input to row R+H+1 of the output.\n6. Create a mirrored pattern from the original pattern underneath the original pattern.\n7. Create mirrored pattern for each grid.",
    "eb5a1d5d.json": "1. Determine the number of distinct color values in the input grid. Let this number be N.\n2. Create an output grid with dimensions (2 * N - 1) x (2 * N - 1).\n3. Initialize all cells in the output grid with the color value of the outermost border of the input grid.\n4. Define the center of the output grid as the location ((2 * N - 1) // 2, (2 * N - 1) // 2).\n5. Identify the innermost color value in the input grid. Fill the center cell of the output grid with this innermost color value.\n6. If N > 1, identify the second-innermost color value in the input grid. Construct a square of size 3x3 in the output grid, centered around the center cell, and fill its outer border with this second-innermost color value, excluding the already filled center cell. \n7. If N > 2, identify the third-innermost color value in the input grid. Construct a square of size 5x5 in the output grid, centered around the center cell, and fill its outer border with this third-innermost color value, excluding the already filled 3x3 square.\n8. If N > 3, identify the fourth-innermost color value in the input grid. Construct a square of size 7x7 in the output grid, centered around the center cell, and fill its outer border with this fourth-innermost color value, excluding the already filled 5x5 square.",
    "ec883f72.json": "1. Copy the input grid to the output grid.\n2. Locate the corners of the outer square region within the input grid. In the training examples, the outer square is formed by a solid block of a single value.\n3. Locate the inner square region within the outer square. The inner square is of a different value than the outer square.\n4. For each corner of the outer square, extend a diagonal line using the value of the inner square until the edge of the grid is reached. Diagonals extend in all four directions from their respective corners.",
    "ecdecbb3.json": "1. Copy the input grid to the output grid.\n2. Locate all pixels with value 2 in the input grid.\n3. For each pixel with value 2 located at row R and column C:\n    a. Extend a line of value 2 vertically from (R, C) until it meets a pixel with value 8.\n    b. Extend a line of value 2 horizontally from (R, C) until it meets a pixel with value 8.\n    c. Change all pixels with value 0 to value 8 in a 3x3 square centered on the original pixel with value 2, except for the center pixel which remains 2.",
    "ed36ccf7.json": "1. The output grid has the same dimensions as the input grid.\n2. Rotate the input grid 90 degrees counter-clockwise to produce the output grid.",
    "ef135b50.json": "1. Maintain the input grid's dimensions.\n2. Iterate through each row R of the input grid.\n3. Iterate through each column C of the input grid.\n4. If the value at (R, C) is 2 and there is another 2 in the same row R, find all continuous sequences of 0s between two 2s in row R.\n5. Change the value of each 0 in the identified continuous sequence to 9.",
    "f15e1fac.json": "1. Copy the input grid to the output grid.\n2. Identify the coordinates (R, C) of all pixels with value 8 in the input grid.\n3. For each identified coordinate (R, C) with value 8, fill the pixel at (R, C) and all pixels to its right (R, C+1), (R, C+2), and so on, with the value 8, until the end of the grid column is reached.\n4. Identify the coordinates (R, C) of all pixels with value 2 in the input grid.\n5. For each identified coordinate (R, C) with value 2, fill the pixel at (R, C) and all pixels above it (R-1, C), (R-2, C), and so on, with the value 8, until the top of the grid column is reached.",
    "f1cefba8.json": "1. Copy the input grid to the output grid. \n2. Identify rows that contain both the border color and the inner color.\n3. In these rows, change the pixel value of the inner section to the border color until reaching the border.",
    "f25fbde4.json": "1. Find the bounding box of the non-zero (4) pixels in the input grid.\n2. Determine the height and width of this bounding box.\n3. Create an output grid. The output grid's height is twice the height of the bounding box. The output grid's width is twice the width of the bounding box.\n4. Copy the non-zero (4) pixels from the input's bounding box to the output grid. Each pixel in the bounding box will be copied to a 2x2 block of pixels in the output grid. For example, if a pixel with value 4 exists at coordinate (r, c) within the bounding box, copy it to the output grid at coordinates (2*r, 2*c), (2*r+1, 2*c), (2*r, 2*c+1), and (2*r+1, 2*c+1).\n5. Fill the rest of the output grid with zeros (0).",
    "f25ffba3.json": "1. Take the input grid. The output grid will have the same dimensions as the input grid.\n2. Reflect the input grid vertically to generate the output grid. Specifically, the row at the top of the input becomes the row at the bottom of the output, and the row at the bottom of the input becomes the row at the top of the output. All other rows shift vertically according to this reflection.",
    "f2829549.json": "1. Consider a 7x4 input grid of integers from 0 to 9.\n2. Create a 3x4 output grid.\n3. For each cell (R, C) in the output grid, where R is the row index (0 to 3) and C is the column index (0 to 2):\n4. Examine the input grid. If the input grid value at (R,C) is 7 OR the input grid value at (R, C+4) is 5, then set the output grid value at (R,C) to 0. Otherwise, set the output grid value at (R,C) to 3.",
    "f35d900a.json": "1. Copy the input grid to the output grid.\n2. Identify the coordinates of non-zero pixel values in the input grid. Let these coordinates be (R1, C1) and (R2, C2).\n3. Around the pixel value at (R1, C1), create a 3x3 square in the output grid using the pixel value at (R2, C2). If the value at (R2, C2) is zero, do not perform this step. The square's center should be at (R1, C1).\n4. Around the pixel value at (R2, C2), create a 3x3 square in the output grid using the pixel value at (R1, C1). If the value at (R1, C1) is zero, do not perform this step. The square's center should be at (R2, C2).\n5. Set the pixel values at (R, C) that are horizontally or vertically adjacent to the 3x3 square such that the square is now connected by alternating pixel value 5 and 0.",
    "f5b8619d.json": "1. Determine the input grid's dimensions (rows and columns).\n2. Create an output grid with double the height and double the width of the input grid.\n3. Iterate through each cell (R, C) of the input grid.\n4. For each input cell (R, C) with value V, set the corresponding 2x2 block in the output grid as follows:\n   a. output[2*R][2*C] = V\n   b. output[2*R+1][2*C] = 8 if V is not 0, otherwise output[2*R+1][2*C] = 0\n   c. output[2*R][2*C+1] = V\n   d. output[2*R+1][2*C+1] = 8 if V is not 0, otherwise output[2*R+1][2*C+1] = 0",
    "f76d97a5.json": "1. Read the input grid. The output grid has the same dimensions as the input grid.\n2. Iterate through each cell (R, C) of the input grid.\n3. If the pixel value at (R, C) is 5, change the pixel value at (R, C) in the output grid to the original non-5 value found in the input grid at that location.\n4. If the pixel value at (R, C) is not 5, change the pixel value at (R, C) in the output grid to 0.",
    "f8a8fe49.json": "1. Locate the outer shape consisting of pixel value 2. The outer shape is bracket-like.\n2. Locate the inner shape(s) consisting of pixel value 5. The inner shape(s) are located either inside or outside the shape of pixel value 2.\n3. If the shape(s) of pixel value 5 are inside the shape of pixel value 2, move them to the outside, maintaining vertical alignment and adding a single column of 0s as a gap between the shape of pixel value 2 and the shape(s) of pixel value 5.\n4. If the shape(s) of pixel value 5 are outside the shape of pixel value 2, move them to the inside, maintaining vertical alignment and adding even spacing of 0s between the shape of pixel value 2 and the shape(s) of pixel value 5.",
    "f8b3ba0a.json": "1. Analyze the input grid and identify the distinct non-zero pixel values.\n2. Count the occurrences of each distinct non-zero pixel value in the input grid.\n3. Sort the distinct non-zero pixel values based on their counts in ascending order (from least frequent to most frequent).\n4. Create a 3x1 output grid.\n5. Assign the least frequent color (pixel value) to the bottom row (row 2) of the output grid.\n6. Assign the second least frequent color (pixel value) to the middle row (row 1) of the output grid.\n7. Assign the third least frequent color (pixel value) to the top row (row 0) of the output grid.",
    "f8c80d96.json": "1. Change the background color (pixel value 0) to 5.\n2. Extend lines of the same color as the original lines, maintaining the same spacing and right-angle bends.",
    "f8ff0b80.json": "1. Find the unique non-zero numbers in the input grid. These are the relevant numbers.\n2. Count the occurrences of each relevant number in the input grid.\n3. Create a 3x1 output grid.\n4. Sort the relevant numbers by their counts in descending order.\n5. In the output grid, assign the numbers to the cells in the order determined in step 4, from top to bottom.",
    "f9012d9b.json": "1. Find the contiguous region(s) of 0s in the Input grid. These regions define the output size.\n2. For each 0-region, identify the coordinates (R, C) of the cells that would have been present, based on the color pattern of the surrounding non-zero cells in the Input grid.\n3. Extract the values that would have been present at the identified (R, C) coordinates.\n4. Construct the output grid by arranging the extracted values in the shape of the 0-region.",
    "fafffa47.json": "1. Create a 3x3 output grid filled with 0.\n2. Locate all pixels with value 9 in the input grid.\n3. Place a pixel with value 2 in the output grid at the corresponding column of each identified value 9 in the input. Specifically, if a pixel with value 9 is at column C in the input, place a pixel with value 2 at column C in the output grid, at the top-most and bottom-most rows (row 0 and row 2). If there is value 9 in both of those locations, both locations are set to value 2.\n4. Pixels with value 2 in the output are only set where the corresponding columns from the input grid had value 9.",
    "fcb5c309.json": "1. Find the largest rectangular frame in the input grid, defined as the frame with the maximum area of the outer border. The border must consist of a single repeating value. The area is calculated as the (height * width) of the rectangle.\n2. Create an output grid. The output grid's dimensions match the height and width of the largest frame found in step 1.\n3. Copy the largest frame from the input grid to the output grid.\n4. Identify the value that fills the inner region of the largest frame in the input grid.\n5. Change the color of the frame's border in the output grid to match the color of the inner region identified in Step 4.",
    "fcc82909.json": "1. Copy the input grid to the output grid.\n2. For each 2x2 block in the input grid, consider the 2x2 block starting at row R and column C.\n3. Create a 2x2 block of value 3 (green) in the output grid, starting at row R+2 and column C.",
    "feca6190.json": "1. Define the input grid. Let I be its height and width. In all examples I equals 1 for height, and 5 for width.\n2. Count the number of non-zero values in the input grid. Call this count N.\n3. Determine the output grid size: The output grid's height and width are both equal to N * 5.\n4. Initialize the output grid with all 0s.\n5. Iterate through the rows of the output grid, from bottom to top (from row N*5-1 down to row 0, inclusive). Let the current row index be R.\n6. Iterate through the columns of the output grid, from left to right (from column 0 to N*5-1, inclusive). Let the current column index be C.\n7. If C equals (R modulo (N*5)), then calculate the index of the pixel value in the input grid using (C divided by 5) floored.\n8. Set the pixel value at (R, C) of the output grid to the corresponding value from the input grid at the calculated index. Otherwise set the value to 0.",
    "ff28f65a.json": "1. Create a new 3x3 output grid filled with 0s.\n2. Count the number of 2x2 square regions in the input grid where all cells have the value 2.\n3. If the count is 1, set the pixel value at (0, 0) in the output grid to 1.\n4. If the count is 2, set the pixel value at (0, 0) and (0, 2) in the output grid to 1.\n5. If the count is 3, set the pixel value at (0, 0), (0, 2), and (1, 1) in the output grid to 1.\n6. If the count is 4, set the pixel value at (0, 0), (0, 2), (1, 1), and (2, 0) in the output grid to 1.\n7. If the count is 5, set the pixel value at (0, 0), (0, 2), (1, 1), (2, 0), and (2, 2) in the output grid to 1.\n8. If the count is 6 or more, set the pixel value at (0, 0), (0, 2), (1, 1), (2, 0), and (2, 2) in the output grid to 1.",
    "ff805c23.json": "1. Identify the square block of color 1 in the input grid.\n2. Determine the height and width of this color 1 square. The output grid's height and width should match the dimensions of this square.\n3. Create an output grid with the determined height and width.\n4. Extract the underlying pattern located at the same coordinates of the color 1 square from the input grid.\n5. Fill the output grid with the extracted pattern."
}