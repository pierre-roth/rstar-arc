{
    "604001fa": "1. Parse the input grid into a 2D array G of integers.\n2. Find all connected components of value 7 in G. Define a component as a maximal set of cells of value 7 connected orthogonally. Collect these into a list SevenComps.\n3. Find all connected components of value 1 in G. Collect these into a list OneComps.\n4. Sort SevenComps in ascending order by the minimum row index of each component. Sort OneComps in ascending order by the minimum row index of each component.\n5. Define a mapping from missing corner of a 2×2 block to new color:\n   - missing (min_row,min_col) → 3\n   - missing (min_row,max_col) → 8\n   - missing (max_row,min_col) → 4\n   - missing (max_row,max_col) → 6\n6. For each index i from 0 to length(SevenComps)−1, do:\n   a. Let C7 = SevenComps[i]. Compute rmin = minimum row of C7, rmax = maximum row of C7, cmin = minimum column of C7, cmax = maximum column of C7.\n   b. Consider the four corner coordinates of the 2×2 block: (rmin,cmin), (rmin,cmax), (rmax,cmin), (rmax,cmax). Identify the one corner not present in C7; call it (rm,cm).\n   c. Let new_color = the mapped color for missing corner (rm,cm).\n   d. Let C1 = OneComps[i]. For each cell (r,c) in C1, set G[r][c] = new_color.\n7. For every cell (r,c) in every component in SevenComps, set G[r][c] = 0.\n8. Return G as the output grid.",
    "94133066": "1. Identify the blue component: find all cells (r,c) with value 1. Compute min_r = min(r), max_r = max(r), min_c = min(c), max_c = max(c).\n2. Define B = {(r,c) | min_r ≤ r ≤ max_r and min_c ≤ c ≤ max_c}.\n3. Inside B, collect all colored cells P_inside = {(r,c,v) ∈ B | grid[r][c] > 1}. For each color v in P_inside count its occurrences; let U = {v | it occurs exactly once in P_inside}.\n4. For each v ∈ U record p_v = its unique (r,c) in P_inside.\n5. In the whole grid, collect outside markers P_outside = {(r,c,v) | grid[r][c]>1, v ∈ U, and ((r<min_r or r>max_r) or (c<min_c or c>max_c))}. For each v ∈ U record m_v = its unique (r,c) in P_outside.\n6. Convert p_v to local coords p_v_loc = (p_v.r - min_r, p_v.c - min_c).\n7. For each of the eight isometries iso (rotate by 0°, 90°, 180°, 270° then optional horizontal flip):\n   a. Compute p'_v = iso(p_v_loc) for each v ∈ U.\n   b. For any v₀ ∈ U compute translation T = (m_v₀.r - (p'_v₀.r + min_r), m_v₀.c - (p'_v₀.c + min_c)).\n   c. If for all v ∈ U, (p'_v.r + min_r + T.r, p'_v.c + min_c + T.c) == m_v, select this iso and T and break.\n8. Apply selected iso and T to all cells in B: for each (r,c) in B let local = (r-min_r, c-min_c), local' = iso(local), global' = (local'.r + min_r + T.r, local'.c + min_c + T.c). Record S = {(global'.r, global'.c, grid[r][c])}.\n9. Compute min_r2 = min(r') over S, max_r2 = max(r'), min_c2 = min(c') over S, max_c2 = max(c'). Let H = max_r2-min_r2+1, W = max_c2-min_c2+1.\n10. Initialize result grid R of size H×W and set every cell to 1.\n11. For each (r',c',v) in S set R[r'-min_r2][c'-min_c2] = v.\n12. Output R.",
    "f3b10344": "1. Scan the input grid and collect all distinct non-zero, non-8 values (colors).  \n2. For each color c in this set:  \n   a. Locate every connected component of cells equal to c using 4-connectivity.  \n   b. For each component, compute its bounding box: top = minimum row index, bottom = maximum row index, left = minimum column index, right = maximum column index.  \n3. For each unordered pair of clusters A and B of the same color c:  \n   a. Compute horizontal_overlap = min(A.bottom, B.bottom) - max(A.top, B.top) + 1.  \n   b. If horizontal_overlap ≥ 1 then  // clusters aligned horizontally  \n      i.   row_start = max(A.top, B.top) + 1  \n      ii.  row_end   = min(A.bottom, B.bottom) - 1  \n      iii. If A.right < B.left then left=A and right=B else left=B and right=A  \n      iv.  col_start = left.right + 1  \n      v.   col_end   = right.left - 1  \n      vi.  For each r from row_start to row_end and each c from col_start to col_end set grid[r][c] = 8  \n   c. Else  // clusters not overlapping rows, must overlap columns  \n      i.   col_start = max(A.left, B.left) + 1  \n      ii.  col_end   = min(A.right, B.right) - 1  \n      iii. If A.bottom < B.top then top=A and bottom=B else top=B and bottom=A  \n      iv.  row_start = top.bottom + 1  \n      v.   row_end   = bottom.top - 1  \n      vi.  For each r from row_start to row_end and each c from col_start to col_end set grid[r][c] = 8  \n4. Return the modified grid.",
    "60a26a3e": "1. Scan the entire grid and record every coordinate (r,c) whose value is 2.\n2. Identify all \"flower\" shapes as those sets of four 2-pixels arranged exactly at north, south, west and east of a common center.  For each grid cell (r,c), if the cells at (r-1,c), (r+1,c), (r,c-1) and (r,c+1) all contain 2, then record (r,c) as a flower center.\n3. For each recorded center (r,c), note its four petal coordinates:\n   - North petal: (r-1,c)\n   - South petal: (r+1,c)\n   - West petal:  (r,c-1)\n   - East petal:  (r,c+1)\n4. Connect horizontally aligned flowers:\n   a. Group all centers by equal row index.\n   b. For each group at row r, sort centers by increasing column: c1, c2, c3, …\n   c. For each adjacent pair (r,c_i) and (r,c_{i+1}):\n      i. Compute x_start = c_i + 2  (just right of the east petal of the left flower).\n      ii. Compute x_end   = c_{i+1} - 2  (just left of the west petal of the right flower).\n      iii. For every column x in the inclusive range [x_start, x_end], set grid[r][x] = 1.\n5. Connect vertically aligned flowers:\n   a. Group all centers by equal column index.\n   b. For each group at column c, sort centers by increasing row: r1, r2, r3, …\n   c. For each adjacent pair (r_i,c) and (r_{i+1},c):\n      i. Compute y_start = r_i + 2  (just below the south petal of the upper flower).\n      ii. Compute y_end   = r_{i+1} - 2  (just above the north petal of the lower flower).\n      iii. For every row y in the inclusive range [y_start, y_end], set grid[y][c] = 1.\n6. Do not modify any existing 2 pixels or other cells.  Leave all other cells at 0 unless overwritten by step 4 or 5.",
    "94414823": "1. Locate the grey 6×6 square:\n   a. Find all grid cells with value 5.\n   b. Let r0 = minimum of their row indices, r1 = maximum of their row indices, c0 = minimum of their column indices, c1 = maximum of their column indices.\n   c. Verify that r1 = r0 + 5 and c1 = c0 + 5.\n2. Find the two colored guide cells:\n   a. Find all cells with value ≠ 0 and ≠ 5; there will be exactly two.\n   b. Denote them (rA, cA) with color C_A and (rB, cB) with color C_B.\n3. Determine which side of the grey square they mark:\n   a. If rA < r0 and rB < r0, side = TOP.\n   b. Else if cA > c1 and cB > c1, side = RIGHT.\n   c. Else if rA > r1 and rB > r1, side = BOTTOM.\n   d. Else if cA < c0 and cB < c0, side = LEFT.\n4. Assign guide colors:\n   If side = TOP or BOTTOM:\n     • The guide cell with column < c0 is C_left; with column > c1 is C_right.\n   If side = LEFT or RIGHT:\n     • The guide cell with row < r0 is C_top; with row > r1 is C_bottom.\n5. Define the four 2×2 quadrants of the central 4×4 region inside the grey square:\n   • TL quadrant: rows r0+1 to r0+2, columns c0+1 to c0+2.\n   • TR quadrant: rows r0+1 to r0+2, columns c1-2 to c1-1.\n   • BL quadrant: rows r1-2 to r1-1, columns c0+1 to c0+2.\n   • BR quadrant: rows r1-2 to r1-1, columns c1-2 to c1-1.\n6. Fill quadrants according to side:\n   If side = TOP:\n     • TL ← C_left, TR ← C_right, BL ← C_right, BR ← C_left.\n   If side = BOTTOM:\n     • BL ← C_left, BR ← C_right, TL ← C_right, TR ← C_left.\n   If side = LEFT:\n     • TL ← C_top, BL ← C_bottom, BR ← C_top, TR ← C_bottom.\n   If side = RIGHT:\n     • TR ← C_top, BR ← C_bottom, BL ← C_top, TL ← C_bottom.\n7. For each quadrant, set every cell in that 2×2 block to its assigned color.\n8. Leave all other cells unchanged.",
    "f3cdc58f": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Create an output grid of size H×W, initializing every cell to 0.\n3. Define an array ColorVals = [1, 2, 3, 4], corresponding to blue (1), red (2), green (3), yellow (4), in that order.\n4. For each index i from 0 to 3:\n   a. Let C = ColorVals[i].\n   b. Count the number of cells in the input grid whose value equals C; call this count N.\n   c. For k from 0 to N-1:\n      i. Set the output cell at row (H-1-k) and column i to C.\n5. Return the output grid.",
    "60c09cac": "1. Let the input grid have H rows and W columns.\n2. Create an output grid with 2*H rows and 2*W columns.\n3. For each row index r from 0 to H-1:\n4.   For each column index c from 0 to W-1:\n5.     Let v = input[r][c].\n6.     Set output[2*r][2*c] = v.\n7.     Set output[2*r][2*c+1] = v.\n8.     Set output[2*r+1][2*c] = v.\n9.     Set output[2*r+1][2*c+1] = v.\n10. Return the output grid.",
    "94be5b80": "1. Locate the 3-row “bar” block (the palette):\n   a. For each row r from 0 to H−3, if rows r, r+1, r+2 share the same set of non-zero columns (i.e. for some columns c each of grid[r][c], grid[r+1][c], grid[r+2][c] is non-zero, and no other non-zero appears in those rows), then set startBarRow = r and break.\n2. Extract palette colors:\n   a. Let barCols = all column indices c where grid[startBarRow][c] ≠ 0, sorted ascending.\n   b. Define paletteColors = [grid[startBarRow][c] for c in barCols].\n3. Remove the palette:\n   For each row in {startBarRow, startBarRow+1, startBarRow+2} and each c in barCols, set grid[row][c] = 0.\n4. Identify the reference shape pattern from the second palette color:\n   a. Let refColor = paletteColors[1].\n   b. Collect all coordinates S = {(r,c) | grid[r][c] = refColor}.\n   c. Compute minR = min r over S, maxR = max r over S, minC = min c over S, maxC = max c over S.\n   d. Let shapeHeight = maxR - minR + 1.\n   e. Define offsets = {(r - minR, c - minC) for (r,c) in S}.\n5. Draw each palette color’s shape in a vertical stack:\n   For each index i from 0 to |paletteColors|−1:\n     a. Let color = paletteColors[i].\n     b. Compute targetTopRow = minR + (i - 1) * shapeHeight.\n     c. For each (dr,dc) in offsets, set grid[targetTopRow + dr][minC + dc] = color.\n6. Return the modified grid.",
    "f3e62deb": "1. Let H and W be the grid height and width (both 10).\n2. Identify the block color value V: scan all cells, collect all positions (r,c) where grid[r][c] != 0. All nonzero cells share the same V.\n3. Compute the bounding box of the block: min_r = minimum r, max_r = maximum r, min_c = minimum c, max_c = maximum c.\n4. Compute block height h = max_r - min_r and width w = max_c - min_c. (For this task h = 2 and w = 2.)\n5. Determine destination top-left corner (dest_min_r, dest_min_c) based on V:\n   - If V == 6 (pink), set dest_min_r = 0 and dest_min_c = min_c.  // move block to top\n   - If V == 4 (yellow), set dest_min_r = H - 1 - h and dest_min_c = min_c.  // move block to bottom\n   - If V == 8 (cyan), set dest_min_r = min_r and dest_min_c = W - 1 - w.  // move block to right\n   - If V == 3 (green), set dest_min_r = min_r and dest_min_c = 0.  // move block to left\n6. Clear the original block: for each (r,c) in the set of original block positions, set grid[r][c] = 0.\n7. Relocate the block:\n   For each original position (r,c):\n     a. Compute offset_row = r - min_r, offset_col = c - min_c.\n     b. Compute new_r = dest_min_r + offset_row, new_c = dest_min_c + offset_col.\n     c. Set grid[new_r][new_c] = V.\n8. Return the modified grid as the output.",
    "626c0bcc": "1. Let H and W be the height and width of the input grid of integers. Create an output grid of same size, initialized to 0. Create a Boolean mask Assigned[r][c]=false for all cells.\n2. Detect all 2×2 full blocks of value 8 (\"squares\"), in row-major order:\n   a. For r from 0 to H-2, for c from 0 to W-2, consider the block corners (r,c), (r,c+1), (r+1,c), (r+1,c+1).\n   b. If all four input[r+i][c+j]==8 and Assigned[r+i][c+j]==false for i,j∈{0,1}, then:\n      i. For each of the four positions, set output[r+i][c+j]=1 and Assigned[r+i][c+j]=true.\n3. Detect all 2×2 blocks forming 3-cell L-shapes, in row-major order:\n   a. For r from 0 to H-2, for c from 0 to W-2, let the four corner positions be P = {(r,c), (r,c+1), (r+1,c), (r+1,c+1)}.\n   b. Let U = {p∈P | input[p]==8 and Assigned[p]==false}.\n   c. If |U|==3, then exactly one corner M∈P is not in U. Determine its location:\n      • If M==(r,c) (missing top-left), set color=2.\n      • If M==(r+1,c) (missing bottom-left), set color=3.\n      • If M==(r,c+1) (missing top-right), set color=4.\n   d. For each p∈U, set output[p]=color and Assigned[p]=true.\n4. Leave all other output cells at 0. Return the output grid.",
    "95a58926": "1. Let background=0 and line=5.  Identify dot_color as the single integer value in the input grid that is neither background nor line.\n2. Let H = number of rows, W = number of columns in the input grid.\n3. Determine line_rows = all row indices r in [0..H-1] where count of cells equal to line in row r > W/2.\n4. Determine line_cols = all column indices c in [0..W-1] where count of cells equal to line in column c > H/2.\n5. Create an output grid of size H×W.\n6. For each cell at coordinates (r,c):\n   a. If r∈line_rows and c∈line_cols, set output[r][c] = dot_color.\n   b. Else if input[r][c] == line, set output[r][c] = line.\n   c. Else set output[r][c] = background.\n7. Return the output grid.",
    "f4081712": "1. Identify the green region: scan all cells (r,c) and collect those with value 3. 2. Compute its bounding rectangle: topRow = minimum r, bottomRow = maximum r, leftCol = minimum c, rightCol = maximum c. 3. Let h = number of rows, w = number of columns, and midRow = (h - 1) / 2. 4. If bottomRow < midRow (region entirely above horizontal center): for each r from topRow to bottomRow and each c from leftCol to rightCol, compute sourceR = (h - 1) - r and sourceC = c, then set output[r - topRow][c - leftCol] = input[sourceR][sourceC]. 5. Otherwise (region entirely below center): for each r from topRow to bottomRow and each c from leftCol to rightCol, compute sourceR = r and sourceC = (w - 1) - c, then set output[r - topRow][c - leftCol] = input[sourceR][sourceC]. 6. Return the output grid of size (bottomRow - topRow + 1) rows and (rightCol - leftCol + 1) columns filled as above.",
    "62ab2642": "1. Scan the entire input grid and collect all coordinates (r,c) where the cell value is 0.\n2. Group these coordinates into connected components using 4-directional adjacency (two cells belong to the same component if one is directly above, below, left, or right of the other).\n3. For each connected component, count its number of cells.\n4. Identify the component with the maximum cell count (Largest) and the component with the minimum cell count (Smallest).  If multiple tie for min or max, pick any one of them.\n5. For every coordinate in the Largest component, set the grid cell to 8.\n6. For every coordinate in the Smallest component, set the grid cell to 7.\n7. Leave all other cells unchanged.",
    "963f59bc": "1. Let input be a 2D grid of integers. Create an output grid initialized as a copy of input.  \n2. Identify the base shape: collect all coordinates (r,c) where input[r][c] == 1.  \n3. Compute the bounding box of the base shape: let r_min = min(r), r_max = max(r), c_min = min(c), c_max = max(c) over all base-shape pixels.  \n4. For each color C ≠ 1 present in input:  \n   a. Locate the single seed coordinate (r_s,c_s) where input[r_s][c_s] == C.  \n   b. If r_min ≤ r_s ≤ r_max, then perform a horizontal (left-right) mirror:  \n      i. On row r_s, find the unique c_source such that input[r_s][c_source] == 1.  \n      ii. Compute pivot column p = (c_source + c_s) / 2.  \n      iii. For each base-shape pixel (r,c): compute mirrored column c' = 2*p - c, then set output[r][c'] = C.  \n   c. Else if c_min ≤ c_s ≤ c_max, then perform a vertical (up-down) mirror:  \n      i. On column c_s, find the unique r_source such that input[r_source][c_s] == 1.  \n      ii. Compute pivot row p = (r_source + r_s) / 2.  \n      iii. For each base-shape pixel (r,c): compute mirrored row r' = 2*p - r, then set output[r'][c] = C.  \n5. Leave all other cells in output unchanged.  \n6. Return the output grid.",
    "f45f5ca7": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Create an output grid of size H×W and fill every cell with 0.\n3. Define a mapping from input value v in column 0 to its target column index c:\n   - If v = 8, then c = 1\n   - If v = 2, then c = 2\n   - If v = 4, then c = 3\n   - If v = 3, then c = 4\n4. For each row r from 0 to H−1:\n   a. Read v = input[r][0].\n   b. If v is one of {8,2,4,3}, then set output[r][c] = v, where c is the mapped column from step 3.\n   c. Otherwise (v = 0 or any other value), leave output[r][*] all zeros.\n5. Return the output grid.",
    "62b74c02": "1. Let N = number of columns in the input grid.\n2. Scan row 0 from column 0 upward until you find the first column c where input[0][c] == 0; set W = c.\n3. Compute offset = N - W.\n4. Create an output grid of the same dimensions as the input.\n5. For each row r from 0 to height−1:\n   a. For each column c from 0 to W−1: set output[r][c] = input[r][c].\n   b. For each column c from W to offset inclusive: set output[r][c] = input[r][W−1].\n   c. For each i from 1 to W−1: set output[r][offset + i] = input[r][i].\n6. Return the output grid.",
    "96a8c0cd": "1. Let H = number of rows, W = number of columns.  \n2. Locate the unique starting cell with value 2. Call its coordinates (r, c).  \n3. Determine horizontal direction:  \n   a. Compute distLeft = c, distRight = W - 1 - c.  \n   b. If distLeft < distRight then set dc = -1 (move left), else set dc = +1 (move right).  \n4. Repeat:  \n   a. Let nextC = c + dc. If nextC < 0 or nextC >= W, break the loop.  \n   b. If grid[r][nextC] == 0 and column nextC contains no cells of value 3 or 1:  \n      i. Set c = nextC.  \n      ii. If grid[r][c] == 0 then set grid[r][c] = 2.  \n      iii. Continue to next iteration.  \n   c. Else if column nextC contains at least one 3 (green):  \n      i. Let G = {row i | grid[i][nextC] == 3}. Let maxG = max(G).  \n      ii. While r < maxG + 1:  \n          - r = r + 1.  \n          - If grid[r][c] == 0 then set grid[r][c] = 2.  \n      iii. Set c = nextC.  \n      iv. If grid[r][c] == 0 then set grid[r][c] = 2.  \n      v. Continue to next iteration.  \n   d. Else if column nextC contains at least one 1 (blue):  \n      i. Let B = {row i | grid[i][nextC] == 1}. Let minB = min(B).  \n      ii. While r > minB - 1:  \n          - r = r - 1.  \n          - If grid[r][c] == 0 then set grid[r][c] = 2.  \n      iii. Set c = nextC.  \n      iv. If grid[r][c] == 0 then set grid[r][c] = 2.  \n      v. Continue to next iteration.  \n5. End loop.  \n\nDefinitions:  \n- Coordinates (r, c) use 0-based row and column indices.  \n- Operations never overwrite original cells of value 1 or 3.  \n- Painting sets only cells of initial value 0 to 2.  \n- Value 3 corresponds to green; value 1 corresponds to blue; value 2 is the path color (red).  ",
    "f5aa3634": "1. Identify all connected components of non-zero pixels using 4-connectivity (adjacent up/down/left/right), regardless of pixel value. 2. For each component, compute its minimal bounding rectangle: min_row, max_row, min_col, max_col. 3. Extract the subgrid of the input from min_row to max_row and min_col to max_col; record this subgrid as the component’s shape. 4. Compare these shapes for exact element-wise equality. 5. Count how many times each distinct shape occurs. 6. Select the shape whose occurrence count is greater than one (the most frequent duplicate). 7. Return that shape’s subgrid as the output.",
    "639f5a19": "1. Scan the grid and find each connected component of cells with value 8 (original light-blue blocks).\n2. For each connected component:\n   a. Compute its bounding box: let top = minimum row index, bottom = maximum row index, left = minimum column index, right = maximum column index. Let height = bottom – top + 1, width = right – left + 1.\n   b. Compute half_height = floor(height / 2), half_width = floor(width / 2).\n   c. For each cell (r, c) within the bounding box that has original value 8:\n      i. If r < top + 2 or r > bottom – 2 or c < left + 2 or c > right – 2 (border region of thickness 2):\n         - If (r – top) < half_height and (c – left) < half_width, set grid[r][c] = 6.\n         - Else if (r – top) < half_height and (c – left) ≥ half_width, set grid[r][c] = 1.\n         - Else if (r – top) ≥ half_height and (c – left) < half_width, set grid[r][c] = 2.\n         - Else (r – top) ≥ half_height and (c – left) ≥ half_width, set grid[r][c] = 3.\n      ii. Else (interior region), set grid[r][c] = 4.\n3. Leave all cells not in value-8 components unchanged (remain 0).",
    "97239e3d": "1. Let H and W be the number of rows and columns of the input grid. Create an output grid as a copy of the input grid.\n2. For each color value C in {1,2,3,4,5,6,7,9} (i.e., each distinct cell value in the input except 0 and 8):\n  a. Collect all coordinates P = {(r,c) | input[r][c] == C}.\n  b. If |P| != 2, skip this C.\n  c. Let r1 = min_{(r,*) in P}(r), r2 = max_{(r,*) in P}(r); let c1 = min_{(*,c) in P}(c), c2 = max_{(*,c) in P}(c).\n  d. Determine the top horizontal row t_top:\n     i. If row r1 is entirely zeros in the input, t_top = r1.\n     ii. Else if r1 > 0 and row (r1 - 1) is entirely zeros, t_top = r1 - 1.\n     iii. Else t_top = r1.\n  e. Determine the bottom horizontal row t_bottom:\n     i. If row r2 is entirely zeros in the input, t_bottom = r2.\n     ii. Else if r2 + 1 < H and row (r2 + 1) is entirely zeros, t_bottom = r2 + 1.\n     iii. Else t_bottom = r2.\n  f. Draw horizontal lines:\n     For each column c from c1 to c2 inclusive:\n       If input[t_top][c] == 0, set output[t_top][c] = C.\n       If input[t_bottom][c] == 0, set output[t_bottom][c] = C.\n  g. Draw vertical lines:\n     For each row r from r1 to r2 inclusive:\n       If input[r][c1] == 0, set output[r][c1] = C.\n       If input[r][c2] == 0, set output[r][c2] = C.\n3. Return the output grid.",
    "f5c89df1": "1. Let H and W be the height and width of the input grid. 2. Identify the cell G where grid[G.r][G.c] == 3 (the single green pixel). 3. Collect all cells B = { (r,c) | grid[r][c] == 8 } (the blue pixels). 4. Compute the set of offsets D = { (r - G.r, c - G.c) for each (r,c) in B }. 5. Collect all cells R = { (r,c) | grid[r][c] == 2 } (the red pixels). 6. Create an output grid of size H×W initialized to 0. 7. For each (r0,c0) in R do: for each (dr,dc) in D do: if 0 ≤ r0+dr < H and 0 ≤ c0+dc < W then set output[r0+dr][c0+dc] = 8. 8. Return the output grid.",
    "642248e4": "1. Let numRows = number of rows in the grid, numCols = number of columns. 2. Identify the two opposite border strips:\n   a. If every cell in row 0 is non-zero and every cell in row numRows-1 is non-zero, set orientation = horizontal. Define colorTop = grid[0][0], colorBottom = grid[numRows-1][0].\n   b. Otherwise, if every cell in column 0 is non-zero and every cell in column numCols-1 is non-zero, set orientation = vertical. Define colorLeft = grid[0][0], colorRight = grid[0][numCols-1].\n3. For each cell (r,c) such that grid[r][c] == 1 (blue):\n   If orientation == horizontal:\n     a. Compute distTop = r, distBottom = (numRows-1) - r.\n     b. If distTop <= distBottom:\n        i. Set grid[r-1][c] = colorTop.\n       Else:\n        i. Set grid[r+1][c] = colorBottom.\n   If orientation == vertical:\n     a. Compute distLeft = c, distRight = (numCols-1) - c.\n     b. If distLeft <= distRight:\n        i. Set grid[r][c-1] = colorLeft.\n       Else:\n        i. Set grid[r][c+1] = colorRight.\n4. Leave all other cells unchanged.\n5. Return the modified grid.",
    "9772c176": "1. Locate each connected component of cells with value 8 (use 4-connectivity).\n2. For each component, compute its axis-aligned bounding box: r_min = minimum row, r_max = maximum row, c_min = minimum column, c_max = maximum column.\n3. Identify the top flat edge:\n   a. Let top_row = r_min. Let c1 = smallest column in the component at top_row; let c2 = largest column in the component at top_row.\n   b. Compute width_top = c2 - c1 + 1 and h_top = floor(width_top / 2).\n   c. For d from 1 to h_top:\n      i. target_row = r_min - d.\n      ii. start_col = c1 + d; end_col = c2 - d.\n      iii. For col from start_col to end_col, if (target_row, col) is inside the grid and has value 0, set it to 4.\n4. Identify the bottom flat edge:\n   a. Let bottom_row = r_max; let c1′ and c2′ be min and max columns of the component at bottom_row.\n   b. Compute width_bottom = c2′ - c1′ + 1 and h_bottom = floor(width_bottom / 2).\n   c. For d from 1 to h_bottom:\n      i. target_row = r_max + d.\n      ii. start_col = c1′ + d; end_col = c2′ - d.\n      iii. For col from start_col to end_col, if inside grid and value 0, set to 4.\n5. Identify the left flat edge:\n   a. Let c_side = c_min. Find all rows r in [r_min..r_max] where (r, c_side) is 8. Among those, restrict to the contiguous block of rows [r1..r2] on which the component’s row-length equals the maximum row-length of the component.\n   b. Let height_left = r2 - r1 + 1 and h_left = floor(height_left / 2).\n   c. For d from 1 to h_left:\n      i. target_col = c_min - d.\n      ii. start_row = r1 + d; end_row = r2 - d.\n      iii. For row from start_row to end_row, if (row, target_col) is in bounds and value 0, set to 4.\n6. Identify the right flat edge:\n   a. Let c_side = c_max. Find contiguous block of rows [r1..r2] where (r, c_side) is 8 and row-length equals the maximum.\n   b. Let height_right = r2 - r1 + 1 and h_right = floor(height_right / 2).\n   c. For d from 1 to h_right:\n      i. target_col = c_max + d.\n      ii. start_row = r1 + d; end_row = r2 - d.\n      iii. For row from start_row to end_row, if in bounds and value 0, set to 4.\n7. Leave all original 8 cells unchanged and only overwrite 0 cells as described. 4’s may be clipped by the grid border if any target_row or target_col is out of bounds.",
    "f823c43c": "1. Compute the count of each integer value in the input grid. 2. Let noiseColor = the integer with the smallest total count. Let mainColors = the two other integers. 3. For each row index r:   a. Let rowSet = set of values in row r excluding noiseColor.   b. If rowSet has size 1, mark r as a uniformRow and record uniformColor[r] = the sole value in rowSet.   c. Otherwise mark r as a patternRow. 4. Let W = number of columns. Initialize an array basePattern[0..W-1]. 5. For each column index c from 0 to W-1:   a. Find any patternRow r such that input[r][c] != noiseColor.   b. Set basePattern[c] = input[r][c]. 6. Construct the output grid by iterating each row r and column c:   a. If r is a uniformRow, set output[r][c] = uniformColor[r].   b. If r is a patternRow, set output[r][c] = basePattern[c]. 7. Return the output grid.",
    "642d658d": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Initialize an empty map counts from integer to integer (default value 0).\n3. For each row index r from 0 to H-1:\n   For each column index c from 0 to W-1:\n     a. If grid[r][c] == 4 then:\n        i. If r-1 >= 0 and r+1 < H and c-1 >= 0 and c+1 < W then:\n           A. Let p1 = grid[r-1][c]\n           B. Let p2 = grid[r+1][c]\n           C. Let p3 = grid[r][c-1]\n           D. Let p4 = grid[r][c+1]\n           E. If p1 == p2 == p3 == p4 and p1 != 4 then increment counts[p1] by 1.\n4. If counts is empty, set result_color = 0; otherwise set result_color to the key in counts with the maximum value.\n5. Produce an output grid of size 1×1 whose single cell value is result_color.",
    "981571dc": "1. Parse the grid as a 2D array G of size H×W with integer values 0–9. 0 represents a missing (black) cell.  \n2. Find every maximal axis-aligned rectangular region R of cells whose value is 0. For each region R:  \n   a. Let R spans rows r1…r2 and columns c1…c2 (inclusive), and w = c2–c1+1.  \n   b. For each row r from r1 to r2:  \n      i. Check if the w cells immediately to the right of R, at columns c2+1 … c2+w, are all within [0,W) and nonzero. If so, for each offset i from 0 to w–1, set G[r][c1+i] = G[r][c2+1 + (w–1–i)].  \n      ii. Otherwise, check if the w cells immediately to the left of R, at columns c1–w … c1–1, are all within [0,W) and nonzero. If so, for each i from 0 to w–1, set G[r][c2–i] = G[r][c1–w + (w–1–i)].  \n3. After filling all zero regions, output the completed grid.",
    "f83cb3f6": "1. Let H and W be the number of rows and columns of the input grid.\n2. Identify all coordinates (r,c) where input[r][c] == 8.  \n   a. If all these coordinates share the same row index r0, set orientation = horizontal, line_row = r0, and line_cols = { c | input[r0][c] == 8 }.  \n   b. Otherwise, they share the same column index c0; set orientation = vertical, line_col = c0, and line_rows = { r | input[r][c0] == 8 }.\n3. Initialize an H×W output grid filled with 0.\n4. Copy the line of 8s to the output:\n   For each (r,c) in the input where input[r][c] == 8, set output[r][c] = 8.\n5. If orientation == horizontal:\n   a. Initialize empty sets above_cols and below_cols.\n   b. For each cell (r,c) of the input where value V = input[r][c] is neither 0 nor 8:\n      i. If c ∉ line_cols, continue to next cell.\n      ii. If r < line_row, add c to above_cols.\n      iii. If r > line_row, add c to below_cols.\n   c. For each c in above_cols, set output[line_row - 1][c] = V (use the same V as in the input at any (r,c) with that column).\n   d. For each c in below_cols, set output[line_row + 1][c] = V.\n6. If orientation == vertical:\n   a. Initialize empty sets left_rows and right_rows.\n   b. For each cell (r,c) of the input where value V = input[r][c] is neither 0 nor 8:\n      i. If r ∉ line_rows, continue to next cell.\n      ii. If c < line_col, add r to left_rows.\n      iii. If c > line_col, add r to right_rows.\n   c. For each r in left_rows, set output[r][line_col - 1] = V.\n   d. For each r in right_rows, set output[r][line_col + 1] = V.\n7. Return the output grid.",
    "64a7c07e": "1. Let the input be a grid G of size R rows and C columns, with integer values 0–9. 2. Create an output grid O of size R×C, initialized so that every cell is 0. 3. Initialize a boolean visited[R][C] all false. 4. For each cell (r,c) in G: if G[r][c] ≠ 0 and visited[r][c] is false, do steps 5–9 to process a component of color V=G[r][c]. 5. Perform a flood‐fill from (r,c) to collect all cells in the 8-connected component: use neighbors (dr,dc) in {–1,0,1}×{–1,0,1} except (0,0). Mark each visited. Store the set of coordinates S = {(r_i,c_i)}. 6. Compute min_c = min(c_i), max_c = max(c_i) over all (r_i,c_i) in S. 7. Compute width = max_c – min_c + 1. 8. For each (r_i,c_i) in S, compute c_new = c_i + width, and set O[r_i][c_new] = V. 9. Continue until all nonzero cells are visited. 10. Return O as the transformed grid.",
    "992798f6": "1. Find the position of the unique pixel with value 2 (the red square): (rR, cR).\n2. Find the position of the unique pixel with value 1 (the blue square): (rB, cB).\n3. Compute dr = rB – rR, dc = cB – cR.\n4. Compute step directions sdr = sign(dr) (±1 or 0), sdc = sign(dc) (±1 or 0).\n5. Compute the start-diagonal adjacency P0 = (r0, c0) = (rR + sdr, cR + sdc).\n6. Compute the end-diagonal adjacency P2 = (r2, c2) = (rB – sdr, cB – sdc).\n7. Determine the primary axis for the straight segment:\n   • If |dr| > |dc|, primary axis = vertical; else primary axis = horizontal.\n8. If primary axis = vertical:\n   a. Let ct = c0.\n   b. Let tau = |c2 – ct|.\n   c. Let rt = r2 – sdr * tau.\n   d. Initialize (r, c) := (r0, c0); mark this cell with 3.\n   e. While r ≠ rt:\n      i. r := r + sdr; mark (r, c) with 3.\n   f. While (r, c) ≠ (r2, c2):\n      i. r := r + sdr; c := c + sdc; mark (r, c) with 3.\n9. If primary axis = horizontal:\n   a. Let rt = r0.\n   b. Let tau = |r2 – rt|.\n   c. Let ct = c2 – sdc * tau.\n   d. Initialize (r, c) := (r0, c0); mark this cell with 3.\n   e. While c ≠ ct:\n      i. c := c + sdc; mark (r, c) with 3.\n   f. While (r, c) ≠ (r2, c2):\n      i. r := r + sdr; c := c + sdc; mark (r, c) with 3.\n10. Leave the original red (2) and blue (1) pixels unchanged; all other positions remain 0 or become 3 along the path.",
    "f8be4b64": "1. Let H = number of rows and W = number of columns of the input grid.\n2. Initialize two H×W arrays h_ext and v_ext with null values. Initialize the output grid as a copy of the input grid.\n3. Identify the set of seed cells S = { (r,c) | input[r][c] != 0 and input[r][c] != 3 }.\n4. For each seed (r,c) in S with color V = input[r][c]:\n   a. Define its own barrier set B = { (r+dr, c+dc) | (dr,dc) in {(-1,0),(1,0),(0,-1),(0,1)} and that cell is within grid and input[...] == 3 }.\n   b. Vertical extension: for each (dr,dc) in {(-1,0),(1,0)} do:\n      i. Set r0 = r + dr, c0 = c.\n      ii. While 0 <= r0 < H and 0 <= c0 < W:\n          A. If input[r0][c0] == 3 and (r0,c0) not in B: break.\n          B. If input[r0][c0] != 3: set v_ext[r0][c0] = V.\n          C. r0 += dr.\n   c. Horizontal extension: for each (dr,dc) in {(0,-1),(0,1)} do:\n      i. Set r0 = r, c0 = c + dc.\n      ii. While 0 <= r0 < H and 0 <= c0 < W:\n          A. If input[r0][c0] == 3 and (r0,c0) not in B: break.\n          B. If input[r0][c0] != 3: set h_ext[r0][c0] = V.\n          C. c0 += dc.\n5. Build the final output grid: for each cell (r,c):\n   a. If input[r][c] == 3 or (r,c) in S, leave output[r][c] = input[r][c].\n   b. Else if v_ext[r][c] is not null, set output[r][c] = v_ext[r][c].\n   c. Else if h_ext[r][c] is not null, set output[r][c] = h_ext[r][c].\n   d. Else set output[r][c] = 0.",
    "00576224": "1. Let M be the input grid of size 2×2, where M[r][c] is the value at row r and column c with 0 ≤ r,c ≤ 1.\n2. Create an empty output grid G of size 6×6, with rows and columns indexed 0 to 5.\n3. For each tile row index tr from 0 to 2 (inclusive):\n   a. Set flip = (tr mod 2 == 1).\n   b. For each tile column index tc from 0 to 2 (inclusive):\n      i. For each local row lr in {0,1} and local column lc in {0,1}:\n         A. If flip is false, let value = M[lr][lc];\n            if flip is true, let value = M[lr][1 - lc].\n         B. Compute output row R = tr * 2 + lr, output column C = tc * 2 + lc.\n         C. Set G[R][C] = value.\n4. Return G as the 6×6 transformed grid.",
    "66e6c45b": "1. Let N be the number of rows minus 1 (for a 4×4 grid, N=3).\n2. Create an output grid of the same dimensions as the input grid and fill every cell with 0.\n3. Define the set of central coordinates C = {(1,1), (1,2), (2,1), (2,2)}.\n4. For each coordinate (r, c) in C:\n   a. Let v = input_grid[r][c].\n   b. If v is not 0, compute:\n      i. new_r = 0 if r == 1, otherwise new_r = N  (when r == 2).\n      ii. new_c = 0 if c == 1, otherwise new_c = N  (when c == 2).\n   c. Set output_grid[new_r][new_c] = v.\n5. Return the output grid.",
    "99306f82": "1. Locate the square border of color 1:\n   a. Let B1 = set of all cells (r,c) where grid[r][c] == 1.\n   b. Compute r_min = min_{(r,c) in B1}(r), r_max = max_{(r,c) in B1}(r), c_min = min_{(r,c) in B1}(c), c_max = max_{(r,c) in B1}(c).\n   c. Confirm that r_max - r_min == c_max - c_min (the border is a square) and that every cell on the boundary of the rectangle [r_min..r_max] x [c_min..c_max] has value 1.\n2. Extract the diagonal color sequence c[0..K], where K = r_min:\n   For i from 0 to K inclusive, set c[i] = grid[i][i].\n3. Fill interior rectangles in order:\n   For j from 1 to K inclusive:\n     a. Compute top = r_min + j, bottom = r_max - j, left = c_min + j, right = c_max - j.\n     b. For every cell (r,c) with r in [top..bottom] and c in [left..right], set grid[r][c] = c[j-1].\n4. Leave all other cells unchanged.",
    "f9a67cb5": "1. Identify grid height H and width W.  2. Locate the single starting cell S at (r_s, c_s) with value 2 on the grid perimeter.  3. Determine gravity direction (dr, dc):\n   - If r_s = 0, set (dr, dc) = (1, 0).\n   - Else if r_s = H−1, set (dr, dc) = (−1, 0).\n   - Else if c_s = 0, set (dr, dc) = (0, 1).\n   - Else if c_s = W−1, set (dr, dc) = (0, −1).\n4. Initialize a queue of flow seeds with S.  \n5. While the queue is nonempty, remove a seed position (r, c):\n   a. Perform a vertical flow from (r, c):\n      i. Loop: let (r1, c1) = (r + dr, c + dc).\n      ii. If (r1, c1) is outside grid or grid[r1][c1] = 8, break the loop.\n      iii. If grid[r1][c1] = 0, set grid[r1][c1] = 2, then update (r, c) = (r1, c1) and repeat step i.\n      iv. If grid[r1][c1] = 2, set (r, c) = (r1, c1) and repeat step i.\n      v. After break, at current (r, c), invoke lateral spreads.\n   b. Define perpendicular side directions (sd1_r, sd1_c) = (dc, −dr) and (sd2_r, sd2_c) = (−dc, dr).\n   c. For each side direction (sd_r, sd_c) in {(sd1_r, sd1_c), (sd2_r, sd2_c)}:\n      i. Initialize (r2, c2) = (r + sd_r, c + sd_c).\n      ii. While (r2, c2) is inside grid and grid[r2][c2] = 0:\n         1. Let (r_down, c_down) = (r2 + dr, c2 + dc).\n         2. If (r_down, c_down) is inside grid and grid[r_down][c_down] = 0:\n            a. Set grid[r2][c2] = 2.\n            b. Enqueue (r2, c2) as a new seed for vertical flow.\n            c. Break this lateral loop.\n         3. Else (grid[r_down][c_down] ∈ {8, 2} or outside):\n            a. Set grid[r2][c2] = 2.\n            b. Update (r2, c2) = (r2 + sd_r, c2 + sd_c) and continue.\n6. Terminate when queue is empty.  7. Return the modified grid with all newly marked 2’s.",
    "009d5c81": "1. Let G be the input grid of integers.\n2. Locate the set S1 of all coordinates (r,c) where G[r][c]==1.  \n3. Compute min_r = minimum r in S1, max_r = maximum r in S1, min_c = minimum c in S1, max_c = maximum c in S1.\n4. Extract a 3×3 binary mask M of the small shape: for i from 0 to 2 and j from 0 to 2, let M[i][j]=1 if G[min_r+i][min_c+j]==1, else 0.\n5. Determine new_color as follows:\n   a. If M equals [[0,1,0],[1,1,1],[0,1,0]] then new_color=2.\n   b. Else if M equals [[1,0,1],[0,1,0],[1,1,1]] then new_color=3.\n   c. Else if M equals [[1,1,1],[1,0,1],[0,1,0]] then new_color=7.\n6. For every cell (r,c) in the grid:\n   a. If G[r][c]==8, set G[r][c]=new_color.\n   b. Else if G[r][c]==1, set G[r][c]=0.\n   c. Else leave G[r][c] unchanged.\n7. Return G as the output grid.",
    "66f2d22f": "1. Let H = number of rows in the input grid and W = number of columns. 2. Compute L = W / 2 (an integer). 3. Create an output grid of size H × L, filled initially with 0. 4. For each row r from 0 to H−1, and for each column c from 0 to L−1:    a. If input[r][c] == 0 AND input[r][c + L] == 0, set output[r][c] = 5;    b. Otherwise, leave output[r][c] = 0. 5. Return the output grid.",
    "9a4bb226": "1. Let the input be a 2D integer grid G of size H×W. 2. Initialize best_count = -1 and best_top = (0,0). 3. For each row r from 0 to H−3 inclusive:   a. For each column c from 0 to W−3 inclusive:     i. Collect the 3×3 block B of values B[i][j] = G[r+i][c+j] for i=0..2, j=0..2.     ii. If any value in B equals 0, skip this block.     iii. Compute the set S of distinct values in B and let count = |S|.     iv. If count > best_count, then set best_count = count and best_top = (r,c). 4. After scanning, let (r0,c0) = best_top. 5. Construct the output grid as the 3×3 block G[r0+i][c0+j] for i=0..2, j=0..2. 6. Return this 3×3 block as the result.",
    "f9d67f8b": "1. Identify all maximal connected components of value 9. For each component:\n   a. Compute its bounding box: min_row, max_row, min_col, max_col.\n2. For each cell (r, c) within that bounding box that currently holds 9:\n   a. Compute its zero‐based offsets within the box: dr = r - min_row, dc = c - min_col.\n   b. Define four candidate cells:\n      i.   Left:  (r, min_col - dc - 1)\n      ii.  Right: (r, max_col + dc + 1)\n      iii. Top:   (min_row - dr - 1, c)\n      iv.  Bottom:(max_row + dr + 1, c)\n   c. In the order Left, Right, Top, Bottom, pick the first candidate whose coordinates lie inside the grid and whose value is not 9. Let that value be v.\n   d. Set cell (r, c) = v.\n3. Repeat for every 9‐filled component until no cells with value 9 remain.",
    "00dbd492": "1. Let G be the input grid of size R×C. 2. Find all 4-connected components of pixels with value 2. 3. For each component comp:\n   a. Compute min_row = minimum row index of comp, max_row = maximum row index, min_col = minimum column index, max_col = maximum column index.\n   b. Let H = max_row - min_row + 1 and W = max_col - min_col + 1.\n   c. If H == W and H ∈ {5,7,9} then:\n      i. Verify that for every cell (r,c) on the border of the bounding box (r = min_row or r = max_row, for c from min_col to max_col; or c = min_col or c = max_col, for r from min_row to max_row), G[r][c] == 2.\n      ii. Verify that every interior cell (r,c) with min_row < r < max_row and min_col < c < max_col satisfies G[r][c] == 0.\n      iii. Determine fill_value: if H == 5 use 8; if H == 7 use 4; if H == 9 use 3.\n      iv. For every interior cell (r,c) with min_row < r < max_row and min_col < c < max_col, set G[r][c] = fill_value.\n4. Return the modified grid G as the output.",
    "67636eac": "1. Scan the input grid of size R×C to locate all plus-shaped objects: for each cell (r,c) with value V≠0, if cells (r-1,c), (r+1,c), (r,c-1) and (r,c+1) exist and all equal V, then record one object with center at (r,c) and color V.\n2. For each recorded object, compute its 3×3 bounding box: rows r-1 to r+1 and columns c-1 to c+1. Extract the 3×3 subgrid of values (including zeros) and store it along with the object’s center coordinates (r,c).\n3. Let N be the total number of objects. Compute min_col = minimum of all center_col values; max_col = maximum of all center_col values; horizontal_span = max_col - min_col. Compute min_row = minimum of all center_row values; max_row = maximum of all center_row values; vertical_span = max_row - min_row.\n4. If horizontal_span ≥ vertical_span, set orientation = horizontal and sort objects in ascending order of center_col. Otherwise set orientation = vertical and sort objects in ascending order of center_row.\n5. If orientation is horizontal:\n   a. Create an output grid of size 3 rows × (3×N) columns filled with 0.\n   b. For each object at sorted index i from 0 to N-1, copy its 3×3 subgrid into output rows 0..2 and columns (3×i) .. (3×i+2).\n6. If orientation is vertical:\n   a. Create an output grid of size (3×N) rows × 3 columns filled with 0.\n   b. For each object at sorted index i from 0 to N-1, copy its 3×3 subgrid into output rows (3×i) .. (3×i+2) and columns 0..2.\n7. Return the output grid.",
    "9b2a60aa": "1. Identify all non-zero cells in the grid.\n2. Identify the guide line:\n   a. If two or more non-zero cells share the same row R and no other non-zero cell lies outside that row among isolated singletons, set orientation = horizontal and guide_row = R.\n   b. Else if two or more share the same column C, set orientation = vertical and guide_col = C.\n3. Extract markers:\n   If orientation = horizontal:\n     • For each column C where grid[guide_row][C] ≠ 0 record a marker at coord = C and color = grid[guide_row][C].\n   If orientation = vertical:\n     • For each row R where grid[R][guide_col] ≠ 0 record a marker at coord = R and color = grid[R][guide_col].\n   Sort the list of markers by coord in ascending order. Let n = number of markers.\n4. Locate the template shape:\n   a. Choose any non-zero cell not on the guide line. Perform a 4‐connected flood fill to collect its connected component.\n   b. Compute its bounding box: min_r, max_r, min_c, max_c.\n   c. Compute shape_offsets = { (r - min_r, c - min_c) for each (r,c) in the component }.\n   d. Let shape_h = max_r - min_r + 1 and shape_w = max_c - min_c + 1.\n5. Compute spacing array S of length n−1:\n   For i from 0 to n−2: S[i] = marker_coord[i+1] - marker_coord[i] - 1.\n6. Determine the template marker index t:\n   If horizontal:\n     • Let template_center = round((min_c + max_c) / 2).\n     • Choose t ∈ [0..n−1] minimizing |marker_coord[t] - template_center|.\n   If vertical:\n     • Let template_center = round((min_r + max_r) / 2).\n     • Choose t minimizing |marker_coord[t] - template_center|.\n7. Initialize the output grid as a copy of the input grid.\n8. For each marker index i from 0 to n−1:\n   a. If i < t then direction = -1 and index_range = [i .. t−1];\n      else if i > t then direction = +1 and index_range = [t .. i−1];\n      else direction = 0 and index_range = empty.\n   b. Compute shift = direction * Σ_{j∈index_range}( (orientation=horizontal ? shape_w : shape_h) + S[j] ).\n   c. For each (dr,dc) in shape_offsets:\n       If orientation = horizontal:\n         set output[min_r + dr][min_c + dc + shift] = marker_color[i].\n       If orientation = vertical:\n         set output[min_r + dr + shift][min_c + dc] = marker_color[i].\n9. Return the output grid.",
    "fafd9572": "1. Parse the input grid of integers, let R be number of rows and C be number of columns.\n2. Identify the key shape:\n   a. Find all cells with value >1. These form exactly one connected component under 4-neighborhood; record its cell coordinates.\n   b. Compute key_top = minimum row, key_left = minimum column, key_bottom = maximum row, key_right = maximum column among those cells.\n   c. Let H = key_bottom – key_top + 1, W = key_right – key_left + 1.\n   d. Define a template array T of size H×W. For each 0 ≤ i < H and 0 ≤ j < W:\n        if grid[key_top + i][key_left + j] > 1 then T[i][j] = grid[key_top + i][key_left + j]\n        else T[i][j] = 0\n3. Identify all target shapes:\n   a. Find every connected component under 4-neighborhood of cells with value exactly 1.\n   b. For each component, compute its comp_top = min row, comp_left = min column, comp_bottom, comp_right.\n   c. Compute comp_H = comp_bottom – comp_top + 1, comp_W = comp_right – comp_left + 1.\n   d. If comp_H ≠ H or comp_W ≠ W or the set of offsets {(r–comp_top, c–comp_left) | grid[r][c] == 1} ≠ the set of offsets {(i, j) | T[i][j] ≠ 0}, skip this component.\n4. Recolor each matching component:\n   For each remaining component and for each offset (i, j) with T[i][j] ≠ 0,\n      set output_grid[comp_top + i][comp_left + j] = T[i][j].\n5. For all other cells where input value ≠1 and ≠ template colors, copy input to output unchanged (0 or >1 remain same).",
    "03560426": "1. Let values = the set of non-zero integers present in the input grid. 2. For each v in values, compute its bounding box: r0_v = minimum row of v, c0_v = minimum column of v, r1_v = maximum row of v, c1_v = maximum column of v; let H_v = r1_v - r0_v + 1, W_v = c1_v - c0_v + 1. 3. Sort the values into a list shapes[1..n] in ascending order of their c0_v (if tied, by ascending r0_v). 4. Initialize an output grid of the same dimensions filled with 0. 5. For i from 1 to n, do:   a. Let v = shapes[i], and let (r0,c0,r1,c1,H,W) = (r0_v,c0_v,r1_v,c1_v,H_v,W_v).   b. If i < n, define removal_cell = (r1,c1); otherwise removal_cell = none.   c. If i == 1, set new_tl_row[1] = 0 and new_tl_col[1] = 0; else set new_tl_row[i] = new_tl_row[i-1] + H_{shapes[i-1]} - 1 and new_tl_col[i] = new_tl_col[i-1] + W_{shapes[i-1]} - 1.   d. For each cell (r,c) in the input grid with value = v:      i. If (r,c) == removal_cell, skip it.     ii. Compute dr = r - r0 and dc = c - c0.    iii. Set output[new_tl_row[i] + dr, new_tl_col[i] + dc] = v. 6. Return the output grid.",
    "67b4a34d": "1. Let H and W be the height and width of the input grid.\n2. Identify all cells (r,c) with value 3. Compute min_r = minimum r, max_r = maximum r, min_c = minimum c, max_c = maximum c among these cells. Verify that max_r-min_r+1 = 4 and max_c-min_c+1 = 4.\n3. Initialize a 4×4 output array OUT.\n4. For i from 0 to 3 and j from 0 to 3:\n   a. Let r = min_r + i, c = min_c + j.\n   b. For each candidate reflection (r1,c1) in the sequence:\n      i. (r, W-1-c)  // vertical mirror\n      ii. (H-1-r, c)  // horizontal mirror\n      iii. (H-1-r, W-1-c)  // both axes\n      If grid[r1][c1] ≠ 3 then set OUT[i][j] = grid[r1][c1] and break out of the reflection loop.\n5. Return OUT as the 4×4 result grid.",
    "9b365c51": "1. Let H = number of rows, W = number of columns. 2. Identify bar columns: for each column C in [0..W−1], if every row R in [0..H−1] has grid[R][C] = k > 0 and the same k for all R, then record (C, k) as a bar. 3. Sort the list of bars by their column index C in ascending order to obtain bar_colors = [k₁, k₂, …]. 4. Find all connected components of cells with value 8 using 4-connectivity. For each component i, compute its minimum column minC[i]. 5. Sort the components by minC ascending to obtain component order [comp₁, comp₂, …]. 6. For each index i from 1 to N (number of bars and components): for every cell (R, C) in compᵢ, set grid[R][C] = bar_colors[i]. 7. For each recorded bar column C (from step 2), for each row R, set grid[R][C] = 0. 8. (Optional) For any remaining cell with value 8, set it to 0. 9. Return the modified grid.",
    "fb791726": "1. Let h_in be the number of rows and w_in be the number of columns of the input grid.\n2. Create an output grid of size (2 * h_in) rows and (2 * w_in) columns, initializing all cells to 0.\n3. For each non-zero value v present in the input:\n   a. For each column index c from 0 to w_in - 1:\n      i. Let P = sorted list of row indices r where input[r][c] == v.\n      ii. If P has exactly two elements r0 and r1 (with r0 < r1), then:\n          1. Copy the two pixels to the top-left quadrant:\n             - Set output[r0][c] = v and output[r1][c] = v.\n          2. Copy the two pixels to the bottom-right quadrant:\n             - Set output[r0 + h_in][c + w_in] = v and output[r1 + h_in][c + w_in] = v.\n          3. Compute r_mid = (r0 + r1) / 2 (integer division, guaranteed integer).\n          4. Draw a horizontal line of color 3 across the entire output at row r_mid:\n             - For x from 0 to (2 * w_in - 1), set output[r_mid][x] = 3.\n          5. Draw a horizontal line of color 3 across the entire output at row (r_mid + h_in):\n             - For x from 0 to (2 * w_in - 1), set output[r_mid + h_in][x] = 3.\n4. After processing all values and columns, return the output grid.",
    "05a7bcf2": "1. Identify all connected components of pixels with value 4 (yellow) in the input. For each component, compute:   • min_row = minimum row index of its pixels   • max_row = maximum row index   • min_col = minimum column index   • max_col = maximum column index\n2. Identify the long straight line of pixels with value 8 (blue). Determine if it lies entirely on a single row (horizontal) or a single column (vertical). Let line_index = that row or column index, and note orientation = “horizontal” or “vertical”.\n3. For each 4–component, perform the following steps in order:\n   a. Replace every pixel (r,c) in the component with value 3 (green).\n   b. Determine stripe direction:\n      • If orientation = horizontal:\n         – If max_row < line_index, set direction = down;\n         – Else (min_row > line_index), set direction = up.\n      • If orientation = vertical:\n         – If max_col < line_index, set direction = right;\n         – Else (min_col > line_index), set direction = left.\n   c. Draw a yellow stripe (value 4) connecting the component to the line:\n      • If orientation = horizontal:\n         – For each column c from min_col to max_col:\n            · If direction = down, for r from max_row+1 to line_index-1, set cell (r,c)=4;\n            · If direction = up, for r from min_row-1 down to line_index+1, set cell (r,c)=4.\n      • If orientation = vertical:\n         – For each row r from min_row to max_row:\n            · If direction = right, for c from max_col+1 to line_index-1, set cell (r,c)=4;\n            · If direction = left, for c from min_col-1 down to line_index+1, set cell (r,c)=4.\n   d. Continue the stripe beyond the line to the grid edge with blue (value 8):\n      • If orientation = horizontal:\n         – For each column c from min_col to max_col:\n            · If direction = down, for r from line_index+1 to last_row, set (r,c)=8;\n            · If direction = up, for r from line_index-1 down to 0, set (r,c)=8.\n      • If orientation = vertical:\n         – For each row r from min_row to max_row:\n            · If direction = right, for c from line_index+1 to last_col, set (r,c)=8;\n            · If direction = left, for c from line_index-1 down to 0, set (r,c)=8.\n4. Do not modify any other pixels; leave all existing 0, 2, and the input 8–line pixels unchanged except where overwritten by the above steps.",
    "67c52801": "1. Let H be the number of rows and W be the number of columns of the input grid.  Index rows r from 0 (top) to H-1 (bottom) and columns c from 0 (left) to W-1 (right).\n2. Set base_row = H-1.  Let base_color = input[base_row][0].  (All cells in row base_row are equal to base_color.)\n3. Set slot_row = base_row - 1.\n4. Identify all contiguous horizontal segments of zeros in row slot_row.  Scan c from 0 to W-1.  Whenever input[slot_row][c] == 0, record start_col = c and increment c until input[slot_row][c] != 0 or c == W.  Let segment.length = c - start_col.  Store each segment as (start_col, length).\n5. Find all connected components (“shapes”) of cells with value ≠ 0 and ≠ base_color in rows r ∈ [0, slot_row-1].  Use 4-connected adjacency.  Each shape has a uniform color ≠ base_color.  There will be exactly one shape per segment.\n6. For each shape:\n   a. Compute its minimal bounding box: min_r, max_r, min_c, max_c over its cells.\n   b. Let shape.height = max_r - min_r + 1, shape.width = max_c - min_c + 1, and shape.color = the cell value.\n   c. Extract shape.pattern as an array of size [shape.height][shape.width], where pattern[i][j] = shape.color if input[min_r + i][min_c + j] == shape.color, else 0.\n7. Assign each shape to exactly one segment so that for each (shape, segment): either shape.width == segment.length or shape.height == segment.length.  (Assignment is unique since counts match.)\n8. Initialize the output grid as all zeros of size H×W.\n9. Copy input rows slot_row and base_row into the output grid: for each r in {slot_row, base_row} and each c in 0..W-1, set output[r][c] = input[r][c].\n10. For each assigned (shape, segment):\n    a. If shape.width == segment.length, keep orientation; else (shape.height == segment.length) rotate shape.pattern 90° clockwise so that new width = original height and new height = original width.\n    b. Let Hs = shape.height after any rotation, Ws = shape.width after any rotation.\n    c. Compute top_row = base_row - Hs.\n    d. Compute left_col = segment.start_col.\n    e. For i in 0..Hs-1 and j in 0..Ws-1: if shape.pattern[i][j] != 0 then set output[top_row + i][left_col + j] = shape.color.\n11. Return the output grid.",
    "9b4c17c4": "1. Let H be the number of rows and W the number of columns in the input grid.\n2. Find all 4-connected components of cells with value 2 (the “red” shapes). Call each component C.\n3. Create the output grid as a copy of the input grid.\n4. For each component C:\n   a. Choose any cell (r,c) in C. Examine its up/down/left/right neighbors in the input to find one with value B, where B is either 1 or 8. That B is the background color of C.\n   b. Set dir = +1 if B == 1; set dir = -1 if B == 8.\n   c. For each cell (r,c) in C, compute how many columns it can move in direction dir through “free” cells: free cells are those whose input value is B or that belong to C itself. Formally, for each (r,c) find the largest k ≥ 0 such that for all j from 1 to k, the position (r, c + dir*j) is within [0..W-1] and (input[r][c + dir*j] == B or (r, c + dir*j) ∈ C). Call this count_i. Then let d = min(count_i) over all (r,c) in C.\n   d. In the output grid, erase C’s original cells by setting output[r][c] = B for each (r,c) in C.\n   e. In the output grid, draw C at its shifted location: for each (r,c) in C, set output[r][c + dir*d] = 2.\n5. Leave all other cells unchanged and return the output grid.",
    "fc754716": "1. Let R be the number of rows and C be the number of columns in the input grid.\n2. Compute the center row index cr = floor(R/2) and the center column index cc = floor(C/2).\n3. Read the value center_color = grid[cr][cc].\n4. For each cell at row r from 0 to R-1 and column c from 0 to C-1:\n   a. If r == 0 or r == R-1 or c == 0 or c == C-1, set grid[r][c] = center_color.\n   b. Otherwise, set grid[r][c] = 0.\n5. Return the modified grid.",
    "0607ce86": "1. Let H and W be the number of rows and columns of the input grid.\n2. Identify all row indices R_sep where every cell in that row equals 0. Sort R_sep in ascending order. Add R_sep_start = -1 at start and R_sep_end = H at end.\n3. Build a list RowGroups of contiguous nonzero-row intervals: for each consecutive pair (r0, r1) in R_sep_start, R_sep..., R_sep_end, let interval be rows [r0+1 .. r1-1]; include it if r1 - r0 > 1.\n4. Identify all column indices C_sep where every cell in that column equals 0. Sort C_sep in ascending order. Add C_sep_start = -1 at start and C_sep_end = W at end.\n5. Build a list ColGroups of contiguous nonzero-column intervals: for each consecutive pair (c0, c1) in C_sep_start, C_sep..., C_sep_end, let interval be columns [c0+1 .. c1-1]; include it if c1 - c0 > 1.\n6. For each pair (rg, cg) in RowGroups × ColGroups, extract the subgrid Block[rg,cg] consisting of rows in rg and columns in cg. Collect all such Blocks into a list Blocks.\n7. Compare Blocks for exact equality (same dimensions and same values). Count frequency of each unique block pattern. Let CanonicalBlock be the pattern with the highest count.\n8. Create an output grid of size H×W filled entirely with 0s.\n9. For each (rg, cg) in RowGroups × ColGroups, copy CanonicalBlock into the output grid at the same row and column positions: for each offset i in 0..height-1 and j in 0..width-1, set output[rg.start+i][cg.start+j] = CanonicalBlock[i][j].\n10. Return the output grid.",
    "68b67ca3": "1. Let G be the input grid of integers with dimensions 6 rows and 6 columns, using zero to represent empty (black) and 1–9 for other colors.\n2. Compute R, the sorted list of all row indices r (0 ≤ r ≤ 5) such that there exists at least one column c where G[r][c] ≠ 0. (R will contain exactly three indices.)\n3. Compute C, the sorted list of all column indices c (0 ≤ c ≤ 5) such that there exists at least one row r where G[r][c] ≠ 0. (C will contain exactly three indices.)\n4. Initialize an output grid O with dimensions 3 rows by 3 columns, filled with zeros.\n5. For each i from 0 to 2 and each j from 0 to 2, set O[i][j] = G[R[i]][C[j]].\n6. Return O as the transformed 3×3 grid.",
    "9bebae7a": "1. Locate all grid cells with value 4 (yellow); record their coordinates in a set Y.  \n2. Locate all grid cells with value 6 (pink); record their coordinates in a set P.  \n3. Compute the bounding box of Y:  \n   a. y_min = minimum row index among Y.  \n   b. y_max = maximum row index among Y.  \n   c. x_min = minimum column index among Y.  \n   d. x_max = maximum column index among Y.  \n4. Determine pink shape type:  \n   For each (r,c) in P, count its pink neighbors in the four cardinal directions.  \n   If any pink cell has 4 pink neighbors, classify P as a cross.  \n   Otherwise classify P as a T.  \n5. If P is a cross:  \n   a. Compute horizontal mirror axis: axis_r = y_max + 0.5.  \n   b. For each (r,c) in Y, compute r' = floor(2*axis_r - r) and c' = c.  \n   c. Add (r',c') to the grid with value 4.  \n6. If P is a T:  \n   a. Identify the bar row of P: the row index rb that contains exactly 3 cells of P.  \n   b. If rb == minimum row index of P, set direction = right; else if rb == maximum row index of P, set direction = left.  \n   c. If direction == right, set axis_x = x_max + 0.5; if direction == left, set axis_x = x_min - 0.5.  \n   d. For each (r,c) in Y, compute c' = floor(2*axis_x - c) and r' = r.  \n   e. Add (r',c') to the grid with value 4.  \n7. Remove all pink cells: for each (r,c) in P set the grid cell to 0.  \n8. Leave all original yellow cells in place.  \n9. Return the modified grid.",
    "fd096ab6": "1. Let G be the input grid of size R×C, indexed 0≤r<R, 0≤c<C. 2. Identify the reference shape: collect all coordinates of color 4 (yellow) in G into set P_abs = {(r,c) | G[r][c]==4}. 3. Compute the reference origin: min_r = min{r | (r,c)∈P_abs}, min_c = min{c | (r,c)∈P_abs}. 4. Compute the reference pattern offsets P = {(dr,dc) | (dr,dc) = (r−min_r, c−min_c) for each (r,c)∈P_abs}. 5. For each color x≠1 and x≠4 present in G:  5.1. Let Cx = {(r,c) | G[r][c]==x}.  5.2. Find a translation (Δr,Δc) such that Cx ⊆ {(min_r+dr+Δr, min_c+dc+Δc) | (dr,dc)∈P}.  Equivalently, choose any (r0,c0)∈Cx and any (dr0,dc0)∈P, compute candidate Δr = r0−(min_r+dr0), Δc = c0−(min_c+dc0), then verify that for every (r,c)∈Cx there exists (dr,dc)∈P with r = min_r+dr+Δr and c = min_c+dc+Δc.  5.3. Fix the unique (Δr,Δc) that satisfies this containment. 6. For each x≠1,4 and its translation (Δr,Δc), for every offset (dr,dc)∈P compute target (r',c')=(min_r+dr+Δr, min_c+dc+Δc) and set G[r'][c']=x. 7. Return the completed grid G.",
    "0692e18c": "1. Read the 3×3 input grid G. 2. Let background = 0. Let foreground be the single non-zero value present in G. 3. Build a 3×3 inverted pattern P: for each r in 0..2 and c in 0..2, if G[r][c]==foreground then set P[r][c]=background; else set P[r][c]=foreground. 4. Create a 9×9 output grid O and fill every cell with background. 5. For each input cell at (i,j) with i,j in 0..2: if G[i][j]==foreground then copy P into the 3×3 block of O with top-left corner at (i*3, j*3): for each p,q in 0..2 set O[i*3+p][j*3+q]=P[p][q]. 6. Return O.",
    "692cd3b6": "1. Define a magnet as a 3×3 block containing exactly one cell of value 5 at its center, eight cells of value 2 on its perimeter, and exactly one of those eight perimeter cells equal to 0 (the opening).\n2. Traverse the grid to locate all cells C with value 5 that satisfy the magnet pattern. There will be exactly two such centers, C₁ and C₂. For each center C = (r, c):\n   a. Examine its four orthogonal neighbors N = (r-1, c), S = (r+1, c), W = (r, c-1), E = (r, c+1). One of them has value 0; call that the opening O = (ro, co).\n   b. Compute a direction vector D = O – C. That vector is one of (–1, 0), (1, 0), (0, –1), (0, 1).\n   c. Compute the tail endpoint E = O + D = (ro + Dr, co + Dc).\n3. Let E₁ and E₂ be the two tail endpoints. Compute rmin = min(E₁.r, E₂.r), rmax = max(E₁.r, E₂.r), cmin = min(E₁.c, E₂.c), cmax = max(E₁.c, E₂.c).\n4. For every cell (r, c) with rmin ≤ r ≤ rmax and cmin ≤ c ≤ cmax:\n   if the original grid at (r, c) == 0, set grid[r][c] = 4.\n5. Leave all nonzero cells unchanged.\n\nResult: All zeros in the axis-aligned rectangle between the two tail endpoints become 4, connecting the two magnet openings by a yellow corridor.",
    "9c1e755f": "1. Identify all maximal straight segments of value 5 (grey) that form bars:\n   a. A horizontal bar is a contiguous run of two or more 5s in the same row, with no adjacent 5 above or below.\n   b. A vertical bar is a contiguous run of two or more 5s in the same column, with no adjacent 5 to the left or right.\n2. For each horizontal bar spanning row R and columns C1 through C2:\n   a. Find block_col: the unique column j in [C1..C2] such that grid[R+1][j] ≠ 0.\n   b. Build pattern_rows:\n      i. Initialize an empty list.\n      ii. For d from 1 upward, if grid[R+d][block_col] ≠ 0, append R+d; else stop. Let K = length of pattern_rows.\n   c. Extract pattern P of length K: for i in 0..K-1, P[i] = grid[pattern_rows[i]][block_col].\n   d. For each i in 0..K-1 and each j in C1..C2, set grid[R+1+i][j] = P[i].\n3. For each vertical bar spanning column C and rows R1 through R2:\n   a. Build pattern_rows: the sorted list of all r in [R1..R2] for which grid[r][C+1] ≠ 0. These r are contiguous; let K = length of pattern_rows.\n   b. Let r0 = pattern_rows[0]. Determine W: the maximum t≥1 such that for all u in 1..t, grid[r0][C+u] ≠ 0.\n   c. Extract pattern matrix P of size K×W: for i in 0..K-1 and t in 0..W-1, P[i][t] = grid[pattern_rows[i]][C+1+t].\n   d. For each r in R1..R2, compute i = (r – pattern_rows[0]) mod K; then for each t in 0..W-1 set grid[r][C+1+t] = P[i][t].\n4. Return the modified grid.",
    "fd4b2b02": "1. Identify the input block:\n   1.1. Scan the grid for non-zero cells; let color0 be their value (either 3 or 6).\n   1.2. Compute r0 = minimum row of those cells, r1 = maximum row, c0 = minimum column, c1 = maximum column.\n   1.3. Compute h = r1 – r0 + 1 and w = c1 – c0 + 1.\n2. Define the alternate color:\n   2.1. If color0 = 3 then color1 = 6, else color1 = 3.\n3. Precompute segment sizes and colors by layer:\n   For k = 0,1,2,... until no placement fits:\n   3.1. If k is even: seg_color[k] = color0; seg_height[k] = (k==0 ? h : w); seg_width[k] = (k==0 ? w : h).\n   3.2. If k is odd:  seg_color[k] = color1; seg_height[k] = w; seg_width[k] = h.\n4. Place layer k=0:\n   4.1. Fill all cells in rows r0..r1 and cols c0..c1 with seg_color[0].\n5. For each subsequent layer k=1,2,...:\n   5.1. For each of the four diagonal directions dir in {(-1,-1),(−1,+1),(+1,−1),(+1,+1)}:\n     a. Let (px,py) be the corner of layer k-1 in that direction:\n        • If dir = (−1,−1), px = r0, py = c0.\n        • If dir = (−1,+1), px = r0, py = c1.\n        • If dir = (+1,−1), px = r1, py = c0.\n        • If dir = (+1,+1), px = r1, py = c1.\n     b. Let H = seg_height[k], W = seg_width[k], C = seg_color[k].\n     c. Compute row_end = (dir_row = dir.0) < 0 ? px : px + (H − 1);\n        row_start = row_end − (H − 1).\n     d. Compute col_end = (dir_col = dir.1) < 0 ? py : py + (W − 1);\n        col_start = col_end − (W − 1).\n     e. If row_start < 0 or col_start < 0 or row_end ≥ num_rows or col_end ≥ num_cols, then STOP all further layers.\n     f. Fill all cells in rows row_start..row_end and cols col_start..col_end with color C.\n   5.2. Update r0 = minimum over all filled rows in this layer, r1 = maximum row, c0 = minimum col, c1 = maximum col (for next layer anchoring).\n6. End when layer k cannot be placed for any dir. The grid now contains an X of alternating-color segments.",
    "070dd51e": "1. Let H be the number of rows and W be the number of columns in the input grid. Index rows by r∈[0,H−1] and columns by c∈[0,W−1].\n2. Initialize an empty map PixelCoords.\n3. For each cell (r,c):\n   a. If grid[r][c]≠0, append coordinate (r,c) to PixelCoords[grid[r][c]].\n4. For each color value k in PixelCoords:\n   a. Let [(r1,c1),(r2,c2)] be the two coordinates in PixelCoords[k], sorted so that r1<r2 or (r1=r2 and c1<c2).\n   b. Store for k: r1_k=r1, c1_k=c1, r2_k=r2, c2_k=c2.\n5. For each color k in ascending order:\n   a. For col from min(c1_k,c2_k) to max(c1_k,c2_k), inclusive, set grid[r1_k][col]=k.\n6. For each color k in ascending order:\n   a. For row from min(r1_k,r2_k) to max(r1_k,r2_k), inclusive, set grid[row][c2_k]=k.\n7. Return the modified grid as the output.\n\nNote: Drawing horizontals in step 5 before drawing verticals in step 6 ensures that any vertical segment overwrites horizontal segments at their intersections.",
    "695367ec": "1. Let input_grid be the given grid of size m×m. 2. Let v be the integer value at input_grid[0][0]. 3. Set N = 15 and period = m + 1. 4. Create an empty output_grid of size N×N. 5. For each row index r from 0 to N-1:   a. For each column index c from 0 to N-1:      i. If (r mod period == m) OR (c mod period == m), then set output_grid[r][c] = v.     ii. Otherwise set output_grid[r][c] = 0. 6. Return output_grid.",
    "9c56f360": "1. Let H be the number of rows and W be the number of columns of the input grid, with rows indexed 0…H-1 and columns indexed 0…W-1.  Values: 0=black, 8=blue, 3=green.\n2. For each row r from 0 to H-1:\n   a. Collect the list G of all column indices c where grid[r][c] == 3.\n   b. If G is empty, continue to the next row.\n   c. Let first_green = minimum value in G, and k = size of G.\n   d. Collect the list B of all column indices c where grid[r][c] == 8 and c < first_green.\n   e. If B is non-empty, let max_blue_left = maximum value in B; otherwise set max_blue_left = -1.\n   f. Compute target_start = max_blue_left + 1.\n   g. For each c in G, set grid[r][c] = 0.\n   h. For i from 0 to k-1, set grid[r][target_start + i] = 3.\n3. Return the modified grid as the output.",
    "fe9372f3": "1. Let H = number of rows, W = number of columns.  Use 0-based indexing for rows (0…H–1) and columns (0…W–1).\n2. Locate the center of the red cross: find the unique cell (r0,c0) with grid value 2 whose four orthogonal neighbors (r0-1,c0), (r0+1,c0), (r0,c0-1), (r0,c0+1) also all equal 2.\n3. Preserve all original nonzero cells (value 2) in the output; initialize all other cells to 0.\n4. Draw diagonal arms in dark blue (value 1):\n   For each direction (dr,dc) in {(-1,-1),(-1,1),(1,-1),(1,1)}:\n     a. For step d = 1,2,…:\n        i. Compute (r,c) = (r0 + d·dr, c0 + d·dc).\n       ii. If (r,c) is outside the grid, break the loop for this direction.\n      iii. Set output[r][c] = 1.\n5. Draw horizontal and vertical arms with repeating light-blue/yellow pattern {8,8,4}:\n   For each direction (dr,dc) in {(-1,0),(1,0),(0,-1),(0,1)}:\n     a. For step d = 2,3,…:\n        i. Compute (r,c) = (r0 + d·dr, c0 + d·dc).\n       ii. If (r,c) is outside the grid, break the loop for this direction.\n      iii. Let k = (d - 2) mod 3.\n       iv. If k < 2, set output[r][c] = 8; else set output[r][c] = 4.\n6. Leave all other cells at their initialized value (0).",
    "08573cc6": "1. Let m = number of rows, n = number of columns.\n2. Locate the origin cell (r0,c0) where grid[r0][c0] == 1.\n3. Read two spiral colors: A = grid[0][0], B = grid[0][1].\n4. Initialize an output grid of size m×n filled with 0.\n5. Set output[r0][c0] = 1.\n6. Set current position (r,c) = (r0,c0).\n7. Define an ordered list of direction vectors: D0 = (0,–1)   // left\n                                 D1 = (1,0)    // down\n                                 D2 = (0,1)    // right\n                                 D3 = (–1,0)   // up\n8. Initialize segment index s = 1.\n9. Repeat:\n   a. Let dir = D[(s–1) mod 4].\n   b. Let length = s + 1.\n   c. Let color = A if s is odd, else B.\n   d. For i from 1 to length:\n        i.   Compute nr = r + dir.row, nc = c + dir.col.\n        ii.  If (nr,nc) lies within [0..m–1]×[0..n–1]:\n                 set output[nr][nc] = color;\n                 update (r,c) = (nr,nc);\n             Else:\n                 Terminate all loops and finish.\n   e. Increment s by 1.\n10. Return the output grid.",
    "696d4842": "1. Identify all colors present in the grid and classify pixels by color value.\n2. Locate all single‐pixel dots: any color C_dot whose pixels count = 1. Record each dot coordinate D.\n3. Locate all multi‐pixel shapes: any contiguous component of nonzero pixels of color C_shape where component size > 1. Record each shape’s cell set S.\n4. For each dot D of color C_dot and each shape S of color C_shape (C_shape ≠ C_dot):\n   a. Find candidate pivot cells P in S such that P shares either row or column with D, and every cell on the straight line between P and D (exclusive) has value 0.\n   b. If no such P, skip this shape/dot pair.\n   c. Choose the pivot P among candidates that minimizes ManhattanDistance(P, D).\n   d. Determine path direction: if P.row = D.row, path is horizontal along row = r = P.row; else path is vertical along col = c = P.col.\n   e. Collect PathCells = all zero‐valued cells strictly between P and D along that row or column.\n   f. Let L = number of cells in PathCells.\n   g. For each cell in PathCells, set its value to C_shape.\n   h. Define BranchCells = all cells in S that are not on the line of the path through P:\n      - If path is horizontal, BranchCells = {s∈S | s.row ≠ P.row}.\n      - If path is vertical,   BranchCells = {s∈S | s.col ≠ P.col}.\n   i. Compute distance for each b∈BranchCells as ManhattanDistance(b, P).\n   j. Sort BranchCells by descending distance from P.\n   k. Take the first L cells in that sorted list; for each, set its value to C_dot.\n5. Leave all other pixels unchanged.",
    "9caba7c3": "1. Let R be the number of rows and C the number of columns of the input grid G. 2. Initialize output grid O as a copy of G. 3. Identify all unordered pairs of red pixels (value 2) at positions (r1,c1) and (r2,c2) satisfying |r1–r2| = 1 and |c1–c2| = 1. Call each such pair a diagonal red pair. 4. For each diagonal red pair:  4.1 Compute r_lo = min(r1,r2), r_hi = max(r1,r2), c_lo = min(c1,c2), c_hi = max(c1,c2).  4.2 Define two candidate yellow‐center positions:  A = (r_lo,c_hi)  B = (r_hi,c_lo)  4.3 For X in [A,B] in that order:    a. Let (RC,CC) = X.    b. If RC–1 < 0 or RC+1 ≥ R or CC–1 < 0 or CC+1 ≥ C, continue to next candidate.    c. If for every (r,c) with RC–1 ≤ r ≤ RC+1 and CC–1 ≤ c ≤ CC+1, G[r][c] is either grey (5) or red (2), then select X as the center and break out of the candidate loop.  4.4 If no candidate was selected, skip this pair and continue to next.  4.5 Otherwise, with selected center (RC,CC), overlay a 3×3 block in O covering rows RC–1 through RC+1 and columns CC–1 through CC+1:    – For (r,c) == (RC,CC): set O[r][c] = 4 (yellow).    – Else if G[r][c] == 2: set O[r][c] = 2 (leave red).    – Else if G[r][c] == 5: set O[r][c] = 7 (orange).    – Else leave O[r][c] unchanged. 5. Return O.",
    "fea12743": "1. Partition the grid into six 4×4 subgrids (“blocks”) with top‐left corners at (1+5⋅r, 1+5⋅c) for r=0,1,2 and c=0,1. 2. For each block i, record P_i := { (dx,dy) ∈ {0…3}² ∣ grid[r_i+dx][c_i+dy]==2 }. 3. Identify the block G for which |P_G| is maximal. If multiple tie, select the one with greatest r_i, then greatest c_i. 4. In the output grid, set every cell of block G that was 2 to value 3. 5. For each unordered pair of distinct blocks (i,j)≠G, compute U := P_i ∪ P_j. If U equals P_G, then in the output set every cell of blocks i and j that was 2 to value 8, and stop. 6. Leave all other cells unchanged.",
    "0934a4d8": "1. Let R be the number of rows and C be the number of columns in the input grid.\n2. Let mask_value = 8.\n3. Collect all coordinates (r,c) such that grid[r][c] == mask_value.\n4. Compute r0 = minimum r, r1 = maximum r, c0 = minimum c, c1 = maximum c among those coordinates.  Let h = r1 - r0 + 1 and w = c1 - c0 + 1.\n5. Create an empty output grid O of size h rows and w columns.\n6. For each i from 0 to h−1 and each j from 0 to w−1, do:\n   a. Let r = r0 + i and c = c0 + j.\n   b. Define three reflection positions:\n      • (rA, cA) = (r, C−1−c)   // vertical mirror\n      • (rB, cB) = (R−1−r, c)   // horizontal mirror\n      • (rC, cC) = (R−1−r, C−1−c) // both axes\n   c. Retrieve values vA = grid[rA][cA], vB = grid[rB][cB], vC = grid[rC][cC].\n   d. Form a list V = [vA, vB, vC] and remove any entries equal to mask_value.\n   e. Determine the value v in V that appears at least twice (the mode).  Assign O[i][j] = v.\n7. Return O as the result grid.",
    "69889d6e": "1. Scan the input grid to find:   \n   - The seed position S = (r0, c0), the single cell whose value is 2.   \n   - The set of obstacle positions O = {(r, c) | grid[r][c] == 1}.   \n   - Let M = number of rows, N = number of columns.\n2. Initialize an integer variable shift = 0.\n3. For each step index i = 1, 2, 3, … do:\n   a. Compute target_row = r0 - i.\n      - If target_row < 0, terminate the loop.\n   b. Compute base_col = c0 + (i - 1) + shift.\n   c. Resolve collisions with obstacles on the left edge of the 2-block segment:\n      - While (target_row, base_col) ∈ O, do shift = shift + 1 and base_col = base_col + 1.\n   d. Define two target cells:\n      - P1 = (target_row, base_col)\n      - P2 = (target_row, base_col + 1)\n   e. If P1 is out of bounds (base_col < 0 or base_col ≥ N), terminate the loop.\n   f. If P2 is out of bounds (base_col + 1 ≥ N) or P2 ∈ O:\n      - Set grid[P1] = 2.\n      - Terminate the loop.\n   g. Otherwise (both P1 and P2 are within [0..M-1]×[0..N-1] and neither is in O):\n      - Set grid[P1] = 2 and grid[P2] = 2.\n      - Continue to the next iteration (i = i + 1).\n4. Preserve all original nonzero cells (values 1 or 2) and only write new 2s as above.  \n5. Return the modified grid as the output.",
    "9ddd00f0": "1. Let H = number of rows in the input grid, W = number of columns.\n2. Find all indices r where row r is entirely 0. Call this sorted list dividerRows.\n3. Find all indices c where column c is entirely 0. Call this sorted list dividerCols.\n4. Define rowBounds = [-1] + dividerRows + [H] and colBounds = [-1] + dividerCols + [W].\n5. Let R = len(rowBounds)-1 (number of cell‐rows), C = len(colBounds)-1 (number of cell‐cols).\n6. For each cell coordinate (i,j) with 0 ≤ i < R and 0 ≤ j < C:\n   a. Let r0 = rowBounds[i]+1, r1 = rowBounds[i+1]-1; let c0 = colBounds[j]+1, c1 = colBounds[j+1]-1.\n   b. Extract block B[i][j] = grid[r0..r1][c0..c1].\n   c. Mark nonEmpty[i][j] = True if any value in B[i][j] ≠ 0, else False.\n7. For each original cell (i,j) where nonEmpty[i][j] is True, perform three reflections:\n   For each (flipV, flipH) in {(True,False), (False,True), (True,True)} do:\n     a. Compute ti = (R-1 - i) if flipV else i; tj = (C-1 - j) if flipH else j.\n     b. If nonEmpty[ti][tj] is False then:\n        i. Let S = deep copy of B[i][j].\n        ii. If flipH is True, for each row in S reverse the row order (horizontal flip).\n        iii. If flipV is True, reverse the order of rows in S (vertical flip).\n        iv. Write S back into grid[r0'..r1'][c0'..c1'], where r0'=rowBounds[ti]+1, r1'=rowBounds[ti+1]-1, c0'=colBounds[tj]+1, c1'=colBounds[tj+1]-1.\n        v. Set nonEmpty[ti][tj] = True.\n8. Output the modified grid.",
    "ff72ca3e": "1. Identify all yellow pixels (value 4). Let Y = list of their coordinates (r_y, c_y).  \n2. Identify all grey pixels (value 5). Let G = list of their coordinates (r_g, c_g).  \n3. For each yellow pixel (r_y, c_y) in Y, do:  \n   a. Compute the Chebyshev distance to each grey: for each (r_g, c_g) in G compute d = max(|r_y - r_g|, |c_y - c_g|).  \n   b. Let d_min = minimum of these distances.  \n   c. Let radius r = d_min - 1.  \n   d. For every grid coordinate (r, c) satisfying max(|r - r_y|, |c - c_y|) ≤ r, if grid[r][c] == 0 then set grid[r][c] = 2.  \n4. Leave all non-zero cells unchanged (do not overwrite any 4 or 5).  \n5. Return the modified grid.",
    "09c534e7": "1. Let H and W be the number of rows and columns of the input grid, respectively.  \n2. Initialize a boolean array visited[H][W] all false.  \n3. For each cell (r,c) in the grid:  \n   a. If grid[r][c] != 1 and visited[r][c] is false, perform a flood fill (DFS or BFS) to collect a component C:  \n      i. Use 4-connectivity (neighbors up, down, left, right).  \n      ii. Include neighbor (r2,c2) in C if grid[r2][c2] != 1 and not yet visited.  \n      iii. Mark all cells in C as visited.  \n   b. After collecting C, check if any (r2,c2) in C lies on the grid boundary (r2=0, r2=H-1, c2=0, or c2=W-1). If yes, skip C (it is background). Otherwise C is an interior region.  \n4. For each interior region C:  \n   a. Determine fill_color: the unique integer value >1 present in grid at any cell of C.  \n   b. For every cell (r2,c2) in C, set grid[r2][c2] = fill_color.  \n5. Return the modified grid as the output.",
    "6a11f6da": "1. Let the input grid have 15 rows and 5 columns. 2. Define three 5×5 blocks: Block A = rows 0–4, Block B = rows 5–9, Block C = rows 10–14 (row and column indices zero-based). 3. Initialize an empty 5×5 output grid. 4. For each row r from 0 to 4 and each column c from 0 to 4, do in order:   a. If Block C[r][c] == 6, set output[r][c] = 6.   b. Else if Block A[r][c] == 1, set output[r][c] = 1.   c. Else if Block B[r][c] == 8, set output[r][c] = 8.   d. Else set output[r][c] = 0. 5. Return the output grid.",
    "9def23fe": "1. Let H = number of rows, W = number of columns.\n2. For each row index r from 0 to H-1:\n   a. Collect all column indices c where grid[r][c] == 2. If this set is empty, continue to the next row.\n   b. Let leftmost = minimum of these c values, rightmost = maximum of these c values.\n   c. Define a blocker as any cell value v where v ≠ 0 and v ≠ 2.\n   d. Check leftward extension:\n      i. If for every column c in [0 .. leftmost-1], grid[r][c] is either 0 or 2 (i.e., no blocker in that interval), then:\n         - For each column c in [0 .. leftmost-1], if grid[r][c] == 0, set grid[r][c] = 2.\n   e. Check rightward extension:\n      i. If for every column c in [rightmost+1 .. W-1], grid[r][c] is either 0 or 2 (i.e., no blocker in that interval), then:\n         - For each column c in [rightmost+1 .. W-1], if grid[r][c] == 0, set grid[r][c] = 2.\n3. Leave all non-zero values other than 2 unchanged; do not overwrite blocker cells.\n4. Return the modified grid.",
    "0a1d4ef5": "1. Let grid be the input 2D array of size H×W with integer values 0–9.\n2. Initialize an empty list blocks and a H×W boolean array visited set to false.\n3. For each cell (r,c) in grid:\n   a. If grid[r][c] == 0 or visited[r][c] is true, continue.\n   b. Let V = grid[r][c]. Perform a 4‐connected flood fill starting at (r,c) to collect all cells of this component; mark each visited.\n   c. Let S be the number of cells in this component. Compute r_min = minimum row index, r_max = maximum row index, c_min = minimum column index, c_max = maximum column index among the component cells.\n   d. If S == (r_max - r_min + 1) × (c_max - c_min + 1), then this component is a full rectangle. Append (V, r_min, c_min) to blocks.\n4. Extract row_keys as the sorted list of unique r_min values from blocks.\n5. Extract col_keys as the sorted list of unique c_min values from blocks.\n6. Let R = length of row_keys and C = length of col_keys. Create an output array out of size R×C initialized to 0.\n7. For each (V, r_min, c_min) in blocks:\n   a. Let i be the index of r_min in row_keys.\n   b. Let j be the index of c_min in col_keys.\n   c. Set out[i][j] = V.\n8. Return out.",
    "6ad5bdfd": "1. Let H be the number of rows and W the number of columns of the input grid.  \n2. Identify the belt line:  \n   a. If every cell in row 0 has value 2, set belt_orientation=\"top\", belt_index=0, dr=-1, dc=0.  \n   b. Else if every cell in row H-1 has value 2, set belt_orientation=\"bottom\", belt_index=H-1, dr=1, dc=0.  \n   c. Else if every cell in column 0 has value 2, set belt_orientation=\"left\", belt_index=0, dr=0, dc=-1.  \n   d. Else if every cell in column W-1 has value 2, set belt_orientation=\"right\", belt_index=W-1, dr=0, dc=1.  \n3. Using 4-connectivity, find all connected components of cells whose value v is nonzero and not 2.  For each component C, record its list of coordinates coords_C and its color value v_C.  \n4. For each component C, compute its maximum free distance dist_C to the belt:  \n   If dr=1: dist_C = min_{(r,c) in coords_C}(belt_index - r - 1)  \n   If dr=-1: dist_C = min_{(r,c) in coords_C}(r - belt_index - 1)  \n   If dc=1: dist_C = min_{(r,c) in coords_C}(belt_index - c - 1)  \n   If dc=-1: dist_C = min_{(r,c) in coords_C}(c - belt_index - 1)  \n5. Sort all components in ascending order of dist_C (smallest first).  \n6. Make a working copy of the input grid, G.  \n7. For each component C in the sorted list:  \n   a. For each (r,c) in coords_C, set G[r][c] = 0.  \n   b. Let D = dist_C.  For k from D down to 0, do:  \n      i.  For every (r,c) in coords_C, compute r' = r + dr*k and c' = c + dc*k.  \n      ii. If every G[r'][c'] is 0 (and indices r',c' are within grid bounds), choose this k and break.  \n   c. For each (r,c) in coords_C, set G[r+dr*k][c+dc*k] = v_C.  \n8. Return G as the output grid.",
    "9f27f097": "1. Let BG be the value that appears in every cell on the outermost border of the grid.  \n2. Find the minimal rectangle of all cells with value 0. Let its row bounds be r0_min and r0_max, and its column bounds be c0_min and c0_max.  \n3. Find the minimal rectangle of all cells with value neither 0 nor BG. Let its row bounds be r1_min and r1_max, and its column bounds be c1_min and c1_max.  \n4. Compute source height H = r1_max – r1_min + 1 and source width W = c1_max – c1_min + 1.  \n5. For each cell (r, c) in the source rectangle (r1_min ≤ r ≤ r1_max, c1_min ≤ c ≤ c1_max):  \n   a. Compute row offset dr = r – r1_min and column offset dc = c – c1_min.  \n   b. Compute target cell coordinates: r' = r0_min + dr, c' = c0_min + (W – 1 – dc).  \n   c. Set the value at (r', c') to the original value at (r, c).  \n6. Leave all other cells unchanged.  \n7. Return the modified grid.",
    "0a2355a6": "1. Define a component as a 4-connected region of pixels with value 8.  \n2. For each component, compute its bounding box.  3. Within that bounding box, identify all 4-connected regions of pixels with value 0 that do not touch the bounding‐box border (i.e. are completely enclosed by the component).  Call the number of such enclosed zero‐regions the hole_count.  \n4. Determine the new_value for the component by this mapping:  \n   • hole_count = 1 → new_value = 1  \n   • hole_count = 2 → new_value = 3  \n   • hole_count = 3 → new_value = 2  \n   • hole_count = 4 → new_value = 4  \n5. In the output grid, for each pixel of that component, replace 8 with new_value.  \n6. Leave all other pixels (value 0) unchanged.",
    "6df30ad6": "1. Let H and W be the height and width of the input grid. 2. Collect shape_pixels = all coordinates (r,c) such that input[r][c] == 5. 3. Collect candidate_pixels = all coordinates (r,c) such that input[r][c] != 0 and input[r][c] != 5. 4. For each candidate pixel p in candidate_pixels, compute d(p) = min_{s in shape_pixels} [(p.r - s.r)^2 + (p.c - s.c)^2]. 5. Let p_min be any candidate pixel with the smallest d(p). 6. Let fill_color = input[p_min.r][p_min.c]. 7. Initialize an output grid of size H×W with all cells = 0. 8. For each (r,c) in shape_pixels, set output[r][c] = fill_color. 9. Return the output grid.",
    "a04b2602": "1. Initialize the output grid as an exact copy of the input grid.\n2. For each cell (r,c) in the input grid with value 2:\n   a. For each offset dr in {-1, 0, 1}:\n      For each offset dc in {-1, 0, 1}:\n         i. If dr == 0 and dc == 0, skip to the next offset pair.\n         ii. Compute neighbor coordinates nr = r + dr, nc = c + dc.\n         iii. If (nr,nc) lies within the grid bounds AND the input grid at (nr,nc) equals 3, then set the output grid at (nr,nc) to 1.\n3. Leave all other cells in the output grid unchanged.\n4. Return the output grid.",
    "0b17323b": "1. Let H be the number of rows and W the number of columns in the input grid (zero-indexed coordinates from 0 to H-1 and 0 to W-1).\n2. Collect all coordinates (r,c) where the pixel value is 1; call this list L.\n3. Sort L by r ascending (if tie, by c ascending).\n4. Let (r0,c0)=L[0] and (r1,c1)=L[1]; compute dr = r1 - r0 and dc = c1 - c0.\n5. Identify (rl,cl) as the coordinate in L with the largest r (if tie, largest c).\n6. Initialize r = rl and c = cl. Repeat:\n   a. r = r + dr\n   b. c = c + dc\n   c. If r < H and c < W, set the pixel at (r,c) to 2; otherwise stop the loop.\n7. Leave all other pixels unchanged.",
    "6ea4a07e": "1. Let H = number of rows and W = number of columns of the input grid.\n2. Scan all cells to identify the unique non-zero value; call it color_value.\n3. Determine fill_value according to:\n   - If color_value == 3 then fill_value = 1\n   - Else if color_value == 5 then fill_value = 4\n   - Else if color_value == 8 then fill_value = 2\n4. Initialize an output grid of size H×W.\n5. For each row r from 0 to H-1 and each column c from 0 to W-1:\n   a. If input[r][c] == color_value, set output[r][c] = 0\n   b. Else (input[r][c] == 0), set output[r][c] = fill_value\n6. Return the output grid.",
    "a096bf4d": "1. Initialize the output grid as a copy of the input grid.\n2. Define boundary colors as any value not in {0, 2, 5}.\n3. For each row index R from 0 to height–1:\n   a. For each column pair c1 < c2:\n      i. Let C = output[R][c1]. If C equals output[R][c2] and C is a boundary color:\n         - For each column c in c1+1 to c2–1:\n             * If output[R][c] == 2, set output[R][c] = C.\n4. For each column index K from 0 to width–1:\n   a. For each row pair r1 < r2:\n      i. Let C = output[r1][K]. If C equals output[r2][K] and C is a boundary color:\n         - For each row r in r1+1 to r2–1:\n             * If output[r][K] == 2, set output[r][K] = C.\n5. Return the output grid.",
    "0bb8deee": "1. Let H and W be the number of rows and columns of the input grid.\n2. Identify the divider color D: find the unique non-zero value that fills exactly one entire row and exactly one entire column. Let r be the index of that row and c be the index of that column.\n3. Partition the input into four quadrants by row r and column c:\n   • Q1: rows 0 to r-1, columns 0 to c-1\n   • Q2: rows 0 to r-1, columns c+1 to W-1\n   • Q3: rows r+1 to H-1, columns 0 to c-1\n   • Q4: rows r+1 to H-1, columns c+1 to W-1\n4. For each quadrant Qi (i=1..4):\n   a. Let Ci be the unique value in Qi that is non-zero and not equal to D.\n   b. Compute minRow_i and maxRow_i as the smallest and largest row indices in Qi where value = Ci; compute minCol_i and maxCol_i similarly.\n   c. Extract subgrid Si from the input spanning rows minRow_i to maxRow_i and columns minCol_i to maxCol_i (this block is 3×3 including zeros for positions without Ci).\n5. Create an output grid G of size 6×6, initialized to 0.\n6. For each quadrant index i and its subgrid Si:\n   a. Set (rowOffset, colOffset) =\n      • (0,0) for i=1\n      • (0,3) for i=2\n      • (3,0) for i=3\n      • (3,3) for i=4\n   b. For each cell (ri,ci) in Si with value v, set G[rowOffset + (ri - minRow_i)][colOffset + (ci - minCol_i)] = v.\n7. Return G as the 6×6 output grid.",
    "6f473927": "1. Let H = number of rows and W = number of columns of the input grid.\n2. Initialize an empty output grid of size H rows and 2×W columns.\n3. For each row r from 0 to H−1 and each column c from 0 to W−1:\n   a. Set output[r][c] = input[r][c].\n4. For each row r from 0 to H−1 and each column c from 0 to W−1:\n   a. Let original_value = input[r][W−1−c].\n   b. If original_value == 2 then mapped_value = 0; else if original_value == 0 then mapped_value = 8.\n   c. Set output[r][W + c] = mapped_value.\n5. Return the output grid.",
    "a3f84088": "1. Locate the bounding rectangle of the single grey (value 5) square outline: compute min_row = smallest r with grid[r][c]==5, max_row = largest r with grid[r][c]==5; min_col = smallest c with grid[r][c]==5, max_col = largest c with grid[r][c]==5.\n2. Initialize k = 1.\n3. Repeat while (min_row + k) < (max_row - k) AND (min_col + k) < (max_col - k):\n   a. If k is odd, set layer_color = 2; else set layer_color = 5.\n   b. Let top = min_row + k, bottom = max_row - k, left = min_col + k, right = max_col - k.\n   c. For each column c from left to right:\n      i. Set grid[top][c] = layer_color.\n      ii. Set grid[bottom][c] = layer_color.\n   d. For each row r from top to bottom:\n      i. Set grid[r][left] = layer_color.\n      ii. Set grid[r][right] = layer_color.\n   e. Increment k by 1.\n4. Return the modified grid.",
    "0becf7df": "1. Read grid dimensions H (number of rows) and W (number of columns).\n2. Let a = grid[0][0], b = grid[0][1], c = grid[1][0], and d = grid[1][1].\n3. Create an empty grid new_grid of size H by W.\n4. For each row r from 0 to H-1 and each column c from 0 to W-1:\n   4.1. If r ≤ 1 and c ≤ 1, set new_grid[r][c] = grid[r][c].\n   4.2. Otherwise, let v = grid[r][c]:\n      - If v == a, set new_grid[r][c] = b.\n      - Else if v == b, set new_grid[r][c] = a.\n      - Else if v == c, set new_grid[r][c] = d.\n      - Else if v == d, set new_grid[r][c] = c.\n      - Else set new_grid[r][c] = v.\n5. Return new_grid.",
    "7039b2d7": "1. Let grid be the input two-dimensional array of integers, with height H_in rows and width W_in columns.\n2. Compute background_color as the integer value that appears most frequently in grid.\n3. Identify line_color as any integer value ≠ background_color.\n4. Initialize vertical_lines = 0.\n5. For each column C from 0 to W_in−1:\n   a. If for every row R from 0 to H_in−1, grid[R][C] == line_color, then increment vertical_lines by 1.\n6. Initialize horizontal_lines = 0.\n7. For each row R from 0 to H_in−1:\n   a. If for every column C from 0 to W_in−1, grid[R][C] == line_color, then increment horizontal_lines by 1.\n8. Set output_width = vertical_lines + 1.\n9. Set output_height = horizontal_lines + 1.\n10. Construct an output grid of size output_height rows × output_width columns.\n11. Fill every cell of the output grid with background_color.\n12. Return the output grid.",
    "a406ac07": "1. Let H be the number of rows and W be the number of columns in the grid.\n2. Define the Y-axis as the cells in column x = Wâ1 for rows y in [0, Hâ2]. Define the X-axis as the cells in row y = Hâ1 for columns x in [0, Wâ2].\n3. Identify the set of colors C_set = all nonzero values appearing on the Y-axis and also appearing on the X-axis.\n4. For each color C in C_set:\n   a. Collect row indices R_C = { y | 0 â¤ y â¤ Hâ2 and grid[y][Wâ1] == C }.\n   b. Let r_min = minimum of R_C and r_max = maximum of R_C.\n   c. Collect column indices X_C = { x | 0 â¤ x â¤ Wâ2 and grid[Hâ1][x] == C }.\n   d. Let c_min = minimum of X_C and c_max = maximum of X_C.\n   e. For every row y in [r_min, r_max] and every column x in [c_min, c_max], set grid[y][x] = C.\n5. Leave all other cells (including the axes at row Hâ1 and column Wâ1) unchanged.",
    "0c786b71": "1. Let I be the input grid with H rows and W columns (in all examples H=3, W=4).\n2. Create an empty output grid O with 2H rows and 2W columns (here 6×8).\n3. For each input cell at row r (0 ≤ r < H) and column c (0 ≤ c < W), let v = I[r,c], then place v into four positions in O:\n   a. Lower-right quadrant (no flip): set O[r + H, c + W] = v.\n   b. Lower-left quadrant (horizontal flip): set O[r + H, (W - 1 - c)] = v.\n   c. Upper-right quadrant (vertical flip): set O[(H - 1 - r), c + W] = v.\n   d. Upper-left quadrant (both axes flip): set O[(H - 1 - r), (W - 1 - c)] = v.\n4. Return O.",
    "705a3229": "1. Let H = number of rows in input grid, W = number of columns.\n2. Initialize output grid as a copy of the input grid.\n3. For each cell (r,c) in the input grid where input[r][c] = v > 0 do:\n   3.1 Compute vertical distances: dist_up = r, dist_down = (H - 1 - r).\n   3.2 If dist_up <= dist_down then set vr0 = 0 and vr1 = r; otherwise set vr0 = r and vr1 = H - 1.\n   3.3 Compute horizontal distances: dist_left = c, dist_right = (W - 1 - c).\n   3.4 If dist_left <= dist_right then set vc0 = 0 and vc1 = c; otherwise set vc0 = c and vc1 = W - 1.\n   3.5 For each row i from vr0 to vr1 (inclusive), set output[i][c] = v.\n   3.6 For each column j from vc0 to vc1 (inclusive), set output[r][j] = v.\n4. Return the output grid.",
    "a57f2f04": "1. Identify the background value B as the integer filling the outer border of the grid (in all examples B=8).\n2. Find all connected regions R of cells with value != B, using 4-adjacency. Treat each region independently.\n3. For each region R:\n   a. Let (r_min, c_min) = the minimum row and minimum column indices of all cells in R.\n   b. Let P = the set of all cells (i,j) in R whose value is not 0.\n   c. Compute (p_rmin, p_cmin) = the minimum row and column of P, and (p_rmax, p_cmax) = the maximum row and column of P.\n   d. Define template height h = p_rmax - p_rmin + 1 and width w = p_cmax - p_cmin + 1.\n   e. Extract an h×w template T where for 0 ≤ dr < h, 0 ≤ dc < w: T[dr][dc] = grid[p_rmin + dr][p_cmin + dc].\n   f. For every cell (i,j) in R, compute dr = (i - r_min) mod h and dc = (j - c_min) mod w, and set grid[i][j] = T[dr][dc].\n4. Return the modified grid.",
    "0c9aba6e": "1. Let R be the number of rows and C be the number of columns in the input.  \n2. Find the separator row index S such that for all j in 0..C-1, input[S][j] == 7.  \n3. Let H = S and verify that R - S - 1 == H.  \n4. Create an output grid of size H × C and fill every cell with 0.  \n5. For each i in 0..H-1 and each j in 0..C-1:  \n   a. Let top = input[i][j] and bottom = input[S+1+i][j].  \n   b. If top == 0 AND bottom == 0, then set output[i][j] = 8.  \n6. Return the output grid.",
    "712bf12e": "1. Let row_count be the number of rows and col_count be the number of columns in the grid.\n2. Identify all starting positions: every coordinate (r, c) such that grid[r][c] == 2 in the input.\n3. For each starting position (r, c):\n   a. Set current_row = r and current_col = c.\n   b. Repeat the following steps until termination:\n      i.   If current_row > 0 and grid[current_row-1][current_col] == 0 then\n           - Set grid[current_row-1][current_col] = 2\n           - Set current_row = current_row - 1\n           - Continue to the next iteration of the loop\n      ii.  Else if current_col < col_count - 1 and grid[current_row][current_col+1] == 0 then\n           - Set grid[current_row][current_col+1] = 2\n           - Set current_col = current_col + 1\n           - Continue to the next iteration of the loop\n      iii. Else\n           - Break out of the loop for this starting position\n4. After all starting positions have been processed, return the modified grid as the output.",
    "a59b95c0": "1. Let the input grid have H rows and W columns.\n2. Compute the set S of all distinct integer values in the input grid. Let k = |S|.\n3. Initialize an output grid of size (H * k) rows by (W * k) columns.\n4. For each tile_row from 0 to k-1:\n     For each tile_col from 0 to k-1:\n         For each r from 0 to H-1:\n             For each c from 0 to W-1:\n                 Set output[tile_row * H + r][tile_col * W + c] = input[r][c].\n5. Return the output grid.",
    "0d87d2a6": "1. Let P be the set of all coordinates (r, c) in the input grid where the cell value equals 1.\n2. Initialize the output grid as a copy of the input grid.\n3. Perform horizontal connections:\n   a. For each row index r for which P contains two or more points with that same r:\n      i.   Collect the list C_r of all column indices c for points (r, c) in P.\n      ii.  Let c_min = minimum value in C_r and c_max = maximum value in C_r.\n      iii. For each column c from c_min through c_max (inclusive), set output_grid[r][c] = 1.\n      iv.  Remove all points with row r from P.\n4. Perform vertical connections on remaining points:\n   a. For each column index c for which P contains two or more points with that same c:\n      i.   Collect the list R_c of all row indices r for points (r, c) in P.\n      ii.  Let r_min = minimum value in R_c and r_max = maximum value in R_c.\n      iii. For each row r from r_min through r_max (inclusive), set output_grid[r][c] = 1.\n5. Return the output grid.\n\nExplanation of terms:\n- \"Input grid\" and \"output grid\" are 2D arrays of integers 0, 1, 2.\n- P is based only on original 1s in the input; newly drawn 1s are not added to P.\n- Steps 3 and 4 overwrite any values (0 or 2) along the connecting segments with 1, and leave all other cells unchanged.",
    "72207abc": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Identify r, the index of the single row that contains any non-zero cell values.\n3. Initialize an empty list C.\n4. For each column c from 0 to W–1:\n     if input[r][c] ≠ 0, append input[r][c] to the end of C.\n5. Let m = length of C.\n6. Create an output grid of size H×W filled with 0.\n7. For every row i ≠ r and every column c from 0 to W–1:\n     set output[i][c] = input[i][c].\n8. For each integer n starting at 0:\n     a. Compute pos = n × (n + 1) / 2.\n     b. If pos ≥ W, stop the loop.\n     c. Let color = C[n mod m].\n     d. Set output[r][pos] = color.\n9. Return the output grid.",
    "a680ac02": "1. Scan the input grid and identify all non-zero connected components (4-connected). For each component:\n   a. Let c be its integer value (1–9).\n   b. Compute its bounding box: min_row, max_row, min_col, max_col.\n   c. Compute height = max_row - min_row + 1 and width = max_col - min_col + 1.\n2. For each component, test hollow‐square shape:\n   a. Require height ≥ 3 and width ≥ 3 and height = width.\n   b. For every cell on the border of the bounding box, its value must equal c.\n   c. For every interior cell (rows min_row+1..max_row-1, cols min_col+1..max_col-1), its value must be 0.\n   d. If all conditions hold, collect this component as a shape; otherwise ignore it.\n3. For each collected shape, compute its centroid coordinates:\n   a. centroid_row = (min_row + max_row) / 2.0\n   b. centroid_col = (min_col + max_col) / 2.0\n4. Let row_range = max(centroid_row) - min(centroid_row) over all shapes; let col_range = max(centroid_col) - min(centroid_col).\n5. If col_range > row_range, set orientation = HORIZONTAL; else orientation = VERTICAL.\n6. Sort the shapes:\n   a. If orientation = HORIZONTAL, sort by increasing centroid_col.\n   b. If orientation = VERTICAL, sort by increasing centroid_row.\n7. Compute output grid dimensions:\n   a. If HORIZONTAL: out_height = max(height of shapes), out_width = sum(width of shapes).\n   b. If VERTICAL: out_height = sum(height of shapes), out_width = max(width of shapes).\n8. Create an output grid of size out_height × out_width, initialized to 0.\n9. Place shapes into the output grid in sorted order:\n   a. Maintain an offset: cum_row = 0, cum_col = 0.\n   b. For each shape:\n      i. Let h = height, w = width, c = shape value, and bbox = (min_row..max_row, min_col..max_col).\n      ii. If HORIZONTAL: copy the subgrid input[min_row..max_row, min_col..max_col] into output[0..h-1, cum_col..cum_col+w-1]; then cum_col += w.\n      iii. If VERTICAL: copy input[min_row..max_row, min_col..max_col] into output[cum_row..cum_row+h-1, 0..w-1]; then cum_row += h.\n10. Return the output grid.",
    "0e671a1a": "1. Copy the input grid to the output grid.\n2. Locate the coordinates of the three special pixels:\n   a. (r_green, c_green) where pixel value == 3 (green).\n   b. (r_yellow, c_yellow) where pixel value == 4 (yellow).\n   c. (r_red, c_red) where pixel value == 2 (red).\n3. Draw a path of pixels value 5 (grey) from green to yellow:\n   a. Compute dr1 = sign(r_yellow - r_green).\n   b. For r = r_green + dr1; r != r_yellow + dr1; r += dr1:\n        If output[r][c_green] == 0, set output[r][c_green] = 5.\n   c. Compute dc1 = sign(c_yellow - c_green).\n   d. For c = c_green + dc1; c != c_yellow + dc1; c += dc1:\n        If output[r_yellow][c] == 0, set output[r_yellow][c] = 5.\n4. Draw a path of pixels value 5 (grey) from yellow to red:\n   a. Compute dr2 = sign(r_red - r_yellow).\n   b. For r = r_yellow + dr2; r != r_red + dr2; r += dr2:\n        If output[r][c_yellow] == 0, set output[r][c_yellow] = 5.\n   c. Compute dc2 = sign(c_red - c_yellow).\n   d. For c = c_yellow + dc2; c != c_red + dc2; c += dc2:\n        If output[r_red][c] == 0, set output[r_red][c] = 5.\n5. Leave all other pixels unchanged.\n\nDefinitions:\n- sign(x) = 1 if x>0; -1 if x<0; 0 if x==0.\n- Loops in 3b and 3d include the cell at yellow (for the vertical leg) and the corner at (r_yellow, c_green), but never overwrite the special pixels 2, 3, or 4 because we only set pixels whose current value is 0.",
    "72a961c9": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Locate the base row index r_base (0 ≤ r_base < H) defined as the unique row containing at least one cell with value 2 or value 8.\n3. For each column index c from 0 to W-1, inspect the value v = grid[r_base][c]:\n   a. If v == 2, then:\n      i.   For delta from 1 to 3, set grid[r_base - delta][c] = 1.\n      ii.  Set grid[r_base - 4][c] = 2.\n   b. Else if v == 8, then:\n      i.   For delta from 1 to 2, set grid[r_base - delta][c] = 1.\n      ii.  Set grid[r_base - 3][c] = 8.\n4. Leave all other cells unchanged.\n5. Return the resulting grid.",
    "a8610ef7": "1. Locate all cells with the value 8; treat each such cell as a node in an undirected graph. 2. Connect two nodes by an edge if their cells are adjacent orthogonally (share a side). 3. Initialize an empty set VISITED. 4. For each connected component of this graph (i.e. each maximal set of 8-cells reachable by orthogonal moves):\n   a. Find the cell (r,c) in the component with the smallest row index; if multiple, the one with the smallest column index. Call this the seed.\n   b. Perform a breadth-first traversal from the seed over the component. Assign the seed a new value of 5. Mark it VISITED.\n   c. For each node reached from a parent node during the BFS: assign its new value equal to 7 minus the parent’s new value (so that neighbors alternate between 5 and 2). Mark it VISITED.\n5. Replace each original 8 in the grid by the new value assigned in step 4; leave all other cells unchanged.",
    "0f63c0b9": "1. Let H = number of rows and W = number of columns in the input grid.\n2. Identify all non-zero pixels (\"dots\"). For each dot record its row index r and its value v.\n3. Sort the list of dots by ascending r. Let the sorted list be [(r0,v0),(r1,v1),…,(rN-1,vN-1)].\n4. For each index i from 0 to N-1 do:\n   a. Let r = ri and v = vi.\n   b. If i == 0 then start = 0; otherwise start = floor((r_{i-1} + r) / 2) + 1.\n   c. If i == N-1 then end = H - 1; otherwise end = floor((r + r_{i+1}) / 2).\n   d. For each row R from start to end inclusive:\n      i. If R == r OR (i == 0 AND R == start) OR (i == N-1 AND R == end) then:\n         • For each column C from 0 to W-1 set output[R][C] = v.\n      ii. Otherwise:\n         • Set output[R][0] = v and output[R][W-1] = v.\n5. Set all other cells to 0.",
    "73182012": "1. Scan the input grid to find all cells with value ≠ 0. 2. Let r_min = smallest row index of any non-zero cell; r_max = largest such row index. 3. Let c_min = smallest column index of any non-zero cell; c_max = largest such column index. 4. Compute height = r_max − r_min + 1 and width = c_max − c_min + 1. 5. Assert that height and width are even. 6. Let h2 = height / 2 and w2 = width / 2. 7. Define the top-left quadrant as rows r_min through r_min + h2 − 1 and columns c_min through c_min + w2 − 1. 8. Create a new output grid of size h2 × w2. 9. For each row r in [r_min, r_min + h2 − 1] and each column c in [c_min, c_min + w2 − 1], copy the value at input(r,c) into output at (r − r_min, c − c_min). 10. Return the output grid.",
    "a934301b": "1. Let G be the input grid of size H×W. Initialize an output grid O of the same size, filling every cell with 0.\n2. Create a boolean grid V of size H×W, initialized to false, to track visited cells.\n3. For each cell (r,c) with 0 ≤ r < H and 0 ≤ c < W, do:\n   a. If V[r][c] is false and G[r][c] is either 1 or 8, begin a new component:\n      i. Initialize an empty list L and a queue Q containing (r,c). Set V[r][c] = true.\n      ii. While Q is not empty, remove a cell (x,y) from Q, append (x,y) to L. \n          For each of the four orthogonal neighbors (x±1,y) and (x,y±1) that lies within the grid:\n             - If V[nx][ny] is false and G[nx][ny] is in {1,8}, set V[nx][ny]=true and enqueue (nx,ny) into Q.\n   b. After the flood fill, count the number of cells in L where G[x][y] == 8; call this count k.\n   c. If k ≤ 1, then for each (x,y) in L set O[x][y] = G[x][y]; otherwise leave O[x][y] = 0.\n4. After processing all cells, return O as the transformed grid.",
    "103eff5b": "1. Locate the small prototype shape:\n   1.1. Scan the grid to collect all cells with value not equal to 0 and not equal to 8.\n   1.2. Let min_r_small = minimum row index among these cells, max_r_small = maximum row index, min_c_small = minimum column index, max_c_small = maximum column index.\n   1.3. Define height_small = max_r_small – min_r_small + 1, width_small = max_c_small – min_c_small + 1.\n   1.4. Extract small_shape[i][j] = grid[min_r_small + i][min_c_small + j] for i in [0..height_small-1], j in [0..width_small-1].\n2. Locate the large target shape:\n   2.1. Scan the grid to collect all cells with value 8.\n   2.2. Let min_r_large = minimum row, max_r_large = maximum row, min_c_large = minimum column, max_c_large = maximum column among those cells.\n   2.3. Define height_large = max_r_large – min_r_large + 1, width_large = max_c_large – min_c_large + 1.\n3. Compute uniform scale factor f = height_large / height_small. Verify that width_large = width_small * f.\n4. Rotate the small prototype 90° clockwise:\n   4.1. Initialize rotated[i][j] of size [height_small][width_small].\n   4.2. For each i in [0..height_small-1], j in [0..width_small-1], set rotated[j][height_small-1-i] = small_shape[i][j].\n5. Paint the large shape with scaled colors:\n   5.1. For each cell (i_s,j_s) in rotated:\n      • Let v = rotated[i_s][j_s]. If v = 0, continue to next cell.\n      • For di in [0..f-1] and dj in [0..f-1], set grid[min_r_large + i_s*f + di][min_c_large + j_s*f + dj] = v.\n6. Leave all other cells (including the original small shape and any zeros) unchanged.",
    "73c3b0d8": "1. Let H be the number of rows and W the number of columns. Index rows 0 to H-1 from top and columns 0 to W-1 from left.\n2. Find the index R_const of the row that is filled entirely with value 2.\n3. Initialize the output grid as a copy of the input grid.\n4. For each cell (r,c) in the input grid with value 4:\n   a. In the output grid set cell (r,c) to 0.\n   b. Compute new_r = r + 1. In the output grid set cell (new_r,c) to 4.\n   c. If new_r + 1 == R_const (i.e. the moved 4 is directly above the constant-2 row), then:\n      i. For deltaC in {-1,+1} do:\n         A. Let rr = new_r and cc = c.\n         B. Repeat:\n            - Set rr = rr - 1 and cc = cc + deltaC.\n            - If rr < 0 or cc < 0 or cc >= W, exit this loop.\n            - Otherwise set output(rr,cc) = 4.\n            - Continue the loop.\n5. Leave all other cells unchanged. Return the output grid.",
    "aa18de87": "1. Let H be the number of rows and W be the number of columns of the input grid. 2. Initialize the output grid as an exact copy of the input grid. 3. Determine outline_color by scanning all cells of the input and collecting the set S of values >0 and ≠2. There must be exactly one value in S; assign that value to outline_color. 4. Set fill_color to 2. 5. For each row index r from 0 to H-1 do:   a. Let cols be the sorted list of all column indices c (0 ≤ c < W) such that input[r][c] == outline_color.   b. For each index i from 0 to length(cols)-2 do:     i. Let c1 = cols[i] and c2 = cols[i+1].     ii. For each column c from c1+1 to c2-1 inclusive do:         – Set output[r][c] = fill_color. 6. Return the output grid.",
    "11e1fe23": "1. Identify all non-zero input cells; each such cell has a unique color value v in {1..9}. For each v record its position P_v = (r_v, c_v).  \n2. Compute min_row = min(r_v for all v), max_row = max(r_v for all v); compute min_col = min(c_v for all v), max_col = max(c_v for all v).  \n3. Compute center_r = (min_row + max_row) / 2 and center_c = (min_col + max_col) / 2.  \n4. Copy the input grid to the output grid.  \n5. Set the output cell at (center_r, center_c) to 5.  \n6. For each color v with original position (r_v, c_v):  \n   a. Compute dr = sign(r_v - center_r) (i.e. +1, 0, or -1).  \n   b. Compute dc = sign(c_v - center_c) (i.e. +1, 0, or -1).  \n   c. Set the output cell at (center_r + dr, center_c + dc) to v.  \n7. Leave all other cells unchanged and return the output grid.",
    "73ccf9c2": "1. Let background = 0. 2. Scan the input to identify the unique non-zero value c (the shape color). 3. Find all connected components of cells with value c using 4-directional adjacency. 4. For each component, compute:   • r_min = minimum row index of its cells   • r_max = maximum row index   • c_min = minimum column index   • c_max = maximum column index 5. Select the component S whose r_max is maximal. If multiple components tie for maximal r_max, select among them the one with smallest c_min. 6. Compute output dimensions: H = r_max(S) – r_min(S) + 1, W = c_max(S) – c_min(S) + 1. 7. Initialize an H×W grid filled with 0. 8. For each cell (r,c) in the bounding box [r_min(S)..r_max(S)]×[c_min(S)..c_max(S)], set output[r – r_min(S)][c – c_min(S)] = input[r][c]. 9. Return the output grid.",
    "aa300dc3": "1. Let H=grid height and W=grid width. Index rows r from 0 to H-1 top to bottom, columns c from 0 to W-1 left to right.\n2. Define value 0 as the region color (black) and 8 as the fill color (cyan/light blue).\n3. Define two diagonal direction vectors: D_pos=(dr=1, dc=1) and D_neg=(dr=1, dc=-1).\n4. Initialize best_run as an empty list of coordinates.\n5. For each cell (r,c) in the grid with value 0 do:\n   a. If the cell at (r-1, c-1) is outside the grid or has value not equal to 0, then:\n      i. Set current_run empty. Set (rr,cc)=(r,c).\n      ii. While (rr,cc) is inside the grid and grid[rr][cc]==0 do:\n          - Append (rr,cc) to current_run.\n          - Update rr=rr+1 and cc=cc+1.\n      iii. If length of current_run > length of best_run, then set best_run=current_run.\n   b. If the cell at (r-1, c+1) is outside the grid or has value not equal to 0, then:\n      i. Set current_run empty. Set (rr,cc)=(r,c).\n      ii. While (rr,cc) is inside the grid and grid[rr][cc]==0 do:\n          - Append (rr,cc) to current_run.\n          - Update rr=rr+1 and cc=cc-1.\n      iii. If length of current_run > length of best_run, then set best_run=current_run.\n6. For each coordinate (r,c) in best_run, set grid[r][c]=8.\n7. Return the modified grid.",
    "12422b43": "1. Let H = number of rows and W = number of columns in the input grid.\n2. Identify the pattern rows P = [r₀, r₁, …, r_{k-1}] in ascending order where input[r][0] == 5 (grey). Let k = |P|.\n3. For each pattern row index p in P, record its pattern content C[p][c] = input[p][c] for columns c = 1..W-1.\n4. Find blank_start = the smallest row index r (0 ≤ r < H) such that for all c in 0..W-1, input[r][c] == 0.  If no such row exists, set blank_start = k.\n5. Initialize output[r][c] = input[r][c] for all 0 ≤ r < H, 0 ≤ c < W.\n6. For each row r from blank_start to H-1:\n   a. Compute t = (r - blank_start) mod k.\n   b. Let source_row = P[t].\n   c. Set output[r][0] = 0.\n   d. For each column c from 1 to W-1:\n         If input[r][c] == 0 then set output[r][c] = C[source_row][c].  Otherwise leave output[r][c] unchanged.\n7. Return the output grid.",
    "759f3fd3": "1. Scan the input grid to locate the horizontal green line and the vertical green line (pixel value 3). Identify r0 as the unique row index where more than one cell has value 3. Identify c0 as the unique column index where more than one cell has value 3.  \n2. For each cell at coordinates (r, c) in the grid do the following:  \n   a. If the input cell value at (r, c) equals 3, set the output cell to 3.  \n   b. Otherwise, compute dr = |r – r0| and dc = |c – c0|, and let k = max(dr, dc).  \n   c. If k mod 2 equals 0, set the output cell to 4.  \n   d. Otherwise, set the output cell to 0.  \n3. Preserve the grid dimensions and apply these rules to every cell to produce the output grid.",
    "aa4ec2a5": "1. Define values: shape pixels = 1, background pixels = 4. hole pixels = background pixels not connected to the grid border. outline color = 2, fill-within-hole color = 6, fill-shape-interior color = 8.\n2. Identify all shape components: perform a 4-connected flood fill of pixels==1 to assign a unique component ID to each shape.\n3. Identify external background: perform a 4-connected flood fill from every border cell with value==4; mark all reachable 4 pixels as external.\n4. Identify holes: any pixel with value==4 that is not marked external belongs to a hole. Group those hole pixels into hole components by 4-connected flood fill.\n5. Map each hole component to its enclosing shape: for each hole component, find all 4-connected neighbor pixels of value==1; they all belong to the same shape component ID, so record that shape ID has holes and record its hole pixels.\n6. Create output grid initialized as a copy of the input grid.\n7. For each shape component ID:\n   a. Outline: for every pixel (r,c) in the component, if any of its 4 neighbors is not in the same component, set output[r][c] = 2.\n   b. If this shape has no associated hole components, leave all other pixels of this component as 1.\n   c. If this shape has one or more hole components:\n      i. For each hole pixel in those components, set output[r][c] = 6.\n      ii. For every pixel in this shape component not already set to outline (step 7a), set output[r][c] = 8.\n8. Leave all other pixels (background external 4 pixels and any other values) unchanged.\n9. Return the output grid.",
    "12997ef3": "1. Use 0-based indices (row 0 at top, column 0 at left).\n2. Locate all template pixels: scan input grid and collect all coordinates (r,c) where cell value = 1.\n3. Compute bounding rectangle of template: min_r = min r, max_r = max r, min_c = min c, max_c = max c. Let H = max_r - min_r + 1, W = max_c - min_c + 1.\n4. Build binary mask M of size H×W: for dr in [0..H-1], dc in [0..W-1], M[dr][dc] = 1 if input[min_r+dr][min_c+dc] == 1, else 0.\n5. Identify instruction pixels: scan input grid for all cells with value ≥ 2. Collect list P of tuples (r,c,color).\n6. Determine orientation:\n   a. If all P have identical r, set orientation = horizontal.\n   b. Else if all P have identical c, set orientation = vertical.\n7. Sort P:\n   a. If orientation = horizontal, sort by increasing c.\n   b. If orientation = vertical, sort by increasing r.\n8. Let N = number of instruction pixels in P.\n9. Define output grid dimensions and initialize to 0:\n   a. If horizontal: out_H = H, out_W = N * W.\n   b. If vertical:   out_H = N * H, out_W = W.\n10. For i from 0 to N-1:\n    a. Let (r, c, col) = P[i].\n    b. If orientation = horizontal:\n         For each dr in [0..H-1], dc in [0..W-1]:\n           If M[dr][dc] == 1, set output[dr][i*W + dc] = col.\n       Else (vertical):\n         For each dr in [0..H-1], dc in [0..W-1]:\n           If M[dr][dc] == 1, set output[i*H + dr][dc] = col.\n11. Return the output grid.",
    "762cd429": "1. Let the grid have H rows and W columns. 2. Locate the unique 2×2 non‐zero block: scan for a cell (r0,c0) such that grid[r0][c0]≠0, grid[r0][c0+1]≠0, grid[r0+1][c0]≠0, grid[r0+1][c0+1]≠0, and all four form a contiguous 2×2. 3. Extract pattern P of size 2×2: P[0][0]=grid[r0][c0], P[0][1]=grid[r0][c0+1], P[1][0]=grid[r0+1][c0], P[1][1]=grid[r0+1][c0+1]. 4. Compute maximum levels L: the largest integer L≥1 satisfying both ∑_{k=1..L}2^k ≤ r0 and ∑_{k=1..L}(2·2^k) ≤ W−(c0+2). 5. For each level n from 1 to L do:   a. Set h=2^n and w=2·2^n.   b. Compute vertical offset Y=∑_{k=1..n}2^k and horizontal offset X=∑_{k=1..n−1}(2·2^k).   c. For each pattern cell (i,j) with i∈{0,1}, j∈{0,1}:      i. Let row_start = (r0+1) − Y + i·h.      ii. Let col_start = (c0+2) + X + j·w.      iii. For dr from 0 to h−1 and dc from 0 to w−1 set grid[row_start+dr][col_start+dc] = P[i][j]. 6. Return the modified grid.",
    "aab50785": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Initialize an empty list RESULT_ROWS.\n3. For each row index r from 0 to H-2 do:\n   a. Initialize an empty list BAND_COLUMNS.\n   b. For each column index c from 0 to W-2 do:\n      i. If grid[r][c]==8 and grid[r][c+1]==8 and grid[r+1][c]==8 and grid[r+1][c+1]==8 then append c to BAND_COLUMNS.\n   c. If the length of BAND_COLUMNS is exactly 2 then:\n      i. Sort BAND_COLUMNS in ascending order. Let left = BAND_COLUMNS[0] and right = BAND_COLUMNS[1].\n      ii. Let START_C = left + 2 and END_C = right - 1.\n      iii. For each rr in [r, r+1] do:\n           - Extract the segment SEG = [grid[rr][cc] for cc from START_C to END_C inclusive].\n           - Append SEG as a new row at the end of RESULT_ROWS.\n4. After processing all r, form the output grid by stacking all rows in RESULT_ROWS in the order they were appended.\n5. Return this output grid.",
    "12eac192": "1. Define target values T = {1, 5, 7}.\n2. For each v in T, find all connected components (4-adjacency: up, down, left, right) of pixels whose grid value equals v. A component is a maximal set of same-value pixels connected by side adjacency.\n3. For each component of value v in T:\n   a. If the number of pixels in the component is less than 3, set every pixel in that component to 3.\n   b. Otherwise leave those pixels unchanged.\n4. Leave all pixels with values not in T unchanged.",
    "770cc55f": "1. Let R be the number of rows and C be the number of columns of the input grid.\n2. Identify the middle bar row index M: the unique row where the nonzero cells form a single contiguous segment of length C (grid[M][c] != 0 for all c in [0..C-1]).\n3. Identify the top bar:\n   a. Find the greatest row index T_top < M such that there exists at least one nonzero cell in that row.\n   b. Let top_color = grid[T_top][c] for any c where grid[T_top][c] != 0.\n   c. Define S_top = { c | grid[T_top][c] == top_color }.\n4. Identify the bottom bar:\n   a. Find the smallest row index B_bot > M such that there exists at least one nonzero cell in that row.\n   b. Let bot_color = grid[B_bot][c] for any c where grid[B_bot][c] != 0.\n   c. Define S_bot = { c | grid[B_bot][c] == bot_color }.\n5. Verify that top_color == bot_color; call this outer_color.\n6. Compute the overlap columns S_overlap = S_top ∩ S_bot.\n7. Determine which outer bar is longer:\n   a. If |S_top| > |S_bot|, set row_start = T_top + 1 and row_end = M - 1.\n   b. Otherwise (|S_bot| > |S_top|), set row_start = M + 1 and row_end = B_bot - 1.\n8. For each row r in [row_start..row_end] and for each column c in S_overlap, set grid[r][c] = 4.\n9. Leave all other cells unchanged. ",
    "ac0c5833": "1. Identify the red prototype:\n   a. Let R = set of all grid coordinates (r,c) where grid[r][c] == 2.\n   b. Compute red_min_row = min r in R, red_max_row = max r in R, red_min_col = min c in R, red_max_col = max c in R.\n   c. Define red_rel = { (r - red_min_row, c - red_min_col) | (r,c) in R }.\n   d. Let red_h = red_max_row - red_min_row + 1, red_w = red_max_col - red_min_col + 1.\n2. Find every yellow pattern:\n   a. Let Y = set of all grid coordinates where grid[r][c] == 4.\n   b. Compute connected components of Y under 4-connectivity; for each component Yk:\n      i. Compute y_min_row, y_max_row, y_min_col, y_max_col over Yk.\n      ii. Compute y_h = y_max_row - y_min_row + 1, y_w = y_max_col - y_min_col + 1.\n      iii. Let y_rel = { (r - y_min_row, c - y_min_col) | (r,c) in Yk }.\n3. For each yellow component Yk, determine correct orientation:\n   a. For each rotation angle θ in {0°, 90°, 180°, 270°}:\n      i. Compute rotated_rel = rotate red_rel by θ around (0,0):\n         - 0°: (dr,dc)→(dr,dc)\n         - 90°: (dr,dc)→(dc, red_h-1-dr)\n         - 180°: (dr,dc)→(red_h-1-dr, red_w-1-dc)\n         - 270°: (dr,dc)→(red_w-1-dc, dr)\n      ii. Let rot_h = bounding height of rotated_rel = max dr in rotated_rel +1;\n          let rot_w = bounding width = max dc +1.\n      iii. If rot_h==y_h and rot_w==y_w and Yk ⊂= { (y_min_row+dr, y_min_col+dc) | (dr,dc) in rotated_rel }:\n           • And |rotated_rel| - |Yk| == 1 (exactly one rotated cell is not covered by Yk), then select this θ and break.\n4. Place red shapes at each Yk:\n   a. For the selected rotated_rel for Yk, for each (dr,dc) in rotated_rel:\n      i. Let (r_new,c_new) = (y_min_row + dr, y_min_col + dc).\n      ii. If grid[r_new][c_new] == 0, set grid[r_new][c_new] = 2.\n5. Return the modified grid.",
    "136b0064": "1. Identify the vertical divider column D: the unique column where every cell has value 4.\n2. Let H = number of rows, Wout = D. Initialize an output grid of size H×Wout filled with 0.\n3. In the input grid, find all connected components (4‐connected) of cells whose value ≠0 and ≠4.  Record for each component:\n   • color C\n   • list of its cell coordinates\n   • minimal row r_min, minimal column c_min, maximal row r_max, maximal column c_max\n4. Build a list S of these components in this order:\n   a. First, the one component with C=5 (there is exactly one single‐cell gray point to the right of D).  \n   b. Then all other components sorted by ascending r_min, then ascending c_min.\n5. Define a lookup by color C → (orientation, length L):\n   • C=5 → horizontal, L=1\n   • C=1 → horizontal, L=3\n   • C=2 → horizontal, L=2\n   • C=3 → horizontal, L=4\n   • C=6 → vertical,   L=2\n6. For i from 1 to |S|, place segment i as follows:\n   Let (ori,L)=lookup for S[i].C, and let r0 = row of the component’s centroid rounded to an integer (use ⌊(r_min + r_max)/2⌋).\n   If i=1 (gray point):\n     • Place a single cell of color 5 at output row=r0, column = ⌊Wout/2⌋.\n     • Record its end‐coordinate (r_end, c_end) = (r0,⌊Wout/2⌋).\n   Else:\n     • Choose starting cell (r_start,c_start) as the empty neighbor of (r_end,c_end) in the direction you will draw:   \n       – If ori=horizontal, prefer the cell to the right of (r_end,c_end) if c_end+L-1 < Wout, otherwise use the cell to the left.\n       – If ori=vertical, prefer the cell below (r_end,c_end) if r_end+L-1 < H, otherwise use the cell above.\n     • From (r_start,c_start), draw L cells of color C in a straight line in the chosen orientation (increasing column for rightward, decreasing for leftward; increasing row for downward, decreasing for upward).\n     • Record the segment’s other end as (r_end,c_end).\n7. After all segments are placed, the output grid is complete. All unfilled cells remain 0.",
    "782b5218": "1. Let c_bg be 0. 2. Scan entire input grid to collect the set C of colors ≠ c_bg; it has exactly two elements. 3. Let c_line be the color in C with the smaller total count of pixels; let c_fill be the other color in C. 4. For each column index c from 0 to width–1:  a. Compute positions_c = { r | input[r][c] == c_line }.  b. Let r_min_c = min(positions_c), r_max_c = max(positions_c). 5. Create an output grid of the same dimensions. 6. For each cell at (r,c):  a. If r ∈ positions_c, set output[r][c] = c_line.  b. Else if r < r_min_c, set output[r][c] = c_bg.  c. Else (r > r_max_c), set output[r][c] = c_fill. 7. Return the output grid.",
    "ac2e8ecf": "1. Let input grid have R rows (indexed 0 to R-1) and C columns (0 to C-1). Create an output grid of same size initialized to 0.\n2. Identify all non-zero connected components using 4-connectivity. For each component:\n   a. Let v be its integer value (1–9).\n   b. Compute its pixel list P = {(r,c)}.\n   c. Compute top = min_{(r,c) in P} r, bottom = max_{(r,c) in P} r, left = min_{(r,c) in P} c, right = max_{(r,c) in P} c.\n   d. Compute box_height = bottom - top + 1, box_width = right - left + 1.\n   e. Let pixel_count = |P|.\n   f. If pixel_count == box_height*box_width or pixel_count == 2*(box_height + box_width) - 4, classify as RECTANGLE; otherwise classify as CROSS.\n3. For each component:\n   a. If RECTANGLE: compute shift = top. For each (r,c) in P, place value v at (r - shift, c) in output grid.\n   b. If CROSS: compute shift = (R - 1) - bottom. For each (r,c) in P, place value v at (r + shift, c) in output grid.\n4. Return the output grid.",
    "13713586": "1. Let G be the set of all grid cells with value 5. 2. Determine the base orientation:\n   a. If all cells in G have the same row index gr, set Mode = \"HORIZONTAL\" and BaseRow = gr.\n   b. Else if all cells in G have the same column index gc, set Mode = \"VERTICAL\" and BaseCol = gc.\n3. Create an output grid initialized to the input grid. Create a priority matrix P of same dimensions, initialized to a large value (e.g. infinity) in every cell.\n4. For each cell p at (r,c) in the input grid with color v ≠ 0 and v ≠ 5, do:\n   a. Compute distance d:\n      • If Mode = HORIZONTAL, d = |r − BaseRow|.\n      • If Mode = VERTICAL, d = |c − BaseCol|.\n   b. Compute step (dr,dc):\n      • If Mode = HORIZONTAL: dr = sign(BaseRow − r) (±1), dc = 0.\n      • If Mode = VERTICAL: dr = 0, dc = sign(BaseCol − c) (±1).\n   c. Let (cr,cc) = (r,c). Repeat:\n      i. If d < P[cr][cc], then set Output[cr][cc] = v and P[cr][cc] = d.\n      ii. Update (cr,cc) = (cr + dr, cc + dc).\n      iii. Stop when (cr,cc) would equal (BaseRow, c) in HORIZONTAL mode or (r, BaseCol) in VERTICAL mode (i.e. do not include any cell in G).\n5. Return the Output grid.",
    "79369cc6": "1. Let G be the input grid of size R×C. 2. Locate the unique 3×3 subgrid B in G that contains at least one cell with value 6 and at least one cell with value 4. Record its top-left corner as (r0,c0). 3. Build a 3×3 binary mask M where M[i][j]=1 if B[i][j]==6, otherwise M[i][j]=0, for i,j in {0,1,2}. 4. Precompute four masks: M0=M; M90 = rotate M 90° clockwise; M180 = rotate M 180°; M270 = rotate M 270° clockwise. 5. For each position (r,c) with 0≤r≤R−3 and 0≤c≤C−3:   a. Extract the 3×3 window W from G at top-left (r,c).   b. Build Wmask where Wmask[i][j]=1 if W[i][j]==6 else 0.   c. If Wmask equals any of {M0,M90,M180,M270}, then for all i,j in {0,1,2}:      i. If G[r+i][c+j]≠6, set G[r+i][c+j]=4. 6. Return the modified grid G.",
    "ac3e2b04": "1. Let H = height of grid, W = width of grid.  \n2. Identify all maximal horizontal red segments: For each row R, scan columns 0 to W-1 to find contiguous runs of value 2 of length ≥ 3. Record each as (R, C_start, C_end).  \n3. Identify all maximal vertical red segments: For each column C, scan rows 0 to H-1 to find contiguous runs of value 2 of length ≥ 3. Record each as (C, R_start, R_end).  \n4. Identify all green 3×3 blocks: For each cell (r,c) with value 2, if all eight neighbors (r±1, c±1 etc.) exist and have value 3, record (r,c) as a block center.  \n5. For each recorded block center (r,c):  \n   a. For each horizontal red segment (R, C_start, C_end):  \n      i. If C_start ≤ c+1 and C_end ≥ c−1 (i.e. the segment’s columns overlap the block’s columns [c−1,c+1]), then draw a vertical blue line at column c:  \n         • For i from 0 to H−1, if grid[i][c] == 0 then set grid[i][c] = 1.  \n   b. For each vertical red segment (Cv, R_start, R_end):  \n      i. If R_start ≤ r+1 and R_end ≥ r−1 (i.e. the segment’s rows overlap the block’s rows [r−1,r+1]), then draw a horizontal blue line at row r:  \n         • For j from 0 to W−1, if grid[r][j] == 0 then set grid[r][j] = 1.  \n6. Return the modified grid.",
    "137f0df0": "1. Identify all cells with value 5. Compute row_min = minimum row index of any 5, row_max = maximum row index of any 5, col_min = minimum column index of any 5, col_max = maximum column index of any 5.\n2. For each cell (r,c) such that row_min ≤ r ≤ row_max and col_min ≤ c ≤ col_max:\n   a. If the input value at (r,c) is 0, set it to 2.\n   b. Otherwise leave its original value (including 5) unchanged.\n3. For each cell (r,c) outside the rectangle (r < row_min or r > row_max or c < col_min or c > col_max) with input value 0:\n   a. Check horizontal:\n      i. If there exists a column c0 in [col_min..col_max] such that the cell (r,c0) is 2, and for every intermediate column k between c and c0 (exclusive) the input value at (r,k) is not 5, then set (r,c) = 1 and continue to next cell.\n   b. Otherwise check vertical:\n      i. If there exists a row r0 in [row_min..row_max] such that the cell (r0,c) is 2, and for every intermediate row k between r and r0 (exclusive) the input value at (k,c) is not 5, then set (r,c) = 1.\n   c. Otherwise leave the cell at 0.\n4. Leave all other cells unchanged.",
    "7953d61e": "1. Let A be the input grid of size 4×4, with rows r=0..3 and columns c=0..3.\n2. Create an empty output grid B of size 8×8, with rows R=0..7 and columns C=0..7.\n3. Copy the original pattern into the upper-left quadrant:\n   For each r in 0..3 and c in 0..3, set B[r][c] = A[r][c].\n4. Fill the upper-right quadrant with A rotated 90° counterclockwise:\n   For each r in 0..3 and c in 0..3, set B[r][c+4] = A[c][3−r].\n5. Fill the lower-left quadrant with A rotated 180°:\n   For each r in 0..3 and c in 0..3, set B[r+4][c] = A[3−r][3−c].\n6. Fill the lower-right quadrant with A rotated 270° counterclockwise:\n   For each r in 0..3 and c in 0..3, set B[r+4][c+4] = A[3−c][r].\n7. Return B as the 8×8 output grid.",
    "ac605cbb": "1. Copy the input grid into an output grid of the same dimensions.\n2. Locate all seed pixels: every cell with value v in {1,2,3,6}. Record each seed’s coordinates (r,c) and its value v.\n3. For each seed (r,c,v), compute the direction and counts:  \n   - If v==1: set (dr,dc)=(0,1), n_grey=2, (dr_final,dc_final)=(-1,0).\n   - If v==2: set (dr,dc)=(0,-1), n_grey=3, (dr_final,dc_final)=(0,-1).\n   - If v==3: set (dr,dc)=(1,0), n_grey=2, (dr_final,dc_final)=(1,0).\n   - If v==6: set (dr,dc)=(-1,0), n_grey=5, (dr_final,dc_final)=(-1,0).\n4. For each seed, generate its grey segment positions: for i from 1 to n_grey, compute (r_i,c_i)=(r + i*dr, c + i*dc) and mark output[r_i][c_i]=5. Also record each (r_i,c_i) in a list of grey positions for that seed.\n5. For each seed, compute its final pixel position as (r_end,c_end)=(r + (n_grey+dr_final/dr_final==0?0:dr_final), c + (n_grey+dc_final/dc_final==0?0:dc_final)) correctly as (r + n_grey*dr + dr_final, c + n_grey*dc + dc_final). Set output[r_end][c_end]=v.\n6. Identify the set of overlapping grey cells: any coordinate present in the grey-position lists of two or more seeds. If this set is nonempty, let (r_o,c_o) be each such cell (there will be one in all examples).\n7. For each overlapping cell (r_o,c_o), set output[r_o][c_o]=4 (yellow).\n8. From each overlap (r_o,c_o), draw a southwest diagonal of 4’s: initialize (r_d,c_d)=(r_o+1, c_o-1). While 0<=r_d<rows and 0<=c_d<cols, set output[r_d][c_d]=4, then update r_d+=1, c_d-=1.\n9. Return the output grid.",
    "ad7e01d0": "1. Let N be the number of rows (and columns) in the input grid.  \n2. Let M = 5.  // Marker value corresponding to the gray canvas in the input  \n3. Initialize an output grid of size (N×N) rows by (N×N) columns, and fill every cell with 0.  \n4. For each input cell at row i (0 ≤ i < N) and column j (0 ≤ j < N):  \n   a. If input[i][j] == M, then copy the entire input grid into the output grid at the block whose top‐left corner is (i×N, j×N):  \n      i. For each r from 0 to N−1 and each c from 0 to N−1, set  \n         output[i×N + r][j×N + c] = input[r][c].  \n   b. Otherwise (input[i][j] ≠ M), leave the corresponding N×N block in the output as zeros.  \n5. Return the output grid.",
    "79fb03f4": "1. Let grid be the input of size H×W. Initialize output grid as a copy of the input.\n2. Identify all marker pixels M = {(r,c) | grid[r][c] == 1}.\n3. Identify all target pixels T = {(r,c) | grid[r][c] != 0 and grid[r][c] != 1} (this is one uniform color C).\n4. For each marker (r0,c0) in M:\n   a. Compute Manhattan distance d((r0,c0),(r,c)) = |r - r0| + |c - c0| for each (r,c) in T.\n   b. Select a target (rt,ct) in T that minimizes d; if multiple, choose the one with the largest column index.\n   c. For rr from rt-1 to rt+1 and cc from ct-1 to ct+1:\n      i. If (rr,cc) is within grid bounds and output[rr][cc] == 0, set output[rr][cc] = 1.\n5. Return the output grid.",
    "140c817e": "1. Let H and W be the height and width of the input grid.  \n2. Identify the background value B as the value that appears most frequently in the input.  \n3. Identify the marker value M as the other value (the only value not equal to B).  \n4. Let L be the list of all coordinates (r,c) where input[r][c] == M.  \n5. Initialize the output grid as a copy of the input grid.  \n6. For each (r,c) in L: set output[r][c] = 2.  \n7. For each (r,c) in L and for each diagonal offset (dr,dc) in {(-1,-1),(-1,1),(1,-1),(1,1)}:  \n   a. Let r2 = r + dr and c2 = c + dc.  \n   b. If 0 ≤ r2 < H and 0 ≤ c2 < W, set output[r2][c2] = 3.  \n8. For each (r,c) in L:  \n   a. For each column j from 0 to W-1, if (r,j) ≠ (r,c), set output[r][j] = 1.  \n   b. For each row i from 0 to H-1, if (i,c) ≠ (r,c), set output[i][c] = 1.  \n9. Leave all other cells unchanged.  \n10. Return the output grid.",
    "14754a24": "1. Let H = number of rows and W = number of columns of the input grid.\n2. Create an empty list C of center coordinates.\n3. For each cell (r,c) with 0 ≤ r < H and 0 ≤ c < W:\n   a. Let N4 be the count of its orthogonal neighbors (r-1,c), (r+1,c), (r,c-1), (r,c+1) that are within bounds and have value 4.\n   b. If N4 ≥ 2, append (r,c) to C.\n4. For each center (r,c) in C:\n   For each position (i,j) in {(r,c), (r-1,c), (r+1,c), (r,c-1), (r,c+1)}:\n     If (i,j) is within bounds and grid[i][j] == 5, set grid[i][j] = 2.\n5. Return the modified grid as the output.",
    "7bb29440": "1. Initialize an empty list rectangles.\n2. Create a boolean array visited of same size as input grid, all false.\n3. For each cell (r,c) in row-major order:\n   a. If grid[r][c] > 0 and visited[r][c] is false, then:\n      i. Perform a flood fill from (r,c) over orthogonal neighbors, collecting all cells (r',c') with grid[r'][c'] > 0; mark each visited[r'][c'] = true.\n      ii. Compute min_r = minimum r' in collected cells; max_r = maximum r'; min_c = minimum c'; max_c = maximum c'.\n      iii. Check if for every i in [min_r..max_r] and j in [min_c..max_c], grid[i][j] > 0; if any grid[i][j] == 0, skip this component.\n      iv. Let special_count = count of cells (i,j) with i in [min_r..max_r], j in [min_c..max_c] where grid[i][j] == 4 or grid[i][j] == 6.\n      v. Let area = (max_r - min_r + 1) * (max_c - min_c + 1).\n      vi. Append record (min_r, max_r, min_c, max_c, special_count, area) to rectangles.\n4. From rectangles, select the record with the smallest special_count; if multiple, select the one with the smallest area.\n5. Let (min_r, max_r, min_c, max_c) be from the selected record. Extract and return the subgrid consisting of rows min_r..max_r and columns min_c..max_c from the input grid.",
    "ae58858e": "1. Create an output grid identical to the input grid. 2. Initialize an empty set VISITED. 3. For each cell (r,c) in the grid:    a. If input[r][c] ≠ 2 or (r,c) is in VISITED, skip to the next cell.    b. Otherwise, perform a flood fill:       i. Initialize a list COMPONENT = [(r,c)] and add (r,c) to VISITED.       ii. For each position (x,y) in COMPONENT, examine its four orthogonal neighbors (x-1,y), (x+1,y), (x,y-1), (x,y+1).       iii. If a neighbor (nx,ny) is within grid bounds, input[nx][ny] == 2, and (nx,ny) is not in VISITED, then add (nx,ny) to COMPONENT and to VISITED.       iv. Repeat until COMPONENT contains all orthogonally connected cells of value 2.    c. If the size of COMPONENT is ≥ 4, then for each (x,y) in COMPONENT set output[x][y] = 6. 4. Return the output grid.",
    "15113be4": "1. Identify separator color 4. Treat any row or column entirely of 4s as a gridline; these gridlines partition the grid into 3×3 “cells” (sub‐grids).\n2. Let R be the set of 3×3 cells (by their top‐left coordinates) that contain at least one pixel of a color C that is not in {0,1,4}. Exactly four such cells form a 2×2 block of cells (call this the “large square”).\n3. Record C as the template color (the only non‐{0,1,4} in that 2×2 block).\n4. For each of the four cells of the large square, build a mask M: the set of offsets (dr,dc) within the 3×3 cell for which the pixel equals C.\n   • Denote these four masks M00, M01, M10, M11 corresponding to cell‐row∈{0,1} and cell‐col∈{0,1} within the large square.\n5. For every other 3×3 cell whose nine pixels are all the same uniform color K∈{0,1} (i.e. all 0 or all 1), do:\n   a. Let (i,j) = (cell_row mod 2, cell_col mod 2).\n   b. Look up mask Mij.\n   c. For each offset (dr,dc) in Mij, set the pixel at that cell’s top‐left coordinate plus (dr,dc) to C; leave all other pixels unchanged.\n6. Leave all gridline pixels (value 4) intact.\n7. Return the modified grid.",
    "7c8af763": "1. Identify each connected component of pixels with value 0 (zero) using 4-connectivity (neighbors at up, down, left, right).\n2. For each 0-component, initialize two counters: count1 = 0 and count2 = 0.\n3. For each pixel (r,c) in the 0-component, examine its 4 neighbors at (r-1,c), (r+1,c), (r,c-1) and (r,c+1) that lie within grid bounds:\n   a. If a neighbor’s value = 1, increment count1.\n   b. If a neighbor’s value = 2, increment count2.\n   c. Otherwise (neighbor value 0 or 5), ignore.\n4. After processing all pixels of the component, compare count1 and count2:\n   a. If count1 > count2, set fillColor = 1.\n   b. Otherwise (count2 ≥ count1), set fillColor = 2.\n5. Replace every pixel in the 0-component with fillColor.\n6. Leave all pixels not in any 0-component unchanged.\n7. Return the resulting grid.",
    "aee291af": "1. Let G be the input grid of size H×W.  \n2. Compute the frequency of each color value in G.  Let C_bg be the color with the greatest count.  Let C_border be the color (≠C_bg) with the next greatest count.  Let C_shape be any remaining color (≠C_bg,≠C_border).  \n3. Find all connected components of pixels with value C_border using 4‐connected adjacency.  For each component comp:  \n   a. Compute its bounding box: r0=min_row(comp), r1=max_row(comp), c0=min_col(comp), c1=max_col(comp).  \n   b. If (r1–r0)==(c1–c0) (box is square) AND every cell on the perimeter of that bounding box has value C_border, then record this box with coordinates (r0,r1,c0,c1).  \n4. You now have exactly four square border boxes.  For each box i with coords (r0_i,r1_i,c0_i,c1_i):  \n   a. Extract its interior subgrid I_i of size (r1_i–r0_i–1)×(c1_i–c0_i–1) at rows r0_i+1…r1_i–1 and cols c0_i+1…c1_i–1.  \n5. Compare the four interiors I_1…I_4 as 2D arrays.  Identify the unique interior pattern I_u that occurs only once.  Let the corresponding box be (r0_u,r1_u,c0_u,c1_u).  \n6. Extract the full subgrid B from G at rows r0_u…r1_u and cols c0_u…c1_u (this includes the border of C_border and the interior).  \n7. Return B as the output grid.",
    "15663ba9": "1. Identify external background zeros:\n   a. Initialize a boolean grid External[r][c]=false for all cells.\n   b. For each cell on the grid border with value 0, perform a 4-connected flood fill to mark External[r][c]=true for every reachable cell with value 0.\n2. Initialize the output grid as a copy of the input grid.\n3. For each cell (r,c) in the grid whose input value V≠0 do:\n   a. Let Z be the list of its 4-neighbors (up, down, left, right) whose input value is 0.\n   b. If |Z|=2 and the two neighbors are not opposite directions (i.e., they form an orthogonal corner) then:\n      i. Let externalCount = number of cells in Z for which External=true.\n      ii. If externalCount = 2 then // both zeros belong to external background\n            set output[r][c] = 4   // outside corner => yellow\n         else // at least one zero is part of an internal hole\n            set output[r][c] = 2   // inside corner => red\n4. Return the output grid.",
    "7c9b52a0": "1. Let grid be the input 2D array of size R×C.  \n2. Let border_color = grid[0][0].  \n3. Compute border_rows as the sorted list of all row indices r such that for every column c in 0…C−1, grid[r][c] == border_color.  \n4. Compute border_cols as the sorted list of all column indices c such that for every row r in 0…R−1, grid[r][c] == border_color.  \n5. Build row_intervals: for each adjacent pair border_rows[k], border_rows[k+1], if border_rows[k+1] > border_rows[k]+1 then add interval [r0 = border_rows[k]+1, r1 = border_rows[k+1]–1].  \n6. Build col_intervals similarly from border_cols: for each adjacent pair border_cols[k], border_cols[k+1], if border_cols[k+1] > border_cols[k]+1 then add interval [c0 = border_cols[k]+1, c1 = border_cols[k+1]–1].  \n7. Let H = row_intervals[0].r1 – row_intervals[0].r0 + 1 and W = col_intervals[0].c1 – col_intervals[0].c0 + 1.  Assert every interval in row_intervals has height H and every interval in col_intervals has width W.  \n8. Initialize an output grid out of size H×W with all entries 0.  \n9. For each row interval [r0,r1] in row_intervals in ascending order, and for each col interval [c0,c1] in col_intervals in ascending order:  \n   a. For i from 0 to H–1 and j from 0 to W–1:  \n      i. Let v = grid[r0 + i][c0 + j].  \n      ii. If v != 0 and v != border_color then set out[i][j] = v.  \n10. Return out as the output grid.",
    "af22c60d": "1. Let H = number of rows in grid, W = number of columns.\n2. Define the symmetry center as:\n   • center_r = H // 2  (integer division)\n   • center_c = W // 2\n3. Iterate over every cell (r, c) with 0 ≤ r < H and 0 ≤ c < W:\n   a. If grid[r][c] ≠ 0, continue to next cell.\n   b. Compute the three mirror positions:\n      i.   (r_mirror_h, c_mirror_h) = (2*center_r - r, c)         // horizontal reflection\n      ii.  (r_mirror_v, c_mirror_v) = (r, 2*center_c - c)         // vertical reflection\n      iii. (r_mirror_d, c_mirror_d) = (2*center_r - r, 2*center_c - c) // diagonal reflection\n   c. In the order (i), (ii), (iii), check each mirror position (rm, cm):\n      • If 0 ≤ rm < H and 0 ≤ cm < W and grid[rm][cm] ≠ 0, set grid[r][c] = grid[rm][cm] and break.\n4. After filling all zeros, the grid is both vertically and horizontally symmetric around (center_r, center_c).\n5. Return the completed grid.",
    "15696249": "1. Let A be the input 3×3 grid, indexed A[i][j] for i,j in 0..2.  \n2. Identify the solid stripe:  \n   a. For each row r in 0..2, if A[r][0] == A[r][1] == A[r][2], set orientation = horizontal and stripeIndex = r, then go to step 3.  \n   b. Otherwise, for each column c in 0..2, if A[0][c] == A[1][c] == A[2][c], set orientation = vertical and stripeIndex = c, then go to step 3.  \n3. Create an output grid B of size 9×9 and initialize all B[x][y] = 0 for x,y in 0..8.  \n4. If orientation is horizontal:  \n   For each blockCol in 0..2 and for each local i,j in 0..2, set B[stripeIndex*3 + i][blockCol*3 + j] = A[i][j].  \n   Else (orientation is vertical):  \n   For each blockRow in 0..2 and for each local i,j in 0..2, set B[blockRow*3 + i][stripeIndex*3 + j] = A[i][j].  \n5. Return B as the 9×9 output grid.",
    "7d18a6fb": "1. Locate the blue key region:\n   a. Collect all coordinates (r,c) where grid[r][c]==1.\n   b. Let minR = minimum r, maxR = maximum r among those; let minC = minimum c, maxC = maximum c.\n   c. Confirm that maxR−minR+1 == 7 and maxC−minC+1 == 7.\n2. Read the four key colors in row-major order at offsets inside the key:\n   a. TL_color = grid[minR+1][minC+1]\n   b. TR_color = grid[minR+1][minC+5]\n   c. BL_color = grid[minR+5][minC+1]\n   d. BR_color = grid[minR+5][minC+5]\n   e. Let colors = [TL_color, TR_color, BL_color, BR_color].\n3. For each color c in colors:\n   a. Collect shapeCells[c] = all coordinates (r,c2) where grid[r][c2]==c and not (minR ≤ r ≤ maxR and minC ≤ c2 ≤ maxC).\n   b. Compute for shape c: minSr = min r in shapeCells[c], maxSr = max r; minSc = min c2, maxSc = max.\n4. Initialize output as a 7×7 array of zeros.\n5. Place each shape into the output quadrants in the same order as colors:\n   For index i from 0 to 3:\n     a. Let originR = (i<2 ? 0 : 4).\n     b. Let originC = (i%2 == 0 ? 0 : 4).\n     c. Let c = colors[i].\n     d. For each (r,c2) in shapeCells[c]:\n         output[ originR + (r − minSr[c]) ] [ originC + (c2 − minSc[c]) ] = c\n6. Leave row 3 and column 3 of output as zeros (they remain separators).",
    "af24b4cc": "1. Let inputGrid be the given 9-row by 10-column grid of integers (values 0–9). 2. Create outputGrid of size 4 rows × 5 columns and initialize every cell to 0. 3. For each blockRow in 0..1 do:  \n   a. Compute rowStart = 1 + blockRow * 4.  \n   b. For each blockCol in 0..2 do:  \n      i. Compute colStart = 1 + blockCol * 3.  \n      ii. Collect all values in the 3×2 subgrid of inputGrid with rows rowStart .. rowStart+2 and columns colStart .. colStart+1.  \n      iii. Determine modeValue = the integer that occurs most frequently in that subgrid.  \n      iv. Set outputGrid[row = 1 + blockRow][col = 1 + blockCol] = modeValue.  \n4. Return outputGrid.",
    "16b78196": "1. Identify region_color: compute the total count of each non-zero color c in the grid; region_color = the color with the maximum count.  \n2. Compute the bounding box of the region: find min_row, max_row, min_col, max_col over all positions (r,c) where grid[r][c] == region_color.  \n3. Within that bounding box, find hole components: consider all positions (r,c) inside the box where grid[r][c] == 0; compute their 4-connected connected components (holes).  \n4. Find puzzle pieces: for each color c ≠ 0 and c ≠ region_color, find all 4-connected components of color c anywhere in the grid.  \n5. For each hole component H:  \n   a. Compute H’s bounding box (hmin_r,hmax_r,hmin_c,hmax_c) and its set of relative coordinates RH = {(r–hmin_r, c–hmin_c) | (r,c) in H}.  \n   b. Among the puzzle pieces, find a component P of some color p_color whose bounding box (pmin_r,pmax_r,pmin_c,pmax_c) yields the same relative coordinate set RP = {(r–pmin_r, c–pmin_c) | (r,c) in P} == RH.  \n   c. Remove P from its original location: for each (r,c) in P set grid[r][c] = 0.  \n   d. Place P into the hole: for each (dr,dc) in RH set grid[hmin_r+dr][hmin_c+dc] = p_color.  \n   e. Mark P and H as filled and do not reuse them.  \n6. After all hole components are filled, leave all other cells unchanged and output the resulting grid.",
    "7d1f7ee8": "1. Define coordinates with row index R from 0 at top to H-1 at bottom, and column index C from 0 at left to W-1 at right.\n2. Let GRID be the input H×W array of integers 0–9.\n3. Find all non-zero connected components:\n   a. For each color value c in 1..9, find each maximal orthogonally‐connected set of cells S where GRID[r][c]==c.\n   b. For each component S, compute minR = min(r), maxR = max(r), minC = min(c), maxC = max(c).\n   c. If S contains exactly all cells on the perimeter of the rectangle defined by (minR,minC) to (maxR,maxC)—i.e. every cell in S satisfies (r==minR or r==maxR or c==minC or c==maxC), and no perimeter cell is missing—then record a rectangle object Rect = {top=minR, bottom=maxR, left=minC, right=maxC, color=c}.\n4. Sort the list of Rect objects in ascending order of area = (bottom−top+1)×(right−left+1).\n5. For each Rect in the sorted list (from smallest area to largest):\n   For every row r in (top+1) through (bottom−1):\n     For every column c in (left+1) through (right−1):\n       If GRID[r][c] ≠ 0: set GRID[r][c] = Rect.color.\n6. The resulting GRID is the output.",
    "b0722778": "1. Let R be the number of rows in the input grid. Initialize an output grid of size R×2 filled with zeros.\n2. Identify all row indices i where the entire row i in the input is nonzero (contains at least one nonzero cell). These nonzero rows form groups separated by rows that are all zeros. Each group consists of exactly two consecutive nonzero rows followed by at least one all-zero row (or end of grid).\n3. For each group of two consecutive nonzero rows with indices r0 and r1:\n   a. Extract three 2×2 blocks from these rows:\n      • Block A (left block): A[0,0]=input[r0][0], A[0,1]=input[r0][1], A[1,0]=input[r1][0], A[1,1]=input[r1][1]\n      • Block B (middle block): B[0,0]=input[r0][3], B[0,1]=input[r0][4], B[1,0]=input[r1][3], B[1,1]=input[r1][4]\n      • Block C (right block): C[0,0]=input[r0][7], C[0,1]=input[r0][8], C[1,0]=input[r1][7], C[1,1]=input[r1][8]\n   b. Define the four positions PSet = {(0,0),(0,1),(1,0),(1,1)}. Consider the eight spatial permutations P on PSet corresponding to the isometries of a 2×2 grid (identity, rotations by 90°,180°,270°, and reflections). For each candidate permutation P:\n      i. Attempt to build a color mapping M from values in A to values in B as follows: for each (i,j) in PSet, let src = A[P(i,j)] and dst = B[i,j]. Check that every occurrence of the same src maps to the same dst. If consistent for all four positions, accept P and its corresponding M (a function mapping each distinct src to dst).\n      ii. If P and M are found that satisfy B[i,j] = M(A[P(i,j)]) for all (i,j), stop searching.\n   c. Construct a new 2×2 block D by applying P and M to C: for each (i,j) in PSet, set D[i,j] = M(C[P(i,j)]) (if C[P(i,j)] is not a key in M, use C[P(i,j)] unchanged).\n   d. Write D into the output grid at rows r0 and r1: output[r0][0] = D[0,0], output[r0][1] = D[0,1], output[r1][0] = D[1,0], output[r1][1] = D[1,1].\n4. For any row i that is entirely zero in the input, leave output[i] as [0,0].\n5. Return the output grid of size R×2.",
    "17b80ad2": "1. Let H be the number of rows and W be the number of columns in the input grid. Rows are indexed 0..H-1 (top to bottom), columns 0..W-1 (left to right).\n2. Initialize the output grid as a copy of the input grid.\n3. For each column j from 0 to W-1:\n   a. If the bottom cell input_grid[H-1][j] is 5 (grey):\n      i.   Set current_color = 5.\n      ii.  For r from H-1 down to 0:\n           - If input_grid[r][j] != 0:\n               * Set current_color = input_grid[r][j].\n               * Set output_grid[r][j] = input_grid[r][j].\n           - Else:\n               * Set output_grid[r][j] = current_color.\n   b. Otherwise (if input_grid[H-1][j] ≠ 5): leave output_grid[r][j] unchanged for all r.\n4. Return the output grid.",
    "7d419a02": "1. Locate the 2×2 pink block (value 6): collect all positions (r,c) with grid[r][c]==6. Compute r0 = minimum r, c0 = minimum c among these; these define the top-left of the pink block.\n2. Detect all 2×2 blue blocks (value 8): for each position (rb,cb) such that grid[rb][cb]==8, grid[rb][cb+1]==8, grid[rb+1][cb]==8, and grid[rb+1][cb+1]==8, add (rb,cb) to set B.\n3. Build sorted index lists:\n   a. Let rowsList = sorted unique values of all rb in B plus r0.\n   b. Let colsList = sorted unique values of all cb in B plus c0.\n4. Compute pink block indices: i0 = index of r0 in rowsList; j0 = index of c0 in colsList.\n5. For each (rb,cb) in B:\n   a. Let i = index of rb in rowsList; let j = index of cb in colsList.\n   b. If abs(i - i0) == abs(j - j0) and (i != i0 or j != j0), then for each (r,c) in {(rb,cb),(rb,cb+1),(rb+1,cb),(rb+1,cb+1)}, set grid[r][c] = 4.\n6. Preserve all other cells unchanged.",
    "b0f4d537": "1. Locate the vertical separator column sep where every cell in that column has value 5. 2. Define left_region as all columns c in [0 .. sep-1] and right_region as all columns c in [sep+1 .. C-1]. 3. In left_region, identify all vertical stripes:\n   a. For each column c_L in left_region, collect values v = { left[r][c_L] | left[r][c_L] not in {0,5} }.\n   b. If v contains exactly one distinct color c_V and occurs in at least two rows, record (c_L,c_V).\n   c. Sort the list vertical_stripes by c_L ascending. 4. In left_region, identify all horizontal stripes:\n   a. For each row r_L in left_region, collect values h = { left[r_L][c] | left[r_L][c] not in {0,5} }.\n   b. If h contains exactly one distinct color c_H and occurs in at least two columns, record (r_L,c_H).\n   c. Sort the list horizontal_stripes by r_L ascending. 5. In right_region, let M be the marker color: the distinct nonzero, non-5 value that appears in right_region (it is always 4). 6. Compute reference column for horizontal mapping:\n   a. Let (c_L0,_) = first element of vertical_stripes.\n   b. Compute c_R_ref = sep + 1 + c_L0. 7. Scan right_region at column c_R_ref and collect rows R = sorted { r | right[r][c_R_ref] == M }.\n8. For k=0 .. horizontal_stripes.size-1:\n   a. Let (r_Lk,c_Hk) = horizontal_stripes[k].\n   b. Let r_out = R[k].\n   c. Fill entire row r_out, columns 0..W_out-1, of the output grid with color c_Hk. 9. Compute reference row for vertical mapping:\n   a. Let r_ref = R[0].\n   b. In right_region at row r_ref collect columns C = sorted { c | right[r_ref][c] == M }.\n   c. Let N = vertical_stripes.size, drop d = (C.size - N)/2 elements from the start and end of C to obtain a sublist C_used of length N.\n10. For j=0 .. vertical_stripes.size-1:\n   a. Let (c_Lj,c_Vj) = vertical_stripes[j].\n   b. Let c_out = C_used[j].\n   c. Fill entire column c_out, rows 0..H_out-1, of the output grid with color c_Vj.\n11. Initialize all other cells of the output grid to 0.\n\nDefinitions:\n- left[r][c] and right[r][c] refer to the input grid's values in left_region and right_region.\n- W_out and H_out are the width and height of right_region.\n- Output grid has dimensions H_out x W_out.\n- sep is in absolute input-column coordinates; output uses 0-based columns within right_region.",
    "17cae0c1": "1. Partition the input grid of size 3×9 into three consecutive 3×3 blocks: for each block index i in {0,1,2}, let its rows be 0–2 and its columns be i*3 through i*3+2.  \n2. For each block, compute the set S of relative coordinates (r,c) with 0≤r,c≤2 where the input pixel equals 5.  \n3. Determine the block’s output color code by matching S exactly to one of these five patterns:  \n   3.1 If S == {(0,0),(0,1),(0,2),(1,0),(1,2),(2,0),(2,1),(2,2)} (a frame of 5’s around the center), assign color 3.  \n   3.2 Else if S == {(1,1)} (only the center), assign color 4.  \n   3.3 Else if S == {(0,2),(1,1),(2,0)} (diagonal from top-right to bottom-left), assign color 9.  \n   3.4 Else if S == {(2,0),(2,1),(2,2)} (bottom row), assign color 1.  \n   3.5 Else if S == {(0,0),(0,1),(0,2)} (top row), assign color 6.  \n4. Construct the output grid by replacing each 3×3 block with a solid block of its assigned color code: fill all cells in that block (rows 0–2, columns i*3–i*3+2) with the block’s color.  \n5. Return the resulting 3×9 grid.",
    "7e02026e": "1. Let H be the number of rows and W be the number of columns in the input grid. Use 0-based indexing for rows and columns.\n2. Create an empty set S of coordinates.\n3. For each row r from 1 to H-2 and each column c from 1 to W-2, do:\n   a. If grid[r][c] == 0 and grid[r-1][c] == 0 and grid[r+1][c] == 0 and grid[r][c-1] == 0 and grid[r][c+1] == 0, then:\n      i. Add (r, c) to S.\n      ii. Add (r-1, c), (r+1, c), (r, c-1), and (r, c+1) to S.\n4. For each coordinate (r, c) in S, set grid[r][c] = 3.\n5. Return the modified grid.",
    "b15fca0b": "1. Let H and W be the number of rows and columns of the input grid G. 2. Scan all cells of G to find exactly two cells with value 2; name their coordinates S=(rS,cS) and T=(rT,cT). 3. Initialize an empty queue Q and a 2D array parent of size H×W filled with null. 4. Enqueue S into Q and mark parent[rS][cS]=S. 5. While Q is not empty:\n   a. Dequeue the front cell (r,c).\n   b. If (r,c)==T, break the loop.\n   c. For each of the four neighbor coordinates (r+1,c), (r-1,c), (r,c+1), (r,c-1) that lie within the grid bounds:\n      i. If parent[rn][cn] is null and G[rn][cn]≠1 (i.e., not a blue wall):\n         • Set parent[rn][cn]=(r,c).\n         • Enqueue (rn,cn) into Q.\n6. Reconstruct the shortest path P by starting at T and following parent links back to S, collecting each coordinate. 7. For each coordinate (r,c) in P except S and T: set G[r][c]=4. 8. Return the modified G as the output grid.",
    "18419cfa": "1. Identify all connected components of cell value 8 using 4-connectivity.   \n2. For each component:   \n   a. Compute its bounding box: min_row, max_row, min_col, max_col (the minimum and maximum row and column indices of its 8 pixels).   \n   b. Define the interior of the component as all cells (r,c) satisfying min_row<r<max_row and min_col<c<max_col.   \n   c. For each interior cell (r,c) whose current value is 2:   \n      i. Compute its mirror column c_mirror = min_col + max_col - c.   \n     ii. If the cell at (r, c_mirror) lies within the interior (min_row<r<max_row and min_col<c_mirror<max_col) and its current value is 0, set that cell to 2.   \n3. Leave all other cells unchanged and return the resulting grid.",
    "7ee1c6ea": "1. Scan the entire input grid and collect coordinates of every pixel with value 5.\n2. Compute min_row = minimum row index among those coordinates, max_row = maximum row index, min_col = minimum column index, max_col = maximum column index. These define the grey border rectangle.\n3. Initialize an empty set S. For each coordinate (r,c) such that min_row < r < max_row and min_col < c < max_col, let v = input[r][c]. If v ≠ 0 and v ≠ 5, add v to S.\n4. Verify that S contains exactly two distinct values; label them vA and vB.\n5. Create the output grid as a copy of the input grid.\n6. For each coordinate (r,c) with min_row < r < max_row and min_col < c < max_col:\n   a. If input[r][c] = vA, set output[r][c] = vB.\n   b. Else if input[r][c] = vB, set output[r][c] = vA.\n   c. Else (input[r][c] = 0 or 5), leave output[r][c] unchanged.\n7. Leave every cell with r ≤ min_row or r ≥ max_row or c ≤ min_col or c ≥ max_col unchanged in the output.\n8. Return the output grid.",
    "b1fc8b8e": "1. Input: a 6×6 grid of integers (0 or 8). Output: a 5×5 grid.\n2. Identify all cells with value 8 in the input; they form one connected cluster of 12 cells that is composed of four identical L-shaped subclusters of size 3 each, rotated by 0°, 90°, 180°, and 270° around the cluster center.\n3. Define the prototype L-shape as three cells: two orthogonally adjacent cells forming a length-2 segment, plus a third cell adjacent to the second segment cell in the perpendicular direction (i.e., a 2-cell arm with a 1-cell foot at its end).\n4. In the output 5×5 grid, place four copies of this prototype L-shape, each with its corner cell located at one of the four grid corners, oriented so that:\n   a. Top-left copy: foot extends right from the corner of the vertical segment that extends down.\n   b. Top-right copy: foot extends left from the corner of the vertical segment that extends down.\n   c. Bottom-left copy: foot extends right from the corner of the vertical segment that extends up.\n   d. Bottom-right copy: foot extends left from the corner of the vertical segment that extends up.\n5. Concretely, set output cells to 8 at coordinates (row,column):\n   a. Top-left L: (0,1), (1,1), (1,0)\n   b. Top-right L: (0,4), (1,4), (1,3)\n   c. Bottom-left L: (3,1), (4,1), (4,0)\n   d. Bottom-right L: (3,4), (4,4), (4,3)\n6. Set all other output cells to 0.",
    "184a9768": "1. Replace all cells with value 5 by 0.\n2. Identify all connected components of non-zero cells using 4-connectivity. For each component, record its pixel count and its pixel value.\n3. Sort these components in descending order by pixel count. Let the first two be TARGET_A and TARGET_B.\n4. For each TARGET in [TARGET_A, TARGET_B]:\n   a. Compute its bounding box: rows r_min..r_max and columns c_min..c_max.\n   b. Within that bounding box, find all cells equal to 0. Compute the connected component of these 0-cells that lies strictly inside the bounding box (the HOLE).\n   c. Determine HOLE’s bounding box: rows h_r_min..h_r_max and columns h_c_min..h_c_max. Let H = h_r_max-h_r_min+1 and W = h_c_max-h_c_min+1.\n   d. Among the remaining components (excluding TARGET_A and TARGET_B), find the unique component PIECE whose bounding box height equals H and width equals W. (PIECE.value is its integer color.)\n   e. Remove PIECE from its original location by setting all its cells to 0.\n   f. Fill the HOLE region: for all row in h_r_min..h_r_max and col in h_c_min..h_c_max, set grid[row][col] = PIECE.value.\n5. After both TARGETs are processed, clear any non-zero cells outside TARGET_A and TARGET_B regions by setting them to 0.\n6. Return the resulting grid.",
    "817e6c09": "1. Locate Tiles: Scan the grid and identify every 2×2 tile whose all four cells equal 2. For each such tile, record its top-left coordinate (r, c).\n2. Extract Unique Columns: From those tiles, extract the set of distinct top-left column indices. Sort this list of unique columns in ascending order to form [C0, C1, …, Ck].\n3. Column Indexing: Build a map from each column Ci to its index i in the sorted list.\n4. Recoloring Rule: For each identified 2×2 tile at top-left (r, c):\n   a. Let i = index of c in the sorted unique-columns list.\n   b. If i mod 2 == 0, set all four cells of that tile to 8; otherwise leave them as 2.\n5. Output: Produce the modified grid.",
    "b20f7c8b": "1. Define legend_background_color = 8 (pale blue). 2. Identify legend shapes:  \n   a. Find every connected component CC of cells with color ≠ legend_background_color and ≠ 0 whose bounding box is not 5×5.  \n   b. For each CC, record:\n      • shape_color = the common color value of CC.\n      • bounding box (min_row..max_row, min_col..max_col).  \n      • shape_pattern = set of relative coordinates (r – min_row, c – min_col) for each cell of CC.  \n   Store these as legend_shapes[].  \n3. Identify all 5×5 target blocks:  \n   For each position (R,C) with 0 ≤ R ≤ H–5 and 0 ≤ C ≤ W–5, extract subgrid S of size 5×5.  If all of these hold, record block at (R,C):  \n   a. No cell in S has color = legend_background_color or 0.  \n   b. All cells on the perimeter of S share the same color border_color (≠ legend_background_color, ≠ 0).  \n   c. The interior of S (rows R+1..R+3, cols C+1..C+3) contains only colors in {border_color} ∪ X, where X are other nonzero colors.  \n4. For each target block at (R,C) with border_color and its 5×5 cells:  \n   a. Let interior_colors = set of S[r][c] for r∈R+1..R+3, c∈C+1..C+3 excluding border_color.  \n   b. If interior_colors is empty (solid block):  \n      i. fill_color = border_color.  \n      ii. Find legend_shape in legend_shapes with shape_color = fill_color; let P = its shape_pattern.  \n      iii. Replace S by new 5×5 grid T:  \n           – For each i=0..4, j=0..4:  \n             • If i=0 or i=4 or j=0 or j=4: T[i][j] = legend_background_color.  \n             • Else if (i-1, j-1) ∈ P: T[i][j] = fill_color.  \n             • Else: T[i][j] = legend_background_color.  \n   c. Else (interior_colors contains one value silhouette_color):  \n      i. silhouette_pattern = set of (r–(R+1), c–(C+1)) where S[r][c] = silhouette_color.  \n      ii. Find legend_shape in legend_shapes with shape_pattern = silhouette_pattern; let fill_color = legend_shape.shape_color.  \n      iii. Overwrite all 25 cells of S with fill_color.  \n5. Return the modified grid.",
    "195ba7dc": "1. Let input be a grid of integers. 2. Find column index S such that every row at column S has value 2. 3. Let W = S and H = number of rows. 4. Create an empty output grid of size H rows and W columns. 5. For each row r from 0 to H-1:   a. For each column c from 0 to W-1:     i. Let L = input[r][c]   (left block)    ii. Let R = input[r][c + S + 1]   (right block)   iii. If L == 0 AND R == 0 then set output[r][c] = 0 else set output[r][c] = 1. 6. Return the output grid.",
    "81c0276b": "1. Let H be the number of rows and W the number of columns of the input grid.\n2. Identify sep_color: for each integer c from 1 to 9, if there exists a row r such that for all columns x grid[r][x]==c or there exists a column x such that for all rows r grid[r][x]==c, then set sep_color=c and stop.\n3. Initialize an empty map counts from integer to integer.\n4. For each row r from 0 to H-2 and each column x from 0 to W-2:\n   a. Let v = grid[r][x].\n   b. If v!=0 and v!=sep_color and grid[r][x+1]==v and grid[r+1][x]==v and grid[r+1][x+1]==v, then increment counts[v] by 1 (initialize counts[v]=0 if absent).\n5. Let colors be the list of keys in counts, sorted in ascending order by counts[color].\n6. Let max_count = the maximum value among counts[color] for color in colors.\n7. Create an output grid of size R rows and C columns, where R = length of colors and C = max_count, and initialize all cells to 0.\n8. For each index i from 0 to R-1:\n   a. Let color = colors[i] and n = counts[color].\n   b. For j from 0 to n-1, set output[i][j] = color.\n9. Return the output grid.",
    "b457fec5": "1. Identify the sample sequence:\n   1.1. Locate the first row (sampleRow) that contains contiguous non-zero cells none of which equal 5, and immediately below which begins a region of cells of value 5.\n   1.2. In sampleRow, extract the values of the longest contiguous run of non-zero, non-5 cells from left to right into an array sample[0..L-1], where L is its length.\n2. Identify the grey region:\n   2.1. Let greyCells be the set of all coordinates (r,c) whose value is 5 and that form a single connected region.\n   2.2. Find the minimal row r0 among greyCells; among those cells at row r0, let c0 be the minimal column.\n   2.3. Find the minimal row r1>r0 among greyCells; among those at row r1, let c1 be the minimal column.\n3. Determine orientation:\n   3.1. If c1 – c0 ≥ 0, set orientation = \"right\"; else set orientation = \"left\".\n4. For each (r,c) in greyCells:\n   4.1. Compute rRel = r – r0.\n   4.2. If orientation == \"right\", compute cRel = c – c0; else compute cRel = c0 – c.\n   4.3. Compute d = min(rRel, cRel).\n   4.4. If d ≥ L, set d = L – 1.\n   4.5. Replace cell (r,c) value 5 with sample[d].\n5. Leave all other cells unchanged and output the modified grid.",
    "1990f7a8": "1. Let R and C be the number of rows and columns of the input grid. 2. Identify all orthogonally connected components of cells with value 2 (ignore cells with value 0). 3. For each component i:   a. Compute its bounding box: min_row_i, max_row_i, min_col_i, max_col_i.   b. Compute its height H_i = max_row_i – min_row_i + 1 and width W_i = max_col_i – min_col_i + 1.   c. Record the set S_i of relative positions of its nonzero pixels: for each cell (r,c) in the component, include (r–min_row_i, c–min_col_i).   d. Compute its center coordinates: center_row_i = (min_row_i + max_row_i)/2.0, center_col_i = (min_col_i + max_col_i)/2.0. 4. Create an output grid of size 7×7 filled with zeros. 5. For each component i, assign it to one of four corners based on its center:   – If center_row_i < R/2 and center_col_i < C/2 ⇒ top-left.   – If center_row_i < R/2 and center_col_i ≥ C/2 ⇒ top-right.   – If center_row_i ≥ R/2 and center_col_i < C/2 ⇒ bottom-left.   – Otherwise ⇒ bottom-right. 6. For each component i, let (dr,dc) be its target offset in the output:   – top-left: dr=0, dc=0.   – top-right: dr=0, dc=7–W_i.   – bottom-left: dr=7–H_i, dc=0.   – bottom-right: dr=7–H_i, dc=7–W_i. 7. For each (r,c) in S_i, set output[dr + r][dc + c] = 2. 8. Return the 7×7 output grid.",
    "833dafe3": "1. Let R = number of rows in the input grid and C = number of columns in the input grid.  \n2. Create an output grid with 2R rows and 2C columns.  \n3. For each row index r from 0 to R-1 and each column index c from 0 to C-1:  \n   a. Let v = input[r][c].  \n   b. Set output[r + R][c + C] = v.                     // bottom-right quadrant: original  \n   c. Set output[r + R][(C - 1 - c)] = v.               // bottom-left quadrant: horizontal flip  \n   d. Set output[(R - 1 - r)][c + C] = v.               // top-right quadrant: vertical flip  \n   e. Set output[(R - 1 - r)][(C - 1 - c)] = v.         // top-left quadrant: horizontal + vertical flip  ",
    "b4a43f3b": "1. Let H and W be the input grid’s height and width.\n2. Find the divider row R_div such that for all c in [0,W), grid[R_div][c]==5.\n3. Define the pattern region as rows 0..R_div-1 and cols 0..W-1. Its height H_p=R_div and width W_p=W.\n4. Compute small grid dimensions: h_s = H_p/2, w_s = W_p/2 (both integral).\n5. Construct small grid S of size h_s×w_s: for each i in [0,h_s), j in [0,w_s), set S[i][j] = grid[2*i][2*j].\n6. Define marker region as rows R_div+1..R_div+2*h_s and cols 0..2*w_s-1. Partition it into h_s×w_s non-overlapping 2×2 segments. Segment (i,j) covers rows [R_div+1+2*i, R_div+2+2*i] and cols [2*j,2*j+1].\n7. For each segment (i,j), if any cell in that 2×2 has value 2, record placement (i,j).\n8. Set tile size T_y=T_x = 2*h_s.\n9. Create an output grid of size (h_s*T_y)×(w_s*T_x), initialized to 0.\n10. For each recorded placement (i,j) and for each a in [0,h_s), b in [0,w_s):\n    a. If S[a][b]≠0, then set output[i*T_y + h_s + a][j*T_x + w_s + b] = S[a][b].\n11. Return the output grid.",
    "19bb5feb": "1. Identify the bounding rectangle of the 8-valued region:  \n   a. Let R8 = set of all grid coordinates (r,c) where grid[r][c] == 8.  \n   b. Compute r_min = minimum r in R8, r_max = maximum r in R8, c_min = minimum c in R8, c_max = maximum c in R8.  \n2. Compute height = r_max - r_min + 1 and width = c_max - c_min + 1.  \n3. Compute half_h = height / 2 and half_w = width / 2 (both integers).  \n4. Initialize a 2×2 output array OUT with all entries = 0.  \n5. For each output row index i in {0,1} and column index j in {0,1}:  \n   a. Let row_start = r_min + i * half_h and row_end = r_min + (i+1) * half_h - 1.  \n   b. Let col_start = c_min + j * half_w and col_end = c_min + (j+1) * half_w - 1.  \n   c. For r from row_start to row_end and c from col_start to col_end:  \n      i. If grid[r][c] != 8, set OUT[i][j] = grid[r][c] and break both loops for this (i,j).  \n6. Return OUT as the resulting 2×2 grid.",
    "845d6e51": "1. Let grid have dimensions H rows and W columns, indexed from 0.\n2. Locate the grey border (value 5) in the upper‐left corner:\n   a. In row 0, find the column C such that grid[0][C] == 5 and grid[0][C-1] != 5 (the first grey in row 0).\n   b. Starting at row 0, follow the vertical border at column C: find the smallest row R such that grid[R][C] != 5; then let border_row = R-1.\n   c. The key region is all cells with row < border_row and col < C.\n3. Extract key shapes:\n   a. In the key region, find all 4-connected components of cells with value != 0. For each component:\n      i. Let its color v be the common grid value of its cells.\n      ii. Compute its normalized shape S_v as the set of coordinate offsets {(r - r_min, c - c_min)} over its cells, where r_min and c_min are the minimum row and column of the component.\n   b. Store each (v, S_v) as a key shape.\n4. Recolor target shapes:\n   a. Find all 4-connected components of cells with value 3 (green) that lie entirely outside the key region (i.e., any cell has row >= border_row or col >= C).\n   b. For each component:\n      i. Compute its normalized pattern P as {(r - r_min, c - c_min)}.\n      ii. For each key shape (v, S_v), test if P equals S_v under any rotation by 0°, 90°, 180°, or 270° (apply rotations to P around its origin).\n      iii. When a match is found, set every cell of the component to color v and break.\n5. Leave all other cells unchanged. Return the resulting grid.",
    "b7999b51": "1. Identify the set C of all distinct nonzero values present in the input grid.\n2. For each color value c in C:\n   a. Let R_c be the set of row indices r (0-based, 0 at top) such that input[r][*] contains c in at least one column.\n   b. Compute height h_c = |R_c| (the number of rows in R_c).\n3. Sort the values in C into a list L = [c_0, c_1, …, c_{W-1}] in descending order of their heights h_c (if two colors have equal height, any order between them is acceptable).\n4. Let H = max_{c in C} h_c and W = |C|.\n5. Create an output grid of size H rows by W columns, initializing every cell to 0.\n6. For each column index j from 0 to W-1:\n   a. Let c = L[j] and h = h_c.\n   b. For each row index i from 0 to h-1:\n      i. Set output[i][j] = c.\n7. Return the output grid.",
    "1a2e2828": "1. Let the input be a 2D array grid with R rows and C columns, indexed from 0 to R-1 and 0 to C-1.\n2. Construct the set Colors of all distinct values v in grid such that v ≠ 0.\n3. For each value v in Colors, do:\n   a. For each row r from 0 to R-1, if for every column c from 0 to C-1 grid[r][c] == v, then set Winner = v and go to step 5.\n   b. For each column c from 0 to C-1, if for every row r from 0 to R-1 grid[r][c] == v, then set Winner = v and go to step 5.\n4. (By task definition, exactly one such v exists.)\n5. Produce an output grid of size 1×1 whose only cell (0,0) holds the value Winner.",
    "84db8fc4": "1. Let H be the number of rows and W the number of columns of the input grid.\n2. Initialize a boolean array visited of size H×W to false.\n3. For each cell (r,c) in the grid do:\n   a. If grid[r][c] ≠ 0 or visited[r][c] is true, continue to the next cell.\n   b. Otherwise, perform a breadth-first or depth-first search beginning at (r,c) to find its connected component of cells with value 0, using orthogonal (up, down, left, right) adjacency. During the search:\n      i. Mark each reached cell (r',c') as visited.\n      ii. Add each reached cell to a list COMPONENT.\n      iii. Track a flag touches_border that becomes true if any reached cell satisfies r'=0 or r'=H−1 or c'=0 or c'=W−1.\n   c. After the search completes, if touches_border is true, set every cell in COMPONENT to 2; otherwise set every cell in COMPONENT to 5.\n4. Leave all cells with original values other than 0 unchanged.\n5. Return the modified grid.",
    "b7cb93ac": "1. Let Input be the given grid of size H×W with integer values 0–9. Define Output as a new grid of size 3 rows × 4 columns with all cells initialized to 0.\n2. Identify each nonzero color v present in Input. For each such v, find its connected component C_v: the set of all cells (r,c) with Input[r][c]==v that are 4-neighbor connected.\n3. For each component C_v:\n   a. Compute min_row = minimum r in C_v, min_col = minimum c in C_v.\n   b. Build its normalized shape P_v as the set of relative coordinates {(r-min_row, c-min_col) | (r,c) in C_v}.\n   c. Record its shape dimensions h_v = 1 + max(dr) over P_v, w_v = 1 + max(dc) over P_v.\n4. For each shape P_v, generate the set of its unique rotations R_v: for each angle θ in {0°,90°,180°,270°}, compute P_v^θ by rotating each (dr,dc) in P_v about (0,0) (90° rotation maps (dr,dc)->(dc, h_v-1-dr)), then re-normalize to have min row and col = 0. Discard duplicates.\n5. Perform a backtracking search to assign to each color v one rotated pattern Q_v from R_v and one placement offset (or,oc) in Output such that:\n   a. 0 ≤ or ≤ 3 - height(Q_v) and 0 ≤ oc ≤ 4 - width(Q_v).\n   b. For every two distinct colors v≠u, the placed cells { (or+dr, oc+dc) | (dr,dc) in Q_v } and { (or_u+dr_u, oc_u+dc_u) | (dr_u,dc_u) in Q_u } are disjoint.\n   c. The union of all placed cells across all colors equals exactly all coordinates in the 3×4 grid.\n6. Once a valid assignment is found, for each color v and its placement (Q_v, or,oc), set Output[or+dr][oc+dc] = v for every (dr,dc) in Q_v.\n7. Return Output.",
    "1a6449f1": "1. Let the input be a 2D array grid of size H×W with zero-based row indices 0…H−1 and column indices 0…W−1.\n2. Initialize best_area ← 0 and best_rectangle ← null.\n3. For each color value v from 1 to 9 do:\n   a. For each top row r1 from 0 to H−1 do:\n      i. For each bottom row r2 from r1+2 to H−1 do:  // ensure at least one interior row\n         A. For each left column c1 from 0 to W−1 do:\n            1. For each right column c2 from c1+2 to W−1 do:  // ensure at least one interior column\n               a. Check whether all border cells of the rectangle with corners (r1,c1),(r1,c2),(r2,c1),(r2,c2) equal v:\n                  • For each c in c1…c2, require grid[r1][c]==v and grid[r2][c]==v.\n                  • For each r in r1…r2, require grid[r][c1]==v and grid[r][c2]==v.\n               b. If the above is true then:\n                  • Let area ← (r2−r1−1)×(c2−c1−1).  // interior area\n                  • If area>best_area then set best_area←area and best_rectangle←(r1,r2,c1,c2).\n4. After scanning all v,r1,r2,c1,c2, best_rectangle holds the largest border frame.\n5. Let (r1,r2,c1,c2)←best_rectangle. Define r_start←r1+1, r_end←r2−1, c_start←c1+1, c_end←c2−1.\n6. Construct the output grid of size (r_end−r_start+1)×(c_end−c_start+1) by copying:\n   output[i−r_start][j−c_start]←grid[i][j] for each i in r_start…r_end and j in c_start…c_end.\n7. Return the output grid.",
    "84f2aca1": "1. Let the output grid be a copy of the input grid.\n2. Find every connected component of non-zero cells, where connectivity is 4-directional and all cells in a component share the same value c (c ∈ {1..9}).\n3. For each component:\n   a. Compute minRow = minimum row index of its cells, maxRow = maximum row index, minCol = minimum column index, maxCol = maximum column index.\n   b. Initialize an empty list holes.\n   c. For each row r from minRow+1 to maxRow-1, and for each column k from minCol+1 to maxCol-1:\n      i. If inputGrid[r][k] == 0, append the coordinate (r,k) to holes.\n   d. If holes contains exactly 1 coordinate (r,k), set outputGrid[r][k] = 5.\n   e. If holes contains exactly 2 coordinates, for each (r,k) in holes set outputGrid[r][k] = 7.\n4. Return the output grid.",
    "b7f8a4d8": "1. Scan the entire grid and count the occurrences of each color value >0. 2. Let primary = the color with the highest count (this is the block color forming solid squares). 3. Let outliers = all colors >0 except primary. 4. If |outliers| > 2 then compute frequency f[c] for each c in outliers and let selected = the two colors with smallest f[c]; else selected = outliers. 5. For each color c in selected:   a. Let P = list of all coordinates (r, col) where grid[r][col] == c.   b. For each distinct row r among P:      i. Let C = sorted list of cols where (r, col)∈P.      ii. For each adjacent pair (c1, c2) in C: for col = c1+1 to c2-1 set grid[r][col] = c.   c. For each distinct col among P:      i. Let R = sorted list of rows where (row, col)∈P.      ii. For each adjacent pair (r1, r2) in R: for row = r1+1 to r2-1 set grid[row][col] = c. 6. Output the modified grid.",
    "1acc24af": "1. Locate the single connected component of cells with value 1.  For each column c, compute silhouette[c] = the maximum row index r such that grid[r][c] == 1.\n2. Identify each concave cavity (“pocket”) under the silhouette as follows:\n   a. For each maximal interval of columns [L..R] (inclusive) where for every c in [L..R], silhouette[c] < silhouette[L-1] (if L>0) and silhouette[c] < silhouette[R+1] (if R<width–1):\n      i. Let top = max(silhouette[c] for c in [L..R]).\n      ii. Let belowLeft = (silhouette[L-1] if L>0 else height), belowRight = (silhouette[R+1] if R<width–1 else height).\n      iii. Let bottom = min(belowLeft, belowRight).\n      iv. If bottom > top, define pocket region P = { (r,c) | c in [L..R] and r in [top+1 .. bottom] }.\n   b. For each pocket region P, extract its connected component(s) of cells where grid[r][c] == 0 and (r,c) ∈ P.  Record each pocket’s shape as the set of relative coordinates normalized to its top-left bounding box.\n3. Extract each connected component of cells with value 5.  For each grey component G, record its shape as the set of relative coordinates normalized to its top-left bounding box.\n4. For each grey shape G and each pocket shape P, test all four rotations of G.  If any rotated G has an identical set of relative coordinates to P, mark component G as “fit”.\n5. Produce the output grid by copying the input grid, then for every cell belonging to a grey component G marked “fit”, change its value from 5 to 2.  Leave all other cells unchanged.",
    "8597cfd7": "1. Scan each row of the input grid to find the separator row R_sep where every cell value equals 5.\n2. Define the top region as all rows with index R < R_sep. Define the bottom region as all rows with index R > R_sep.\n3. In the top region, count:\n   • top2 = number of cells with value 2.\n   • top4 = number of cells with value 4.\n4. In the bottom region, count:\n   • bottom2 = number of cells with value 2.\n   • bottom4 = number of cells with value 4.\n5. Compute:\n   • diff2 = bottom2 − top2\n   • diff4 = bottom4 − top4\n6. Determine the output color value:\n   • If diff2 > diff4, set C = 2.\n   • Else if diff4 > diff2, set C = 4.\n   • Else (diff2 = diff4), set C = 2.\n7. Construct the output as a 2×2 grid where every cell equals C.",
    "b7fb29bc": "1. Scan the input grid and collect all coordinates of pixels with value 3. 2. Compute min_row = minimum row index among these coordinates, max_row = maximum row index, min_col = minimum column index, max_col = maximum column index. 3. Partition the value-3 pixels into:   a. border_pixels = those with row == min_row or row == max_row or col == min_col or col == max_col;   b. center_pixel = the single remaining 3 whose coordinate (R,C) is not on the border. 4. Compute max_radius = minimum of (R - min_row, max_row - R, C - min_col, max_col - C). 5. For each cell (r,c) such that min_row < r < max_row and min_col < c < max_col and original grid[r][c] == 0:   a. Let d = max(|r - R|, |c - C|).   b. If 1 ≤ d ≤ max_radius then:      i. If d mod 2 == 1, set grid[r][c] = 4;      ii. Else (d mod 2 == 0), set grid[r][c] = 2. 6. Leave all original 3’s unchanged (both the border and the center pixel) and leave any other values outside the bounding box unchanged.",
    "1c02dbbe": "1. Locate the background region:\n   a. Let B be the non-zero color that forms the single largest contiguous group of cells (connectivity: orthogonal).\n   b. Compute region_top = minimum row index of any cell with color B.\n   c. Compute region_bottom = maximum row index of any cell with color B.\n   d. Compute region_left = minimum column index of any cell with color B.\n   e. Compute region_right = maximum column index of any cell with color B.\n2. Identify pointer cells:\n   a. For each cell p at (r,c) whose value V ≠ 0 and V ≠ B, record p as a pointer of color d = V.\n3. For each pointer p at (r,c) of color d, compute adjusted coordinates (r′,c′):\n   a. If r < region_top then r′ = r + 1; else if r > region_bottom then r′ = r - 1; else r′ = r.\n   b. If c < region_left then c′ = c + 1; else if c > region_right then c′ = c - 1; else c′ = c.\n4. For each distinct pointer color d:\n   a. Collect all adjusted rows R = {r′ of each pointer of color d} and adjusted columns C = {c′ of each pointer of color d}.\n   b. Let r_min = minimum of R, r_max = maximum of R, c_min = minimum of C, c_max = maximum of C.\n   c. For every cell (r,c) with r_min ≤ r ≤ r_max and c_min ≤ c ≤ c_max, set its value to d.\n5. Remove all original pointers:\n   a. For each recorded pointer cell at (r,c), set its value to 0.\n\nAll indices are 0-based. Perform steps in order to transform the input grid to the output grid.",
    "85b81ff1": "1. Let H be the number of rows and W the number of columns in the input grid.\n2. Identify all separator columns S = [c | 0 ≤ c < W and for every row r in 0..H-1, grid[r][c] == 0]. Sort S in ascending order.\n3. Define block slots as the contiguous column intervals between separators:\n   a. Let S' = [-1] + S + [W].\n   b. For each i from 0 to |S|, define block_i spanning columns from (S'[i] + 1) to (S'[i+1] - 1), inclusive. Each block_i has width ≥1 and contains no all-zero columns.\n4. For each block_i, compute count_i = number of cells (r,c) within block_i for which grid[r][c] != 0.\n5. Create a list of block indices [0,1,…,|S|] and stably sort it in descending order by count_i (higher count_i first; if count_i equals count_j for i<j, keep i before j).\n6. Initialize an output grid of size H×W.\n7. For each separator column c in S, set output[r][c] = 0 for all rows r.\n8. Let sorted_indices be the list from step 5. For each slot index j from 0 to |S|:\n   a. Let target_cols = the original columns of block_j, i.e. from (S'[j] + 1) to (S'[j+1] - 1).\n   b. Let source_block = block with index sorted_indices[j].\n   c. For each row r and each k in 0..width(source_block)-1, set output[r][ target_cols.start + k ] = input[r][ source_block.start + k ].\n9. Return the output grid.",
    "b942fd60": "1. Locate the unique pivot cell (r,c) such that grid[r][c]==2.\n2. Initialize a worklist with one segment defined by (start_r=r, start_c=c, dr=0, dc=1).\n3. While the worklist is not empty:\n   a. Remove one segment (sr, sc, dr, dc) from the worklist.\n   b. Let cr=sr and cc=sc.\n   c. Repeat:\n      i. Compute nr=cr+dr and nc=cc+dc.\n      ii. If nr<0 or nr>=height or nc<0 or nc>=width, break the loop for this segment.\n      iii. If grid[nr][nc]==0, set grid[nr][nc]=2, then set cr=nr and cc=nc, and continue the loop.\n      iv. Else (grid[nr][nc]!=0), record branch_r=cr and branch_c=cc, then break the loop.\n   d. After the loop, if the last computed (nr,nc) is inside bounds and grid[nr][nc]!=0 (an obstacle), then:\n      i. If dr==0 (horizontal movement), add two new segments to the worklist:\n         - (start_r=branch_r, start_c=branch_c, dr=1, dc=0)\n         - (start_r=branch_r, start_c=branch_c, dr=-1, dc=0)\n      ii. Else (vertical movement dr!=0), add:\n         - (start_r=branch_r, start_c=branch_c, dr=0, dc=1)\n         - (start_r=branch_r, start_c=branch_c, dr=0, dc=-1)\n4. When the worklist is empty, all zeros reachable by this branching process have been set to 2. The grid is now the desired output.",
    "1c0d0a4b": "1. Initialize an output grid of the same size as the input, filling every cell with 0.\n2. Find every connected component of input cells equal to 8 (cyan), using 4-way adjacency (up, down, left, right).\n3. For each connected component:\n   a. Let rmin = minimum row index in the component, rmax = maximum row index, cmin = minimum column index, cmax = maximum column index.\n   b. Confirm that rmax - rmin == 2 and cmax - cmin == 2 (so the component lies within a 3×3 square).\n   c. For each row r in [rmin..rmax] and each column c in [cmin..cmax]:\n      i. If input[r][c] == 8, set output[r][c] = 0.\n      ii. If input[r][c] == 0, set output[r][c] = 2.\n4. Leave all cells not covered by any 3×3 bounding box at 0.\n5. Return the output grid.",
    "85fa5666": "1. Let H and W be the grid height and width.\n2. Find every 2×2 sub‐block whose four cells all equal the same non-zero value (the “central block”). For each such block:\n  a. Let rmin and cmin be the row and column of its top-left cell. Let rmax=rmin+1, cmax=cmin+1.\n  b. Identify the four original corner cells immediately diagonal to the block:\n     • NW_orig = (rmin-1, cmin-1)\n     • NE_orig = (rmin-1, cmax+1)\n     • SE_orig = (rmax+1, cmax+1)\n     • SW_orig = (rmax+1, cmin-1)\n  c. Read and store their values v_NW, v_NE, v_SE, v_SW. Then set those four original cells to 0.\n  d. Compute rotated corner values:\n     • v_new_NW = v_SW\n     • v_new_NE = v_NW\n     • v_new_SE = v_NE\n     • v_new_SW = v_SE\n  e. Define the four new corner positions (same as orig): NW=(rmin-1,cmin-1), NE=(rmin-1,cmax+1), SE=(rmax+1,cmax+1), SW=(rmax+1,cmin-1).\n  f. Place the rotated values at those positions:\n     • grid[NW] = v_new_NW\n     • grid[NE] = v_new_NE\n     • grid[SE] = v_new_SE\n     • grid[SW] = v_new_SW\n  g. For each placed corner, extend a diagonal ray away from the central block:\n     • For NW use direction dr=-1, dc=-1 with start=(rmin-1,cmin-1) and value=v_new_NW.\n     • For NE use dr=-1, dc=+1 starting at (rmin-1,cmax+1) with v_new_NE.\n     • For SE use dr=+1, dc=+1 starting at (rmax+1,cmax+1) with v_new_SE.\n     • For SW use dr=+1, dc=-1 starting at (rmax+1,cmin-1) with v_new_SW.\n     For each corner do:\n       i. Let (r,c) = corner position.\n      ii. Loop: r+=dr; c+=dc.\n     iii. If (r,c) is outside [0..H-1]×[0..W-1] or grid[r][c] ≠ 0, stop this ray.\n      iv. Else set grid[r][c] = the corner’s value and repeat step ii.\n3. After processing all central blocks, leave all other cells unchanged and return the grid.",
    "b9630600": "1. Scan the grid and identify every connected component of pixel value 3.  For each component, compute its bounding box: top row T, bottom row B, left column L, and right column R.\n2. For each unordered pair of boxes (i,j):\n   a. Compute the interior row ranges: Ri = [T_i+1, B_i-1], Rj = [T_j+1, B_j-1].  If Ri ∩ Rj is non-empty, then boxes i and j can be connected by a horizontal corridor:\n      i. Let r = min(Ri ∩ Rj).\n      ii. Determine which box is left: if R_i < L_j then i is left and j is right; else j is left and i is right.\n      iii. Let c1 = right_left_box + 1 and c2 = left_right_box - 1.\n      iv. For every column c from c1 through c2 inclusive, set cell (r, c) = 3.\n   b. Otherwise, compute interior column ranges: Ci = [L_i+1, R_i-1], Cj = [L_j+1, R_j-1].  If Ci ∩ Cj is non-empty, then boxes i and j can be connected by a vertical corridor:\n      i. Let c = min(Ci ∩ Cj).\n      ii. Determine which box is above: if B_i < T_j then i is above and j is below; else j is above and i is below.\n      iii. Let r1 = bottom_above_box + 1 and r2 = top_below_box - 1.\n      iv. For every row r from r1 through r2 inclusive, set cell (r, c) = 3.\n3. Leave all original 3’s intact; only add new 3’s for these corridors.  Return the modified grid.",
    "1c56ad9f": "1. Let input be a 2D array grid of size H×W. 2. Compute R_min = minimum row index r where ∃c: grid[r][c] ≠ 0. Compute R_max = maximum row index r where ∃c: grid[r][c] ≠ 0. 3. Create output as a copy of input. 4. For each row r from R_min to R_max inclusive:  \n   a. Let d = R_max − r. Let p = d mod 4.  \n   b. If p == 1 then offset = -1. Else if p == 3 then offset = +1. Else offset = 0.  \n   c. If offset == -1 (shift left):  \n      i. For c from 0 to W−2: output[r][c] = input[r][c+1].  \n      ii. Set output[r][W−1] = 0.  \n   d. Else if offset == +1 (shift right):  \n      i. For c from W−1 down to 1: output[r][c] = input[r][c−1].  \n      ii. Set output[r][0] = 0.  \n   e. Else if offset == 0: leave output[r][*] unchanged.  \n   f. Always source values from the original input grid, not from output. 5. Return output grid.",
    "8719f442": "1. Let input_size = height of input grid (here 3).  \n2. Compute scales array of length input_size: for k from 0 to input_size-1, scales[k] = 2^(input_size - k) - 1.  (For input_size=3 this yields scales = [2^3-1=7, 2^2-1=3, 2^1-1=1].)  \n3. Set output_size = 2 * scales[0] + 1.  (For scales[0]=7, output_size = 15.)  \n4. Initialize an output grid of dimensions output_size×output_size filled with 0s.  \n5. Build a list offsets = [(i - floor(input_size/2), j - floor(input_size/2)) for each cell (i,j) in input where input[i][j] = 5].  (With zero-based indices and floor(3/2)=1, offsets for input nonzeros are e.g. (0,1)→(-1,0), (1,0)→(0,-1), etc.)  \n6. Define a recursive procedure draw(level, center_r, center_c):  \n   a. Let s = scales[level].  \n   b. For each (dr, dc) in offsets:  \n      i. Compute new_r = center_r + dr * s, new_c = center_c + dc * s.  \n      ii. Set output[new_r][new_c] = 5.  \n      iii. If level + 1 < input_size, let next_s = scales[level + 1];  \n           if new_r - next_s ≥ 0 AND new_r + next_s < output_size AND new_c - next_s ≥ 0 AND new_c + next_s < output_size, then call draw(level + 1, new_r, new_c).  \n7. Let center = (scales[0], scales[0]). Call draw(0, center_row, center_col).  \n8. Return the output grid.",
    "ba9d41b8": "1. Let output be a copy of the input grid.\n2. For each distinct non-zero integer value C present in the input:  \n   a. Collect all coordinates (r,c) where input[r][c] == C.  \n   b. Compute min_r = minimum r, max_r = maximum r, min_c = minimum c, max_c = maximum c over those coordinates.\n3. For each such value C, if max_r - min_r >= 2 and max_c - min_c >= 2, then for each row r from min_r + 1 to max_r - 1 (inclusive) and each column c from min_c + 1 to max_c - 1 (inclusive):  \n   a. Let i = r - (min_r + 1) and j = c - (min_c + 1).  \n   b. If (i + j) mod 2 == 0, set output[r][c] = 0; otherwise set output[r][c] = C.\n4. Leave all other cells of output unchanged.  \n5. Return output.",
    "1d0a4b61": "1. Let H and W be the grid height and width. 2. Identify all border row indices R: each r in [0,H) such that grid[r][c]≠0 for all c and all grid[r][c] are equal. Sort R ascending. 3. Identify all border column indices C: each c in [0,W) such that grid[r][c]≠0 for all r and all grid[r][c] are equal. Sort C ascending. 4. Compute tile_height = R[1] – R[0] and tile_width = C[1] – C[0]. 5. For each cell (r,c) with grid[r][c]==0 do:  5.1. Find i such that R[i]<r<R[i+1].  5.2. Compute dr = r – R[i] – 1.  5.3. Find j such that C[j]<c<C[j+1].  5.4. Compute dc = c – C[j] – 1.  5.5. In the same tile‐row i, search k from 0…|C|–2 for a tile‐col index k≠j where the subgrid rows R[i]+1…R[i+1]–1 and cols C[k]+1…C[k+1]–1 contains no zeros.   • Prefer the largest k<j; if none, the smallest k>j.  5.6. Let r0 = R[i]+1 + dr and c0 = C[k]+1 + dc.  5.7. Set grid[r][c] = original grid[r0][c0]. 6. Return the filled grid.",
    "88207623": "1. Let G be the input grid of size H×W. Create a copy G′ initialized to G.\n2. Find all connected components of pixels with value 2 using 4-connectivity, but restrict connectivity to vertical adjacency. Each component corresponds to one vertical red line. For each component:\n   a. Let col_line be the constant column index of the component. Let row_min and row_max be the minimum and maximum row indices of pixels in this component.\n3. For each red-line component, collect all shape pixels on its left:\n   a. For each row r in [row_min, row_max], and for each column c from 0 to col_line−1, if G[r][c]≠0 and G[r][c]≠2, record (r,c) as a shape pixel. All such pixels share the same shape_color = G[r][c] (typically 4).\n4. For each red-line component, locate the single fill dot on its right:\n   a. For each row r in [row_min, row_max], and for each column c from col_line+1 to W−1, if G[r][c]≠0 and G[r][c]≠2, record (r,c) as the fill dot. There is exactly one such dot; let fill_color = G[r][c].\n5. Remove the fill dot from G′ by setting G′[r_fill][c_fill] = 0.\n6. Mirror the shape pixels across the red line in G′:\n   For each recorded shape pixel (r,c):\n     a. Compute mirrored column c′ = col_line + (col_line − c).\n     b. Set G′[r][c′] = fill_color.\n7. Leave all other cells of G′ unchanged. Return G′ as the output grid.",
    "baf41dbf": "1. Let H and W be the grid height (number of rows) and width (number of columns).  \n2. Locate all cells with value 3. Compute:  \n   a. min_row = minimum row index of any 3  \n   b. max_row = maximum row index of any 3  \n   c. min_col = minimum column index of any 3  \n   d. max_col = maximum column index of any 3  \n3. Identify vertical stripe columns within the original shape:  \n   a. Initialize stripe_cols = {min_col, max_col}  \n   b. For each column c from min_col+1 to max_col-1, if there exists any row r with min_row < r < max_row such that grid[r][c] == 3, then add c to stripe_cols  \n4. Locate all marker cells with value 6. Initialize new_min_row = min_row, new_max_row = max_row, new_min_col = min_col, new_max_col = max_col.  \n   For each marker at (r,c):  \n   a. If c < min_col, set new_min_col = min(new_min_col, c + 1)  \n   b. If c > max_col, set new_max_col = max(new_max_col, c - 1)  \n   c. If r < min_row, set new_min_row = min(new_min_row, r + 1)  \n   d. If r > max_row, set new_max_row = max(new_max_row, r - 1)  \n5. Draw the expanded rectangle border and stripes without erasing other cells:  \n   a. For each column c from new_min_col to new_max_col, set grid[new_min_row][c] = 3 and grid[new_max_row][c] = 3  \n   b. For each column c in stripe_cols, for each row r from new_min_row to new_max_row, set grid[r][c] = 3  \n6. Leave all other cells unchanged (including original markers and zeros).",
    "1d398264": "1. Scan the grid to collect all cells with value V != 0. 2. Compute r0 = minimum row index among these cells, r1 = maximum row index. Compute c0 = minimum column index, c1 = maximum column index. 3. Verify that r1 - r0 == 2 and c1 - c0 == 2 (bounding box is 3×3). 4. Let center_r = r0 + 1, center_c = c0 + 1. 5. For each cell (r, c) with value V != 0 in the 3×3 box:  a. If r == center_r and c == center_c, skip.  b. Let dr = sign(r - center_r) and dc = sign(c - center_c), where sign(x) = -1 if x<0, 0 if x==0, +1 if x>0.  c. For k = 1, 2, …:     i. Compute nr = r + k*dr, nc = c + k*dc.    ii. If nr or nc is outside grid bounds, break.   iii. Set grid[nr][nc] = V. 6. Return the modified grid.",
    "891232d6": "1. Locate all cells with value 6 (pink) in the input grid; for each such cell, perform steps 2–5 independently.   \n2. Initialize: set current position P to the pink cell coordinates; set direction D to UP (delta = (–1, 0)).   \n3. Repeat until terminated:\n   a. If D is UP:\n      i.  While the cell one step above P (row = P.row – 1, same column) exists and its value is not 7:\n           – Move P up by one; set grid[P] = 2 (red).\n      ii. If the cell above P exists and its value is 7:\n           – Change that cell’s value to 8 (blue).\n           – Change the current cell P’s value to 4 (yellow).\n           – Keep P unchanged; set D = RIGHT (delta = (0, +1)); go to step 3.\n      iii. If the cell above P is outside the grid:\n           – Change grid[P] to 6 (pink) and terminate this repeat loop for this starting cell.\n   b. Else if D is RIGHT:\n      i.  While the cell one step to the right of P (same row, column = P.col + 1) exists and there is at least one cell of value 7 in that column strictly above P.row:\n           – Move P right by one; set grid[P] = 2 (red).\n      ii. If the cell to the right exists and in its column above P.row no 7 remains:\n           – Change grid[P] to 3 (green).\n           – Set D = UP; go to step 3.\n      iii. If the cell to the right is outside the grid:\n           – Change grid[P] to 6 (pink) and terminate this repeat loop for this starting cell.\n4. Do not modify any cell of nonzero value except as specified when hitting a 7 or marking the final pink.\n5. After processing all pink starts, output the resulting grid.",
    "bb52a14b": "1. Copy the input grid to output grid.\n2. Let background = 0.\n3. Compute set S = all non-zero values present anywhere in the input.\n4. Slide a 3×3 window over all positions (r, c) where 0 ≤ r ≤ H-3 and 0 ≤ c ≤ W-3. For each window, collect its values into a set W. Find the single window whose set W equals S. Let its top-left be (r0, c0).\n5. Define reference pattern R as the 3×3 array R[dr][dc] = input[r0+dr][c0+dc] for dr, dc ∈ {0,1,2}.\n6. Identify matchColor = the value v ∈ S that appears exactly once in R.\n7. Let (drm, dcm) be the unique offset in {0,1,2}×{0,1,2} where R[drm][dcm] = matchColor.\n8. For each cell (i, j) in the input where input[i][j] = matchColor:\n   a. Compute candidate top-left (rt, ct) = (i – drm, j – dcm). If rt<0 or ct<0 or rt+2≥H or ct+2≥W, skip.\n   b. For all dr, dc ∈ {0,1,2}, if input[rt+dr][ct+dc] ≠ background and input[rt+dr][ct+dc] ≠ R[dr][dc], skip this (rt, ct).\n   c. Otherwise, for all dr, dc ∈ {0,1,2} where R[dr][dc] ≠ background, set output[rt+dr][ct+dc] = R[dr][dc].\n9. Return the output grid.",
    "1da012fc": "1. Locate the legend region: find the largest 4-connected component of pixels with value 5. 2. Compute its bounding box: let (Rmin, Cmin) and (Rmax, Cmax) be the minimal and maximal row and column indices of pixels in that component. 3. Extract the mapping colors: for every cell (r, c) with Rmin ≤ r ≤ Rmax and Cmin ≤ c ≤ Cmax, if its value v ≠ 5 and v ≠ 0, collect v. Sort these collected values by increasing r, then by increasing c. Call the resulting list M. 4. Determine the shape color S: scan all cells outside the legend region; find the unique nonzero value S≠5 that appears there. 5. Identify all shape components: find all 4-connected components of cells with value S that lie outside the legend region. 6. For each component, compute its “leader” cell as the one with the smallest row; if tied, the smallest column. 7. Sort the components in ascending order of their leader cell’s (row, column). 8. For i from 0 to (number_of_components−1): let color = M[i]; then for every cell in the i-th component, set its value to color. 9. Leave all other cells unchanged. 10. Return the resulting grid.",
    "896d5239": "1. Let Grid be the input M×N array of integers.  \n2. Define an apex as any cell (r,c) where Grid[r][c]==3, that has no 3 at either diagonal above it and has at least one 3 at a diagonal below it:  \n   a. Condition A: both positions (r-1,c-1) and (r-1,c+1) are either out of bounds or not equal to 3.  \n   b. Condition B: at least one of positions (r+1,c-1) or (r+1,c+1) is within bounds and equal to 3.  \n   If A and B hold, mark (r,c) as an apex.  \n3. For each apex (r,c), perform:  \n   For d = 1,2,3,... until break:  \n     a. Compute row2 = r + d; left2 = c - d; right2 = c + d.  \n     b. If row2 is out of [0,M-1], break the loop.  \n     c. Let Lval = value at (row2,left2) if in bounds else null;  \n        Rval = value at (row2,right2) if in bounds else null.  \n     d. If neither Lval==3 nor Rval==3, break the loop.  \n     e. For each col from left2+1 through right2-1 inclusive:  \n         If col in [0,N-1] and Grid[row2][col]==0, set Grid[row2][col] = 8.  \n4. After processing all apexes, output the modified Grid.",
    "bbb1b8b6": "1. Let rows = number of rows of the input grid and cols = number of columns.\n2. Find sep_col such that for every r in [0, rows-1], input[r][sep_col] == 5.\n3. Define subgrid A of size rows × sep_col: for each r∈[0, rows-1], c∈[0, sep_col-1], set A[r][c] = input[r][c].\n4. Define subgrid B of size rows × (cols - sep_col - 1): for each r∈[0, rows-1], c∈[0, cols-sep_col-2], set B[r][c] = input[r][sep_col + 1 + c].\n5. Initialize overlap = false.\n6. For each r∈[0, rows-1] and c∈[0, sep_col-1], if A[r][c] ≠ 0 and B[r][c] ≠ 0 then set overlap = true.\n7. If overlap == true, return A as the output grid.\n8. Otherwise, create output grid Out of size rows × sep_col filled with 0.\n9. For each r∈[0, rows-1] and c∈[0, sep_col-1]:\n   a. If A[r][c] ≠ 0 then Out[r][c] = A[r][c].\n   b. Else if B[r][c] ≠ 0 then Out[r][c] = B[r][c].\n   c. Else Out[r][c] = 0.\n10. Return Out as the output grid.",
    "1e81d6f9": "1. Scan the entire grid to collect all coordinates where the cell value is 5. 2. Compute top = minimum row index of those coordinates; bottom = maximum row index; left = minimum column index; right = maximum column index. 3. For each cell (r,c) with r between top and bottom and c between left and right, if grid[r][c] != 5, record key_color = grid[r][c] and key_r = r and key_c = c. 4. For each cell (r,c) in the grid, if grid[r][c] == key_color and not (r == key_r and c == key_c), set grid[r][c] = 0. 5. Leave all other cells unchanged.",
    "8a371977": "1. Let R = number of rows, C = number of columns in the input grid.\n2. Identify horizontal separator rows H: all row indices r (0 ≤ r < R) such that for every column c (0 ≤ c < C), grid[r][c] == 1. Sort H in ascending order.\n3. Identify vertical separator columns V: all column indices c (0 ≤ c < C) such that for every row r (0 ≤ r < R), grid[r][c] == 1. Sort V in ascending order.\n4. Compute num_block_rows = |H| - 1 and num_block_cols = |V| - 1.\n5. For each block_row from 0 to num_block_rows - 1:\n   a. Let row_start = H[block_row] + 1 and row_end = H[block_row + 1] - 1.\n   b. For each block_col from 0 to num_block_cols - 1:\n      i. Let col_start = V[block_col] + 1 and col_end = V[block_col + 1] - 1.\n      ii. If block_row == 0 or block_row == num_block_rows - 1 or block_col == 0 or block_col == num_block_cols - 1, set fill_color = 2; otherwise set fill_color = 3.\n      iii. For each r in row_start..row_end and each c in col_start..col_end:\n           - If grid[r][c] == 0, assign grid[r][c] = fill_color.\n6. Return the modified grid.",
    "bc4146bd": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Define output_width = W × 5. Create an empty output grid with H rows and output_width columns.\n3. For each row index r from 0 to H–1:\n   a. For each repetition index s from 0 to 4:\n      i. For each column index c from 0 to W–1:\n         - If s mod 2 = 0, set output[r][s×W + c] = input[r][c].\n         - If s mod 2 = 1, set output[r][s×W + c] = input[r][W–1–c].\n4. Return the output grid.",
    "1e97544e": "1. Determine cycleLength: scan grid to find the maximum value M > 0; set cycleLength = M.\n2. Define nextVal(x): if x < cycleLength then x+1 else 1. Define prevVal(x): if x > 1 then x-1 else cycleLength.\n3. Locate every maximal rectangular block of zeros (value 0): for each block, record topRow r1, bottomRow r2, leftCol c1, rightCol c2 (inclusive), such that for all r in [r1..r2] and c in [c1..c2], grid[r][c] == 0, and cells adjacent outside that box are non-zero or out of bounds.\n4. For each zero‐block do:\n   a. If c1 > 0 and c2 < width-1 (block has non-zero neighbors on both left and right):\n      i. For each row r from r1 to r2:\n         A. Let leftVal = grid[r][c1-1]. Let rightVal = grid[r][c2+1].\n         B. Set v = nextVal(leftVal).\n         C. For c from c1 to c2 in increasing order:\n            • grid[r][c] = v\n            • v = nextVal(v)\n   b. Else if c1 == 0 (block touches left border) and c2 < width-1:\n      i. For each row r from r1 to r2:\n         A. Let rightVal = grid[r][c2+1].\n         B. Set v = prevVal(rightVal).\n         C. For c from c2 down to c1:\n            • grid[r][c] = v\n            • v = prevVal(v)\n   c. Else if c2 == width-1 (block touches right border) and c1 > 0:\n      i. For each row r from r1 to r2:\n         A. Let leftVal = grid[r][c1-1].\n         B. Set v = nextVal(leftVal).\n         C. For c from c1 to c2:\n            • grid[r][c] = v\n            • v = nextVal(v)\n5. After filling all zero-blocks, return the completed grid.",
    "8b28cd80": "1. Let N=9. Let input be a 3×3 grid with exactly one non-zero cell. 2. Scan the 3×3 input to find its non-zero cell at coordinates (r_in, c_in), zero-based, and let V be its integer value. 3. Compute the spiral center in the 9×9 output: center_row = r_in * 3 + 1; center_col = c_in * 3 + 1. 4. Initialize a 9×9 output grid filled with zeros. 5. Initialize current position (r, c) = (center_row, center_col). Set output[r][c] = V. 6. Define an ordered list of direction vectors: dirs = [(-1, 0), (0, -1), (1, 0), (0, 1)] (up, left, down, right). 7. Initialize step_length = 2 and dir_index = 0. 8. Loop:   a. Let (dr, dc) = dirs[dir_index mod 4].   b. Repeat step_length times:     i. Set r = r + dr; c = c + dc.     ii. If (r, c) is outside [0‥8]×[0‥8], terminate the loop.     iii. Set output[r][c] = V.   c. Increment dir_index by 1.   d. After every two direction changes (i.e., if dir_index mod 2 == 0), increase step_length by 2. 9. End loop. 10. The grid in output now contains a single-thick spiral of value V, winding counterclockwise, starting by going up from the center mapped from the input position.",
    "bcb3040b": "1. Locate all coordinates (r1,c1) and (r2,c2) in the input grid where the cell value equals 2. There will be exactly two such cells.  \n2. Compute row_step: if r2>r1 then row_step=1; if r2<r1 then row_step=-1; otherwise row_step=0. Compute col_step: if c2>c1 then col_step=1; if c2<c1 then col_step=-1; otherwise col_step=0.  \n3. Initialize (r,c) = (r1,c1). Repeat the following until (r,c) has been processed for (r2,c2):  \n   a. Let v = original input value at (r,c).  \n   b. If v == 0 then set output[r][c] = 2; else if v == 1 then set output[r][c] = 3; else set output[r][c] = v.  \n   c. If (r,c) == (r2,c2) then stop.  \n   d. Otherwise set r = r + row_step and c = c + col_step.  \n4. For every other cell not visited in step 3, copy the input value to the output grid unchanged.",
    "2037f2c7": "1. Let input be a 2D array G of integers, size R×C.\n2. Define a non-zero pixel as any G[r][c] ≠ 0.\n3. Find all connected components of non-zero pixels in G using 4-connectivity (neighbors up/down/left/right).\n4. Identify the two largest components by pixel count. Call the larger component Full and the smaller component Incomplete.\n5. Build a set M of coordinates (r,c) in Full such that G[r][c] ≠ 0 and either G[r][c] in Incomplete is zero (i.e., (r,c) is not in Incomplete).\n6. Compute the minimal bounding box of M:\n   a. min_r = min(r) over all (r,c) in M\n   b. max_r = max(r) over all (r,c) in M\n   c. min_c = min(c) over all (r,c) in M\n   d. max_c = max(c) over all (r,c) in M\n7. Let H = max_r - min_r + 1 and W = max_c - min_c + 1.\n8. Create an output grid O of size H×W, initialize all entries to 0.\n9. For each (r,c) in M, set O[r - min_r][c - min_c] = 8.\n10. Return O.",
    "8ba14f53": "1. Let input be a 4×9 integer grid. 2. Find all distinct nonzero values; for each value v, find its connected component of cells equal to v (4-way connectivity). 3. For each component of value v:\n   a. Compute minRow, maxRow, minCol, maxCol over its cells.\n   b. Define its interior as all cells (r,c) with minRow<r<maxRow and minCol<c<maxCol.\n   c. Count zeros in the interior; call this holeCount[v].\n4. Sort the values v in ascending order of their minCol. Call the sorted list [v1, v2, …]. 5. Create an output grid of size 3 rows by 3 columns, initialize all cells to 0. 6. Initialize outRow=0.\n7. For each v in [v1, v2, …]:\n   a. Let count = holeCount[v]. If count=0, continue to next v.\n   b. Let fullRows = count ÷ 3 (integer division), rem = count mod 3. If rem>0, rowsNeeded = fullRows + 1; else rowsNeeded = fullRows.\n   c. For i from 0 to rowsNeeded−1:\n       i. If outRow > 2, stop all filling.\n      ii. If i < fullRows:\n            • Fill output row outRow, all 3 columns, with v.\n      iii. Else (i == fullRows):\n            • In output row outRow, fill the first rem columns with v, leave remaining columns as 0.\n      iv. Increment outRow by 1.\n8. Leave any rows outRow through 2 (if any) as all zeros.\n9. Return the 3×3 output grid.",
    "bd14c3bf": "1. Let G be the input grid of size R×C. Define background value 0.\n2. Let ref_val = G[0][0].  Perform a 4‐connected flood fill from (0,0) on cells equal to ref_val to obtain the reference component Ref.\n3. Compute the bounding box of Ref: min_row = min(r | (r,c)∈Ref), max_row = max(r), min_col = min(c), max_col = max(c).  Let H = max_row–min_row+1, W = max_col–min_col+1.\n4. Define a frame‐shape test:  for any candidate component Comp with bounding box [r1..r2]×[c1..c2], let h = r2–r1+1, w = c2–c1+1.  Comp is a hollow rectangle frame if and only if:\n   a. h≥2 and w≥2\n   b. For all c in [c1..c2], G[r1][c]≠0 and G[r2][c]≠0  (top and bottom rows full)\n   c. For all r in [r1..r2], G[r][c1]≠0 and G[r][c2]≠0  (left and right columns full)\n   d. For all r in [r1+1..r2–1] and c in [c1+1..c2–1], G[r][c]==0  (interior empty)\n5. Initialize the output grid O = copy of G.\n6. Enumerate all 4‐connected components Comp of nonzero cells in G.  For each Comp:\n   a. If Comp is identical to Ref (same cell set), skip.\n   b. If Comp passes the frame‐shape test in step 4, then for every (r,c) in Comp set O[r][c] = ref_val.\n7. Return O as the output grid.",
    "2072aba6": "1. Let H and W be the input grid dimensions. Create an output grid of size (2×H) rows and (2×W) columns.\n2. For each input cell at (r, c), 0≤r<H, 0≤c<W:\n   a. Let v = input[r][c]. Compute br = 2×r, bc = 2×c (the top-left of the 2×2 block in output).\n   b. If v == 5 (grey):\n      i. Set output[br][bc]     = 1 (blue).\n      ii. Set output[br][bc+1] = 2 (red).\n      iii. Set output[br+1][bc]     = 2 (red).\n      iv. Set output[br+1][bc+1] = 1 (blue).\n   c. Otherwise (v ≠ 5):\n      For dr in {0,1} and dc in {0,1}, set output[br+dr][bc+dc] = v.\n3. Return the output grid.",
    "8cb8642d": "1. Define background as color 0.  Treat grid cells with values 1–9 as shapes or anomaly cells.\n2. Identify each rectangular shape:\n   a. For each color C in {1..9} present in the grid, collect all coordinates (r,c) where grid[r][c]==C.\n   b. Compute r_min=min(r), r_max=max(r), c_min=min(c), c_max=max(c) over those coordinates.\n   c. Verify that every cell on the border of this bounding box (rows r_min or r_max, columns c_min..c_max; and columns c_min or c_max, rows r_min..r_max) has value C, and that r_max>r_min+1 and c_max>c_min+1.\n   d. If so, record this bounding box and its color C as one shape region.\n3. For each recorded shape region with color C and bounding box (r_min,r_max,c_min,c_max):\n   a. Find the anomaly color A: the unique cell within the box for which grid[r][c]!=C and grid[r][c]!=0.\n   b. Clear the interior: for all r in [r_min+1..r_max-1] and c in [c_min+1..c_max-1], set grid[r][c]=0.\n   c. Draw an X of color A inside the box:\n      For each row r in [r_min+1..r_max-1]:\n         i. Let d = min(r - (r_min+1), (r_max-1) - r).\n         ii. Compute c_left = c_min+1 + d and c_right = c_max-1 - d.\n         iii. Set grid[r][c_left] = A and grid[r][c_right] = A.\n4. Leave all other cells unchanged.\n5. Return the modified grid.",
    "be03b35f": "1. Let N be the size of the input grid (number of rows). 2. Compute K = N - 2. 3. Define the four 2×2 quadrant origins: O = [(0,0), (0,K), (K,0), (K,K)]. 4. For each origin (r,c) in O, extract block B(r,c) = [[G[r][c], G[r][c+1]], [G[r+1][c], G[r+1][c+1]]]. 5. Partition the blocks: if any cell in B(r,c) equals 2, designate it as the red block and ignore it; otherwise, add B(r,c) to pattern_blocks. 6. Let base = the first block in pattern_blocks. 7. Define rotate90(M): a new 2×2 block R where R[0][0] = M[1][0], R[0][1] = M[0][0], R[1][1] = M[0][1], and R[1][0] = M[1][1]. 8. Compute rotations: R0 = base; R90 = rotate90(R0); R180 = rotate90(R90); R270 = rotate90(R180). 9. For each R in [R0, R90, R180, R270], if R does not exactly match any block in pattern_blocks, set missing = R and stop. 10. Return missing as the 2×2 output grid.",
    "20818e16": "1. Identify the background color: examine the outermost rows and columns of the input grid; the color that fills all border cells is the background color (BG).\n2. Collect all non‐background colors. For each such color c:\n   a. Find all coordinates (r,c) in the input grid with that color.\n   b. Compute the minimal bounding rectangle: min_row[c], max_row[c], min_col[c], max_col[c].\n   c. Compute its height h[c] = max_row[c] - min_row[c] + 1 and width w[c] = max_col[c] - min_col[c] + 1.\n   d. Compute its area area[c] = number of pixels of color c.\n3. Determine the output grid dimensions:\n   H = max_{c≠BG}(h[c])\n   W = max_{c≠BG}(w[c])\n4. Identify the container color CC as the non‐background color with the largest area[c].\n5. Create an output grid of size H×W and fill every cell with CC.\n6. Create a list L of all non‐background colors except CC, sorted in descending order by area[c].\n7. For each color c in L (in that sorted order):\n   For r from 0 to h[c]–1:\n     For k from 0 to w[c]–1:\n       Set output[r][k] = c\n8. Return the output grid.",
    "8dae5dfc": "1. Locate all cells with value ≠ 0 and group them into connected components using 4-connectivity. Each component is a filled square region. 2. For each square region:  a. Compute its bounding box: r_min = min(row indices), r_max = max(row indices), c_min and c_max likewise.  b. Let size = r_max – r_min + 1 (must equal c_max – c_min + 1).  c. Let K = floor((size–1)/2).  d. For each ring index k from 0 to K:    i. Define ring k as all cells (r,c) in the bounding box satisfying min(r–r_min, r_max–r, c–c_min, c_max–c) == k.   ii. Let original_color[k] be the single non-zero value common to all cells in ring k.  e. Form reversed_colors array by reversing original_color (i.e., reversed_colors[k] = original_color[K–k]).  f. For each ring index k from 0 to K and for each cell in ring k, set its value to reversed_colors[k]. 3. Leave all cells with value 0 unchanged.",
    "bf32578f": "1. Identify the input color:\n   a. Scan the entire grid to find the non‐zero integer c (there is exactly one such color).\n2. Collect the input outline points:\n   a. Create list P = all coordinates (r,c0) where grid[r][c0] == c.\n3. Compute the horizontal mirror axis:\n   a. Let minCol = minimum c0 among P, maxCol = maximum c0 among P.\n   b. Define mirrorAxis = minCol + maxCol.\n4. Generate the mirrored outline:\n   a. For each (r,c0) in P, compute mirrored column cm = mirrorAxis - c0 and add (r,cm) to set M.\n   b. Let Outline = P ∪ M.\n5. Draw the full closed boundary on a copy of the grid:\n   a. Initialize a working grid W as a copy of the input grid.\n   b. For each (r,cm) in M, set W[r][cm] = c.\n6. Flood‐fill the interior of the closed outline:\n   a. Choose a seed point (sr,sc) strictly inside the boundary: \n      sr = floor((minRow + maxRow)/2), sc = floor((minCol + maxCol)/2), where minRow, maxRow are min/max r in Outline.\n   b. Perform a flood‐fill on W, starting at (sr,sc), replacing only zeros with color c, and not crossing any cell already equal to c.\n7. Erase the outline:\n   a. For each (r,c0) in Outline, set W[r][c0] = 0.\n8. Extract the filled region and center it in the original grid:\n   a. Let F = all coordinates (r,c0) in W where W[r][c0] == c.\n   b. Compute fillMinRow, fillMaxRow, fillMinCol, fillMaxCol from F.\n   c. Compute fillHeight = fillMaxRow - fillMinRow + 1, fillWidth = fillMaxCol - fillMinCol + 1.\n   d. Compute targetRow0 = floor((H - fillHeight)/2), targetCol0 = floor((W - fillWidth)/2), where H and W are the original grid’s height and width.\n   e. Initialize an output grid G of size H×W with zeros.\n   f. For each (r,c0) in F, set G[r - fillMinRow + targetRow0][c0 - fillMinCol + targetCol0] = c.\n9. Return G as the transformed grid.",
    "20981f0e": "1. Identify all red corner pixels (value 2) in the input grid. Collect their unique row indices into a sorted list R and their unique column indices into a sorted list C.\n2. For each cell defined by adjacent red rows and columns:\n   a. For each i from 0 to length(R)–2 and each j from 0 to length(C)–2, define cell rows from r_top = R[i]+1 to r_bot = R[i+1]–1, and cell columns from c_left = C[j]+1 to c_right = C[j+1]–1.\n   b. Within this cell region, locate all blue pixels (value 1). If no blue pixels, skip to the next cell.\n   c. Compute the blue shape’s bounding box: min_r = minimum row of these pixels, max_r = maximum row, min_c = minimum column, max_c = maximum column.\n   d. Compute cell height h_c = r_bot – r_top +1 and cell width w_c = c_right – c_left +1.\n   e. Compute shape height h_s = max_r – min_r +1 and shape width w_s = max_c – min_c +1.\n   f. Compute target top-left for centering: start_r = r_top + floor((h_c – h_s)/2), start_c = c_left + floor((w_c – w_s)/2).\n   g. Clear all blue pixels in the cell region by setting those positions to 0.\n   h. For each original blue pixel at (r,c), compute new_r = start_r + (r – min_r), new_c = start_c + (c – min_c), and set that position to 1.\n3. After processing all cells, output the modified grid.",
    "8e2edd66": "1. Let G be the 3×3 input grid with rows 0..2 and columns 0..2. 2. Scan G to find the unique non-zero value C. 3. Create an output grid O of size 9×9, initialize all O[r][c]=0 for r,c in 0..8. 4. For each original cell at (i,j) with i,j in 0..2:   a. Compute block row base br=i*3 and block column base bc=j*3.   b. If G[i][j]==0 then:      i. For each r in 0..2 and c in 0..2:         - If G[r][c]==0 set O[br+r][bc+c]=C.         - Else set O[br+r][bc+c]=0.   c. Else (G[i][j]!=0): leave O[br..br+2][bc..bc+2] as zeros. 5. Return O as the 9×9 output grid.",
    "bf699163": "1. Identify all cells in the input grid whose value is 7. 2. Compute R_min = minimum row index of these cells, R_max = maximum row index, C_min = minimum column index, and C_max = maximum column index. 3. Define the candidate subgrid as all cells with row in [R_min,R_max] and column in [C_min,C_max]. 4. In this candidate subgrid, collect all cells whose value is neither 5 nor 7. 5. Let C be the unique value of these collected cells. 6. Compute r1 = minimum row index of cells with value C, r2 = maximum row index, c1 = minimum column index, c2 = maximum column index. 7. Define H = r2 – r1 + 1 and W = c2 – c1 + 1. 8. Create an output grid of size H rows by W columns, initially filled with 5. 9. For each cell in the output grid at (i,j) where i = 1 or i = H or j = 1 or j = W, set its value to C. 10. Leave all interior cells (i in 2..H–1 and j in 2..W–1) as 5. 11. Return this H×W grid as the output.",
    "212895b5": "1. Locate the 3×3 block of value 8 (the only contiguous 3×3 region where every cell == 8). Let its top-left coordinate be (r0,c0). Then its corners are:\n   • Top-left corner: (r0,   c0)\n   • Top-right corner: (r0,   c0+2)\n   • Bottom-left corner: (r0+2, c0)\n   • Bottom-right corner:(r0+2, c0+2)\n   And its side midpoints (inside the block) are:\n   • Top midpoint:     M0 = (r0,   c0+1)\n   • Right midpoint:   M1 = (r0+1, c0+2)\n   • Bottom midpoint:  M2 = (r0+2, c0+1)\n   • Left midpoint:    M3 = (r0+1, c0)\n\n2. Draw a yellow zig-zag (value 4) from each side midpoint Mi, for i=0,1,2,3 in clockwise order:\n   For side i use two direction vectors:\n     • outward_i  = [(-1,0),(0,1),(1,0),(0,-1)][i]\n     • turn_i      = [(0,1),(1,0),(0,-1),(-1,0)][i]\n   Initialize cur = Mi and segment = 0.\n   Repeat:\n     a. Let dir = outward_i if segment is even, else dir = turn_i.\n     b. Repeat two times:\n        i.   new = cur + dir\n        ii.  If new is outside grid or grid[new] != 0, stop this side’s zig-zag.\n        iii. Set grid[new] = 4 and update cur = new.\n     c. segment += 1 and continue the loop.\n\n3. Draw red diagonals (value 2) from each corner of the 8-block outward until blocked:\n   For each corner corner_j and its diagonal vector diag_j:\n     • corner_0 = (r0,   c0),   diag_0 = (-1,-1)\n     • corner_1 = (r0,   c0+2), diag_1 = (-1,+1)\n     • corner_2 = (r0+2, c0+2), diag_2 = (+1,+1)\n     • corner_3 = (r0+2, c0),   diag_3 = (+1,-1)\n   For each j:\n     cur = corner_j\n     Loop:\n       new = cur + diag_j\n       If new is outside grid or grid[new] != 0, break.\n       Set grid[new] = 2 and update cur = new.\n\n4. Leave all other cells unchanged.",
    "8ee62060": "1. Let H be the number of rows and W the number of columns of the input grid.\n2. For each row r from 0 to H–1:\n   a. Scan columns c from 0 to W–1 to find the first non-zero cell; let c_start[r] be the smallest c such that input[r][c] ≠ 0.\n   b. Count L[r], the length of the contiguous run of non-zero cells starting at c_start[r]: L[r] is the largest positive integer so that for all i in [0, L[r) ), input[r][c_start[r] + i] ≠ 0 and either c_start[r]+L[r] = W or input[r][c_start[r] + L[r]] = 0.\n   c. Record the color sequence S[r] = [ input[r][c_start[r] + i] for i = 0 to L[r]–1 ].\n3. Compute max_start = max{ c_start[r] | r = 0..H–1 }.\n4. Create an output grid of size H×W and fill every cell with 0.\n5. For each row r from 0 to H–1:\n   a. Compute c_out = max_start – c_start[r].\n   b. For each i in [0, L[r) ): set output[r][c_out + i] = S[r][i].\n6. Return the output grid.",
    "bf89d739": "1. Identify all red pixels: scan the input grid and collect the set R of coordinates (r,c) where grid[r][c]==2.\n2. Find the two red pixels with the longest straight alignment:\n   a. Initialize best_distance=-1.\n   b. For each unordered pair (p,q) in R:\n      i. If p.r==q.r (same row), let d=|p.c-q.c|. If d>best_distance, set best_distance=d, orientation=horizontal, trunk_row=p.r, c_min=min(p.c,q.c), c_max=max(p.c,q.c), endpoint1=p, endpoint2=q.\n      ii. If p.c==q.c (same column), let d=|p.r-q.r|. If d>best_distance, set best_distance=d, orientation=vertical, trunk_col=p.c, r_min=min(p.r,q.r), r_max=max(p.r,q.r), endpoint1=p, endpoint2=q.\n3. Draw the trunk in green (value 3):\n   a. If orientation==horizontal: for each c in (c_min+1) to (c_max-1): if grid[trunk_row][c]!=2, set grid[trunk_row][c]=3.\n   b. If orientation==vertical: for each r in (r_min+1) to (r_max-1): if grid[r][trunk_col]!=2, set grid[r][trunk_col]=3.\n4. For each red pixel p in R except endpoint1 and endpoint2, draw a perpendicular branch:\n   a. If trunk is horizontal at row R0=trunk_row:\n      For p=(r,c), for each rr in range(min(r,R0)+1) to (max(r,R0)-1): if grid[rr][c]!=2, set grid[rr][c]=3.\n   b. If trunk is vertical at column C0=trunk_col:\n      For p=(r,c), for each cc in range(min(c,C0)+1) to (max(c,C0)-1): if grid[r][cc]!=2, set grid[r][cc]=3.\n5. Return the modified grid.",
    "21f83797": "1. Let the input be a grid of height H rows and width W columns, indexed from row 0 to H-1 and column 0 to W-1.\n2. Scan the grid to find all cells of value 2. There will be exactly two such cells. Denote their coordinates as (r1, c1) and (r2, c2).\n3. Compute r_min = min(r1, r2), r_max = max(r1, r2), c_min = min(c1, c2), c_max = max(c1, c2).\n4. Draw the two vertical border lines:\n   For each row i from 0 to H-1:\n     Set cell (i, c_min) = 2.\n     Set cell (i, c_max) = 2.\n5. Draw the two horizontal border lines:\n   For each column j from 0 to W-1:\n     Set cell (r_min, j) = 2.\n     Set cell (r_max, j) = 2.\n6. Fill the interior rectangle bounded by these lines:\n   For each row i from r_min + 1 to r_max - 1:\n     For each column j from c_min + 1 to c_max - 1:\n       Set cell (i, j) = 1.\n7. Leave all other cells unchanged.",
    "8fbca751": "1. Define shape pixels as those with value 8 and background pixels as those with value 0. 2. Find all connected components of shape pixels using 8-connectivity (cells are connected if they share an edge or a corner). 3. For each connected component:   a. Compute r_min = minimum row index of its pixels; r_max = maximum row index; c_min = minimum column index; c_max = maximum column index.   b. For each row r from r_min to r_max and each column c from c_min to c_max:      i. If grid[r][c] == 0, set grid[r][c] = 2. 4. Output the resulting grid.",
    "c074846d": "1. Scan the input grid and locate the unique pivot cell with value 5. Record its coordinates as (r0, c0).\n2. Scan the grid and collect the coordinates of all cells with value 2 (the red line). Store these as a list of original red positions: [(r1, c1), (r2, c2), …, (rN, cN)].\n3. For each original red position (ri, ci), compute its offset from the pivot: dr = ri - r0, dc = ci - c0.\n4. For each offset (dr, dc), compute the clockwise-rotated offset: dr′ = -dc, dc′ = dr.\n5. Compute the target positions for the rotated red line: for each (dr′, dc′), new position = (r0 + dr′, c0 + dc′). Collect these as [(r1′, c1′), …, (rN′, cN′)].\n6. Create the output grid by copying the input grid.\n7. For each original red position (ri, ci), set output_grid[ri][ci] = 3 (green).\n8. For each new position (rj′, cj′), set output_grid[rj′][cj′] = 2 (red).\n9. Leave the pivot cell (value 5) and all other cells unchanged.\n10. Return the output grid.",
    "22a4bbc2": "1. Let H be the number of rows and W the number of columns of the input grid.\n2. Initialize an empty list stripes.\n3. Iterate r from 0 to H–1 to partition into horizontal stripes:\n   a. If r==0 or row r has a different sequence of W values than row r–1, start a new stripe with index = length(stripes)+1 and record its start_row = r.\n   b. Else, extend the current stripe to include row r.\n   c. For each stripe, record its start_row and end_row (inclusive) when you finish adding rows to it.\n4. For each stripe in stripes, in top-to-bottom order with 1-based stripe_index:\n   a. If stripe_index mod 3 == 1, then for each row r from start_row to end_row and each column c from 0 to W–1:\n       i. If grid[r][c] != 0, set grid[r][c] = 2.\n   b. Otherwise, leave all cells in that stripe unchanged.\n5. Return the modified grid as the output.",
    "90347967": "1. Let H be the number of rows and W be the number of columns of the input grid.  \n2. Scan the input grid to find all nonzero cells. Record orig_r0 = minimum row index of any nonzero cell; orig_r1 = maximum row index of any nonzero cell; orig_c0 = minimum column index of any nonzero cell; orig_c1 = maximum column index of any nonzero cell.  \n3. Compute h = orig_r1 - orig_r0 + 1 and w = orig_c1 - orig_c0 + 1.  \n4. Extract the h×w subgrid A from the input at rows orig_r0..orig_r1 and columns orig_c0..orig_c1.  \n5. Create an h×w grid B by rotating A by 180 degrees: for each i in [0..h-1] and each j in [0..w-1], set B[i][j] = A[h-1 - i][w-1 - j].  \n6. Compute new_r0 = orig_r0 - (h - 1). If new_r0 < 0, set new_r0 = 0.  \n7. Compute new_c0 = orig_c0 + (w - 1). If new_c0 > W - w, set new_c0 = W - w.  \n8. Initialize the output grid to all zeros of size H×W.  \n9. Overlay B into the output: for each i in [0..h-1] and each j in [0..w-1], set output[new_r0 + i][new_c0 + j] = B[i][j].  \n10. Return the output grid.",
    "c1990cce": "1. Read input grid width N (odd integer ≥5). Compute midpoint mid = (N - 1) / 2.\n2. Create an N×N output grid, initialized to 0.\n3. Draw the red (value 2) pyramid boundary:\n   a. For each row r from 0 to mid (inclusive):\n      i. Set cell (r, mid - r) = 2.\n      ii. Set cell (r, mid + r) = 2.\n4. Draw the interior blue (value 1) diagonals, each of slope +1, spaced by one blank diagonal between them:\n   a. For diagonal index k from 1 to mid − 1:\n      i. Compute start_row = 2*k + 1.\n      ii. Compute start_col = mid - k.\n      iii. If start_row ≥ N or start_col < 0, skip this k.\n      iv. From t = 0 while true:\n           • Let r = start_row + t; c = start_col + t.\n           • If r ≥ N or c ≥ N, break the loop for this k.\n           • If output(r, c) is not 2, set output(r, c) = 1.\n5. Copy the input’s original 2 at row 0, col mid (already placed by step 3). Ensure no other input cells remain nonzero.\n6. Return the output grid.",
    "25094a63": "1. Let G be the input grid of size R rows by C columns. 2. Create an output grid O as an exact copy of G. 3. Define a connected component as a maximal set of positions connected by 4-adjacency (up/down/left/right) having the same integer value v. 4. Find all connected components in G for all values v. 5. For each component comp with value v:   a. Compute min_row = minimum row index in comp, max_row = maximum row index in comp.   b. Compute min_col = minimum column index in comp, max_col = maximum column index in comp.   c. Let height = max_row - min_row + 1, width = max_col - min_col + 1.   d. Check that the bounding rectangle B defined by rows min_row..max_row and columns min_col..max_col is filled entirely with v in G (i.e., for every (r,c) in B, G[r][c] == v).   e. If B is full of v and height >= 4 and width >= 4, then for every (r,c) in B set O[r][c] = 4. 6. After processing all components, return O as the transformed grid.",
    "903d1b4a": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Initialize an output grid of size H×W as an exact copy of the input grid.\n3. For each row index r from 0 to H–1:\n   a. For each column index c from 0 to W–1:\n      i. If input_grid[r][c] ≠ 3, leave output_grid[r][c] unchanged.\n      ii. If input_grid[r][c] = 3, then:\n         A. Compute c_h = W – 1 – c (the horizontal mirror column).\n         B. If input_grid[r][c_h] ≠ 3, set output_grid[r][c] = input_grid[r][c_h].\n         C. Otherwise (input_grid[r][c_h] = 3), compute r_v = H – 1 – r (the vertical mirror row) and set output_grid[r][c] = input_grid[r_v][c].\n4. Return the output grid.",
    "c3202e5a": "1. Let G be the input grid of size R×C.  \n2. Identify the separator value S as the integer V (1–9) for which there exists at least one row r in [0,R–1] such that for all c in [0,C–1], G[r][c]==V, and at least one column c in [0,C–1] such that for all r in [0,R–1], G[r][c]==V.  \n3. Compute the set of separator rows R_sep = {r | ∀c∈[0,C–1], G[r][c]==S}, and sort R_sep in ascending order.  \n4. Compute the set of separator columns C_sep = {c | ∀r∈[0,R–1], G[r][c]==S}, and sort C_sep in ascending order.  \n5. Define row block intervals as the contiguous ranges between separators:  \n   a. Let prev_row = –1.  \n   b. For each r in R_sep in ascending order:  \n      i. Append the interval [prev_row+1, r–1] to RowBlocks if r–1 ≥ prev_row+1.  \n      ii. Set prev_row = r.  \n   c. After the loop, if prev_row < R–1, append [prev_row+1, R–1].  \n6. Define column block intervals analogously using C_sep to obtain ColBlocks.  \n7. For each pair of intervals (row_i = [r1,r2], col_j = [c1,c2]) from RowBlocks × ColBlocks:  \n   a. Extract the subgrid B of size (r2–r1+1)×(c2–c1+1) where B[a][b] = G[r1+a][c1+b] for a∈[0,r2–r1], b∈[0,c2–c1].  \n   b. Let V_set = { x | x≠0 and x occurs in B }.  \n   c. If |V_set|==1 (exactly one unique non-zero value) and B contains at least one non-zero, select B as the target block and stop.  \n8. Return B as the output grid, preserving its exact dimensions and cell values.",
    "2546ccf6": "1. Let D be the integer value (0–9) such that every cell in some rows and the same columns equals D; these are the divider rows and columns.  2. Identify all divider rows (R_div) and divider columns (C_div) where grid[r][*] all == D or grid[*][c] all == D.  3. Let row‐blocks be the contiguous row ranges between consecutive entries in R_div, and let col‐blocks be the contiguous column ranges between consecutive entries in C_div.  4. For each row‐block RB (rows r1…r2 between two horizontal dividers):     a. Collect all cells in RB whose value X ≠0 and X ≠D.     b. Find all orthogonally connected components among these cells; label each component by its color X.     c. For each color X among these components:         i. If exactly one component of color X exists in RB, let its set of cells be P.         ii. Compute c_min = min(c for (r,c) in P) and c_max = max(c for (r,c) in P).         iii. Among all divider columns v in C_div, find the one minimizing distance d = min(|v–c_min|, |v–c_max|) subject to v<c_min or v>c_max. Call this v_bar.         iv. For each (r,c) in P, compute c’ = v_bar + (v_bar – c). Set grid[r][c’] = X. 5. Return the modified grid.",
    "9110e3c5": "1. Let input be a 7×7 grid G of integer values 0–9.  \n2. Initialize a dictionary count[color] = 0 for each color in 1–9.  \n3. For each cell (r,c) in G:  \n   a. Let v = G[r][c].  \n   b. If v ≠ 0, increment count[v] by 1.  \n4. Let color_max be the key k in count with the largest count[k].  \n5. Create an output grid M of size 3×3 and fill every cell with 0.  \n6. If color_max = 1 then set M[0][2] = 8, M[1][0] = 8, M[1][1] = 8, M[2][1] = 8.  \n7. Else if color_max = 2 then set M[1][0] = 8, M[1][1] = 8, M[1][2] = 8.  \n8. Else if color_max = 3 then set M[0][1] = 8, M[0][2] = 8, M[1][1] = 8, M[2][1] = 8.  \n9. Return M as the transformed 3×3 grid.",
    "c35c1b4c": "1. Let H be the number of rows and W the number of columns of the input grid.  2. Compute midCol = W/2 (using 1-based indexing).  Equivalently, in 0-based indexing midCol0 = (W/2) - 1.  3. Count the occurrences of each integer value v in column midCol0 (0-based).  4. Let target be the integer value with the highest count in that column.  5. Initialize an empty list L.  6. For each row r from 0 to H-1 and each column c from 0 to W-1, if grid[r][c] == target then append (r,c) to L.  7. For each (r,c) in L, compute mirror_c = W - 1 - c, and set grid[r][mirror_c] = target.  8. Return the modified grid as the output.",
    "256b0a75": "1. Locate all corner‐marker clusters: scan the grid to find every connected component of exactly three pixels of the same non‐zero color that form a right‐angle “L” shape (i.e. two adjacent pixels in one row plus a third directly below one of them, or two in one column plus a third directly beside one of them). You will find exactly four such clusters, each marking one corner of a rectangle.\n2. For each cluster, compute its row‐min (r_min), row‐max (r_max), col‐min (c_min), and col‐max (c_max).\n3. Determine the rectangle boundaries:\n   • top = minimum of r_min over all clusters\n   • bottom = maximum of r_max over all clusters\n   • left = minimum of c_min over all clusters\n   • right = maximum of c_max over all clusters\n4. Identify the two distinct corner colors (from the four clusters). Count how many clusters each color appears in. Let interior_color be the color that appears in three clusters (the “matching” color) and let frame_color be the color that appears in one cluster (the “different” color).\n5. Initialize the output grid as a copy of the input.\n6. Draw the filled rectangle:\n   a. For every cell (r, c) with top < r < bottom and left < c < right, set output(r,c) = interior_color.\n   b. For every cell on the rectangle border (r == top or r == bottom or c == left or c == right), set output(r,c) = frame_color.\n7. Extend all other original colored pixels (those not in any corner cluster):\n   For each such pixel of color X at (r,c):\n     a. If top <= r <= bottom and c < left, then for k from 0 to left-1 set output(r,k) = X.\n     b. If top <= r <= bottom and c > right, then for k from right+1 to max_col set output(r,k) = X.\n     c. If left <= c <= right and r < top,    then for k from 0 to top-1  set output(k,c) = X.\n     d. If left <= c <= right and r > bottom, then for k from bottom+1 to max_row set output(k,c) = X.\n8. Leave all other cells unchanged.\n9. Return the output grid.",
    "917bccba": "1. Let R be the number of rows and M be the number of columns in the input grid.\n2. Identify the square:\n   a. Find all pixels of a single nonzero value S that form a contiguous filled block.\n   b. Compute the bounding box of these S pixels: r_min = minimum row index, r_max = maximum row index, c_min = minimum column index, c_max = maximum column index.\n   c. Verify that r_max–r_min = c_max–c_min (the block is a square).\n3. Identify the cross color C as the unique nonzero value not equal to S that appears in exactly two straight lines:\n   a. Confirm that all pixels of value C lie on a single row r0 and a single column c0 and that they intersect at (r0, c0).\n4. Erase the original cross by setting every pixel of value C to 0.\n5. Compute the top-right corner of the square: r_tr = r_min, c_tr = c_max.\n6. Draw the horizontal line of the cross:\n   For each column j from 0 to M-1:\n     If grid[r_tr][j] == 0, set grid[r_tr][j] = C.\n7. Draw the vertical line of the cross:\n   For each row i from 0 to R-1:\n     If grid[i][c_tr] == 0, set grid[i][c_tr] = C.\n8. Leave all existing nonzero pixels (the square of S and any other shapes) unchanged.\n9. Return the modified grid as the output.",
    "c48954c1": "1. Let input be a 3×3 grid A with rows r=0..2 and cols c=0..2. 2. Create an empty 9×9 grid B with rows R=0..8 and cols C=0..8. 3. For each block row br in 0..2 and block col bc in 0..2:   a. Determine transform T as follows:      i. If br mod 2 = 0 and bc mod 2 = 0, T = rotate‐180.     ii. Else if br mod 2 = 0 and bc mod 2 = 1, T = vertical‐flip.    iii. Else if br mod 2 = 1 and bc mod 2 = 0, T = horizontal‐flip.     iv. Else (br mod 2 = 1 and bc mod 2 = 1), T = identity.   b. For each local row r in 0..2 and local col c in 0..2:      i. If T = identity, v = A[r][c].     ii. If T = vertical‐flip, v = A[2−r][c].    iii. If T = horizontal‐flip, v = A[r][2−c].     iv. If T = rotate‐180, v = A[2−r][2−c].     v. Set B[br*3 + r][bc*3 + c] = v. 4. Return B.",
    "2685904e": "1. Let R and C be the number of rows and columns of the input grid. 2. Copy the input grid to the output grid. 3. Identify base_row: the row index r (0 ≤ r < R) such that for every column c (0 ≤ c < C), grid[r][c] == 5. 4. Compute N: the count of columns c where grid[0][c] == 8. 5. Find bottom_blank_row: the maximum row index r such that for every column c, grid[r][c] == 0. 6. Define swatch_row = bottom_blank_row - 1. 7. For each distinct color value C_val ≠ 0 and C_val ≠ 5 present in output_grid[swatch_row], compute count_C = the number of columns j where output_grid[swatch_row][j] == C_val. 8. For each column j from 0 to C−1:  if output_grid[swatch_row][j] == C_val and count_C == N, then for k from 1 to N do:    set output_grid[base_row - k][j] = C_val. 9. Leave all other cells of output_grid unchanged. 10. Return output_grid.",
    "929ab4e9": "1. Let H be the number of rows and W be the number of columns in the input grid.  \n2. Initialize the output grid as an exact copy of the input grid.  \n3. For each row index r from 0 to H-1:  \n   a. For each column index c from 0 to W-1:  \n      i. If the input cell at (r,c) has value 2 (red), then set output[r][c] = input[r][W-1-c].  \n      ii. Otherwise leave output[r][c] unchanged.  \n4. Return the output grid.",
    "c62e2108": "1. Identify each hollow-square tile template:\n   a. Find each connected component of nonzero pixels whose bounding box is a square of side N>1.\n   b. Verify that all pixels on the four edges of that box equal a single color C_shape and that all interior pixels are 0.\n   c. Record for each template its color C_shape, its side length N, and its top-left coordinates (r0,c0).\n2. Identify the boundary color C_bound (≠C_shape) as any color that appears in straight horizontal or vertical runs of exactly N adjacent pixels.\n3. For each template do:\n   a. Determine rowMin,rowMax:\n      i.  Let rowsH = {row of each length-N horizontal run of C_bound whose column span [c1..c1+N-1] overlaps [c0..c0+N-1]}.\n      ii. If rowsH contains a value rh<r0, set rowMin=rh; else set rowMin=r0.\n      iii. If rowsH contains a value rh>r0, set rowMax=rh; else set rowMax=r0+N-1.\n   b. Determine colMin,colMax:\n      i.  Let colsV = {col of each length-N vertical run of C_bound whose row span [r1..r1+N-1] overlaps [r0..r0+N-1]}.\n      ii. If colsV contains a value cv<c0, set colMin=cv; else set colMin=c0.\n      iii. If colsV contains a value cv>c0, set colMax=cv; else set colMax=c0+N-1.\n   c. Tile the template over the rectangle R = rows [rowMin..rowMax], columns [colMin..colMax]:\n      For tr from rowMin to rowMax step N:\n        For tc from colMin to colMax step N:\n          For dr in 0..N-1:\n            For dc in 0..N-1:\n              Let r = tr+dr, c = tc+dc.\n              If r in [rowMin..rowMax] and c in [colMin..colMax] then:\n                If dr==0 or dr==N-1 or dc==0 or dc==N-1:\n                  Set grid[r][c] = C_shape\n                Else:\n                  Set grid[r][c] = 0\n4. Leave all other cells unchanged.",
    "2697da3f": "1. Let input be an R×C grid of integers. 2. Identify P = the non-zero pixel value. 3. Find r_min = min r with any cell input[r][c]=P; r_max = max r with input[r][c]=P. 4. Find c_min = min c with input[r][c]=P; c_max = max c with input[r][c]=P. 5. Let H = r_max–r_min+1; W = c_max–c_min+1; S = max(H,W). 6. Extract the H×W block B[r'][c'] = input[r_min+r'][c_min+c'] for r'=0..H-1, c'=0..W-1. 7. Form an S×S square M initialized to 0. Copy B into M at its top-left: for r'=0..H-1, c'=0..W-1 set M[r'][c']=B[r'][c']. 8. Compute the four S×S blocks:  M0 = M (no rotation);  M1 = M rotated 90° clockwise;  M2 = M rotated 180°;  M3 = M rotated 270° clockwise. 9. Let N = H + 2·S. Create an N×N output grid G initialized to 0. 10. Paste M0 at left edge: for i=0..S-1, j=0..S-1 set G[S+i][j] = M0[i][j]. 11. Paste M1 at top edge: for i=0..S-1, j=0..S-1 set G[i][S+j] = M1[i][j]. 12. Paste M2 at right edge: for i=0..S-1, j=0..S-1 set G[S+i][S+H+j] = M2[i][j]. 13. Paste M3 at bottom edge: for i=0..S-1, j=0..S-1 set G[S+H+i][S+j] = M3[i][j]. 14. Return G.",
    "92e50de0": "1. Let input_grid be the given 2D array of size R×C, with pixel values 0–9.  Initialize output_grid as a copy of input_grid.\n2. Identify separator color S: for r in [0,R): if all cells in row r have the same value v, set S=v and break.\n3. Identify horizontal separator rows: let H_seps = [ r for r in [0,R) if all cells in row r == S ].\n4. Identify cell height H: let first_sep = min(H_seps); set H = first_sep if first_sep>0 else 0; (here H is number of non-separator rows before first separator).\n5. Identify vertical separator columns: for c in [0,C): if all rows r in [0,R) have input_grid[r][c]==S, include c in V_seps.\n6. Identify cell width W: let first_vsep = min(V_seps); set W = first_vsep if first_vsep>0 else 0.\n7. Build row_block_starts: let R_starts = [0]; for each r in sorted(H_seps): if r+1<R, append r+1 to R_starts.  Let row_block_count = len(R_starts).\n8. Build col_block_starts: let C_starts = [0]; for each c in sorted(V_seps): if c+1<C, append c+1 to C_starts.  Let col_block_count = len(C_starts).\n9. Determine interior background B: count all pixels in input_grid not equal to S; let B be the most frequent such pixel.\n10. Locate original block (orig_i,orig_j): for i in [0,row_block_count): for j in [0,col_block_count): let r0 = R_starts[i], c0 = C_starts[j]; if any input_grid[r0+dr][c0+dc] != B for dr in [0,H), dc in [0,W), then set orig_i=i, orig_j=j and break both loops.\n11. Extract pattern P of size H×W: for dr in [0,H), dc in [0,W): P[dr][dc] = input_grid[R_starts[orig_i]+dr][C_starts[orig_j]+dc].\n12. For each block (i,j) with i in [0,row_block_count), j in [0,col_block_count): if ((i - orig_i) mod 2 == 0) AND ((j - orig_j) mod 2 == 0) then:\n    a. Let r0 = R_starts[i], c0 = C_starts[j].\n    b. For dr in [0,H), dc in [0,W): set output_grid[r0+dr][c0+dc] = P[dr][dc].\n13. Return output_grid as the final transformed grid.",
    "c64f1187": "1. Identify the legend shapes:\n   a. Let SHAPE_COLOR = 1 (the color used for all blueprint shapes in the input).\n   b. Find all connected components (4-connected) of cells with value SHAPE_COLOR anywhere in the grid. For each component:\n      i. Compute its bounding box: top row r0 = min_row, left column c0 = min_col, height H = max_row-min_row+1, width W = max_col-min_col+1.\n      ii. Build a binary mask M of size H×W where M[i][j] = 1 if input[r0+i][c0+j] == SHAPE_COLOR, else 0.\n      iii. Locate its marker color: read input[r0-1][c0-1] (the cell immediately above and to the left of the mask’s top-left). Call this value COLOR.\n      iv. Store shape_masks[COLOR] = {mask=M, height=H, width=W}.\n2. Determine the output canvas size:\n   a. Find min_r = minimum row index r with input[r][c] == 5 for any c.\n   b. Find max_r = maximum row index r with input[r][c] == 5 for any c.\n   c. Find min_c = minimum column index c with input[r][c] == 5 for any r.\n   d. Find max_c = maximum column index c with input[r][c] == 5 for any r.\n   e. Define output_height = max_r - min_r + 1, output_width = max_c - min_c + 1.\n   f. Initialize an output grid OUT of size output_height×output_width filled with 0.\n3. Place shapes into each 2×2 block of the grey region:\n   a. For each candidate block top-left (r,c) with r from min_r to max_r - shape_height + 1 and c from min_c to max_c - shape_width + 1:\n      i. Let H and W be the common dimensions of all shapes (they all share the same H and W from step 1).\n      ii. If input[r][c] != 5, skip to next (no block starts here).\n      iii. Extract the block region B = {input[r+i][c+j] | 0 ≤ i < H, 0 ≤ j < W}.\n      iv. Within B, find any cell with value != 5 and != 0; call that value COLOR_k (the marker color for this block).\n      v. Retrieve {M, H, W} = shape_masks[COLOR_k].\n      vi. For each i from 0 to H-1 and j from 0 to W-1:\n           - If M[i][j] == 1, then set OUT[r - min_r + i][c - min_c + j] = COLOR_k.\n4. Return OUT as the transformed grid.",
    "2753e76c": "1. Let InputGrid be the given rectangular grid of integers (0–9).  \n2. Identify the set Colors = {v ∈ {1…9} | v appears at least once in InputGrid}.  \n3. For each color v in Colors, compute Count[v] = number of orthogonally connected components of pixels equal to v in InputGrid.  An orthogonally connected component is a maximal set of grid cells of value v where each cell has at least one neighbor in the set sharing a side.  \n4. Let MaxCount = max{Count[v] | v ∈ Colors}.  \n5. Create a list Pairs = [(v, Count[v]) for each v ∈ Colors].  Sort Pairs in descending order of Count; if two counts are equal, sort those by ascending v.  \n6. Let H = number of elements in Pairs, W = MaxCount.  7. Initialize an OutputGrid of size H rows by W columns, filling every cell with 0.  \n8. For each index i from 0 to H−1:  \n   a. Let (v, c) = Pairs[i].  \n   b. In row i of OutputGrid, set the rightmost c cells (columns W−c through W−1) to the value v.  \n9. Return OutputGrid as the result.",
    "9356391f": "1. Let grid be the input array of size H×W.\n2. Read row 0. Find the largest column index L such that grid[0][L] ≠ 0. Define the color pattern P as the sequence [grid[0][0], grid[0][1], …, grid[0][L]].  \n3. Identify the center pixel value C0 = P[0].  \n4. Find the unique coordinates (R,C) with R ≥ 2 where grid[R][C] = C0 (this is the center of concentric squares).\n5. For each integer i from 0 to |P|−1 do:\n   a. Let color = P[i] and radius = i.\n   b. Compute r_min = R − radius, r_max = R + radius, c_min = C − radius, c_max = C + radius.\n   c. For each cell (r,c) satisfying r_min ≤ r ≤ r_max and c_min ≤ c ≤ c_max, if r = r_min or r = r_max or c = c_min or c = c_max, then set grid[r][c] = color.\n6. Leave all other cells unchanged.\n7. Return the modified grid as output.",
    "c658a4bd": "1. Scan the input grid and collect all nonzero colors.\n2. For each color c (>0):\n   a. Find min_row = minimum row index where grid[row][col] == c.\n   b. Find max_row = maximum row index where grid[row][col] == c.\n   c. Find min_col = minimum column index where grid[row][col] == c.\n   d. Find max_col = maximum column index where grid[row][col] == c.\n   e. Compute height = max_row - min_row + 1 and width = max_col - min_col + 1.\n   f. Compute side = max(height, width).\n   g. Record shape (c, side).\n3. Sort the recorded shapes by side in descending order.\n4. Let N = side of the first shape in the sorted list.\n5. Create an output grid of size N×N, initialized to 0s.\n6. For each recorded shape (color c, side s) in sorted order:\n   a. Compute offset = (N - s) // 2.\n   b. For r from 0 to s-1:\n      For k from 0 to s-1:\n         If r == 0 or r == s-1 or k == 0 or k == s-1:\n            Set output[offset + r][offset + k] = c.\n7. Return the output grid.",
    "27a77e38": "1. Let H be the number of rows and W be the number of columns in the input grid. 2. Compute center_col = floor(W/2). 3. Initialize an empty map freq from integer value to count. 4. For each row r from 0 to H-1 and each column c from 0 to W-1:\n   a. Let v = input[r][c].\n   b. If v ≠ 0 and v ≠ 5, then increment freq[v] by 1 (default 0). 5. Identify v_max as the key in freq with the largest count. 6. Copy the entire input grid to the output grid. 7. Set output[H-1][center_col] = v_max. 8. Return the output grid.",
    "93b4f4b3": "1. Locate the separator column SEP in the input grid such that every cell in column SEP has value 0. 2. Define the left subgrid L as all columns from 0 to SEP–1, and the right subgrid R as all columns from SEP+1 to the last column, preserving row indices. 3. In L, let BACKGROUND=0 and let BORDER be the unique non-zero value present in L (the border color). 4. Identify all hole components in L: each hole is a connected component (4-connectivity) of cells with value BACKGROUND. For each hole H, record the set of its cell coordinates H_CELLS and compute its normalized shape signature H_SIG = { (r–min_r, c–min_c) | (r,c) in H_CELLS }. 5. In R, identify all shape components: each shape S is a connected component (4-connectivity) of cells with value != BACKGROUND. For each shape S, record its color S_COLOR (the common non-zero value) and its normalized shape signature S_SIG = { (r–min_r, c–min_c) | (r,c) in S_CELLS }. 6. For each hole H in L, find the shape S in R whose signature S_SIG exactly equals H_SIG. 7. For each matching pair (H,S), fill H in L by setting every cell (r,c) in H_CELLS to S_COLOR. 8. The output grid is the modified subgrid L (all rows, columns 0 to SEP–1).",
    "c663677b": "1. Let N = number of rows and M = number of columns of the input grid. 2. Compute the set D of all divisors s of N such that 1 < s < N and N mod s = 0; sort D in descending order. 3. For each s in D in order: 3.1. For each block origin (r0,c0) where r0 ∈ {0, s, 2s, …, N−s} and c0 ∈ {0, s, 2s, …, M−s}: check the s×s subgrid with top-left at (r0,c0). 3.2. If that subgrid contains no cells of value 0, record pattern_size = s, pattern_origin = (r0,c0), and break out of both loops. 4. Extract the reference pattern P of size pattern_size×pattern_size from grid rows r0..r0+pattern_size−1 and columns c0..c0+pattern_size−1. 5. For each cell (r,c) in the entire grid: if grid[r][c] == 0 then 5.1. Compute dr = (r − r0) mod pattern_size and dc = (c − c0) mod pattern_size. 5.2. Set grid[r][c] = P[dr][dc]. 6. Output the modified grid.",
    "27f8ce4f": "1. Let G be the 3×3 input grid with 1-based indices (r,c) for rows and columns.  \n2. Compute the frequency of each integer value in G. Let M be the value with the highest frequency.  \n3. Initialize a 9×9 output grid O filled with 0.  \n4. For each position (r,c) in G where G[r,c] == M, do:  \n   4.1. For dr from 1 to 3 and dc from 1 to 3, set  \n          O[(r-1)*3 + dr, (c-1)*3 + dc] = G[dr, dc].  \n5. Leave all other cells of O as 0.  \n6. Return O.",
    "93c31fbe": "1. Let H = number of rows and W = number of columns in the input grid.  \n2. Scan the grid to collect all non-zero colors.  \n3. Identify outline_color as the color whose pixels form one or more hollow rectangular frames of thickness one:  \n   a. For each non-zero color c, find each connected component of c.  \n   b. For each component, compute its bounding box [r_min,r_max]×[c_min,c_max].  \n   c. If every cell on the border of that box (r=r_min or r=r_max with c_min≤c≤c_max, or c=c_min or c=c_max with r_min≤r≤r_max) is color c and no cell strictly inside that box has color c, then mark c as a candidate frame color.  \n   d. Let outline_color be the candidate that appears in rectangular loops (there will be exactly one).  \n4. Let pattern_color be the other non-zero color present.  \n5. Copy input to output.  \n6. For each cell (r,c) in output:  \n   If output[r][c] == pattern_color and (r,c) is not strictly inside at least one frame bounding box (r_min<r<r_max and c_min<c<c_max for some frame), then set output[r][c]=0.  \n7. For each frame of outline_color with bounds r_min,r_max,c_min,c_max:  \n   For each interior row r in r_min+1..r_max-1 and each interior column c in c_min+1..c_max-1:  \n     a. Let mirrored_c = c_min + c_max - c.  \n     b. If input[r][c]==pattern_color or input[r][mirrored_c]==pattern_color, then set output[r][c]=pattern_color and output[r][mirrored_c]=pattern_color.  \n8. Return the output grid.",
    "c6e1b8da": "1. Define background as value 0.  \n2. For each nonzero color C in the grid, find all connected components of C.  \n3. For each color C with exactly two components A and B:  \n   a. Let R = the component whose axis-aligned bounding box has both width >1 and height >1 (the rectangle).  \n   b. Let T = the other component; its bounding box has min(width, height)=1 (the tail).  \n4. Determine the direction of T relative to R:  \n   a. If T’s bounding box height=1 and T is immediately left of R (its right edge touches R’s left edge), direction=left.  \n   b. If height=1 and T is immediately right of R, direction=right.  \n   c. If width=1 and T is immediately above R, direction=up.  \n   d. If width=1 and T is immediately below R, direction=down.  \n5. Compute shift distance D = number of cells in T.  \n6. Remove both R and T from the grid (set their cells to 0).  \n7. Translate R by D cells in the determined direction; draw R at its new location (same shape and orientation).  \n8. Leave all other colors and cells unchanged.  \n9. Repeat for every color C with a tail component.  \n10. Output the resulting grid.",
    "281123b4": "1. Identify the three separator columns: scan the input grid’s columns and record every column index C where all rows have value 3. Ensure there are exactly three such columns, dividing the grid into four contiguous 4×4 sub-regions.\n2. Extract the four 4×4 sub-grids:\n   • Let subgrids S1, S2, S3, S4 be the blocks of columns between separators (and before the first, after the last).\n3. Classify each sub-grid by its nonzero color value:\n   • The sub-grid whose nonzero entries are all 5 is the grey layer.\n   • The sub-grid whose nonzero entries are all 8 is the cyan (light blue) layer.\n   • The sub-grid whose nonzero entries are all 4 is the yellow layer.\n   • The sub-grid whose nonzero entries are all 9 is the brown/maroon layer.\n4. Initialize a 4×4 output grid O with all entries 0.\n5. Define the overlay order from bottom to top as: grey (5), then cyan (8), then yellow (4), then brown/maroon (9).\n6. For each color value C in [5, 8, 4, 9] in that sequence:\n   a. Let G be the sub-grid classified with nonzero value C.\n   b. For each row r from 1 to 4 and column c from 1 to 4:\n      – If G[r,c] ≠ 0, set O[r,c] = G[r,c].\n7. Return O as the transformed 4×4 grid.",
    "c7d4e6ad": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. For each row index r from 0 to H-1:\n   a. Read the value at the leftmost cell of the row: row_color = grid[r][0].\n   b. For each column index c from 0 to W-1:\n      i. If grid[r][c] == 5 (gray): set grid[r][c] = row_color.\n3. Leave all other cells (values not equal to 5) unchanged.\n4. Return the modified grid as the output.",
    "292dd178": "1. Determine backgroundColor as the integer that occurs most frequently in the input grid. 2. Let otherColors = all integers present in the grid except backgroundColor. Set fillColor = the element of otherColors with the smallest total count. Set borderColor = the only remaining element of otherColors. 3. Compute all connected components of cells with value borderColor using 4-directional adjacency. 4. For each border component CC:   a. Compute minRow = min(r), maxRow = max(r), minCol = min(c), maxCol = max(c) over all (r,c) in CC.   b. Define perimeterPositions = all positions (r,c) where (r==minRow or r==maxRow) and minCol<=c<=maxCol, or (c==minCol or c==maxCol) and minRow<=r<=maxRow.   c. Identify the opening as the unique (gapRow,gapCol) in perimeterPositions where grid[gapRow][gapCol] != borderColor.   d. Determine direction (dRow,dCol): if gapRow == minRow then (-1,0); else if gapRow == maxRow then (1,0); else if gapCol == minCol then (0,-1); else (0,1).   e. Fill the extension: set (r,c) = (gapRow,gapCol); while 0 <= r < numRows and 0 <= c < numCols: grid[r][c] = fillColor; r += dRow; c += dCol.   f. Fill the interior: for r from minRow+1 to maxRow-1 and for c from minCol+1 to maxCol-1 set grid[r][c] = fillColor. 5. Return the modified grid.",
    "c87289bb": "1. Let H = number of rows, W = number of columns.  \n2. Identify each original vertical bar: any column c where grid[0][c] == 8.  Process each such c independently.  \n3. For each bar at column c:  \n   a. Find r_end = largest r (0 ≤ r < H) such that grid[r][c] == 8 and either r+1 == H or grid[r+1][c] != 8.  (This is the end of the initial bar.)  \n   b. Search for the smallest rp > r_end with grid[rp][c] == 2.  \n      i. If no such rp exists, then for all r from r_end+1 to H-1 set grid[r][c] = 8.  Then continue to next bar.  \n      ii. Otherwise, let target_row = rp - 1.  \n   c. On row rp, identify the contiguous block of 2s that contains column c:  \n      i. Let cl = smallest j ≤ c such that for all k in [j..c], grid[rp][k] == 2.  \n      ii. Let cr = largest j ≥ c such that for all k in [c..j], grid[rp][k] == 2.  \n   d. Compute two candidate detour columns:  \n      i. new_cl = cl - 1  (if new_cl < 0 then treat its distance as infinity)  \n      ii. new_cr = cr + 1  (if new_cr ≥ W then distance = infinity)  \n   e. Compute horizontal distances: dl = |c - new_cl| (or ∞), dr = |new_cr - c| (or ∞).  \n      If dl ≤ dr then choose c_new = new_cl; else choose c_new = new_cr.  \n   f. Fill the horizontal connector on row target_row:  \n      For all x from min(c, c_new) to max(c, c_new), set grid[target_row][x] = 8.  \n   g. Fill the vertical extension from row target_row+1 to the bottom:  \n      For all r from target_row+1 to H-1, set grid[r][c_new] = 8.  \n4. Return the modified grid as output.",
    "29700607": "1. Let H be the number of rows and W be the number of columns of the grid.\n2. For each column C from 0 to W-1, do:\n   a. If the cell at (0, C) has value v and v ≠ 0, then:\n      i. Search the entire grid for any other cell (r_match, c_match) ≠ (0, C) where grid[r_match][c_match] = v.\n     ii. If a match is found, set endpoint (r2, c2) = (r_match, c_match). If no match is found, set endpoint (r2, c2) = (H-1, C).\n    iii. For each row r from 0 to r2 inclusive, set grid[r][C] = v.  // draw vertical segment\n     iv. For each column c from min(C, c2) to max(C, c2) inclusive, set grid[r2][c] = v.  // draw horizontal segment\n3. Return the modified grid as the output.",
    "c8b7cc0f": "1. Identify all coordinates (r,c) in the input grid whose value is 1.  \n2. Let min_r = minimum r, max_r = maximum r; min_c = minimum c, max_c = maximum c among those coordinates.  \n3. Define the interior region as all cells with row index r in [min_r+1, max_r-1] and column index c in [min_c+1, max_c-1].  \n4. Within the interior region, find the non-zero value k (there will be exactly one such color).  \n5. Count N = the number of cells in the interior region whose value equals k.  \n6. Create a new 3×3 output grid initialized with zeros.  \n7. For i from 0 to N-1:  \n   a. Compute row = floor(i/3), col = i mod 3.  \n   b. Set output[row][col] = k.  \n8. Return the 3×3 output grid.",
    "2a5f8217": "1. Scan the input grid to find all non-zero connected components using 4-directional adjacency. 2. For each component, record:\n   a. Its pixel value V (all cells in a component share the same V).  \n   b. Its list of cell coordinates {(r_i,c_i)}. 3. For each component, compute a shape signature by:\n   a. Let r_min = minimum r_i, c_min = minimum c_i.  \n   b. Form a sorted list of pairs [(r_i - r_min, c_i - c_min)]. 4. Group components by identical shape signature. 5. For each group of exactly two components:\n   a. Denote them Comp1 and Comp2 with values V1 and V2.  \n   b. If one component has V=1 and the other has V≠1, then for every cell (r,c) in the component with V=1, set output_grid[r][c] = V_other. 6. Leave all other cells unchanged. 7. Return the modified grid as the output.",
    "c92b942c": "1. Read input grid of size R rows and C columns.\n2. Create output grid of size 3⋅R rows by 3⋅C columns, initialize every cell to 0.\n3. For each input cell at coordinates (r,c) with value v ≠ 0:\n   a. For tile_row from 0 to 2:\n      i. Compute base_row = tile_row * R.\n      ii. For tile_col from 0 to 2:\n          1. Compute base_col = tile_col * C.\n          2. Compute center_row = base_row + r, center_col = base_col + c.\n          3. Set output[center_row][center_col] = v.\n          4. Let left_col = center_col - 1. If left_col ≥ 0, set output[center_row][left_col] = 1.\n          5. Let right_col = center_col + 1. If right_col < 3*C, set output[center_row][right_col] = 1.\n          6. Let ul_row = center_row - 1, ul_col = center_col - 1. If ul_row ≥ 0 and ul_col ≥ 0, set output[ul_row][ul_col] = 3.\n          7. Let dr_row = center_row + 1, dr_col = center_col + 1. If dr_row < 3*R and dr_col < 3*C, set output[dr_row][dr_col] = 3.\n4. Return the output grid.",
    "2b01abd0": "1. Identify the barrier:\n   a. For each row index r, if for all column indices c input[r][c] == 1, set barrier_orientation = \"horizontal\" and barrier_index = r, then stop.\n   b. Otherwise, for each column index c, if for all row indices r input[r][c] == 1, set barrier_orientation = \"vertical\" and barrier_index = c, then stop.\n2. Let S = set of all values v in input grid such that v != 0 and v != 1. Assert |S| = 2. Let the two values be A and B.\n3. Create output grid of same dimensions, initialized to 0.\n4. Copy barrier into output:\n   For each cell (r,c) if input[r][c] == 1 then set output[r][c] = 1.\n5. For each cell (r,c) with input[r][c] in {A, B} do:\n   a. Let original_color = input[r][c].\n   b. Let swapped_color = (original_color == A ? B : A).\n   c. Compute symmetric coordinates (r2,c2):\n      - If barrier_orientation == \"horizontal\": r2 = 2*barrier_index - r; c2 = c.\n      - If barrier_orientation == \"vertical\": c2 = 2*barrier_index - c; r2 = r.\n   d. Set output[r][c] = swapped_color.\n   e. Set output[r2][c2] = original_color.\n6. Leave all other cells in output as 0.",
    "c97c0139": "1. Scan the entire grid to locate all contiguous straight-line segments of value 2 (red) in two orientations:\n   1.1. Horizontal segments: sequences of one or more cells with value 2 in the same row r at consecutive columns c_start…c_end, where grid[r][c_start–1]≠2 (or out of bounds) and grid[r][c_end+1]≠2.\n   1.2. Vertical segments: sequences of one or more cells with value 2 in the same column c at consecutive rows r_start…r_end, where grid[r_start–1][c]≠2 (or out of bounds) and grid[r_end+1][c]≠2.\n2. For each horizontal segment at row r from column c_start to c_end:\n   2.1. Compute segment width W = c_end – c_start + 1.\n   2.2. For k from 1 to floor((W – 1)/2):\n       2.2.1. For each column j from c_start + k to c_end – k:\n           • If (r–k, j) is inside the grid and grid[r–k][j]≠2, set grid[r–k][j] = 8 (light blue).\n           • If (r+k, j) is inside the grid and grid[r+k][j]≠2, set grid[r+k][j] = 8.\n3. For each vertical segment at column c from row r_start to r_end:\n   3.1. Compute segment height H = r_end – r_start + 1.\n   3.2. For k from 1 to floor((H – 1)/2):\n       3.2.1. For each row i from r_start + k to r_end – k:\n           • If (i, c–k) is inside the grid and grid[i][c–k]≠2, set grid[i][c–k] = 8.\n           • If (i, c+k) is inside the grid and grid[i][c+k]≠2, set grid[i][c+k] = 8.\n4. Leave all original 2s and other values unchanged. Return the modified grid.",
    "2c0b0aff": "1. Let Input be the given grid of integers. 2. Identify all connected components of cells with value ≠0 using 4-connectivity (cells are adjacent if they share an edge). 3. For each component:  a. Compute its minimal bounding rectangle: find row_min, row_max, col_min, col_max among all cells in the component.  b. Extract Subgrid = Input[row_min..row_max][col_min..col_max].  c. Compute green_count = number of cells in Subgrid with value 3. 4. Select the Subgrid with the largest green_count. 5. Return that Subgrid as the output grid.",
    "ca8de6ea": "1. Let input be a 5×5 grid indexed 0–4 for rows and columns. Create an empty 3×3 grid output indexed 0–2.\n2. Copy the four corners of input into the four corners of output, preserving relative positions:\n   • Set output[0][0] = input[0][0]\n   • Set output[0][2] = input[0][4]\n   • Set output[2][2] = input[4][4]\n   • Set output[2][0] = input[4][0]\n3. Copy the center of input into the center of output:\n   • Set output[1][1] = input[2][2]\n4. Copy the four diagonal-adjacent positions around the center of input into the middle cells of output:\n   • Set output[0][1] = input[1][1]\n   • Set output[1][2] = input[1][3]\n   • Set output[2][1] = input[3][3]\n   • Set output[1][0] = input[3][1]\n5. Return the filled 3×3 output grid.",
    "2c737e39": "1. Scan the input grid to locate all cells with value 5. 2. For each cell of value 5, count its 4-connected neighbors (up, down, left, right) whose value is non-zero. 3. Designate the cell with at least one non-zero neighbor as the origin (orig_r, orig_c); designate the other cell of value 5 as the target (t_r, t_c). 4. Perform a 4-connected flood fill from (orig_r, orig_c) to collect the set S of all connected cells (r, c) whose value grid[r][c] ≠ 0. 5. Copy the input grid to the output grid. 6. For each (r, c) in S except for (orig_r, orig_c):    a. Compute dr = r – orig_r and dc = c – orig_c.    b. Set output[t_r + dr][t_c + dc] = grid[r][c]. 7. Set output[t_r][t_c] = 0. 8. Return the output grid.",
    "ca8f78db": "1. Let H = number of rows, W = number of columns in the input grid.\n2. Set v_const = value at grid[0][0].  // constant row value\n3. Locate r_pattern = the smallest row index r > 0 such that row r contains at least one cell with a non-zero value not equal to v_const.\n4. Let row_pattern = the array of values in row r_pattern.\n5. Compute m = the index of the first zero in row_pattern; if no zero exists, set m = W.\n6. Define A = row_pattern[0..m-1].  // prefix of non-zero values\n7. Determine the minimal period p (1 ≤ p ≤ m) such that for all i in [0, m-p-1], A[i] == A[i+p].\n8. For each cell (r,c) where grid[r][c] == 0, do:\n   a. Collect S = set of all non-zero values in row r.\n   b. If S is a singleton {x}, then set grid[r][c] = x.\n   c. Otherwise, set grid[r][c] = row_pattern[c mod p].\n9. Return the modified grid as the output.",
    "2f0c5170": "1. Locate all axis-aligned rectangular regions whose border cells are value 8 and whose interior cells are not 8. Exclude the outermost border of the grid. 2. Among these rectangles, identify the template rectangle Tmpl whose interior contains more than one non-zero cell, and the target rectangle Tgt whose interior contains exactly one non-zero cell. 3. Let (r0_Tmpl,c0_Tmpl) be the row–column of the unique non-zero cell Pd (the “dot color”) in Tmpl’s interior, using 0-based indexing relative to Tmpl’s top-left interior cell. Let Ps be the other non-zero value in Tmpl (the “shape color”). For each cell (r,c) in Tmpl’s interior with value Ps, compute the offset (dr,dc) = (r–r0_Tmpl, c–c0_Tmpl) and collect all such offsets into a list Offsets. 4. In Tgt’s interior, let (r0_Tgt,c0_Tgt) be the coordinate of its single non-zero cell Pd. Create an output grid G of the same height and width as Tgt’s interior, initialized to 0. 5. Set G[r0_Tgt][c0_Tgt] = Pd. Then for each (dr,dc) in Offsets, set G[r0_Tgt+dr][c0_Tgt+dc] = Ps. 6. Return G as the final output grid.",
    "cad67732": "1. Let N be the number of rows (and columns) in the input grid.\n2. Compute w = the maximum, over all rows r in 0..N-1, of the count of cells in row r with value ≠ 0.\n3. Compute offset = floor(N / w) * w.\n4. Create an output grid of size (2 × N) rows by (2 × N) columns, initialize all cells to 0.\n5. Determine diagonal orientation:\n   a. If input[0][N−1] ≠ 0 or input[N−1][0] ≠ 0, set orientation = ANTI-DIAGONAL (NE–SW).\n   b. Otherwise set orientation = MAIN-DIAGONAL (NW–SE).\n6. For each input cell (r,c) with value v ≠ 0:\n   a. If orientation = MAIN-DIAGONAL:\n      i. Set output[r][c] = v.\n      ii. Set output[r + offset][c + offset] = v.\n   b. If orientation = ANTI-DIAGONAL:\n      i. Set output[r][c + offset] = v.\n      ii. Set output[r + offset][c] = v.\n7. Return the output grid.",
    "310f3251": "1. Let the input grid have height m and width n.\n2. Create an output grid of size 3m rows by 3n columns, and initialize every cell to 0.\n3. Tile the input grid into the output:\n   a. For each tile_row in {0,1,2} and each tile_col in {0,1,2}:\n      i. For each input coordinate (i,j) with value v = input[i][j] > 0:\n         • Set output[tile_row*m + i][tile_col*n + j] = v.\n4. Add red markers (value 2) diagonally up-left of each colored input pixel in each tile:\n   a. For each tile_row in {0,1,2} and each tile_col in {0,1,2}:\n      i. For each input coordinate (i,j) with value v = input[i][j] > 0:\n         • Compute r = tile_row*m + i - 1 and c = tile_col*n + j - 1.\n         • If 0 ≤ r < 3m and 0 ≤ c < 3n and output[r][c] == 0, then set output[r][c] = 2.\n5. Return the output grid.",
    "cb227835": "1. Scan the grid to find the two cells with value 8. Record their coordinates as (r1,c1) and (r2,c2).  \n2. Compute Δr = r2 – r1 and Δc = c2 – c1.  \n3. If |Δr| ≥ |Δc| (steep or equal slope):  \n   3.1. For each integer k from 1 to |Δr|–1:  \n       a. Let r = r1 + k · sign(Δr).  \n       b. Compute continuous column x = c1 + k·(Δc/Δr).  \n       c. Let c_floor = floor(x) and c_ceil = ceil(x).  \n       d. If c_floor ≠ c_ceil then set grid[r,c_floor]=3 and grid[r,c_ceil]=3; else set grid[r,c_floor]=3.  \n4. Else (|Δr| < |Δc|, shallow slope):  \n   4.1. For each integer k from 1 to |Δc|–1:  \n       a. Let c = c1 + k · sign(Δc).  \n       b. Compute continuous row y = r1 + k·(Δr/Δc).  \n       c. Let r_floor = floor(y) and r_ceil = ceil(y).  \n       d. If r_floor ≠ r_ceil then set grid[r_floor,c]=3 and grid[r_ceil,c]=3; else set grid[r_floor,c]=3.  \n5. Leave all other cells unchanged.",
    "3194b014": "1. Let the input be a grid of size R×C with integer cell values in 0–9.\n2. Define a connected component for a color c (1–9) as a maximal set of orthogonally adjacent cells all equal to c. Ignore cells with value 0.\n3. For each color c from 1 to 9:\n   a. Find all its connected components.\n   b. Compute the size (cell count) of each component.\n   c. Record S(c) = the maximum component size for color c (or 0 if c does not appear).\n4. Let c_max be the color c with the largest S(c). If multiple colors tie for largest S(c), pick any one of them.\n5. Create an output grid of size 3×3. Fill every cell of this grid with the integer value c_max.",
    "ccd554ac": "1. Compute h = number of rows in the input grid and w = number of columns in the input grid.\n2. Compute output_rows = h * h and output_cols = w * w.\n3. Initialize an output grid of size output_rows × output_cols.\n4. For each integer R from 0 to output_rows - 1:\n   a. For each integer C from 0 to output_cols - 1:\n      i. Compute source_row = R mod h.\n      ii. Compute source_col = C mod w.\n      iii. Set output[R][C] = input[source_row][source_col].\n5. Return the output grid.",
    "319f2597": "1. Let H be the number of rows and W the number of columns of the input grid.\n2. Locate the 2×2 block of cells whose value is 0. Let the two distinct row indices of this block be R1 and R2, and the two distinct column indices be C1 and C2.\n3. Initialize the output grid as a copy of the input grid.\n4. For each row r in {R1, R2}:\n     For each column c from 0 to W−1:\n         If input[r][c] ≠ 2 then set output[r][c] = 0.\n5. For each column c in {C1, C2}:\n     For each row r from 0 to H−1:\n         If input[r][c] ≠ 2 then set output[r][c] = 0.\n6. Leave all other cells unchanged.",
    "cd3c21df": "1. Let G be the input grid of size R×C. 2. Identify all connected components of non-zero pixels using 4-connected adjacency (up, down, left, right). Call the set of components {C₁,…,Cₙ}. 3. For each component Cᵢ:   a. Compute its cell list Sᵢ = {(r,c)∈G | pixel at (r,c) belongs to Cᵢ}.   b. Compute its color multiset Mᵢ: a mapping from each color value v∈Sᵢ to the count of v in Sᵢ.   c. Compute its area Aᵢ = |Sᵢ| (number of cells). 4. Count occurrences of each multiset: for each Mᵢ, let count(Mᵢ) = |{j | Mⱼ = Mᵢ}|. 5. Let U = {Cᵢ | count(Mᵢ)=1}. 6. If |U|>1, let C* be the component in U with the largest area Aᵢ; otherwise let C* be the sole component in U. 7. Compute the minimal bounding box of C*:   a. r_min = min(r | (r,c)∈S*), r_max = max(r | (r,c)∈S*).   b. c_min = min(c | (r,c)∈S*), c_max = max(c | (r,c)∈S*). 8. Construct the output grid H of size (r_max−r_min+1)×(c_max−c_min+1) by copying H[i−r_min+1,j−c_min+1] = G[i,j] for all i∈[r_min,r_max], j∈[c_min,c_max]. 9. Return H as the result.",
    "31adaf00": "1. Let H be the number of rows and W the number of columns of the input grid. 2. Initialize the output grid as a copy of the input grid. 3. Create an empty set S of coordinates to fill. 4. For each row r from 0 to H-2 and each column c from 0 to W-2, do:   a. If input[r][c]==0 AND input[r][c+1]==0 AND input[r+1][c]==0 AND input[r+1][c+1]==0, then add the four coordinates (r,c), (r,c+1), (r+1,c), (r+1,c+1) to S. 5. For each coordinate (r,c) in S, set output[r][c]=1. 6. Return the output grid.",
    "ce039d91": "1. Copy the entire input grid into the output grid unchanged.  \n2. Let R be the number of rows and C be the number of columns in the grid.  \n3. For each row r from 0 to R-1, do steps 4–6.  \n4. For each column c from 0 to C-1, compute its mirror column m = C - 1 - c.  \n5. If c < m and input[r][c] == 5 and input[r][m] == 5 then set output[r][c] = 1 and output[r][m] = 1.  \n6. Otherwise leave output[r][c] and output[r][m] as they are.  \n7. After processing all rows and columns, return the output grid.",
    "31d5ba1a": "1. Let height = number of rows in the input grid and width = number of columns. Compute half = height / 2 (here half = 3).  \n2. Create an output grid of size half × width, initialized with 0.  \n3. For each row r from 0 to half − 1 and each column c from 0 to width − 1:  \n   a. Let top = input[r][c].  \n   b. Let bottom = input[r + half][c].  \n   c. If exactly one of the following is true: top == 9, bottom == 4, then set output[r][c] = 6; otherwise leave output[r][c] = 0.  \n4. Return the output grid.",
    "ce8d95cc": "1. Let G be the input grid with H rows (0..H-1) and W columns (0..W-1).\n2. Build a new list of rows R:\n   a. For each row index r from 0 to H-1, do:\n      i. If r==0, append row G[r] to R.\n      ii. Otherwise, compare G[r] to the last row in R; if there exists any column c (0..W-1) where G[r][c] ≠ last kept row[c], append G[r] to R; else skip G[r].\n3. Let H1 be the length of R. Form intermediate grid G1 of size H1×W whose rows are R in the same order.\n4. Build a new list of columns C:\n   a. For each column index c from 0 to W-1, do:\n      i. If c==0, append column G1[*,c] to C.\n      ii. Otherwise, compare G1[*,c] to the last column in C; if there exists any row r (0..H1-1) where G1[r][c] ≠ last kept column[r], append G1[*,c] to C; else skip G1[*,c].\n5. Let W1 be the length of C. Construct the output grid O of size H1×W1 whose columns are C in order.\n6. Return O.",
    "32e9702f": "1. Let the input be a grid G with R rows and C columns indexed from 0. 2. Create an output grid H of the same dimensions. 3. Initialize every cell H[r][c] to 5 (gray). 4. For each cell (r, c) in G:\n   a. Let v = G[r][c].\n   b. If v ≠ 0 (non-black), compute c' = c - 1.\n   c. If c' ≥ 0, set H[r][c'] = v. 5. Return H as the transformed grid.",
    "cf133acc": "1. Let H be grid height and W be grid width. 2. For each column c from 1 to W-2 do:  2.1. Build list gap_rows = [r | 0 ≤ r < H and grid[r][c]==0 and grid[r][c-1]==grid[r][c+1]≠0].  2.2. If gap_rows is empty, continue to next c.  2.3. Sort gap_rows in descending order.  2.4. For i from 0 to len(gap_rows)-1 do:    a. Let r0 = gap_rows[i].    b. Let color = grid[r0][c-1]  〈equals grid[r0][c+1]〉.    c. Set grid[r0][c] = color.    d. Let r_end = (i+1 < len(gap_rows) ? gap_rows[i+1]+1 : 0).    e. For r from r0-1 down to r_end do:       If grid[r][c] == 0 then set grid[r][c] = color else break. 3. Return the resulting grid.",
    "332efdb3": "1. Let H be the number of rows and W the number of columns of the input grid.\n2. Create an output grid of size H×W.\n3. For each row index r from 0 to H − 1 and each column index c from 0 to W − 1:\n   a. If r mod 2 = 1 AND c mod 2 = 1, set output[r][c] = 0.\n   b. Otherwise, set output[r][c] = 1.\n4. Return the output grid.",
    "cfb2ce5a": "1. Identify the original pattern block:\n  a. In rows 0–4 and cols 0–4, find all cells with value ≠0. Let r0_min = minimum row, r0_max = maximum row, c0_min = minimum col, c0_max = maximum col among these cells.  H = r0_max–r0_min+1, W = c0_max–c0_min+1.\n  b. Extract P of size H×W: for i in [0..H-1], j in [0..W-1], P[i][j] = grid[r0_min+i][c0_min+j].\n  c. Let {colorA, colorB} = the two distinct non-zero values in P.\n2. Define three target regions and their reflection rules:\n  Region RT (top-right): rows sr=r0_min..er=r0_max, cols sc=c0_max+1..ec=c0_max+W.\n    Reflection: r_src=r, c_src=c0_max - (c - sc).\n  Region RB (bottom-left): rows sr=r0_max+1..er=r0_max+H, cols sc=c0_min..ec=c0_max.\n    Reflection: r_src=r0_max - (r - sr), c_src=c.\n  Region RD (bottom-right): rows sr=r0_max+1..er=r0_max+H, cols sc=c0_max+1..ec=c0_max+W.\n    Reflection: r_src=r0_max - (r - sr), c_src=c0_max - (c - sc).\n3. For each region:\n  a. Find any hint cell (r_h,c_h) in [sr..er]×[sc..ec] with grid[r_h][c_h]≠0. Let dX = grid[r_h][c_h].\n  b. Compute (i_h,j_h) = (r_src, c_src) from (r_h,c_h) by the region’s reflection. Let v = P[i_h - r0_min][j_h - c0_min].\n  c. Set mapping M[v] = dX. Let u be the other element of {colorA,colorB}. Let S = set of non-zero values in the region. If |S|=2 let dY be the element of S ≠ dX; otherwise dY = 0. Set M[u] = dY.\n  d. For every cell (r,c) in [sr..er]×[sc..ec]: compute (r_src,c_src) by the region’s reflection, then let i = r_src - r0_min, j = c_src - c0_min; set grid[r][c] = M[P[i][j]].\n4. Return the new grid.",
    "3391f8c0": "1. Identify the two non-zero colors in the input grid; call them C1 and C2. 2. Find all 4-connected components of pixels of color C1 and of color C2. 3. Let C_unique be the color whose component count is 1; let C_multi be the other color (which will have count 3). 4. Let S_unique be the set of coordinates of the single C_unique component. 5. Compute the center of mass (average row, average col) of S_unique, call it (rU, cU). 6. For each of the three C_multi components:  6.1. Let S_i be its pixel set and compute its center of mass (r_i, c_i).  6.2. For each (r,c) in S_unique, compute offset (dr,dc) = (r – rU, c – cU), and mark position (r_i+dr, c_i+dc) to receive color C_multi in the output. 7. Let S_multi_rep be the pixel set of any one of the C_multi components in the input. 8. Compute its center of mass (rM, cM). 9. Let (r0,c0) be the center of mass of the single C_unique component (same as (rU,cU)). 10. For each (r,c) in S_multi_rep, compute offset (dr,dc) = (r – rM, c – cM), and mark position (r0+dr, c0+dc) to receive color C_unique. 11. Construct the output grid by setting every marked position to its new color, and setting all other positions to 0.",
    "d017b73f": "1. Let H and W be the height and width of the input grid. 2. Identify each shape as a connected component of non-zero cells (orthogonal adjacency) of the same color. For each shape compute:   • input_x_min = minimum column index of its cells.   • input_x_max = maximum column index.   • input_y_min = minimum row index.   • input_y_max = maximum row index.   • input_row_center = average of its row indices. 3. Sort the shapes into a list S by ascending input_x_min. 4. Initialize an output grid G of size H×W filled with 0. 5. For the first shape S[1], copy each of its cells from input to G at the same (row, col). 6. For i from 2 to N (each subsequent shape S[i]):   a. Let P = S[i−1] be the previous shape, using its placed cells in G.   b. Compute dx = (max column of P in G) + 1 − (input_x_min of S[i]).   c. Compute possible vertical offsets:     • d_min = 1 − (input_y_min of S[i]),     • d_max = H − (input_y_max of S[i]),     • D = all integers d with d_min ≤ d ≤ d_max.   d. Compute sign_pref = − sign(input_row_center of S[i] − input_row_center of S[i−1]); if that difference is 0 set sign_pref = 0.   e. Define C1: if sign_pref ≠ 0 then C1 = {d in D | d·sign_pref > 0} else C1 = {0}.   f. Define a function Adj(d): shift S[i] by (dx,d) and count pairs of cells (p in shifted S[i], q in P) such that p.row = q.row and p.col = q.col + 1. Return true if exactly one such pair.   g. Let C2 = {d in C1 | Adj(d) is true}. If C2 nonempty then choose dy in C2 with maximum |d|. Otherwise let C3 = {d in D | Adj(d) is true} and choose dy in C3 with minimum |d|.   h. Place S[i] in G by copying each input cell at (r,c) to (r+dy, c+dx). 7. After placing all shapes, find col_min = smallest column index in G containing a non-zero, and col_max = largest such column. 8. Crop G to columns col_min through col_max (keep all rows) and return the result.",
    "33b52de3": "1. Let GRID be the input grid with dimensions H×W.  \n2. Identify all cells with value 5.  Let FIVE_ROWS be the sorted list of distinct row indices containing any 5.  Let FIVE_COLS be the sorted list of distinct column indices containing any 5.  \n3. Group FIVE_ROWS into contiguous runs of equal length 3.  For each run, record its first index.  Let ROW_BLOCK_STARTS be the sorted list of these start indices.  \n4. Group FIVE_COLS into contiguous runs of equal length 3.  For each run, record its first index.  Let COL_BLOCK_STARTS be the sorted list of these start indices.  \n5. Identify all cells with value ≠0 and ≠5.  Let PALETTE_COORDS be their coordinates.  Compute PALETTE_ROW_MIN, PALETTE_ROW_MAX, PALETTE_COL_MIN, PALETTE_COL_MAX as the bounding box of PALETTE_COORDS.  \n6. Compute P_ROWS = PALETTE_ROW_MAX–PALETTE_ROW_MIN+1 and P_COLS = PALETTE_COL_MAX–PALETTE_COL_MIN+1.  Verify that P_ROWS = |ROW_BLOCK_STARTS| and P_COLS = |COL_BLOCK_STARTS|.  \n7. Copy GRID into OUTPUT.  \n8. For each block row index i from 0 to P_ROWS–1 and each block column index j from 0 to P_COLS–1:  \n   a. Let BR = ROW_BLOCK_STARTS[i] and BC = COL_BLOCK_STARTS[j].  \n   b. Let PALETTE_VALUE = GRID[PALETTE_ROW_MIN + i][PALETTE_COL_MIN + j].  \n   c. For dr in 0..2 and dc in 0..2:  \n      i. Let r = BR + dr, c = BC + dc.  \n      ii. If GRID[r][c] = 5 then set OUTPUT[r][c] = PALETTE_VALUE.  \n9. Return OUTPUT.",
    "d19f7514": "1. Let H be the number of rows and W the number of columns in the input grid. 2. Compute half_h = H / 2. 3. Create an output grid of dimensions half_h rows by W columns. 4. For each row r from 0 to half_h - 1 and each column c from 0 to W - 1:   a. Let top_val = input[r][c].   b. Let bot_val = input[r + half_h][c].   c. If top_val == 0 AND bot_val == 0, set output[r][c] = 0.   d. Otherwise, set output[r][c] = 4.",
    "3490cc26": "1. Identify all non-zero connected components in the grid. For each component C, compute its bounding box: r_min, r_max (row indices) and c_min, c_max (column indices).  Components will be 2×2 blocks of value 2 (red) or 8 (blue).\n2. Locate the unique red component R (value 2). Set Current = R. Mark R as visited. Let Unvisited = set of all blue components (value 8).\n3. Repeat until no unvisited component can be aligned with Current:\n   a. For each component B in Unvisited, determine if B is aligned with Current:\n      i. Vertical alignment: B.c_min ≤ Current.c_max and B.c_max ≥ Current.c_min.\n     ii. Horizontal alignment: B.r_min ≤ Current.r_max and B.r_max ≥ Current.r_min.\n   b. For each aligned B compute distance D:\n      i. If vertical: if B.r_max < Current.r_min then D = Current.r_min − B.r_max − 1; else if B.r_min > Current.r_max then D = B.r_min − Current.r_max − 1; otherwise skip B.\n     ii. If horizontal: if B.c_max < Current.c_min then D = Current.c_min − B.c_max − 1; else if B.c_min > Current.c_max then D = B.c_min − Current.c_max − 1; otherwise skip B.\n   c. Select B* from aligned Unvisited with minimal D. If none, exit loop.\n   d. Draw a straight orange corridor (value 7) between Current and B*:\n      i. If B* is vertically aligned (column ranges overlap): for c in Current.c_min..Current.c_max and for r in min(Current.r_max,B*.r_max)+1 .. max(Current.r_min,B*.r_min)-1, set grid[r][c]=7 if grid[r][c]==0.\n     ii. Else (horizontally aligned): for r in Current.r_min..Current.r_max and for c in min(Current.c_max,B*.c_max)+1 .. max(Current.c_min,B*.c_min)-1, set grid[r][c]=7 if grid[r][c]==0.\n   e. Mark B* visited, remove B* from Unvisited, set Current = B*.\n4. Return the modified grid.",
    "d282b262": "1. Let H be the number of rows and W the number of columns of the input grid.\n2. Identify each block as a connected component of non-zero cells using 4-neighbor connectivity (up, down, left, right). For each block B, record:\n   a. The list of its cells CB = {(r, c, v)} where v is the cell value (1–9).\n   b. its initial rightmost column index maxColB = max(c for (r,c,v) in CB).\n3. Sort the list of blocks in descending order of maxColB (blocks nearer the right edge first).\n4. Create an empty output grid G of size H×W, initialized to 0.\n5. For each block B in the sorted list, do:\n   a. Initialize k = 0.\n   b. While true:\n      i. For every cell (r, c, v) in CB, compute c2 = c + k + 1.\n      ii. If for all cells, c2 < W and G[r][c2] == 0, then increment k by 1 and repeat step b.\n      iii. Otherwise, stop; the maximum rightward shift is k.\n   c. For each cell (r, c, v) in CB, set G[r][c + k] = v.\n6. Return G as the transformed grid.",
    "34b99a2b": "1. Let H = number of rows and W = number of columns of the input grid.\n2. Find the unique column index D where every input cell equals 4.  // D = 4 in all examples\n3. Compute panel width K = D and verify W == 2*K + 1.\n4. Create an output grid of size H rows and K columns, initially filled with 0.\n5. For each row r from 0 to H-1 and each column c from 0 to K-1:\n   a. Let L = input[r][c] and R = input[r][D + 1 + c].\n   b. If exactly one of L or R equals 0 (black) and the other is nonzero, set output[r][c] = 2; otherwise leave output[r][c] = 0.\n6. Return the output grid composed of values 0 (black) and 2 (red).",
    "d2acf2cb": "1. For each row index r from 0 to height-1:   \n   a. Let Y_cols = list of column indices c where grid[r][c] == 4.   \n   b. If length of Y_cols is exactly 2, let c1 = min(Y_cols), c2 = max(Y_cols).   \n   c. For each column c in the range c1+1 to c2-1 (inclusive):       \n      i. If grid[r][c] == 0, set grid[r][c] = 8.       \n      ii. Else if grid[r][c] == 6, set grid[r][c] = 7.       \n      iii. Else if grid[r][c] == 8, set grid[r][c] = 0.       \n      iv. Else if grid[r][c] == 7, set grid[r][c] = 6.      \n2. For each column index c from 0 to width-1:   \n   a. Let Y_rows = list of row indices r where grid[r][c] == 4.   \n   b. If length of Y_rows is exactly 2, let r1 = min(Y_rows), r2 = max(Y_rows).   \n   c. For each row r in the range r1+1 to r2-1 (inclusive):       \n      i. If grid[r][c] == 0, set grid[r][c] = 8.       \n      ii. Else if grid[r][c] == 6, set grid[r][c] = 7.       \n      iii. Else if grid[r][c] == 8, set grid[r][c] = 0.       \n      iv. Else if grid[r][c] == 7, set grid[r][c] = 6.  \n3. Leave all other cells unchanged.",
    "351d6448": "1. Let F be the filler color: find the color value c such that there are rows in the grid that consist entirely of c; set F=c.  \n2. Let separator_rows be the list of row indices r where every cell in row r equals F, in ascending order.  \n3. Compute block_height = separator_rows[1] - separator_rows[0].  Let data_height = block_height - 1.  \n4. Let start = separator_rows[-1] + 1.  (This is the first row of the final, incomplete block of data rows.)  \n5. Determine the two foreground colors A and B: scan all cells in rows 0..start-1 that are not 0 and not F; the smaller value is A, the larger is B.  \n6. For i from 0 to data_height-1 do:  \n   a. Let row_index = start + i.  \n   b. Let new_row be a copy of grid[row_index].  \n   c. If i > 0 then:  \n      i. Set to_change = i.  \n      ii. For j from 0 to width-1 do:  \n         - If new_row[j] == A and to_change > 0 then:  \n             • Set new_row[j] = B.  \n             • Decrement to_change by 1.  \n         - If to_change == 0 then break the loop over j.  \n   d. Append new_row to the output block.  \n7. Return the sequence of data_height rows new_row for i=0..data_height-1, in order.",
    "d304284e": "1. Let X be the nonzero pixel value in the input grid. 2. Collect all coordinates (r,c) where grid[r][c]==X. 3. Compute top_row = minimum r, left_col = minimum c, bottom_row = maximum r, right_col = maximum c. 4. Define shape_height = bottom_row - top_row + 1, shape_width = right_col - left_col + 1. 5. Build a list P of relative offsets (dr,dc) = (r - top_row, c - left_col) for each (r,c) in the shape. 6. Set horizontal_step = shape_width + 1, vertical_step = shape_height + 1. 7. Let Y = 6. 8. Initialize output grid as a copy of input grid. 9. For each integer j starting at 0 while left_col + j*horizontal_step + shape_width - 1 < number_of_columns:   a. Let base_col = left_col + j*horizontal_step.   b. If (j+1) mod 3 != 0 then:      i. For each (dr,dc) in P set output[top_row+dr][base_col+dc] = X.   c. Else ((j+1) mod 3 == 0) then:      i. For each (dr,dc) in P set output[top_row+dr][base_col+dc] = Y.      ii. For k = 1,2,3,… until break:          A. Let new_top = top_row + k*vertical_step.          B. If new_top + shape_height - 1 ≥ number_of_rows then break.          C. For each (dr,dc) in P set output[new_top+dr][base_col+dc] = Y. 10. Return the output grid.",
    "358ba94e": "1. Scan the entire input grid and identify the single non-zero value X present (all shapes use this one color).  \n2. Find all connected components of cells with value X using 4-connectivity.  \n3. For each component, compute its bounding box: rmin = minimum row index of the component, rmax = maximum row index, cmin = minimum column index, cmax = maximum column index.  \n4. Verify that for every component, (rmax–rmin+1) = (cmax–cmin+1) = K (they are all K×K squares).  \n5. For each bounding box, extract the K×K subgrid G_i from the input.  \n6. Compare all extracted subgrids G_i; one subgrid will have a pattern of zeros and Xs that does not match any other.  \n7. Return that unique K×K subgrid as the output grid.",
    "d37a1ef5": "1. Identify the outer red rectangle:\n   a. Collect all cells with value 2.  \n   b. Let rect_top = minimum row index of these cells.  \n   c. Let rect_bottom = maximum row index of these cells.  \n   d. Let rect_left = minimum column index of these cells.  \n   e. Let rect_right = maximum column index of these cells.  \n2. Identify the inner grey bounding box:\n   a. Collect all cells with value 5.  \n   b. Let grey_top = minimum row index of these cells.  \n   c. Let grey_bottom = maximum row index of these cells.  \n   d. Let grey_left = minimum column index of these cells.  \n   e. Let grey_right = maximum column index of these cells.  \n3. Fill with red (value 2) all cells inside the outer rectangle but outside the grey box:\n   For each cell at (r, c):\n     if rect_top <= r <= rect_bottom and rect_left <= c <= rect_right and not (grey_top <= r <= grey_bottom and grey_left <= c <= grey_right) then set cell(r, c) = 2.\n4. Leave all other cells unchanged.",
    "37d3e8b2": "1. Let each grid cell be addressed by zero-based (r,c)   2. Find all 4-connected components of cells with value 8. Treat each such component as one shape.   3. For each shape:     a. Compute its bounding box: r_min = minimum r of its cells; r_max = maximum r; c_min = minimum c; c_max = maximum c.     b. Within the subgrid rows r in [r_min..r_max], cols c in [c_min..c_max], collect all cells with value 0.     c. On that subgrid, find 4-connected components of these zero cells. Let hole_count = number of such zero-components.     d. Determine fill_value as:        if hole_count == 1 then fill_value = 1;        else if hole_count == 2 then fill_value = 2;        else if hole_count == 3 then fill_value = 3;        else if hole_count == 4 then fill_value = 7.     e. For each cell of the original shape (all cells of the 8-component), set its value to fill_value.   4. Leave all other cells unchanged.",
    "d47aa2ff": "1. Let input grid G have dimensions 10 rows × 21 columns, indexed G[r][c] with 0 ≤ r < 10 and 0 ≤ c < 21.\n2. Define grid1 G1 and grid2 G2 as follows:\n   • For each r in 0..9 and c in 0..9, set G1[r][c] = G[r][c].\n   • For each r in 0..9 and c in 0..9, set G2[r][c] = G[r][c+11].\n3. Initialize an output grid O of size 10×10 with all entries 0.\n4. For each row r in 0..9 and column c in 0..9:\n   a. Let v1 = G1[r][c] and v2 = G2[r][c].\n   b. If v1 > 0 and v2 > 0 and v1 == v2, set O[r][c] = v1.\n   c. Else if v1 > 0 and v2 == 0, set O[r][c] = 2.\n   d. Else if v2 > 0 and v1 == 0, set O[r][c] = 1.\n   e. Otherwise leave O[r][c] = 0.\n5. Return O as the transformed 10×10 grid.",
    "3979b1a8": "1. Let the input be an N×N grid where N is odd (in all examples N=5).  Compute mid = (N+1)/2.\n2. Read three colors from the input:\n   a. c_corner = value at (1,1)\n   b. c_cross = value at (1,mid)\n   c. c_center = value at (mid,mid)\n3. Let size_out = 2×N.  Create an empty output grid of size_out×size_out.\n4. Copy the input into the top-left of the output: for r from 1 to N, for c from 1 to N, set output[r,c] = input[r,c].\n5. Define a cyclic sequence color[k] for k≥1 by:\n     if k mod 3 == 1 then color[k] = c_corner\n     if k mod 3 == 2 then color[k] = c_center\n     if k mod 3 == 0 then color[k] = c_cross\n6. For m from 1 to N do:\n   a. Let main = color[m]\n   b. Let next = color[m+1]\n   c. Let col = N + m\n      For r from 1 to (N + m - 1), set output[r,col] = main\n   d. Let row = N + m\n      For c from 1 to (N + m - 1), set output[row,c] = main\n   e. Set output[row,col] = next\n7. Return the filled output grid of size 2N×2N.",
    "d492a647": "1. Scan the entire grid to locate the unique seed pixel whose value is neither 0 nor 5. Let its coordinates be (R_s, C_s) and its value be C.\n2. For each cell at coordinates (r, c):\n   a. If the current cell value equals 0 (black) AND (r - R_s) % 2 == 0 AND (c - C_s) % 2 == 0, then set this cell’s value to C.\n   b. Otherwise leave the cell’s value unchanged.\n3. Output the resulting grid.",
    "3a301edc": "1. Let background_color = 0.\n2. Scan the entire grid to find all cells with value != background_color. Compute:\n   a. topR = minimum row index of these cells.\n   b. bottomR = maximum row index of these cells.\n   c. leftC = minimum column index of these cells.\n   d. rightC = maximum column index of these cells.\n   This defines the primary bounding rectangle [topR..bottomR] x [leftC..rightC].\n3. Determine outer_color = grid[topR][leftC].\n4. Identify inner_color:\n   a. For every cell (r,c) with r in [topR+1..bottomR-1] and c in [leftC+1..rightC-1], collect its value if it is not outer_color and not background_color.\n   b. inner_color = the unique nonzero value found in step 4a.\n5. Find the inner-color bounding rectangle:\n   a. inner_top = minimum row index of cells with value = inner_color inside [topR+1..bottomR-1] x [leftC+1..rightC-1].\n   b. inner_bottom = maximum row index of those cells.\n   c. inner_left = minimum column index of those cells.\n   d. inner_right = maximum column index of those cells.\n6. Compute inner_height = inner_bottom - inner_top + 1, inner_width = inner_right - inner_left + 1.\n7. Compute border_thickness = ceil(min(inner_height, inner_width) / 2).\n8. Draw a border of thickness border_thickness and color inner_color around the primary rectangle:\n   For each cell (r,c) in the grid that satisfies all:\n     - r in [topR - border_thickness .. bottomR + border_thickness]\n     - c in [leftC - border_thickness .. rightC + border_thickness]\n     - (r < topR OR r > bottomR OR c < leftC OR c > rightC)\n     - r and c are within grid bounds\n     set grid[r][c] = inner_color.\n9. Leave all other cells unchanged. Return the modified grid.",
    "d4b1c2b1": "1. Identify the set of distinct values in the input grid; let N be the size of this set.  \n2. Let H be the number of rows in the input grid and W be the number of columns.  \n3. Initialize an empty output grid with H×N rows and W×N columns.  \n4. For each input row index r from 0 to H−1 and each input column index c from 0 to W−1:  \n   a. Let v = input_grid[r][c].  \n   b. For dr from 0 to N−1 and for dc from 0 to N−1:  \n      i. Set output_grid[r*N + dr][c*N + dc] = v.  \n5. Return the output grid.",
    "3b4c2228": "1. Let input be a grid of size H×W with integer values. 2. Initialize an integer counter N to 0. 3. For each row r from 0 to H–2 and each column c from 0 to W–2, do: if input[r][c]==3 and input[r][c+1]==3 and input[r+1][c]==3 and input[r+1][c+1]==3, then increment N by 1. 4. Create an output grid of size 3×3 and set every cell to 0. 5. For k from 0 to N–1 (inclusive), set output[k][k]=1. 6. Return the output grid.",
    "d4c90558": "1. Locate all connected components of border pixels: find each maximal set of cells with the same nonzero, non-5 value c (pixel values in 1–9 except 5), connected orthogonally. Each such component is the outline of one rectangle.\n2. For each component, compute its bounding box: row_min = minimum row index, row_max = maximum row index, col_min = minimum column index, col_max = maximum column index among its pixels.\n3. For each bounding box, count the number of interior grey pixels: iterate r from row_min+1 to row_max-1 and k from col_min+1 to col_max-1, and count cells where grid[r][k] == 5. Call this count_i.\n4. Record for each rectangle a pair (color_i, count_i), where color_i is the border pixel value c of that rectangle.\n5. Sort the list of pairs by count_i in ascending order. If two counts are equal, maintain any consistent order.\n6. Let n = number of rectangles (list length) and m = maximum count_i over all rectangles.\n7. Initialize an output grid of dimensions n rows and m columns, filled with 0.\n8. For each sorted pair at index i (0-based), let (color_i, count_i) be its values. In output row i, for j from 0 to count_i-1, set output[i][j] = color_i.\n9. Leave all other output cells as 0. Return the output grid.",
    "3d31c5b3": "1. Partition the input grid (12 rows × 6 columns) into four 3×6 blocks:  \n   • Block G (rows 0–2)  \n   • Block Y (rows 3–5)  \n   • Block R (rows 6–8)  \n   • Block C (rows 9–11)\n2. Create an empty output grid O of size 3 rows × 6 columns.\n3. For each row i from 0 to 2 and each column j from 0 to 5, do:\n   a. Let g = input[i][j]          (value from G at (i,j))\n   b. Let y = input[i+3][j]        (value from Y at (i,j))\n   c. Let r = input[i+6][j]        (value from R at (i,j))\n   d. Let c = input[i+9][j]        (value from C at (i,j))\n   e. If g ≠ 0, set O[i][j] = g.\n   f. Else if y ≠ 0, set O[i][j] = y.\n   g. Else if c ≠ 0, set O[i][j] = c.\n   h. Else if r ≠ 0, set O[i][j] = r.\n   i. Else set O[i][j] = 0.\n4. Return O as the transformed grid.",
    "d56f2372": "1. Identify all nonzero colors in the input grid.\n2. For each color c:\n   a. Collect all grid cells with value c and group them by 4-connectivity into a single component (assume one component per color).\n   b. Compute the component’s bounding box: min_row, max_row, min_col, max_col over its cells.\n   c. Let H = max_row – min_row + 1 and W = max_col – min_col + 1.\n   d. Define a binary mask M of size H×W where M[r][x] = 1 if input[min_row+r][min_col+x] == c, else 0.\n   e. Compute two booleans:\n      • vertical_symmetry = true if for all r in 0..H–1 and for all x in 0..W–1: M[r][x] == M[r][W–1–x]\n      • horizontal_symmetry = true if for all r in 0..H–1 and for all x in 0..W–1: M[r][x] == M[H–1–r][x]\n   f. Let symmetry_score_c = (vertical_symmetry ? 1 : 0) + (horizontal_symmetry ? 1 : 0).\n3. Select the color c* with the highest symmetry_score (if tie, any one of highest).\n4. For color c*, retrieve its bounding box and dimensions H*, W* as above.\n5. Construct the output grid of size H*×W*. For each r in 0..H*–1 and x in 0..W*–1:\n   output[r][x] = (input[min_row*+r][min_col*+x] == c* ? c* : 0).\n6. Return this cropped grid as the solution.",
    "3ed85e70": "1. Locate the single dividing row R_div such that all cells in that row have value 0.  \n2. Define the top (green) region as all rows with index < R_div and the bottom (black) region as all rows with index > R_div.  \n3. In the top region, find every connected component C_top of cells with value ≠ 3 (green background). For each component:  \n   a. Compute its bounding box [r_min…r_max]×[c_min…c_max].  \n   b. Extract the subgrid T = grid[r_min…r_max][c_min…c_max].  \n   c. Determine its border_color as the value of any cell on the perimeter of T.  \n   d. Store the tuple (border_color, pattern=T, height=H, width=W).  \n4. In the bottom region, for each stored template (border_color, pattern, H, W):  \n   a. Find every connected component C_bot of cells equal to border_color in rows > R_div.  \n   b. For each component, compute its bounding box top-left coordinate (r0, c0).  \n   c. Overlay the template pattern onto the grid: for dr in 0…H-1 and dc in 0…W-1 set grid[r0+dr][c0+dc] = pattern[dr][dc].  \n5. Leave all other cells unchanged and return the modified grid.",
    "d5c634a2": "1. Let H = number of rows in input grid. Compute mid = floor(H/2).\n2. Initialize counters top_count = 0 and bottom_count = 0.\n3. For each row R from 0 to H-1 and each column C from 0 to W-3 (where W is number of columns):\n   a. If grid[R][C] == 2 and grid[R][C+1] == 2 and grid[R][C+2] == 2 then:\n      i. If R > 0 and grid[R-1][C+1] == 2, or if R < H-1 and grid[R+1][C+1] == 2, then:\n         • Record one T-shape with its horizontal bar on row R.\n         • If R < mid, increment top_count; otherwise increment bottom_count.\n4. Create an output grid out of size 3 rows × 6 columns, filled with 0s.\n5. Define left_corners = [(0,0), (2,0), (0,2), (2,2)] and right_corners = [(0,3), (2,3), (0,5), (2,5)].\n6. For i from 0 to top_count-1 (but no more than 4):\n   a. Let (r,c) = left_corners[i]; set out[r][c] = 3.\n7. For i from 0 to bottom_count-1 (but no more than 4):\n   a. Let (r,c) = right_corners[i]; set out[r][c] = 1.\n8. Return out as the transformed grid.",
    "3ee1011a": "1. Identify all non-zero connected components in the input grid. A connected component is a set of pixels of the same non-zero value connected orthogonally (up, down, left, right).\n2. For each component, record its color C and compute its size L as the number of pixels in that component.\n3. Sort the list of (C, L) pairs in descending order by L. Let this sorted list be [(C0, L0), (C1, L1), …, (C_{n-1}, L_{n-1})].\n4. Let S = L0 (the largest component size). Create an S × S output grid initialized to 0.\n5. For each index i from 0 to n-1:\n   a. Let Ci be the color of the i-th component in the sorted list.\n   b. Let o = i and end = S - 1 - i.\n   c. For each coordinate (r, c) where o ≤ r ≤ end and o ≤ c ≤ end:\n      i. If r == o or r == end or c == o or c == end, set output_grid[r][c] = Ci.\n6. Return the output grid.",
    "d931c21c": "1. Let R,C be the number of rows and columns of the input grid. Initialize the output grid as a copy of the input grid.\n2. Identify exterior background cells:\n   a. Create an empty set ExteriorZeros.\n   b. For each cell on the grid boundary (row=0, row=R-1, col=0, col=C-1) with input value 0, perform a flood‐fill (4‐neighbor) through cells of input value 0 and add all reached cells to ExteriorZeros.\n3. Identify all 4‐connected components of cells with input value 1; call each such component S.\n4. For each component S:\n   a. Compute ShapeAdj4 = { cell z | z has input value 0 and z is 4‐neighbor adjacent to some cell in S }.\n   b. If ShapeAdj4 ∩ ExteriorZeros is non‐empty, skip this component (it is not a closed loop).\n   c. Otherwise, S is a closed loop:\n      i.   Let InteriorBorder = ShapeAdj4 \\ ExteriorZeros.\n      ii.  Compute ShapeAdj8 = { cell z | z has input value 0 and z is 8‐neighbor adjacent to some cell in S }.\n      iii. Let ExteriorBorder = ShapeAdj8 ∩ ExteriorZeros.\n      iv.  For each cell z in InteriorBorder, set output[z]=3.\n      v.   For each cell z in ExteriorBorder, set output[z]=2.\n5. Return the output grid.",
    "3f23242b": "1. Locate every green pixel (value 3) at position (r,c).\n2. Compute col_start = c - 2, col_end = c + 2, row_top = r - 2, row_mid = r - 1, row_bot = r + 2.\n3. Draw the top horizontal grey line: for col from col_start to col_end, set cell at (row_top,col) to 5.\n4. Draw the vertical grey segment: set the cell at (row_mid,c) to 5.\n5. Draw the left and right red pillars: for row from row_mid to r + 1 inclusive, set cells at (row,col_start) and (row,col_end) to 2.\n6. Draw the bottom red base: for every column x in the grid width, set cell at (row_bot,x) to 2.\n7. Draw the bottom light-blue band: for col from col_start to col_end, set cell at (row_bot,col) to 8, overwriting the red base in that segment.\n8. Preserve the original green pixels (value 3) and leave all other cells unchanged.\n9. Apply steps 1–8 independently for each green pixel found in the input grid.",
    "d94c3b52": "1. Identify the target shape pattern:\n   a. Find all pixels with value 8 in the input.\n   b. Group them into 4-connected components (orthogonal adjacency).\n   c. Select one component; compute its bounding box: (min_r, max_r, min_c, max_c).\n   d. Build its shape mask: the set of offsets (r - min_r, c - min_c) for each pixel in the component.\n2. Mark all matching shapes:\n   a. Find every 4-connected component of pixels with value 1.\n   b. For each component, compute its bounding box and its mask of offsets relative to its bounding box.\n   c. If a component’s height = (max_r-min_r+1) and width = (max_c-min_c+1) match the target’s, and its offset set equals the target mask, then recolor all its pixels from 1 to 8.\n3. Recompute the list of 8-pixel components (they now include all target shapes).\n4. Connect shapes with value 7:\n   a. Horizontal connections:\n      i. Group 8-components by identical vertical spans (same min_r and max_r).\n      ii. In each group, sort components by min_c.\n      iii. For each adjacent pair (left, right), find a 1-component whose bounding box has the same min_r and max_r, and satisfies left.max_c < comp.min_c and comp.max_c < right.min_c.\n      iv. Recolor all pixels of each such component from 1 to 7.\n   b. Vertical connections:\n      i. Group 8-components by identical horizontal spans (same min_c and max_c).\n      ii. In each group, sort components by min_r.\n      iii. For each adjacent pair (top, bottom), find a 1-component whose bounding box has the same min_c and max_c, and satisfies top.max_r < comp.min_r and comp.max_r < bottom.min_r.\n      iv. Recolor all pixels of each such component from 1 to 7.\n5. Leave all other pixels unchanged.",
    "40f6cd08": "1. Let bg = 0.\n2. Identify all rectangular border regions:\n   a. For each color c ≠ bg, find each connected component of pixels value c.\n   b. For each component, compute its bounding box [r1..r2]×[c1..c2].\n   c. If every pixel on the perimeter of that box has value c, record this box and its border_color = c.\n3. Collect all such boxes into list RECTS.\n4. Select the template rectangle T from RECTS whose interior (all positions (r,c) with r1<T.r<r2 and c1<T.c<c2) contains at least one pixel value ≠ bg.\n5. Let (r1,c1,r2,c2) = T. Define the interior box I = rows r1+1..r2-1 and cols c1+1..c2-1. Extract the template pattern P of size (r2-r1-1)×(c2-c1-1) as the subgrid of input[T.r1+1..T.r2-1][T.c1+1..T.c2-1].\n6. For each rectangle R in RECTS with the same border_color as T and R ≠ T:\n   a. Compute its interior box J = rows R.r1+1..R.r2-1 and cols R.c1+1..R.c2-1.\n   b. If every pixel in J is bg, overwrite J with pattern P (copy P[r - (R.r1+1)][c - (R.c1+1)] into grid[r][c]).\n7. Output the resulting grid.",
    "da2b0fe3": "1. Let H be the number of rows and W the number of columns of the input grid.\n2. Build the set P of all coordinates (r,c) such that grid[r][c] ≠ 0.\n3. Compute r_min = min{r | (r,*) ∈ P}, r_max = max{r | (r,*) ∈ P}, c_min = min{c | (*,c) ∈ P}, c_max = max{c | (*,c) ∈ P}.\n4. Initialize gap_row = null and gap_col = null.\n5. For each r in [r_min..r_max], if for all c in [c_min..c_max] grid[r][c] == 0, set gap_row = r.\n6. For each c in [c_min..c_max], if for all r in [r_min..r_max] grid[r][c] == 0, set gap_col = c.\n7. If gap_row is not null, then for every c in [0..W-1] set grid[gap_row][c] = 3.\n8. Else (gap_col is not null), for every r in [0..H-1] set grid[r][gap_col] = 3.\n9. Return the modified grid.",
    "414297c0": "1. Parse the input grid of size R_in×C_in.\n2. Identify the inner colored rectangle:\n   a. For each non-zero color C≠0, collect all coordinates with value C.\n   b. For each such color C, compute the minimal bounding box (top, left, bottom, right) of its coordinates and check if every cell in that box has value C.\n   c. Choose the color C whose bounding box is entirely filled and has the largest area. Call its bounding box (rect_top, rect_left, rect_bottom, rect_right). Compute rect_h = rect_bottom–rect_top+1, rect_w = rect_right–rect_left+1.\n3. Initialize an output grid of size rect_h×rect_w, filling every cell with C (the rectangle color).\n4. Extract red‐pattern templates from the exterior region:\n   a. Let exterior = all cells (r,c) not inside the rectangle (r<rect_top or r>rect_bottom or c<rect_left or c>rect_right).\n   b. Find all 4‐connected components within exterior of cells with value ≠0 and ≠C.\n   c. For each component:\n      i. Locate the unique cell (r0,c0) in the component whose value V_center≠2.\n      ii. For every cell (r1,c1) in the component with value 2, record offset (dr=r1–r0, dc=c1–c0).\n      iii. Store pattern[V_center] = list of all such offsets.\n5. Stamp each pattern into the output:\n   a. For each cell (r,c) inside the rectangle (rect_top≤r≤rect_bottom, rect_left≤c≤rect_right):\n      i. Let V = input[r,c]. If V≠C and V is a key in pattern:\n         A. Compute output coordinates r_out = r–rect_top, c_out = c–rect_left.\n         B. Set output[r_out,c_out] = V.\n         C. For each (dr,dc) in pattern[V], set output[r_out+dr, c_out+dc] = 2.\n6. Return the output grid.",
    "da515329": "1. Scan the input grid to locate the ‘center’ of the plus-shape: find the unique cell C=(r,c) whose value is 0 and whose four orthogonal neighbors (r-1,c), (r+1,c), (r,c-1), (r,c+1) all have value 8.  \n2. Initialize an output grid of the same dimensions, setting every cell to 0.  \n3. Set the current position P=(r,c).  Do not color this cell; it remains 0.  \n4. Define direction vectors and indices: 0→E=(0,1), 1→S=(1,0), 2→W=(0,-1), 3→N=(-1,0).  Initialize direction index d=0 (East).  \n5. Repeat the following until no move is possible:  \n   a. Compute the index rd = (d+1) mod 4 (right turn).  \n   b. For each candidate direction in order [rd, d]:  \n      i. Let Δ be the vector for that candidate direction.  \n      ii. Let P1 = P + Δ and P2 = P1 + Δ.  \n      iii. Let L = the vector for (candidate direction+3 mod 4) (left turn).  \n      iv. If P1 and P2 are inside the grid and all three cells at P1, P2, and (P1 + L) currently equal 0, then:  \n          • Set d = candidate direction.  \n          • Move P := P1.  \n          • Set output[P] = 8.  \n          • Go back to step 5.  \n   c. If neither right nor straight moves were valid, terminate the loop.  \n6. Return the output grid.",
    "423a55dc": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Scan the input grid to identify the single non-zero integer S (the shape value).\n3. Find base_row, the maximum row index r (0 ≤ r < H) for which input[r][c] == S for any c.\n4. Initialize an output grid of size H×W filled with 0.\n5. For each cell (r, c) in the input grid:\n   a. If input[r][c] != S, skip to the next cell.\n   b. Compute shift = base_row − r.\n   c. Compute new_c = c − shift.\n   d. If new_c ≥ 0 and new_c < W, set output[r][new_c] = S.\n6. Leave all other cells in the output grid as 0.\n7. Return the output grid.",
    "dc2aa30b": "1. Define block rows and block columns: the grid has size 11×11. Rows 3 and 7 are all zeros; columns 3 and 7 are all zeros. The nine non‐zero 3×3 subgrids lie at row ranges [0–2], [4–6], [8–10] and column ranges [0–2], [4–6], [8–10].\n2. For each block, record its pattern and compute its red‐pixel count:\n   a. For block index b from 0 to 8 in row‐major order (b_row=b//3, b_col=b%3):\n      i. Let r_start = b_row*4, c_start = b_col*4.\n      ii. Let count_b = number of cells equal to 2 in the 3×3 region rows r_start..r_start+2 and cols c_start..c_start+2.\n      iii. Store tuple (count_b, b_row, b_col, pattern_b), where pattern_b is the 3×3 array of values in that region.\n3. Sort the list of tuples by count_b ascending; for ties, by b_row ascending then b_col ascending.\n4. Prepare an empty output grid initialized to all zeros of size 11×11.\n5. Place the sorted blocks into the output grid in ascending‐count order, filling each block row from top to bottom and within each row from rightmost to leftmost column:\n   a. For sorted index i from 0 to 8:\n      i. Let dest_block_row = i // 3, dest_block_col = 2 - (i % 3).\n      ii. Let (count, _, _, pattern) = sorted_list[i].\n      iii. Copy pattern into output grid at rows dest_block_row*4..dest_block_row*4+2 and cols dest_block_col*4..dest_block_col*4+2.\n6. Leave all separator rows and columns (rows 3,7 and cols 3,7) as zeros.\n7. Return the resulting grid.",
    "42918530": "1. Traverse the grid and find all connected components of non-zero cells using 4-connectivity (up, down, left, right).  Mark each visited cell so it is processed only once.\n2. For each connected component, record its color value c and compute its bounding box: minRow, maxRow, minCol, maxCol.\n3. Verify that each bounding box is exactly 5 rows high (maxRow–minRow+1=5) and 5 columns wide (maxCol–minCol+1=5).  (By task design, all color components form 5×5 blocks separated by zero margins.)\n4. Group the 5×5 components by their color value c.\n5. For each color group for value c:\n   a. Among its components, locate the template block whose interior (cells at rows minRow+1..maxRow-1 and cols minCol+1..maxCol-1) contains at least one cell equal to c.  This is the source pattern for color c.\n   b. Build a 3×3 mask M of booleans where for i=0..2 and j=0..2, M[i][j] = true if the template has value c at (minRow+1+i, minCol+1+j), else false.\n   c. For each component in the group (including the template): for i=0..2 and j=0..2:\n      i. If M[i][j] is true, set grid[minRow+1+i][minCol+1+j] = c.\n      ii. If M[i][j] is false, set grid[minRow+1+i][minCol+1+j] = 0.\n6. Leave all border cells (rows minRow and maxRow, cols minCol and maxCol of each block) unchanged (they remain equal to c).  Leave background zeros untouched.\n7. Return the modified grid with every 5×5 block of each color c having identical interior pattern copied from the template block for that color.",
    "dc2e9a9d": "1. Identify all connected components of pixels with value 3 (green), using 4-connected adjacency.\n2. For each component, compute its bounding box: rmin = minimum row index, rmax = maximum row index, cmin = minimum column index, cmax = maximum column index. Let width = cmax - cmin + 1, height = rmax - rmin + 1.\n3. Determine orientation and base square:\n   a. If width = height + 1 (horizontal orientation):\n      i. Set baseHeight = height, baseWidth = height.\n      ii. Set baseRmin = rmin, baseRmax = rmax.\n      iii. Set baseCmin = cmin + 1, baseCmax = cmax.\n      iv. For each column c from cmin to cmax, count how many component pixels lie in column c. If the count = 1 and c = cmin, mark extra side = LEFT; if count = 1 and c = cmax, extra side = RIGHT.\n      v. Set newColor = 1 (dark blue).\n      vi. If extra side = LEFT, set target columns tcmin = baseCmax + 2, tcmax = baseCmax + 1 + baseWidth. If extra side = RIGHT, set tcmax = baseCmin - 2, tcmin = baseCmin - 1 - baseWidth.\n      vii. For each row r from baseRmin to baseRmax and each column c from tcmin to tcmax, if r == baseRmin or r == baseRmax or c == tcmin or c == tcmax, set grid[r][c] = newColor.\n   b. Else if height = width + 1 (vertical orientation):\n      i. Set baseHeight = width, baseWidth = width.\n      ii. Set baseCmin = cmin, baseCmax = cmax.\n      iii. Set baseRmin = rmin + 1, baseRmax = rmax.\n      iv. For each row r from rmin to rmax, count how many component pixels lie in row r. If the count = 1 and r = rmin, mark extra side = TOP; if count = 1 and r = rmax, extra side = BOTTOM.\n      v. Set newColor = 8 (light blue).\n      vi. If extra side = TOP, set target rows trmin = baseRmax + 2, trmax = baseRmax + 1 + baseHeight. If extra side = BOTTOM, set trmax = baseRmin - 2, trmin = baseRmin - 1 - baseHeight.\n      vii. For each column c from baseCmin to baseCmax and each row r from trmin to trmax, if r == trmin or r == trmax or c == baseCmin or c == baseCmax, set grid[r][c] = newColor.\n4. Leave all original pixels unchanged. Return the modified grid.",
    "42a15761": "1. Let H and W be the height and width of the input grid. 2. Identify all separator columns: for each column c from 0 to W-1, if for every row r from 0 to H-1 grid[r][c]==0, add c to the list S. Sort S in ascending order. 3. Define data blocks as the contiguous column intervals between separators:\n   • Let prev = –1. For each separator column c in S (in ascending order):\n     – Define a block interval [prev+1, c-1] and add it to the list of blocks.  \n     – Set prev = c.\n   • After processing all separators, define a final block interval [prev+1, W-1] and add it.  \n   Denote the sequence of B blocks as B0,B1,… in their original order. 4. For each block Bi with column interval [ci_start, ci_end], compute its zero count Zi = number of positions (r,c) with ci_start ≤ c ≤ ci_end and grid[r][c]==0. 5. Create a list of pairs (i,Zi) for i from 0 to B–1. Perform a stable sort of this list in ascending order of Zi. Let the sorted sequence of original indices be I_sorted = [j0,j1,…,jB-1]. 6. Initialize an output grid of size H×W. 7. Reconstruct the output grid column by column:\n   • For k from 0 to B–1:\n     – Let src = I_sorted[k]. Let its original interval be [c_src_start, c_src_end]. Let dst_start be the k-th block interval start from step 3, and dst_end the corresponding end.  \n     – For each row r and for offset d from 0 to (c_src_end–c_src_start):\n         • Set output[r][dst_start + d] = input[r][c_src_start + d].\n   • For each separator column c in S, for every row r set output[r][c] = 0. 8. Return the output grid.",
    "dd2401ed": "1. Scan the grid to find the column index G of the vertical bar of grey pixels (value 5). 2. For each column C from G+1 to the rightmost column, in ascending order, check if every cell in column C has value 0. Stop at the first such column and record its index as T. 3. For each row r: set cell (r, G) to 0. 4. For each row r: set cell (r, T) to 5. 5. For every cell (r, c) with c < T: if its value is 2, change it to 1; otherwise leave it unchanged. 6. Leave all other cells (c > T and cells not on columns G or T) unchanged.",
    "4364c1c4": "1. Let background = grid[0][0]. 2. Initialize output grid identical to input. 3. Build a boolean mask foreground[r][c] = (input[r][c] != background). 4. Compute all 4-connected components of foreground cells. 5. For each component:  \n   a. Collect the set of distinct values in component; call it {v1,v2}.  \n   b. Determine topColor = the value among {v1,v2} whose minimum row index over its cells is smaller; bottomColor = the other value.  \n   c. For each cell (r,c) in component with input[r][c] == topColor: set output[r][c] = background; set output[r][c-1] = topColor.  \n   d. For each cell (r,c) in component with input[r][c] == bottomColor: set output[r][c] = background; set output[r][c+1] = bottomColor. 6. Return output grid.",
    "de493100": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Initialize min_r = H, max_r = -1, min_c = W, max_c = -1.\n3. For each row r from 0 to H-1 and each column c from 0 to W-1:\n   a. If grid[r][c] == 7, then set min_r = min(min_r, r), max_r = max(max_r, r), min_c = min(min_c, c), max_c = max(max_c, c).\n4. Define the missing-region bounding box as rows r = min_r..max_r and columns c = min_c..max_c.\n5. Let R = max_r - min_r + 1 and C = max_c - min_c + 1.\n6. Initialize an output grid O of size R rows and C columns.\n7. For each r in min_r..max_r and each c in min_c..max_c:\n   a. Compute mirror_c = W - 1 - c.\n   b. Set O[r - min_r][c - min_c] = grid[r][mirror_c].\n8. Return O as the output grid.",
    "456873bc": "1. For each row R from 0 to H–1:\n   a. Scan left to right and identify all maximal contiguous runs of cells whose value is exactly 2 (red).  Record each run by its starting column Cstart and its length L.\n   b. If there are no such runs in this row, continue to the next row.\n2. Number the runs in the row from left to right with indices j=0,1,…,N–1 (where N is the total number of runs in that row).\n3. For each run j with start Cstart and length L:\n   a. If L ≥ j+1 then set the cell at (R, Cstart + j) to 8 (cyan).\n   b. Otherwise leave the run unchanged.\n4. Leave all other cells in the grid unmodified.",
    "df8cc377": "1. Scan the grid and identify all hollow rectangular shapes: for each connected component of a non-zero color C where the component’s cells lie exactly on the perimeter of its axis-aligned bounding box (i.e. all cells with row = Rmin or Rmax and col between Cmin and Cmax, and all cells with col = Cmin or Cmax and row between Rmin and Rmax), record that shape with its border color C and its bounding rows Rmin…Rmax and cols Cmin…Cmax.  \n2. Collect all non-zero cell values that are not part of any shape border into a set S of unique colors.  \n3. Sort the list of shapes by their border color in ascending numerical order to get shapes_sorted.  \n4. Sort the list of scattered colors S in ascending numerical order to get colors_sorted.  \n5. For each shape at index i in shapes_sorted, compute fill_color = colors_sorted[length(colors_sorted) - 1 - i].  \n6. For each such shape, for every interior cell (r,c) with Rmin < r < Rmax and Cmin < c < Cmax:  \n   a. If (r + c) mod 2 equals (Rmin + Cmin + 2) mod 2 (so that the cell at (Rmin+1, Cmin+1) is colored), set grid[r][c] = fill_color.  \n   b. Otherwise set grid[r][c] = 0.  \n7. Leave all border cells and all other cells unchanged.",
    "45737921": "1. Let G be the input grid of size H rows by W columns. Initialize an output grid O as a copy of G.\n2. For each row index r from 0 to H-3 inclusive, and for each column index c from 0 to W-3 inclusive, do:\n   a. Compute the set S of values { G[r+i][c+j] | i in 0..2, j in 0..2 }.\n   b. If 0 is not in S and the size of S is exactly 2, then:\n      i. Let the two distinct values in S be a and b.\n      ii. For each i in 0..2 and each j in 0..2:\n          - If G[r+i][c+j] == a, set O[r+i][c+j] = b.\n          - Else (G[r+i][c+j] == b), set O[r+i][c+j] = a.\n3. Return O as the transformed output grid.",
    "e0fb7511": "1. Let R be the number of rows and C be the number of columns in the input grid. 2. Create a boolean array visited of size R×C, initialized to false. 3. For each row r from 0 to R−1 and each column c from 0 to C−1, do:  \n   a. If grid[r][c]==0 and visited[r][c]==false, then:  \n      i. Initialize empty list componentCells.  \n      ii. Create a stack or queue and push (r,c); set visited[r][c]=true.  \n      iii. While the stack is not empty:  \n          - Pop (x,y) from the stack.  \n          - Append (x,y) to componentCells.  \n          - For each neighbor (nx,ny) in the four orthogonal directions {(x−1,y),(x+1,y),(x,y−1),(x,y+1)} that lies within 0≤nx<R and 0≤ny<C:  \n              • If grid[nx][ny]==0 and visited[nx][ny]==false, then set visited[nx][ny]=true and push (nx,ny).  \n      iv. After the flood fill completes, if the number of cells in componentCells is greater than 1, then for each (x,y) in componentCells set grid[x][y]=8.  \n4. Leave all other cells (including single-cell components of value 0) unchanged.  \n5. Output the modified grid.",
    "45bbe264": "1. Scan the input grid to collect all seed cells: for each position (r,c) where grid[r][c] ≠ 0, record a seed with row r_S = r, column c_S = c, and color value v_S = grid[r][c].\n2. Initialize an output grid of the same dimensions.\n3. For each cell position (r,c) in the grid:\n   a. Create an empty set C.\n   b. For each seed S in the seed list:\n      i.  If r = r_S or c = c_S, add v_S to set C.\n   c. If C is empty, set output[r][c] = 0.\n   d. Else if C contains exactly one element v, set output[r][c] = v.\n   e. Else (C contains two or more distinct values), set output[r][c] = 2.\n4. Return the output grid.",
    "e133d23d": "1. Let R be the number of rows and C be the number of columns in the input grid. 2. Locate the index Y of the unique column in which every cell has value 4. 3. Set W = Y and define the output grid as an R×W array of zeros. 4. For each row r from 0 to R–1, and for each column c from 0 to W–1, do:   a. Let L = input_grid[r][c].   b. Let Rv = input_grid[r][Y + 1 + c].   c. If L ≠ 0 OR Rv ≠ 0, then set output_grid[r][c] = 2; otherwise leave output_grid[r][c] = 0. 5. Return the output_grid.",
    "477d2879": "1. Let BARRIER=1 and SEED values = integers >1.  \n2. Locate all seed pixels: collect positions S = {(r,c) | grid[r][c] >1}.  \n3. Compute face components: perform a 4‐connected flood fill on all cells with original value != BARRIER. Each component comp_i is the set of cells reachable from one another by moves up/down/left/right through cells whose original value ≠ BARRIER.  \n4. For each comp_i:  \n   a. Identify its unique seed pixel (r0,c0) ∈ comp_i with original value >1. Let COLOR_i = original grid[r0][c0].  \n   b. Set every cell (r,c) ∈ comp_i to COLOR_i.  \n5. Assign barrier cells: for each cell (r,c) with original value = BARRIER, compute the Manhattan distance to every seed position (r0,c0) ∈ S: d = |r–r0|+|c–c0|. Find seed s* with minimal d (if tie, choose the one with smaller COLOR). Let its color be C*. Set grid[r][c] = C*.  \n6. Return the recolored grid.",
    "e1baa8a4": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Identify the horizontal cut indices:\n   a. Initialize a list horizontal_cuts = [0].\n   b. For each row index r from 1 to H−1, if for every column c in 0..W−1, grid[r][c] ≠ grid[r−1][c], then append r to horizontal_cuts.\n   c. After the loop, append H to horizontal_cuts.\n3. Identify the vertical cut indices:\n   a. Initialize a list vertical_cuts = [0].\n   b. For each column index c from 1 to W−1, if for every row r in 0..H−1, grid[r][c] ≠ grid[r][c−1], then append c to vertical_cuts.\n   c. After the loop, append W to vertical_cuts.\n4. Let R = length(horizontal_cuts) − 1 (number of block rows) and C = length(vertical_cuts) − 1 (number of block columns).\n5. Initialize an output grid of size R rows by C columns.\n6. For each block row index i in 0..R−1 and each block column index j in 0..C−1:\n   a. Let r0 = horizontal_cuts[i] and c0 = vertical_cuts[j].\n   b. Set output[i][j] = grid[r0][c0].\n7. Return the output grid.",
    "47996f11": "1. Let P = 6 (pink).  2. Let H = number of rows, W = number of columns.  3. Copy input grid to output grid.  4. Find all connected components of cells with value P using 4-way adjacency.  5. For each component:    a. Compute its bounding box: min_r, max_r, min_c, max_c.    b. Let h = max_r - min_r + 1, w = max_c - min_c + 1.    c. For each row r in [min_r..max_r]:       i. Identify all columns c in [min_c..max_c] where input[r][c] == P; these will form one or more contiguous segments.      ii. For each contiguous segment [c1..c2] of length L = c2 - c1 + 1:           A. If c2 + L ≤ W - 1 and none of input[r][c] for c in [c2+1..c2+L] equals P, then for i from 0 to L-1 set output[r][c1 + i] = input[r][c2 + (L - i)].           B. Else if c1 - L ≥ 0 and none of input[r][c] for c in [c1-L..c1-1] equals P, then for i from 0 to L-1 set output[r][c2 - i] = input[r][c1 - (L - i)].           C. Else if max_r + L ≤ H - 1 and none of input[r2][c] for r2 in [max_r+1..max_r+L] at any c in [c1..c2] equals P, then for dr from 0 to L-1 and for each c in [c1..c2] set output[min_r + dr][c] = input[max_r + (L - dr)][c].           D. Else if min_r - L ≥ 0 and none of input[r2][c] for r2 in [min_r-L..min_r-1] at any c in [c1..c2] equals P, then for dr from 0 to L-1 and for each c in [c1..c2] set output[max_r - dr][c] = input[min_r - (L - dr)][c].  6. Leave all other cells unchanged.",
    "e1d2900e": "1. Parse the input grid dimensions M×N. 2. Identify all red clusters: find each connected component of value-2 pixels using 4-connectivity. For each component compute its bounding box: r_min, r_max, c_min, c_max. 3. Initialize the output grid as a copy of the input grid. 4. For each blue pixel (value 1) at position (r,c) in the input:   a. Determine all clusters that align with this pixel: a cluster aligns if r_min ≤ r ≤ r_max (horizontal alignment) or c_min ≤ c ≤ c_max (vertical alignment).   b. If no cluster aligns, leave this blue pixel in place.   c. Otherwise, for each aligning cluster compute its alignment distance:      i. If r_min ≤ r ≤ r_max, distance = min(|c − c_min|, |c − c_max|).      ii. Else (c_min ≤ c ≤ c_max), distance = min(|r − r_min|, |r − r_max|).   d. Select the cluster with minimum distance.   e. Compute the new position for the blue pixel:      i. If horizontal alignment (r_min ≤ r ≤ r_max):         • If c < c_min then new_c = c_min − 1; else new_c = c_max + 1.         • new_r = r.      ii. Else (vertical alignment):         • If r < r_min then new_r = r_min − 1; else new_r = r_max + 1.         • new_c = c.   f. In the output grid set output[r][c] = 0 and output[new_r][new_c] = 1. 5. Preserve all red pixels (value 2) and all non-aligned blue pixels in their original positions. 6. Return the output grid.",
    "48131b3c": "1. Let G be the input grid with H rows and W columns. 2. Scan G to find its two distinct values; call the smaller one v1 and the larger v2. 3. Create a grid I of size H×W. For each row r from 0 to H−1 and column c from 0 to W−1: if G[r][c] == v1 then set I[r][c] = v2 else set I[r][c] = v1. 4. Create an output grid O with 2·H rows and 2·W columns. 5. For each output row r_out from 0 to 2·H−1 and column c_out from 0 to 2·W−1: compute r_in = r_out mod H and c_in = c_out mod W, then set O[r_out][c_out] = I[r_in][c_in]. 6. Return O.",
    "e2092e0c": "1. Let background color = 0 and border color = 5. 2. Extract the sample shape from the top-left example (a 5×5 region): record PatternMask = all relative coordinates (dr,dc) within that 5×5 where sample pixel ≠ background, and let PatternHeight = PatternWidth = 5. 3. For each possible top-left (R,C) of a 5×5 window in the input grid (0 ≤ R ≤ H−5, 0 ≤ C ≤ W−5):\n   a. Initialize match = true.\n   b. For each (dr,dc) in PatternMask: if grid[R+dr][C+dc] == background then set match = false and break.\n   c. For each dr from 0 to 4 and dc from 0 to 4 such that (dr,dc) ∉ PatternMask: if grid[R+dr][C+dc] ≠ background then set match = false and break.\n   d. If match is true, record box origin (R,C).\n4. For each recorded box origin (R,C):\n   a. For x from 0 to 4: set grid[R][C+x] = border color and grid[R+4][C+x] = border color.\n   b. For y from 0 to 4: set grid[R+y][C] = border color and grid[R+y][C+4] = border color.\n5. Return the modified grid.",
    "4852f2fa": "1. Let shape_value = 8 and marker_value = 4.\n2. Collect all coordinates (r, c) where input[r][c] == shape_value into list shape_positions.\n3. Compute row_min = min(r), row_max = max(r), col_min = min(c), col_max = max(c) over shape_positions.\n4. Let H = row_max – row_min + 1 and W = col_max – col_min + 1.\n5. Build pattern P as an H×W array where P[i][j] = input[row_min + i][col_min + j] for i in [0..H-1], j in [0..W-1].\n6. Count N = number of cells in input equal to marker_value.\n7. Set output_rows = 3 and output_cols = W * N.\n8. Initialize output as a 3×(W*N) array filled with 0.\n9. Compute vertical_offset = output_rows – H.\n10. For k from 0 to N–1, for i from 0 to H–1, for j from 0 to W–1:\n      If P[i][j] == shape_value, then set output[vertical_offset + i][k * W + j] = shape_value.\n11. Return output.",
    "e21a174a": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Create an empty output grid of size H×W.\n3. For each row index r from 0 to H–1:\n   a. Compute source_row = H–1 – r.\n   b. For each column index c from 0 to W–1:\n      i. Set output[r][c] = input[source_row][c].\n4. Return the output grid.",
    "48f8583b": "1. Read the 3×3 input grid of integers input[r][c], where r and c range from 0 to 2.\n2. Initialize a 9×9 output grid output[R][C] filled with 0 for all R,C in 0..8.\n3. Build a frequency map counts[v] = number of positions (r,c) in the input where input[r][c] == v, for each distinct v in the input (ignore value 0 if present).\n4. Identify the marker value m = the v with the smallest counts[v].\n5. For each cell (r,c) in the input where input[r][c] == m:\n   a. Compute base row BR = r × 3 and base column BC = c × 3.\n   b. For dr from 0 to 2 and dc from 0 to 2, set output[BR + dr][BC + dc] = input[dr][dc].\n6. Leave all other cells of output as 0.\n7. Return the 9×9 output grid.",
    "e345f17b": "1. Let the input grid G have 4 rows (r = 0..3) and 8 columns (c = 0..7). 2. Define the left half as columns 0–3 and the right half as columns 4–7. 3. Create an empty output grid O of size 4×4. 4. For each row r from 0 to 3 and each column c from 0 to 3:    a. If G[r][c] == 0 AND G[r][c+4] == 0, set O[r][c] = 4.    b. Otherwise, set O[r][c] = 0. 5. Return O.",
    "4aab4007": "1. Read H = number of rows and W = number of columns.\n2. Fill zeros in the top three rows:\n   a. For each r in {1,2,3}:\n      i. Find c0 = smallest column c such that grid[r][c] ≠ 0.\n      ii. For each column c from 1 to W:\n          If grid[r][c] == 0, set grid[r][c] = grid[r][c0].\n3. Restore the first pattern row (r = 4) by inferring its horizontal cycle:\n   a. Let Z = {c | grid[4][c] == 0}.\n   b. If Z is nonempty:\n      i. Let c_end = max(Z).\n      ii. Construct tail = [grid[4][d] for d in (c_end+1) to W].\n      iii. Determine the smallest positive period P (1 ≤ P ≤ len(tail)) such that for all i in [0..len(tail)-P-1], tail[i] == tail[i+P].\n      iv. Let cycle = tail[0..P-1].\n      v. For each c in Z in descending order:\n         • Compute idx = ((c - c_end - 1) mod P).\n         • Set grid[4][c] = cycle[idx].\n4. Propagate the diagonal pattern downward for rows r = 5 to H:\n   For each r from 5 to H:\n     For each c from 1 to W:\n       If grid[r][c] == 0, set grid[r][c] = grid[r-1][c+1].\n5. Return the modified grid as the output.",
    "e4075551": "1. Scan the grid to find the unique cell with value 2; record its coordinates as (R, C).  \n2. Collect all cells with value ≠0 and ≠2; there will be exactly four cells with values vᵢ at coordinates (rᵢ, cᵢ).  \n3. From these four cells identify:  \n   • The top pixel as the one with minimum rᵢ; let its coordinates be (r_top, c_top) and its value v_top.  \n   • The bottom pixel as the one with maximum rᵢ; let its coordinates be (r_bot, c_bot) and its value v_bot.  \n   • The left pixel as the one with minimum cᵢ; let its coordinates be (r_left, c_left) and its value v_left.  \n   • The right pixel as the one with maximum cᵢ; let its coordinates be (r_right, c_right) and its value v_right.  \n4. Draw horizontal walls:  \n   For col from c_left to c_right inclusive:  \n     – Set grid[r_top][col] = v_top.  \n     – Set grid[r_bot][col] = v_bot.  \n5. Draw vertical walls (excluding corners):  \n   For row from r_top+1 to r_bot-1 inclusive:  \n     – Set grid[row][c_left] = v_left.  \n     – Set grid[row][c_right] = v_right.  \n6. Draw the horizontal grey connector (value 5) through the red pixel:  \n   For col from c_left+1 to c_right-1 inclusive, if col ≠ C then set grid[R][col] = 5.  \n7. Draw the vertical grey connector (value 5) through the red pixel:  \n   For row from r_top+1 to r_bot-1 inclusive, if row ≠ R then set grid[row][C] = 5.",
    "4acc7107": "1. Let H and W be the number of rows and columns of the input grid.\n2. Identify the set of non-zero colors present in the grid. Call this set C.\n3. For each color c in C:\n   a. Find all connected components of cells equal to c using orthogonal adjacency. Each component is a shape.\n   b. For each shape s, compute:\n      i. Pixel count count_s = number of cells in s.\n      ii. Bounding box coordinates: min_row_s, max_row_s, min_col_s, max_col_s.\n      iii. Height h_s = max_row_s - min_row_s + 1, width w_s = max_col_s - min_col_s + 1.\n      iv. Shape pattern P_s = set of relative coordinates (r - min_row_s, c - min_col_s) for each cell (r,c) in s.\n   c. Verify exactly two shapes exist for color c; name the shape with larger count as L_c and the smaller as S_c.\n4. Sort the colors in C into a list [c1, c2, …] by the smallest min_col among their two shapes, ascending.\n5. Create an output grid of size H×W, initialized to zeros.\n6. Initialize x_offset = 0.\n7. For each color c in the sorted list:\n   a. Let L = L_c (the larger shape), S = S_c (the smaller).\n   b. Let stack_width = max(w_L, w_S).\n   c. Compute y_start_L = H - h_L.\n   d. Place L into the output grid:\n      For each (dr, dc) in P_L, set output[y_start_L + dr][x_offset + dc] = c.\n   e. Leave one blank row above L (row y_start_L - 1 remains zeros).\n   f. Compute y_start_S = y_start_L - 1 - h_S.\n   g. Place S into the output grid:\n      For each (dr, dc) in P_S, set output[y_start_S + dr][x_offset + dc] = c.\n   h. Update x_offset = x_offset + stack_width + 1.\n8. Return the output grid.",
    "e41c6fd3": "1. Let H and W be the number of rows and columns of the input grid. 2. Define background value 0. 3. Identify all non-zero colors in the grid; each color’s pixels form one connected shape. 4. For each non-zero color c, compute min_row[c] = the smallest row index r such that grid[r][col] == c for some col. 5. Let control_color = 8. 6. Let control_top = min_row[control_color]. 7. For each non-zero color c, compute offset[c] = control_top - min_row[c]. 8. Create an output grid of size H×W, fill all cells with 0. 9. For each cell (r, col) in the input grid with value v > 0: 9.1. Compute new_r = r + offset[v]. 9.2. Set output[new_r][col] = v. 10. Return the output grid.",
    "4b6b68e5": "1. Let H and W be the input grid height and width. Initialize an output grid O of size H×W with all cells = 0.\n2. Identify all connected components of non-zero cells in the input grid using 4-connectivity. For each component Comp:\n   a. Let c be the integer value of cells in Comp.\n   b. Compute r0 = min row of Comp, r1 = max row of Comp, c0 = min column of Comp, c1 = max column of Comp.\n   c. Compute expected perimeter size P = 2 * ((r1 - r0 + 1) + (c1 - c0 + 1)) - 4.\n   d. If |Comp| ≠ P, then skip this component (it is not a closed rectangle border).\n   e. Otherwise (Comp is a closed rectangle of color c):\n      i. Define interior cells I = {(r, s) | r0 < r < r1 and c0 < s < c1}.\n      ii. In the input grid, count occurrences of each value v>0 in I. If no v>0 occurs, set fill value f = 0; otherwise set f to the v with the highest count (break ties arbitrarily).\n      iii. For each (r, s) in Comp, set O[r][s] = c.\n      iv. For each (r, s) in I, set O[r][s] = f.\n3. Leave all other cells of O as 0. Return O as the transformed grid.",
    "e57337a4": "1. Let G be the input grid with R rows and C columns (here R=C=15).\n2. Compute block_height = R / 3 and block_width = C / 3 (both equal 5).\n3. Let B = G[0][0] (the uniform non-zero background color).\n4. Create an output grid O of size 3 rows and 3 columns, initializing every cell O[i][j] = B for i,j in 0‥2.\n5. For each input position (r,c) with 0 ≤ r < R and 0 ≤ c < C:\n     a. If G[r][c] == 0 then:\n          i. Compute out_row = floor(r / block_height) and out_col = floor(c / block_width).\n         ii. Set O[out_row][out_col] = 0.\n6. Return the 3×3 grid O.",
    "4c177718": "1. Scan each row to find the dividingRow index where every cell equals 5 (the horizontal line of 5s).  \n2. Partition the grid into upper region (rows 0..dividingRow–1) and lower region (rows dividingRow+1..end).  \n3. In the upper region, find all connected components of nonzero pixels (4-connectivity). For each component, record:  \n   • color = the pixel value  \n   • minRow, maxRow, minCol, maxCol  \n   • centerCol = floor((minCol + maxCol)/2)  \n4. In the lower region, find the single connected component of nonzero pixels. Record its color as D_color, and its minRow_D, maxRow_D, minCol_D, maxCol_D.  \n5. Among the three upper components:  \n   • shapeD_upper = the component with color == D_color  \n   • shapeC = the component with the largest centerCol  \n   • shapeB = the remaining component (the orientation arrow)  \n6. Determine arrow orientation of shapeB:  \n   • Let hB = maxRow_B – minRow_B + 1, wB = maxCol_B – minCol_B + 1.  \n   • Count cells in its top boundingRow (r = minRow_B) as countTop and in its bottom boundingRow (r = maxRow_B) as countBot.  \n   • If countTop == wB and countBot == 1, orientation = down;  \n     if countTop == 1 and countBot == wB, orientation = up.  \n7. Compute dimensions and centers:  \n   • heightD = maxRow_D – minRow_D + 1, widthD = maxCol_D – minCol_D + 1  \n   • heightC = maxRow_C – minRow_C + 1, widthC = maxCol_C – minCol_C + 1  \n   • centerColD = floor((minCol_D + maxCol_D)/2)  \n8. Compute target positions:  \n   If orientation == up:  \n     • topRow_D_out = dividingRow  \n     • topRow_C_out = dividingRow – heightC  \n   Else (orientation == down):  \n     • topRow_D_out = dividingRow – heightD  \n     • topRow_C_out = dividingRow + 1  \n   • leftCol_D_out = centerColD – floor(widthD/2)  \n   • leftCol_C_out = centerColD – floor(widthC/2)  \n9. Initialize an output grid of same dimensions filled with 0.  \n10. Paste shapeD: for each input pixel (r,c) with value == D_color and minRow_D ≤ r ≤ maxRow_D, minCol_D ≤ c ≤ maxCol_D, set  \n     output[r_out, c_out] = D_color  \n     where r_out = topRow_D_out + (r – minRow_D), c_out = leftCol_D_out + (c – minCol_D).  \n11. Paste shapeC: for each input pixel (r,c) with value == C_color and minRow_C ≤ r ≤ maxRow_C, minCol_C ≤ c ≤ maxCol_C, set  \n     output[r_out, c_out] = C_color  \n     where r_out = topRow_C_out + (r – minRow_C), c_out = leftCol_C_out + (c – minCol_C).  \n12. Leave all other cells as 0.  \n13. Return the output grid.",
    "e5790162": "1. Let H be the number of rows and W be the number of columns in the input grid. 2. Find the unique start pixel with value 3. Record its coordinates as (r, c). 3. Define four directions as vectors: East=(dr=0, dc=1), South=(1,0), West=(0,-1), North=(-1,0). 4. Set current direction D to East. 5. Repeat the following:  5.1. Compute next_r = r + dr and next_c = c + dc.  5.2. If next_r < 0 or next_r ≥ H or next_c < 0 or next_c ≥ W, stop.  5.3. Let color = grid[next_r][next_c].  5.4. If color = 0, then:    a. Set grid[next_r][next_c] = 3.    b. Update (r, c) = (next_r, next_c).    c. Continue to step 5.  5.5. Else if color = 6 or color = 8, then:    a. If color = 6, turn D right (clockwise):       • If D=East, set D=South; if D=South, set D=West; if D=West, set D=North; if D=North, set D=East.    b. If color = 8, turn D left (counter-clockwise):       • If D=East, set D=North; if D=North, set D=West; if D=West, set D=South; if D=South, set D=East.    c. Do not move; continue to step 5.  5.6. Else (color is neither 0, 6, nor 8), stop. 6. Output the modified grid.",
    "4cd1b7b2": "1. Let N = 4.  \n2. Identify all blank cells: create a list BLANKS of coordinate pairs (r,c) where grid[r][c] == 0, scanning rows r = 0 to N-1 and columns c = 0 to N-1 in row-major order.  \n3. Define a recursive procedure SOLVE(index):  \n   a. If index == length of BLANKS, return true (all blanks filled).  \n   b. Let (r,c) = BLANKS[index].  \n   c. Compute ROW_VALUES = set of all non-zero values in row r.  \n   d. Compute COL_VALUES = set of all non-zero values in column c.  \n   e. Let USED = ROW_VALUES ∪ COL_VALUES.  \n   f. For each candidate value v in [1,2,3,4]:  \n      i. If v ∉ USED:  \n         1. Assign grid[r][c] = v.  \n         2. If SOLVE(index + 1) returns true, return true.  \n         3. Otherwise reset grid[r][c] = 0 and continue.  \n   g. If no candidate yields success, return false.  \n4. Invoke SOLVE(0).  \n5. On success, the grid is completed so that each row and each column contains exactly one of each value 1,2,3,4, with all original non-zero entries unchanged.",
    "e5c44e8f": "1. Locate the starting point (R, C) where grid[R][C] == 3.  \n2. Define directions in order:  \n   a. Up:     dr = -1, dc =  0  \n   b. Right:  dr =  0, dc = +1  \n   c. Down:   dr = +1, dc =  0  \n   d. Left:   dr =  0, dc = -1  \n3. Initialize:  \n   • current_r = R; current_c = C  \n   • step_length = 2  \n   • dir_index = 0  \n4. Repeat the following until interrupted:  \n   a. Let (dr, dc) = directions[dir_index % 4].  \n   b. For i from 1 to step_length:  \n      i.   next_r = current_r + dr; next_c = current_c + dc  \n      ii.  If next_r or next_c is outside grid bounds, or grid[next_r][next_c] == 2, then stop the entire algorithm.  \n      iii. Set grid[next_r][next_c] = 3.  \n      iv.  current_r = next_r; current_c = next_c.  \n   c. Increment dir_index by 1.  \n   d. After every two directions (i.e., when dir_index % 2 == 0), increase step_length by 2.  \n5. End.  \n\nDefinitions:  \n– \"Outside grid bounds\": next_r < 0 or next_r >= number of rows, or next_c < 0 or next_c >= number of columns.  \n– Stop condition: encountering a cell with value 2 or moving outside the grid.  \n– Do not overwrite any cell except those with value 0 (which become 3).",
    "4e45f183": "1. Let full_grid be the 19×19 input. Identify the 1-cell-wide zero border rows (rows 0,6,12,18) and zero border columns (cols 0,6,12,18). These partition full_grid into a 3×3 array of 5×5 blocks at block positions (r,c) where r,c∈{0,1,2}. Block (r,c) occupies rows (1+6r) to (5+6r) and cols (1+6c) to (5+6c).\n2. For each 5×5 block B:\n   a. Let interior_cells be B at rows 2–4, cols 2–4 (relative to B’s local 1–5 coords). Compute interior_color = mode of interior_cells (the fill color).\n   b. Let border_cells be all cells of B not in interior_cells. Compute border_color = mode of border_cells.\n   c. For each side s in {top,bottom,left,right}, inspect the 5 cells on that side of B. Declare side s “open” if ALL those 5 cells equal interior_color. Record B.open_sides as the set of open sides.\n3. Identify the block B_center whose B_center.open_sides is empty. This is the most complete pattern. Assign B_center to output block position (1,1).\n4. For each remaining block B (B ≠ B_center):\n   a. Let S = B.open_sides.\n   b. If S = {bottom}, assign B to output block (0,1).\n   c. If S = {top}, assign B to (2,1).\n   d. If S = {left}, assign B to (1,2).\n   e. If S = {right}, assign B to (1,0).\n   f. If S = {bottom,right}, assign B to (0,0).\n   g. If S = {bottom,left}, assign B to (0,2).\n   h. If S = {top,right}, assign B to (2,0).\n   i. If S = {top,left}, assign B to (2,2).\n5. Construct the output 19×19 grid as follows:\n   a. Initialize all cells to 0.\n   b. For each block B and its assigned output position (r_out,c_out), copy B (all 25 values) into output rows (1+6r_out)…(5+6r_out), cols (1+6c_out)…(5+6c_out), preserving its original orientation.\n6. Return the assembled output grid.",
    "e619ca6e": "1. Let H and W be the number of rows and columns in the input grid.\n2. Identify all non-zero components: perform a 4-connected flood fill on cells with value ≠ 0. For each component:\n   a. Let v be the common value of its cells.\n   b. Let min_row = minimum row index, max_row = maximum row index, min_col = minimum column index, max_col = maximum column index over its cells.\n   c. Compute height h = max_row – min_row + 1, width w = max_col – min_col + 1.\n   d. Build a set S of relative offsets: for each cell (r,c) in the component, include (dr,dc) = (r – min_row, c – min_col) if grid[r,c] == v.\n3. For each component (with parameters v, min_row, min_col, h, w, S), generate downward tiers:\n   a. For k = 1,2,3,… until min_row + k*h ≥ H, do:\n      i. For each (dr,dc) in S:\n         A. Compute target_row = min_row + k*h + dr.  If target_row ≥ H, skip to next k.\n         B. Compute left_col = min_col + dc – k*w. If 0 ≤ left_col < W, set grid[target_row, left_col] = v.\n         C. Compute right_col = min_col + dc + k*w. If 0 ≤ right_col < W, set grid[target_row, right_col] = v.\n4. Output the modified grid.",
    "4e469f39": "1. Identify all rectangular wireframe shapes of pixel value 5. For each shape:\n  a. Compute its bounding box: min_row, max_row, min_col, max_col over all 5-valued cells.\n  b. Verify that every cell on the perimeter of that box, except exactly one, contains a 5.\n2. For each wireframe, locate the missing-perimeter cell P:\n  a. Let perimeter_cells be the set of coordinates (r,c) where r==min_row or r==max_row and min_col<=c<=max_col, or c==min_col or c==max_col and min_row<=r<=max_row.\n  b. P is the unique coordinate in perimeter_cells whose grid value is not 5.\n3. Fill the interior and the opening:\n  a. For every cell (r,c) with min_row<r<max_row and min_col<c<max_col, set its value to 2.\n  b. Set the value at P to 2.\n4. Determine the outward normal direction D1 from P:\n  a. If P.row==min_row, D1=(-1,0). If P.row==max_row, D1=(1,0).\n  b. Else if P.col==min_col, D1=(0,-1). Else if P.col==max_col, D1=(0,1).\n5. Compute the first extension cell P1=P+D1, and set its value to 2.\n6. Determine the extension direction D2 perpendicular to D1:\n  a. If D1 is vertical (D1.row≠0), do:\n    i. Count left_count = number of cells with value 5 among coordinates (P.row, c) for c from min_col to P.col-1.\n    ii. Count right_count = number of cells with value 5 among coordinates (P.row, c) for c from P.col+1 to max_col.\n    iii. If left_count>right_count, set D2=(0,-1); otherwise set D2=(0,1).\n  b. If D1 is horizontal (D1.col≠0), do:\n    i. Count up_count = number of 5s among (r, P.col) for r from min_row to P.row-1.\n    ii. Count down_count = number of 5s among (r, P.col) for r from P.row+1 to max_row.\n    iii. If up_count>down_count, set D2=(-1,0); otherwise set D2=(1,0).\n7. Extend and fill along D2:\n  a. Initialize Q = P1.\n  b. While Q is within grid bounds, set grid[Q] = 2 and update Q = Q + D2.\n8. Leave all original 5s intact. All new 2s represent the filled interior, the opening, the first outward step, and the continuous tail to the grid edge.",
    "e633a9e5": "1. Let A be the input grid of size 3 rows by 3 columns, with rows indexed 0–2 and columns indexed 0–2.\n2. Define an integer array row_scale = [2,1,2].  // row_scale[r] is the vertical replication factor for input row r\n3. Define an integer array col_scale = [2,1,2].  // col_scale[c] is the horizontal replication factor for input column c\n4. Compute output height H = row_scale[0] + row_scale[1] + row_scale[2] (which equals 5).\n5. Compute output width W = col_scale[0] + col_scale[1] + col_scale[2] (which equals 5).\n6. Initialize an empty output grid B of size H rows by W columns.\n7. Initialize an output row pointer R_out = 0.\n8. For each input row r from 0 to 2 do:\n   a. Repeat the following for rep_r from 1 to row_scale[r]:\n      i. Initialize an output column pointer C_out = 0.\n     ii. For each input column c from 0 to 2 do:\n          A. For rep_c from 1 to col_scale[c] do:\n             - Set B[R_out][C_out] = A[r][c].\n             - Increment C_out by 1.\n    iii. After filling all columns for this repeated row, increment R_out by 1.\n9. After processing all input rows, B is the desired 5×5 output grid.",
    "4f537728": "1. Let X be the unique cell value in the input grid that is neither 0 nor 1. 2. Determine the bounding rectangle of X: compute R_min = minimum row index of any cell equal to X, R_max = maximum row index of any cell equal to X; C_min = minimum column index of any cell equal to X, C_max = maximum column index of any cell equal to X. 3. Initialize the output grid as a copy of the input grid. 4. For each row r in the range R_min to R_max (inclusive): for each column c from 0 to (width−1): if input[r][c] == 1 then set output[r][c] = X. 5. For each column c in the range C_min to C_max (inclusive): for each row r from 0 to (height−1): if input[r][c] == 1 then set output[r][c] = X. 6. Leave all other cells unchanged.",
    "e66aafb8": "1. Let H = number of rows in the input grid and W = number of columns.  \n2. Identify all coordinates (r,c) where the input pixel value = 0.  These zeros form a contiguous rectangular block.  Compute r_min = minimum r of zeros, r_max = maximum r of zeros, c_min = minimum c of zeros, c_max = maximum c of zeros.  3. Initialize an empty output grid of size (r_max - r_min + 1) rows by (c_max - c_min + 1) columns.  \n4. For each pair of indices r in [r_min .. r_max] and c in [c_min .. c_max]:  \n   a. Compute r_sym = H + 1 - r.  \n   b. Compute c_sym = W + 1 - c.  \n   c. Read value v = input[r_sym][c_sym].  \n   d. Set output[r - r_min + 1][c - c_min + 1] = v.  \n5. Return the output grid.",
    "4ff4c9da": "1. Locate all grid cells colored 8. 2. Compute the minimal bounding rectangle that contains every 8-colored cell: let r_min=minimum row, r_max=maximum row, c_min=minimum column, c_max=maximum column among those cells. 3. Within that rectangle, build two lists:\n   a. shape_offsets = all offsets (dr,dc) for which the cell at (r_min+dr, c_min+dc) is color 8.\n   b. background_map = for every offset (dr,dc) in the rectangle not in shape_offsets, record the color B(dr,dc) = original color at (r_min+dr, c_min+dc).\n4. For each possible top-left anchor (r0,c0) such that r0+r_max–r_min < grid height and c0+c_max–c_min < grid width, do:\n   a. Check the background: for every (dr,dc) not in shape_offsets, if grid[r0+dr][c0+dc] ≠ B(dr,dc), skip this anchor.\n   b. Otherwise, for every (dr,dc) in shape_offsets, set grid[r0+dr][c0+dc] = 8.\n5. Return the modified grid.",
    "e681b708": "1. Let N = number of rows, M = number of columns in the input grid.\n2. Identify horizontal boundary rows H:\n   a. Initialize H = {0, N-1}.\n   b. For each row r from 0 to N-1, if count of cells grid[r][c] == 1 across c=0..M-1 is > M/2, add r to H.\n   c. Sort H in ascending order.\n3. Identify vertical boundary columns V:\n   a. Initialize V = {0, M-1}.\n   b. For each column c from 0 to M-1, if count of cells grid[r][c] == 1 across r=0..N-1 is > N/2, add c to V.\n   c. Sort V in ascending order.\n4. For each pair of consecutive rows (r_top, r_bottom) in H and each pair of consecutive columns (c_left, c_right) in V, define a subgrid:\n   a. Determine fill_color = grid[r_top][c_right].\n   b. For every cell (r,c) with r_top < r < r_bottom and c_left < c < c_right:\n      i. If grid[r][c] == 1, set grid[r][c] = fill_color.\n5. Leave all other cells unchanged. Return the modified grid as the output.",
    "505fff84": "1. Let the input be a 2D array G of size H×W, indexed by row r in [0,H) and column c in [0,W).\n2. Initialize an empty list of rows O.\n3. For each row index r from 0 to H–1 do:\n   a. Let row = G[r].\n   b. If row contains at least one cell with value 1 and at least one cell with value 8 then:\n      i. Let c1 be the smallest column index c where row[c] == 1.\n      ii. Let c8 be the smallest column index c > c1 where row[c] == 8.\n      iii. Extract the sequence S of values row[c] for c from c1+1 to c8-1 inclusive.\n      iv. Append S as a new row at the end of O.\n4. Construct the output grid as the array whose rows are the sequences in O, in the same order they were appended.\n5. Return this output grid.",
    "e69241bd": "1. Define: empty pixels have value 0; barrier pixels have value 5; seed (colored) pixels have any other value (1–4,6–9). Use orthogonal adjacency (up, down, left, right).\n2. Create an output grid initialized as a copy of the input grid. Create a boolean visited array of same dimensions, all set to false.\n3. For each cell (r,c) in the grid, do:\n   a. If visited[r][c] is true or input[r][c]==5 (barrier), skip.\n   b. Otherwise, start a flood-fill component:\n      i. Initialize an empty list component_positions and an empty set component_colors.\n      ii. Initialize a stack with (r,c); mark visited[r][c]=true.\n      iii. While the stack is not empty:\n           • Pop (i,j) from the stack.\n           • Add (i,j) to component_positions.\n           • If input[i][j]≠0, add input[i][j] to component_colors.\n           • For each orthogonal neighbor (ni,nj) of (i,j):\n               – If (ni,nj) is within grid bounds AND visited[ni][nj] is false AND input[ni][nj]≠5, then push (ni,nj) onto the stack and set visited[ni][nj]=true.\n      iv. After flood fill, component_colors must contain exactly one value c (the seed color for this component).\n   c. For each (i,j) in component_positions: if output[i][j]==0, set output[i][j]=c.\n4. After processing all cells, return the output grid.",
    "506d28a5": "1. Scan the input grid to locate the divider row index D where every cell in row D has value 4.  \n2. Let H = D (the number of rows above the divider) and W = number of columns in the grid.  \n3. Create an output grid of size H × W.  Initialize every cell in this output grid to 3.  \n4. For each row r from 0 to H–1 and each column c from 0 to W–1, do the following:  \n   a. Let top_val = input[r][c].  \n   b. Let bottom_val = input[D + 1 + r][c].  \n   c. If top_val == 0 AND bottom_val == 0, then set output[r][c] = 0.  \n5. Return the output grid.",
    "e6de6e8f": "1. Parse the input grid of size 2 rows × 12 columns, values in {0,2}.  \n2. Compute the sequence S of all column indices c (0 ≤ c < 12) in increasing order such that input[0][c] == 2 or input[1][c] == 2.  \n3. Create an output grid of size 8 rows × 7 columns, initialize every cell to 0.  \n4. Let current_col = 3.  \n5. Set output[0][current_col] = 3.  \n6. For each k from 1 to 7 (inclusive):  \n   a. Let c = S[k].  \n   b. Determine move_type:  \n      - If input[0][c] == 2 and input[1][c] == 2, then move_type = \"straight\".  \n      - Else if input[0][c] == 2, then move_type = \"right\".  \n      - Else (input[1][c] == 2), move_type = \"left\".  \n   c. Compute new_col:  \n      - If move_type == \"right\", new_col = current_col + 1.  \n      - If move_type == \"left\",  new_col = current_col - 1.  \n      - If move_type == \"straight\", new_col = current_col.  \n   d. On output row k, mark pixels of color 2:  \n      - If move_type is \"straight\": set output[k][new_col] = 2.  \n      - If move_type is \"right\" or \"left\": set both output[k][current_col] = 2 and output[k][new_col] = 2.  \n   e. Update current_col = new_col.  \n7. Return the output grid of size 8×7.",
    "50a16a69": "1. Let M = number of rows, N = number of columns in input grid.\n2. Let c_border = value at cell (M, N).\n3. Compute P_h = maximum row index r (1 ≤ r ≤ M) such that there exists c in 1..N with grid[r][c] ≠ c_border.\n4. Compute P_w = maximum column index c (1 ≤ c ≤ N) such that there exists r in 1..M with grid[r][c] ≠ c_border.\n5. Extract the pattern region R of size P_h × P_w: R[i][j] = grid[i][j] for 1 ≤ i ≤ P_h, 1 ≤ j ≤ P_w.\n6. Let C = list of distinct values in R in order of first appearance scanning rows 1..P_h, cols 1..P_w. Let k = length of C.\n7. Build a k×k tile T as follows:\n   For i from 1 to k:\n     For j from 1 to k:\n       Let j2 = (j mod k) + 1\n       Set T[i][j] = R[i][j2]\n8. Initialize an output grid of size M × N.\n9. For each output cell (r, c) with 1 ≤ r ≤ M and 1 ≤ c ≤ N:\n   Let i = ((r-1) mod k) + 1\n   Let j = ((c-1) mod k) + 1\n   Set output[r][c] = T[i][j]\n10. Return the output grid.",
    "e74e1818": "1. Let original be the input grid of size R rows by C columns with integer values 0–9.  2. Create output as a copy of original.  3. Let colors be the set of all values X>0 present in original.  4. For each X in colors do:   a. Collect all coordinates (r,c) where original[r][c]==X.   b. Compute r_min = minimum r, r_max = maximum r, c_min = minimum c, c_max = maximum c over those coordinates.   c. For each r in the inclusive range [r_min…r_max] and each c in [c_min…c_max] do:      i. Compute r_mirror = r_min + r_max - r.      ii. If original[r_mirror][c] == X then set output[r][c] = X; else set output[r][c] = 0. 5. After processing all X, return output.",
    "50aad11f": "1. Read input grid of size H×W (rows 0…H−1, columns 0…W−1).\n2. Identify the shape pixel value S as the nonzero integer whose 4‐connected component size exceeds 1. Extract all 4‐connected components of pixels with value S.\n3. For each component:\n   a. Compute its bounding box: r0 = min row, r1 = max row, c0 = min column, c1 = max column over all pixels in the component.\n   b. Locate the unique adjacent block pixel: find the single pixel of value C ≠0 and C ≠S that is 4‐adjacent to any pixel of the component. Record its value C and remove it from the grid.\n   c. Remove all S‐pixels of the component from the grid.\n   d. Build a pattern of size (r1−r0+1)×(c1−c0+1): initialize all cells to 0, then for each original component pixel at (r,c) set pattern[r−r0][c−c0]=C.\n   e. Store for this component its pattern, its r0 and its c0 and its pattern height h = r1−r0+1 and width w = c1−c0+1.\n4. Determine output orientation:\n   If H>W (portrait), set ORIENT=“vertical”; else ORIENT=“horizontal”.\n5. Sort the stored components in ascending order of r0 if ORIENT=“vertical”, or ascending order of c0 if ORIENT=“horizontal”.\n6. If ORIENT==“vertical”:\n   a. Compute targetWidth = max over all components of their pattern width w.\n   b. For each sorted component:\n      i. Compute padLeft = targetWidth − w.\n      ii. For each row of its pattern, create a padded row: [0 repeated padLeft times] + original pattern row.\n   c. Build the output grid by stacking all padded patterns in sorted order: place the first at rows 0…h0−1, the next immediately below, and so on.\n7. If ORIENT==“horizontal”:\n   a. Compute targetHeight = max over all components of their pattern height h.\n   b. For each sorted component:\n      i. Compute padTop = targetHeight − h.\n      ii. Create a padded pattern of size targetHeight×w by prepending padTop rows of zeros above its original pattern rows.\n   c. Build the output grid by concatenating all padded patterns side by side: for each row i from 0 to targetHeight−1, the output row is the concatenation of row i of each padded pattern in sorted order.\n8. Return the assembled output grid.",
    "e760a62e": "1. Identify separator lines: rows where every cell equals 8 and columns where every cell equals 8.\n2. Define row groups: the intervals of consecutive row indices between separator rows. Number these row groups from 0 (topmost) to N–1 (bottommost).\n3. Define column groups: the intervals of consecutive column indices between separator columns. Number these column groups from 0 (leftmost) to M–1 (rightmost).\n4. For each non-separator input cell at (r,c) with value v not in {0,6,8}, record its rowGroup rg and colGroup cg.  Build for each color v two sets:\n   a. RG_v = set of all rg where v appears.\n   b. CG_v = set of all cg where v appears.\n5. Initialize an empty map fillBlocks: color → set of (rg,cg) pairs.\n6. For each color v in the recorded colors:\n   a. For each rg in RG_v:\n      i. Let CGs_rg = {cg | a recorded cell of color v has rowGroup=rg and colGroup=cg}.\n      ii. Let min_cg = minimum of CGs_rg; max_cg = maximum.\n      iii. For cg from min_cg to max_cg inclusive, add (rg,cg) to fillBlocks[v].\n   b. For each cg in CG_v:\n      i. Let RGs_cg = {rg | a recorded cell of color v has colGroup=cg and rowGroup=rg}.\n      ii. Let min_rg = minimum of RGs_cg; max_rg = maximum.\n      iii. For rg from min_rg to max_rg inclusive, add (rg,cg) to fillBlocks[v].\n7. Initialize the output grid equal to the input grid.\n8. For each color v and for each block coordinate (rg,cg) in fillBlocks[v]:\n   a. For each row r in that row group rg and each column c in that column group cg:\n      i. If input[r][c] == 8, skip (leave as 8).\n      ii. Else if output[r][c] is still 0, set output[r][c] = v.\n      iii. Else if output[r][c] ≠ v and output[r][c] ≠ 8, set output[r][c] = 6.\n9. Return the output grid.",
    "50f325b5": "1. Let shapeColor = 8 and targetColor = 3.\n2. Scan the entire grid and collect all coordinates (r,c) where grid[r][c] == shapeColor; call this set S.\n3. Compute minR = minimum r in S, maxR = maximum r in S, minC = minimum c in S, maxC = maximum c in S.\n4. Let H = maxR - minR + 1 and W = maxC - minC + 1.\n5. Compute shapeOffsets = set of pairs (dr,dc) for each (r,c) in S, where dr = r - minR and dc = c - minC.\n6. For each possible placement of the H×W bounding box with its top-left at (i,j), where i ranges from 0 to (numRows - H) and j ranges from 0 to (numCols - W):\n   a. If for every (dr,dc) in shapeOffsets, grid[i+dr][j+dc] == targetColor, then:\n      i. For each (dr,dc) in shapeOffsets, set grid[i+dr][j+dc] = shapeColor.\n7. Return the modified grid.",
    "e7639916": "1. Identify all coordinates (r, c) in the input grid whose value is 8 (light blue).\n2. Compute r_min = minimum r among these coordinates, r_max = maximum r, c_min = minimum c, c_max = maximum c.\n3. For each column c in the inclusive range [c_min, c_max]:\n     a. If the cell at (r_min, c) is not 8, set its value to 1 (dark blue).\n     b. If the cell at (r_max, c) is not 8, set its value to 1.\n4. For each row r in the inclusive range [r_min, r_max]:\n     a. If the cell at (r, c_min) is not 8, set its value to 1.\n     b. If the cell at (r, c_max) is not 8, set its value to 1.\n5. Leave all other cells unchanged, preserving original 0 and 8 values. The result is the original grid with a dark blue rectangular border connecting the three light blue cells.",
    "516b51b7": "1. Identify all connected components of pixels with value 1 using 4-connectivity. 2. For each component:  \n   a. Compute minRow = minimum row index of its pixels, maxRow = maximum row index, minCol = minimum column index, maxCol = maximum column index.  \n   b. Compute height H = maxRow - minRow + 1 and width W = maxCol - minCol + 1.  \n   c. Compute maxLayer = floor((min(H, W) - 1) / 2).  \n3. For each layer d from 1 to maxLayer:  \n   a. Set fillColor = 2 if d is odd, else fillColor = 3.  \n   b. For each cell (r, c) with r in [minRow + d, maxRow - d] and c in [minCol + d, maxCol - d], if r == minRow + d or r == maxRow - d or c == minCol + d or c == maxCol - d, then set grid[r][c] = fillColor.  \n4. Leave all pixels originally equal to 1 unchanged (they form the outermost border).  \n5. After processing all layers for all components, return the modified grid.",
    "e78887d1": "1. Scan the input grid row by row to find all rows where every cell equals 0. 2. Partition the grid into blocks of three consecutive non-zero rows separated by these all-zero rows. 3. Select the bottommost block of three rows; call its row indices R,R+1,R+2. 4. In these three rows, mark every column C where grid[R][C]=grid[R+1][C]=grid[R+2][C]=0 as a column separator. 5. Identify each contiguous group of non-separator columns; there will be K such groups, each exactly 3 columns wide. Number them left to right i=0…K-1 and record for each group i its start column S_i. 6. For each group i:  a. Extract its 3×3 subgrid at rows R…R+2 and columns S_i…S_i+2.  b. Define mask p_i[dr][dc]=1 if that cell ≠0, else 0 (dr,dc in 0..2).  c. Let c_i be the nonzero integer value appearing in that subgrid. 7. Create an output grid of 3 rows and the same width as the input; initialize all cells to 0. 8. For each i from 0 to K-1:  a. Let j=(i+1) mod K.  b. For dr in 0..2 and dc in 0..2:    If p_j[dr][dc]=1 then set output[dr][S_i+dc]=c_i. 9. Return the 3×W output grid (rows corresponding to dr=0,1,2).",
    "5207a7b5": "1. Let R = number of rows, C = number of columns in the grid.\n2. Identify all cells with value 5. Confirm they share a single column index g. Let H = count of these value-5 cells.\n3. For each integer d starting at 1 and while g - d >= 0:\n   a. Compute h_left = H + 2*d.\n   b. For each row r from 0 to min(h_left - 1, R - 1), set cell (r, g - d) = 8.\n4. For each integer d starting at 1 and while g + d < C:\n   a. Compute h_right = H - 2*d.\n   b. If h_right <= 0, break this loop.\n   c. For each row r from 0 to min(h_right - 1, R - 1), set cell (r, g + d) = 6.\n5. Leave all other cells unchanged.",
    "e7a25a18": "1. Identify the border color c_border: among all non-zero values in the input grid, select the value that occurs most frequently.  \n2. Find the bounding box of the border: scan all cells equal to c_border and record min_row, max_row, min_col, max_col.  \n3. Compute side_length = max_row - min_row + 1.  Assert side_length == max_col - min_col + 1.  \n4. Compute interior_size = side_length - 2.  \n5. Compute split = interior_size / 2 (an integer).  \n6. Compute the four quadrant color values by examining the input interior (rows min_row+1 to max_row-1, cols min_col+1 to max_col-1):  \n   6.1 Let r_mid = min_row + 1 + split, c_mid = min_col + 1 + split.  \n   6.2 c_tl = any non-zero cell value at input[row < r_mid, col < c_mid].  \n   6.3 c_tr = any non-zero cell value at input[row < r_mid, col >= c_mid].  \n   6.4 c_bl = any non-zero cell value at input[row >= r_mid, col < c_mid].  \n   6.5 c_br = any non-zero cell value at input[row >= r_mid, col >= c_mid].  \n7. Create an output grid of size side_length × side_length, initialized with zeros.  \n8. Draw the border in the output: set every cell in row 0, row side_length-1, col 0, and col side_length-1 to c_border.  \n9. Fill the interior quadrants in the output:  \n   For i in {0,1} and j in {0,1}:  \n     9.1 Let c_q = {c_tl, c_tr; c_bl, c_br}[i][j].  \n     9.2 For dr from 0 to split-1 and dc from 0 to split-1:  \n       output[1 + i*split + dr][1 + j*split + dc] = c_q.  \n10. Return the output grid.",
    "5289ad53": "1. Let H and W be the height and width of the input grid. 2. Initialize two counters g = 0 and r = 0. 3. For each row index i from 0 to H-1:  a. If any cell in row i has value 3, increment g by 1 (count of green rows).  b. If any cell in row i has value 2, increment r by 1 (count of red rows). 4. Create an output grid of size 2 rows and 3 columns, initially unfilled. 5. Initialize an integer k = 0 to represent the next cell in row-major order (k=0 is (0,0), k=1 is (0,1), …, k=5 is (1,2)). 6. Repeat g times:  a. Let row = k // 3 and col = k % 3.  b. Set output[row][col] = 3.  c. Increment k by 1. 7. Repeat r times:  a. Let row = k // 3 and col = k % 3.  b. Set output[row][col] = 2.  c. Increment k by 1. 8. While k < 6:  a. Let row = k // 3 and col = k % 3.  b. Set output[row][col] = 0.  c. Increment k by 1. 9. Return the output grid.",
    "e7b06bea": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Compute the grey block count N:\n   a. Initialize N = 0.\n   b. While N < H and input[N][0] == 5, increment N by 1.\n3. Identify the color columns:\n   a. Initialize an empty list color_cols.\n   b. For each column c from 0 to W-1, if there exists any row r in 0..H-1 with input[r][c] not equal to 0 and not equal to 5, then append c to color_cols.\n   c. Sort color_cols in ascending order.\n4. Let M be the length of color_cols.\n5. Build the color sequence of length M:\n   For i from 0 to M-1:\n     a. Let c = color_cols[i].\n     b. Find any row r in 0..H-1 such that input[r][c] not in {0,5}.\n     c. Set color_sequence[i] = input[r][c].\n6. Compute the target column for the new pattern: target_col = W - M - 1.\n7. Initialize the output grid of size H×W with all cells = 0.\n8. Copy the grey blocks:\n   For r from 0 to N-1, set output[r][0] = 5.\n9. Fill the repeating vertical color pattern in column target_col:\n   For each row r from 0 to H-1:\n     a. Compute block_index = floor(r / N).\n     b. Compute seq_index = block_index mod M.\n     c. Set output[r][target_col] = color_sequence[seq_index].",
    "52fd389e": "1. Let target_color = 4. 2. Find each connected region of pixels equal to target_color. 3. For each region, compute its minimal bounding rectangle: top = minimum row, bottom = maximum row, left = minimum column, right = maximum column over all pixels in the region. 4. Inside that rectangle (rows top..bottom, columns left..right), scan in row-major order. Whenever you find a cell with value neither target_color nor 0, if this is the first such cell record dot_color = that value. Continue scanning to count all cells within the rectangle whose value equals dot_color; call that count thickness. 5. Compute expanded bounds: new_top = top - thickness, new_bottom = bottom + thickness, new_left = left - thickness, new_right = right + thickness. 6. Create the border: for every cell (r,c) with new_top ≤ r ≤ new_bottom and new_left ≤ c ≤ new_right, if r < top or r > bottom or c < left or c > right, set output[r][c] = dot_color. 7. For all other cells (inside the original rectangle or outside the expanded bounds), copy the original grid value to the output unchanged.",
    "e7dd8335": "1. Scan the entire grid and collect all coordinates (r,c) such that grid[r][c] == 1.\n2. Let minRow = the smallest r in that collection and maxRow = the largest r.\n3. Compute height = maxRow - minRow + 1.\n4. Compute halfHeight = (height + 1) // 2  // integer division yields ceiling(height/2).\n5. Compute thresholdRow = maxRow - halfHeight + 1.\n6. For each coordinate (r,c) with grid[r][c] == 1 and r >= thresholdRow, set grid[r][c] = 2.\n7. Leave all other cells unchanged.",
    "54db823b": "1. Let grid be the input matrix of integers 0–9 with R rows and C columns. 2. Define a shape as a connected component of cells where each cell’s value is either 3 or 9, and connectivity is 4-directional (up, down, left, right). 3. Initialize an empty list shapes. 4. Initialize a boolean matrix visited of size R×C, all false. 5. For each cell (r, c):\n   a. If visited[r][c] is false and grid[r][c] is 3 or 9, perform a flood fill starting at (r, c) to collect all coordinates of the component. During flood fill, mark visited for 4-neighbors that have value 3 or 9.   \n   b. After flood fill, record this component as one shape: store its list of coordinates and compute red_count = the number of coordinates in the shape where grid value is 9. Append (coordinates, red_count) to shapes. 6. From shapes, select the shape S_min whose red_count is strictly less than every other shape’s red_count. 7. For each coordinate (r, c) in S_min, set grid[r][c] = 0. 8. Return the modified grid as output.",
    "e872b94a": "1. Let G be the input grid of size R rows and C columns. 2. Define 4-connectivity: two cells (r,c) and (r',c') are adjacent if |r–r'|+|c–c'|=1. 3. Collect all cells where G[r][c]==5. 4. Use flood-fill (BFS or DFS) on these cells under 4-connectivity to identify maximal connected components of value 5. 5. Let k = the number of connected components found. 6. Compute H = k + 1. 7. Create an output grid of H rows and 1 column. 8. For each row i from 0 to H–1, set output[i][0] = 0. 9. Return the output grid.",
    "55059096": "1. Locate all plus shapes: for each cell (r,c) with value 3, if its four orthogonal neighbors (r-1,c), (r+1,c), (r,c-1), (r,c+1) also have value 3, record (r,c) as a plus center.\n2. For each plus center (r,c), compute its four diagonal corner positions:\n   • top-left = (r-1, c-1)\n   • top-right = (r-1, c+1)\n   • bottom-left = (r+1, c-1)\n   • bottom-right = (r+1, c+1)\n3. For each ordered pair of distinct centers A and B:\n   a. If B.r > A.r and B.c > A.c, let start = A.bottom-right and end = B.top-left.\n   b. Else if B.r > A.r and B.c < A.c, let start = A.bottom-left and end = B.top-right.\n   c. Otherwise, skip this pair.\n4. For each chosen start and end:\n   a. Check that Δr = end.r – start.r and Δc = end.c – start.c satisfy |Δr| == |Δc| > 0.\n   b. Verify that every cell on the diagonal from start to end (inclusive) in the input grid has value 0.\n   c. If so, set every such diagonal cell in the output grid to value 2.\n5. In the output grid, preserve all original input values (0 and 3) and overlay the new 2s so that plus shapes remain unchanged except where filled by step 4.c.\n6. Return the resulting grid.",
    "e88171ec": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. For each cell at coordinates (r, c) with 0 ≤ r < H and 0 ≤ c < W, do:\n   a. If the cell value at (r, c) equals 0 and r > 0 and r < H-1 and c > 0 and c < W-1,\n   b. And the four orthogonal neighbors at (r-1, c), (r+1, c), (r, c-1) and (r, c+1) each also equal 0,\n   c. Then set the output cell at (r, c) to 8.\n   d. Otherwise, set the output cell at (r, c) to its original input value.\n3. Return the resulting grid as the output.",
    "551d5bf1": "1. Locate each connected component of cells with value 1.  \n2. For each component, compute its bounding box: let min_row = minimum row, max_row = maximum row, min_col = minimum column, max_col = maximum column among its cells.  \n3. Treat that bounding box as the intended rectangle outline.  \n4. Fill the interior: for every cell (r,c) with min_row < r < max_row and min_col < c < max_col, set value = 8.  \n5. Identify gap cells on the perimeter: for each cell (r,c) on the perimeter of the bounding box (i.e., r == min_row or r == max_row or c == min_col or c == max_col) where the original grid value ≠ 1, record (r,c) as a gap.  \n6. For each gap cell (r_gap,c_gap):  \n   a. Determine the extension direction (dr,dc):  \n      - If r_gap == min_row, set dr = -1, dc = 0.  \n      - Else if r_gap == max_row, set dr = +1, dc = 0.  \n      - Else if c_gap == min_col, set dr = 0, dc = -1.  \n      - Else if c_gap == max_col, set dr = 0, dc = +1.  \n   b. Starting at (r_gap,c_gap), and repeating for k = 0,1,2,... while the position (r_gap + k*dr, c_gap + k*dc) remains within grid bounds, set that cell’s value = 8.  \n7. After processing all components, leave all other cells unchanged.",
    "e95e3d8e": "1. Let R be the number of rows and C the number of columns of the input grid.\n2. Initialize an empty output grid of same size.\n3. For each row index r from 0 to R-1, do:\n   a. Let I = {c | input[r][c] != 0} be the set of column indices in row r where the cell is non-zero.\n   b. Find the smallest period L (1 ≤ L ≤ C) such that for every pair of indices c1, c2 in I, if (c1 - c2) mod L = 0 then input[r][c1] = input[r][c2].\n   c. Build a base pattern P of length L: for each j in 0..L-1, if there exists c in I with c mod L = j then set P[j] = input[r][c]; otherwise leave P[j] undefined.\n   d. For each column c from 0 to C-1:\n      i. If input[r][c] ≠ 0, set output[r][c] = input[r][c].\n     ii. Else (input[r][c] = 0), set output[r][c] = P[c mod L].\n4. Return the fully filled output grid.",
    "55783887": "1. Let G be the input grid of size R×C. Let B be the background color: the integer that occurs most frequently in G. 2. Find all non-B colors in G and their positions. 3. Identify C_conn: a non-B color for which there exist exactly two positions p1=(r1,c1) and p2=(r2,c2) with |r2–r1|=|c2–c1|. 4. Compute dr_conn = sign(r2–r1), dc_conn = sign(c2–c1). 5. Make the output grid O a copy of G. 6. For k from 0 to |r2–r1|: let r = r1 + dr_conn*k, c = c1 + dc_conn*k. If G[r][c] == B, set O[r][c] = C_conn. 7. Identify C_int: any non-B, non-C_conn color in G. 8. For each position q = (rq,cq) where G[rq][cq] == C_int and q lies on the line from p1 to p2 (i.e. rq = r1 + dr_conn*k and cq = c1 + dc_conn*k for some k):  8.1. Compute dr_perp = –dc_conn, dc_perp = dr_conn.  8.2. For each sign s in {+1, –1}:    a. For t = 1,2,… until out of grid:       i. r = rq + s*dr_perp*t, c = cq + s*dc_perp*t.       ii. If (r,c) is outside [0..R–1]×[0..C–1], break this loop.       iii. If G[r][c] == B, set O[r][c] = C_int; otherwise skip (do not overwrite). 9. Return O as the transformed grid.",
    "e99362f0": "1. Let R be the number of rows and C be the number of columns in the input grid.\n2. Find the unique row index row4 such that every cell in that row equals 4. Find the unique column index col4 such that every cell in that column equals 4.\n3. Let H = row4 and W = col4.\n4. Compute h = R - H - 1 and w = C - W - 1.\n5. Define four quadrants of size h × w:\n   • Q1 (top-left): cells at input[r][c] for r in [0..H-1], c in [0..W-1].\n   • Q2 (top-right): cells at input[r][c] for r in [0..H-1], c in [W+1..C-1].\n   • Q3 (bottom-left): cells at input[r][c] for r in [H+1..R-1], c in [0..W-1].\n   • Q4 (bottom-right): cells at input[r][c] for r in [H+1..R-1], c in [W+1..C-1].\n6. Define a priority list P = [8,7,9,2,0], where 8 has highest priority and 0 lowest.\n7. Create an output grid out of size h rows and w columns.\n8. For each local row r from 0 to h-1 and each local column c from 0 to w-1:\n   a. Let v1 = input[r][c]                   (Q1 at (r,c)).\n   b. Let v2 = input[r][c + W + 1]           (Q2 at (r,c)).\n   c. Let v3 = input[r + H + 1][c]           (Q3 at (r,c)).\n   d. Let v4 = input[r + H + 1][c + W + 1]   (Q4 at (r,c)).\n   e. Form V = [v1, v2, v3, v4].\n   f. For each p in P in order, if p is in V, set out[r][c] = p and break.\n9. Return the output grid out.",
    "575b1a71": "1. Scan the input grid and collect the set of all column indices C where at least one cell has value 0. 2. Sort the list of column indices C in ascending order. 3. For each index i in 0..|C|-1, let column c = C[i] and assign color value (i+1) to column c. 4. Create the output grid as a copy of the input grid. 5. For each cell at row r and column c in the input grid: if input[r][c] == 0 then set output[r][c] = (i+1) according to the mapping for column c; otherwise leave output[r][c] unchanged. 6. Return the output grid.",
    "e9ac8c9e": "1. Scan the input grid and identify each connected component of cells with value 5. Treat connectivity as orthogonal (up, down, left, right).\n2. For each connected component of value-5 cells:\n   a. Compute r0 = minimum row index, r1 = maximum row index, c0 = minimum column index, c1 = maximum column index of the component.\n   b. Compute S = r1 - r0 + 1 and verify S == c1 - c0 + 1 and S is even. Compute h = S / 2.\n   c. Read and store the four marker values from the original grid:\n      • TL = grid[r0 - 1][c0 - 1]\n      • TR = grid[r0 - 1][c1 + 1]\n      • BL = grid[r1 + 1][c0 - 1]\n      • BR = grid[r1 + 1][c1 + 1]\n   d. Record the tuple (r0, r1, c0, c1, h, TL, TR, BL, BR).\n3. Set every cell in the grid to 0.\n4. For each recorded tuple (r0, r1, c0, c1, h, TL, TR, BL, BR), fill four quadrants inside the square [r0..r1] × [c0..c1]:\n   a. For rows r = r0 to r0 + h - 1 and columns c = c0 to c0 + h - 1, set grid[r][c] = TL.\n   b. For rows r = r0 to r0 + h - 1 and columns c = c0 + h to c1, set grid[r][c] = TR.\n   c. For rows r = r0 + h to r1 and columns c = c0 to c0 + h - 1, set grid[r][c] = BL.\n   d. For rows r = r0 + h to r1 and columns c = c0 + h to c1, set grid[r][c] = BR.",
    "5783df64": "1. Let H be the number of rows and W be the number of columns of the input grid.  Assume H is divisible by 3. 2. Compute band_size = H / 3. 3. Initialize an empty 3×3 output grid. 4. For each band index b from 0 to 2:   a. Let start_row = b * band_size and end_row = (b + 1) * band_size - 1.   b. Initialize an empty list L.   c. For each row r from start_row to end_row and each column c from 0 to W - 1:      i. If input[r][c] ≠ 0, append the tuple (r, c, input[r][c]) to L.   d. Sort L in ascending order by the column coordinate c.   e. For j from 0 to 2, set output[b][j] = L[j].value  (the third element of the j-th tuple in L). 5. Return the 3×3 output grid.",
    "e9b4f6fc": "1. Locate the target rectangular frame:\n   a. For each color v in 1..9, collect all coordinates (R,C) where grid[R][C]==v.\n   b. Compute Rmin=min(R), Rmax=max(R), Cmin=min(C), Cmax=max(C).\n   c. If Rmax−Rmin≥2 and Cmax−Cmin≥2 and every cell on the perimeter of the box defined by Rmin..Rmax and Cmin..Cmax holds value v, then set border_color=v and record frame_rows=Rmin..Rmax and frame_cols=Cmin..Cmax.\n2. Extract color‐swap pairs from black background:\n   a. Initialize empty bidirectional map M.\n   b. For each cell (R,C) with C+1 within grid width:\n      i. If grid[R][C]≠0 and grid[R][C+1]≠0 and not (R in frame_rows and C≥Cmin and C+1≤Cmax):\n         • Let a=grid[R][C], b=grid[R][C+1].\n         • Set M[a]=b and M[b]=a.\n3. Build the output subgrid:\n   a. Let H=Rmax−Rmin+1, W=Cmax−Cmin+1.\n   b. Initialize output[0..H−1][0..W−1].\n   c. For each r_out in 0..H−1 and c_out in 0..W−1:\n      i. Let R=Rmin+r_out, C=Cmin+c_out, orig=grid[R][C].\n      ii. If orig==border_color then out=border_color else out=M[orig].\n      iii. Set output[r_out][c_out]=out.\n4. Return the output subgrid of size H×W.",
    "5833af48": "1. Locate the three subgrids in the input:   \n   a. Pattern region: the smallest rectangular block of non-zero cells in the top‐left (until a full row or column of zeros).   \n   b. Marker region: the rectangular block of non-zero cells in the top, to the right of the first all-zero columns, sharing the same row extent as the pattern region.   \n   c. Base region: the rectangular block of non-zero cells below both top regions, bounded above by the first full-zero row after the markers.  \n2. Record their coordinates:   \n   – Let (r_p0,c_p0) be the top-left of the pattern region, of size H×W.   \n   – Let (r_m0,c_m0) be the top-left of the marker region, of size H×K.   \n   – Let (r_b0,c_b0) be the top-left of the base region.  \n3. Identify colors:   \n   a. Base color X = the single integer value filling the base region.   \n   b. Fill color Y = the integer ≠X that appears in both the pattern region and the marker region.  \n4. Build pattern mask M of size H×W:   \n   For each (i,j) in [0…H-1]×[0…W-1], include (i,j) in M if pattern_region[i,j]==Y.  \n5. Build marker positions list L:   \n   For each (i,j) in [0…H-1]×[0…K-1], include (i,j) in L if marker_region[i,j]==Y.  \n6. Initialize output_grid as a copy of the base region.  \n7. For each marker position (i_m,j_m) in L:   \n   a. Compute target origin in output: (r_b0 + i_m, c_b0 + j_m).   \n   b. For each (i_p,j_p) in M, set output_grid[r_b0 + i_m + i_p, c_b0 + j_m + j_p] = Y.  \n8. Return output_grid.",
    "e9bb6954": "1. Identify all 3×3 blocks (subgrids) in the input grid where every cell in the block has the same non-zero value v (pixel value 1–9). For each such block, record its color value v and compute its center coordinates:\n   • Let (r0,c0) be the row and column of the top-left cell of the block.  \n   • The center of the block is at (r_center, c_center) = (r0+1, c0+1).\n2. For each cell (r, c) in the grid, build a set S(r,c) of all block colors whose cross lines would cover that cell:\n   • For each recorded block with color v and center (r_center, c_center):\n     – If r = r_center or c = c_center, then add v to S(r,c).\n3. Construct the output grid cell by cell. For each position (r, c):\n   a. If |S(r,c)| > 1 (more than one distinct color in the set), set output(r,c) = 0.\n   b. Else if |S(r,c)| = 1 (exactly one color v), set output(r,c) = v.\n   c. Else (S(r,c) is empty), set output(r,c) = input(r,c).\n4. Leave all other input cells unchanged except where overridden by the above rules.\n\nNotes:\n- Pixel value 0 is background/black and never forms a block to extend.\n- Overlaps occur only when two or more different blocks’ lines meet; in that case the cell becomes 0.\n- A block’s own lines overlap at its center, but since both are the same color, that cell remains v.",
    "58743b76": "1. Let H = number of rows, W = number of columns in the grid.\n2. Identify border color B:\n   a. Collect all values on row 0, row H-1, col 0, and col W-1.\n   b. Let B be the value that occurs most frequently among these perimeter cells.\n3. Locate the 2×2 reference square on a corner:\n   a. If cells (0,0),(0,1),(1,0),(1,1) are all ≠ B, set r0=0, c0=0.\n   b. Else if cells (0,W-2),(0,W-1),(1,W-2),(1,W-1) are all ≠ B, set r0=0, c0=W-2.\n   c. Else if cells (H-2,0),(H-2,1),(H-1,0),(H-1,1) are all ≠ B, set r0=H-2, c0=0.\n   d. Else set r0=H-2, c0=W-2.\n   Record M[0][0]=grid[r0][c0], M[0][1]=grid[r0][c0+1], M[1][0]=grid[r0+1][c0], M[1][1]=grid[r0+1][c0+1].\n4. Identify inner background rectangle of value Y=0:\n   a. Let R = {r | ∃c: grid[r][c]=0}, C = {c | ∃r: grid[r][c]=0}.\n   b. Let r_min = min(R), r_max = max(R), c_min = min(C), c_max = max(C).\n   c. Assert N = r_max - r_min + 1 = c_max - c_min + 1 is even.\n5. Set half = N/2.\n6. For each cell (r,c) with r_min ≤ r ≤ r_max and c_min ≤ c ≤ c_max:\n   a. If grid[r][c] ≠ 0 then:\n      i. Compute dr = r - r_min, dc = c - c_min.\n      ii. Let qr = 0 if dr < half else 1; qc = 0 if dc < half else 1.\n      iii. Replace grid[r][c] ← M[qr][qc].\n7. Return the modified grid.",
    "e9c9d9a1": "1. Identify all horizontal separator rows: find every row index r such that for all columns c, grid[r][c] == 3. Sort these indices into list H.\n2. Identify all vertical separator columns: find every column index c such that for all rows r, grid[r][c] == 3. Sort these indices into list V.\n3. Define row stripes: let R0 = [0 .. H[0]-1], and for each i from 0 to len(H)-2 let Ri+1 = [H[i]+1 .. H[i+1]-1], and Rlast = [H[-1]+1 .. height-1]. Label these stripes R[0], R[1], …, R[N-1] in order.\n4. Define column stripes: let C0 = [0 .. V[0]-1], and for each j from 0 to len(V)-2 let Cj+1 = [V[j]+1 .. V[j+1]-1], and Clast = [V[-1]+1 .. width-1]. Label these stripes C[0], C[1], …, C[M-1] in order.\n5. For each pair of stripe indices (i,j):\n   a. For each cell (r,c) with r in R[i] and c in C[j] and grid[r][c] == 0:\n      - If i==0 and j==0, set grid[r][c] = 2.\n      - Else if i==0 and j==M-1, set grid[r][c] = 4.\n      - Else if i==N-1 and j==0, set grid[r][c] = 1.\n      - Else if i==N-1 and j==M-1, set grid[r][c] = 8.\n      - Else if 0 < i < N-1 and 0 < j < M-1, set grid[r][c] = 7.\n6. Leave all other cells unchanged.",
    "58e15b12": "1. Scan the input grid to find the two non-zero colors (call them cA and cB), each of which appears in exactly two vertical bars.  \n2. For each color c in {cA, cB}:  \n   a. Find its two connected vertical bars.  For each bar, record:  \n      • column index col  \n      • top row r0  \n      • height H (bar spans rows r0..r0+H-1)  \n   b. Identify the left bar (smaller col) and the right bar (larger col).  \n   c. Define extension directions:  \n      • For the left bar, use directions NW = (dr,dc)=(-1,-1) and SW=(+1,-1).  \n      • For the right bar, use directions NE=(-1,+1) and SE=(+1,+1).  \n   d. For each of the two bars and for each of its two directions (dr,dc):  \n      For step s from 1 to H:  \n         i.  Compute new bar top row r_new = r0 + dr*s  \n         ii. Compute new bar column c_new = col + dc*s  \n         iii. Draw a vertical segment of color c from (r_new, c_new) down to (r_new+H-1, c_new), skipping any cells outside the grid.  \n3. After all copies and the original bars are drawn, scan the grid: wherever a cell has been assigned both cA and cB, overwrite it with 6 (pink).  \n4. Leave all other cells at their original values (0 or newly drawn).",
    "ea959feb": "1. Let G be the input grid with R rows and C columns. 2. Let corruption_value = 1. 3. Determine tile height H:\n   a. For each h in 1..R-1 compute score_h = sum over r=0..R-h-1 and c=0..C-1 of 1 if G[r,c]==G[r+h,c], else 0.\n   b. Set H to the smallest h with maximal score_h.\n4. Determine tile width W:\n   a. For each w in 1..C-1 compute score_w = sum over c=0..C-w-1 and r=0..R-1 of 1 if G[r,c]==G[r,c+w], else 0.\n   b. Set W to the smallest w with maximal score_w.\n5. Initialize an array tile of size H×W.\n6. For each i in 0..H-1 and j in 0..W-1:\n   a. Collect values L = [G[r,c] for all r in 0..R-1 and c in 0..C-1 if (r mod H)==i and (c mod W)==j and G[r,c]!=corruption_value].\n   b. Set tile[i,j] = the most frequent value in L.\n7. Initialize output grid Out of size R×C.\n8. For each r in 0..R-1 and c in 0..C-1:\n   a. Compute i = r mod H, j = c mod W.\n   b. Set Out[r,c] = tile[i,j].\n9. Return Out as the transformed grid.",
    "59341089": "1. Let the input grid P have height H=3 and width W=3.\n2. Create an empty output grid Q with height H and width 4×W = 12.\n3. For each row r from 0 to H−1:\n   a. For each block index b from 0 to 3:\n      i. If b mod 2 = 0, then for each column c from 0 to W−1 set Q[r][b×W + c] = P[r][W−1 − c].\n     ii. If b mod 2 = 1, then for each column c from 0 to W−1 set Q[r][b×W + c] = P[r][c].\n4. Return Q as the 3×12 output grid.",
    "ea9794b1": "1. Let N be the dimension of the input grid (N is even). 2. Let M = N/2. 3. Extract four M×M subgrids:\n   a. Q_TL: rows 0..M-1, cols 0..M-1\n   b. Q_TR: rows 0..M-1, cols M..N-1\n   c. Q_BL: rows M..N-1, cols 0..M-1\n   d. Q_BR: rows M..N-1, cols M..N-1\n4. Initialize an M×M output grid Y with all cells = 0.\n5. For each cell (i,j) with 0 ≤ i,j < M, perform in order:\n   a. If Q_TR[i][j] ≠ 0 and Y[i][j] = 0, set Y[i][j] = Q_TR[i][j].\n   b. If Q_BL[i][j] ≠ 0 and Y[i][j] = 0, set Y[i][j] = Q_BL[i][j].\n   c. If Q_BR[i][j] ≠ 0 and Y[i][j] = 0, set Y[i][j] = Q_BR[i][j].\n   d. If Q_TL[i][j] ≠ 0 and Y[i][j] = 0, set Y[i][j] = Q_TL[i][j].\n6. Return Y as the output grid.",
    "5a5a2103": "1. Identify the separator value S: scan each row; the first row where all cells are equal and non-zero is a horizontal separator row with value S. 2. Determine block height H: let R_sep be the index of the first separator row; then H = R_sep. 3. Identify separator columns: scan each column; any column where all cells equal S is a vertical separator. Let C_sep be the index of the first such column. 4. Determine block width W = C_sep. 5. Partition the grid into blocks of size H×W separated by rows and columns of value S. There are N_rows = (total_rows +1)/(H+1) and N_cols = (total_cols +1)/(W+1) blocks. 6. In each block at column 0 (blocks (i,0) for i in [0…N_rows-1]), there is a solid square: find c_i = the unique non-zero value in block (i,0). 7. Locate the source shape block: among all blocks with column ≥1, find the unique block B_src containing any non-zero cells. 8. Extract the shape mask M = {(dr,dc) | cell at row (r0*H + dr), col (c1*W + dc) in B_src is non-zero}, using 0≤dr<H, 0≤dc<W. 9. Initialize the output grid equal to the input grid. 10. For each block row i from 0 to N_rows-1 and each block column j from 0 to N_cols-1: for each (dr,dc) in M set output[(i*(H+1)+dr)][(j*(W+1)+dc)] = c_i. 11. Leave all separator rows and columns (cells equal to S) unchanged. All other cells are either overwritten by step 10 or remain zero.",
    "ecaa0ec1": "1. Locate the unique 3×3 block of pixels whose values are only 1 and 8. Record its top‐left corner at (r0,c0) and its center at (r0+1,c0+1).  \n2. Find all pixels of value 4. Among them, identify the one at exactly one of these four positions:  \n   • NW = (r0-1,c0-1)  \n   • NE = (r0-1,c0+3)  \n   • SW = (r0+3,c0-1)  \n   • SE = (r0+3,c0+3)  \n   Call this the attached yellow; record its diagonal D_init∈{NE,NW,SW,SE}. Label the other value-4 pixels as remote yellows.  \n3. For each remote yellow at (r,c), compute dr = r – (r0+1), dc = c – (c0+1). Sum dr over all remote yellows to total_dr, and sum dc to total_dc.  \n4. Determine the target diagonal D_target:  \n   if total_dr<0 and total_dc<0 → NW;  \n   if total_dr<0 and total_dc>0 → NE;  \n   if total_dr>0 and total_dc<0 → SW;  \n   if total_dr>0 and total_dc>0 → SE.  \n5. Order diagonals in CCW sequence [NE(0),NW(1),SW(2),SE(3)]. Let i_init,index of D_init; i_tgt,index of D_target.  \n6. Compute Δ = (i_tgt – i_init) mod 4. If Δ>2 then Δ = Δ – 4.  \n   • If Δ>0: rotate CCW by |Δ|×90°; if Δ<0: rotate CW by |Δ|×90°.  \n7. Extract the 3×3 submatrix M of values 1 and 8 at rows r0..r0+2, cols c0..c0+2.  \n8. Rotate M by the rotation determined in step 6 to produce M′.  \n9. Compute the new diagonal D_new by moving Δ steps (CCW if Δ>0, CW if Δ<0) from D_init along [NE→NW→SW→SE→NE]. Map D_new to coordinates:  \n   NW=(r0-1,c0-1), NE=(r0-1,c0+3), SW=(r0+3,c0-1), SE=(r0+3,c0+3).  \n10. Set every cell of the grid to 0.  \n11. Write M′ back into rows r0..r0+2, cols c0..c0+2.  \n12. Place a single pixel value 4 at the coordinate for D_new.",
    "5af49b42": "1. Let h = number of rows and w = number of columns in the grid.\n2. Identify all pattern bars in the first and last rows:\n   a. Initialize an empty list Patterns.\n   b. For each of the two rows rowIdx in {0, h-1}:\n      i. Scan columns c from 0 to w-1. Whenever you find the start of a contiguous non-zero segment (grid[rowIdx][c] ≠ 0 and either c=0 or grid[rowIdx][c-1]=0), let start = c.\n     ii. Continue c++ until you reach c2 where c2 = w or grid[rowIdx][c2]=0. The segment is from start to c2-1.\n    iii. If the segment length L = c2 - start is ≥ 2, record a pattern with:\n         • values = [grid[rowIdx][start], grid[rowIdx][start+1], …, grid[rowIdx][start+L-1]]\n         • length = L.\n         Add this pattern to Patterns.\n3. For each cell (r, c) with 0 < r < h-1 and grid[r][c] ≠ 0 (each singleton):\n   a. Let v = grid[r][c].\n   b. Find the unique pattern P in Patterns whose values array contains v exactly once. Let idx be the index in P.values where P.values[idx] = v.\n   c. For each i from 0 to P.length-1:\n      i. Compute targetCol = c + (i - idx).\n     ii. If 0 ≤ targetCol < w, set grid[r][targetCol] = P.values[i].\n4. Return the modified grid as the output.",
    "ed74f2f2": "1. Let G be the 5×9 input grid with 0-based indexing (rows 0–4, cols 0–8).\n2. Extract the left 3×3 subgrid L by L[r][c] = G[r+1][c+1] for r,c in 0..2.\n3. Extract the right 3×3 subgrid R by R[r][c] = G[r+1][c+5] for r,c in 0..2.\n4. Determine an integer fillColor as follows:\n   4.1. If L[0][0]==5 AND L[0][1]==5 AND L[0][2]==5, then set fillColor = 1.\n   4.2. Else if L[0][1]==5 AND L[0][2]==5 AND L[2][0]==5 AND L[2][1]==5, then set fillColor = 3.\n   4.3. Otherwise set fillColor = 2.\n5. Create an output grid O of size 3×3 initialized to zero.\n6. For each r,c in 0..2:\n   If R[r][c] == 5 then set O[r][c] = fillColor otherwise leave O[r][c] = 0.\n7. Return O as the result.",
    "5b526a93": "1. Let H and W be the grid height and width. 2. Identify all row indices r (0 ≤ r < H) such that at least one cell in row r equals 1. Call this list L and sort in ascending order. 3. Partition L into contiguous runs of exactly three consecutive integers. For each run [r, r+1, r+2], record r as a block group base. 4. For each block group base r, initialize an empty set S_r. Then for each column c from 0 to W−3, if grid[r][c]=1, grid[r][c+1]=1, and grid[r][c+2]=1, add c to S_r. 5. Find the block group base R_max whose set S_{R_max} has maximal size. Let S_max = S_{R_max}. 6. For each block group base r ≠ R_max, do:   a. For each c in S_max that is not in S_r, do:     i. For dr in {0,1,2} and dc in {0,1,2}, if not (dr=1 and dc=1), set grid[r+dr][c+dc] = 8. 7. Return the modified grid.",
    "ed98d772": "1. Let A be the 3×3 input grid and N = 3. 2. Create an empty 6×6 grid B. 3. For each block_row in {0,1} and each block_col in {0,1}:\n   a. Compute K = block_col + 2*block_row (number of 90° anticlockwise rotations).\n   b. Initialize C = A.\n   c. Repeat K times:\n      i. Let D be a new empty N×N grid.\n      ii. For each r in [0..N-1] and c in [0..N-1], set D[r][c] = C[c][N-1-r].\n      iii. Set C = D.\n   d. For each r in [0..N-1] and c in [0..N-1], set B[r + block_row*N][c + block_col*N] = C[r][c].\n4. Return B as the 6×6 output grid.",
    "5b692c0f": "1. Let C = 4.  \n2. For each row r compute rowCount[r] = number of cells with value C. For each column c compute colCount[c] = number of cells with value C.  \n3. If max(rowCount) ≥ max(colCount):  \n   a. orientation = \"horizontal\".  \n   b. axis = the row R where rowCount[R] = max(rowCount).  \nElse:  \n   a. orientation = \"vertical\".  \n   b. axis = the column C0 where colCount[C0] = max(colCount).  \n4. Determine source side (the side that contains exactly one C off the axis):  \n   If orientation = \"horizontal\":  \n     topCs = total C in rows r < axis.  \n     bottomCs = total C in rows r > axis.  \n     If topCs = 1 and bottomCs ≠ 1 then source = \"top\".  \n     Else if bottomCs = 1 and topCs ≠ 1 then source = \"bottom\".  \n     Else source = \"top\".  \n   If orientation = \"vertical\":  \n     leftCs = total C in columns c < axis.  \n     rightCs = total C in columns c > axis.  \n     If leftCs = 1 and rightCs ≠ 1 then source = \"left\".  \n     Else if rightCs = 1 and leftCs ≠ 1 then source = \"right\".  \n     Else source = \"left\".  \n5. For each cell (r,c) on the source side with value v ≠ 0:  \n   If orientation = \"horizontal\":  \n     If source = \"top\" and r < axis:  r' = axis + (axis - r), c' = c.  \n     If source = \"bottom\" and r > axis:  r' = axis - (r - axis), c' = c.  \n   If orientation = \"vertical\":  \n     If source = \"left\" and c < axis:  c' = axis + (axis - c), r' = r.  \n     If source = \"right\" and c > axis:  c' = axis - (c - axis), r' = r.  \n   Set grid[r'][c'] = v.  \n6. Leave all original cells intact.  \n7. Return the modified grid.",
    "ef26cbf6": "1. Scan the entire grid and record every row index r such that every cell in row r has value 4; call this list H (horizontal dividers). 2. Scan the entire grid and record every column index c such that every cell in column c has value 4; call this list V (vertical dividers). 3. Sort H and V in ascending order. 4. Define row segments RS as the list of intervals between dividers in H: let prev = -1, then for each h in H append [prev+1, h-1] and set prev = h; after H append [prev+1, num_rows-1]. 5. Define column segments CS analogously using V. 6. Let R = number of row segments in RS and C = number of column segments in CS. 7. For each block coordinate (i,j) where 0 ≤ i < R and 0 ≤ j < C, let B[i][j] be the subgrid rows RS[i] and cols CS[j]. 8. For each block B[i][j], compute count[i][j] = number of cells in B[i][j] whose value is not 0 and not 4. 9. Label block B[i][j] as a single-block if count[i][j] ≤ 1, or as a shape-block if count[i][j] > 1. 10. Identify a separator:  \n   a. For each h in H, let top = all blocks with RS interval entirely above h, bottom = those entirely below h. If every block in top is single-block and every block in bottom is shape-block, or vice versa, record this h as a horizontal separator.  \n   b. For each v in V, let left = all blocks with CS interval entirely left of v, right = those entirely right of v. If every block in left is single-block and every block in right is shape-block, or vice versa, record this v as a vertical separator.  \n   c. There will be exactly one separator; record its orientation (horizontal or vertical) and index S. 11. Determine which side of the separator is singles-region and which is shapes-region:  \n   - If separator is horizontal at row S: blocks above S form region A and below S region B. If blocks in A are single-blocks then singles-region = A and shapes-region = B; else singles-region = B and shapes-region = A.  \n   - If separator is vertical at column S: blocks left of S form region A and right of S region B. If blocks in A are single-blocks then singles-region = A and shapes-region = B; else singles-region = B and shapes-region = A. 12. For each shape-block B[r][c] ∈ shapes-region:  \n   a. If separator is horizontal, its corresponding single-block is at block coordinate (r',c) where r' is the row index of singles-region.  \n   b. If separator is vertical, its corresponding single-block is at (r,c') where c' is the col index of singles-region.  \n   c. In that single-block locate the unique nonzero/non-4 cell and let its value be v.  \n   d. For every cell (x,y) in B[r][c], if its value ≠ 0 and ≠ 4, set it to v. 13. Leave all other cells (value 0 or 4) unchanged and output the modified grid.",
    "5b6cbef5": "1. Let N=4. Let P be the input grid of size N×N. 2. Create an output grid O of size 4N×4N, initialized so that every O[r][c]=0. 3. For each input cell at row i and column j (0 ≤ i,j < N):\n   a. If P[i][j] ≠ 0 then:\n      i. For each dr from 0 to N–1 and each dc from 0 to N–1:\n         – Set O[i⋅N + dr][j⋅N + dc] = P[dr][dc].\n   b. Otherwise (if P[i][j]=0), leave the 4×4 block O[i⋅N .. i⋅N+3][j⋅N .. j⋅N+3] as zeros.\n4. Return O as the 4N×4N output grid.",
    "f0afb749": "1. Let the input grid have height H and width W.  Create an empty output grid of height 2H and width 2W, initialized with 0s.\n2. For each cell (r,c) in the input grid with value v ≠ 0:\n   a. Compute the top-left of its corresponding 2×2 block in the output: r0 = 2·r, c0 = 2·c.\n   b. Fill the four cells of the block with v:\n      – (r0,   c0), (r0,   c0+1)\n      – (r0+1, c0), (r0+1, c0+1)\n3. For each such 2×2 block placed in step 2 (for each original nonzero cell):\n   a. Let (r0,c0) be the block’s top-left and (r1,c1) = (r0+1,c0+1) its bottom-right.\n   b. Draw a diagonal of value 1 (blue) from (r0,c0) toward the top-left edge:\n      – Initialize (i,j) = (r0-1, c0-1).\n      – While 0 ≤ i < 2H and 0 ≤ j < 2W:\n         • Set output[i][j] = 1.\n         • i ← i-1; j ← j-1.\n   c. Draw a diagonal of value 1 from (r1,c1) toward the bottom-right edge:\n      – Initialize (i,j) = (r1+1, c1+1).\n      – While 0 ≤ i < 2H and 0 ≤ j < 2W:\n         • Set output[i][j] = 1.\n         • i ← i+1; j ← j+1.\n4. Return the output grid.",
    "5d2a5c43": "1. Let H be the number of rows in the input grid and W_total be the number of columns.\n2. Find the divider column index D such that for all rows r, input_grid[r][D] == 1.\n3. Let W = D.\n4. Initialize an output grid of size H rows and W columns.\n5. For each row r from 0 to H-1 and each column c from 0 to W-1:\n   a. Let left_pixel = input_grid[r][c].\n   b. Let right_pixel = input_grid[r][c + D + 1].\n   c. If left_pixel == 0 and right_pixel == 0, set output_grid[r][c] = 0; otherwise set output_grid[r][c] = 8.\n6. Return the output grid.",
    "f0df5ff0": "1. Let G be the input grid of size H rows by W columns. 2. Initialize output grid O as a copy of G. 3. Build a list S of all coordinates (r,c) such that G[r][c] == 1. 4. For each (r,c) in S, do:   a. For dr in {-1,0,1} and dc in {-1,0,1}, compute nr = r + dr and nc = c + dc.   b. If 0 ≤ nr < H and 0 ≤ nc < W and G[nr][nc] == 0, set O[nr][nc] = 1. 5. Return O.",
    "5ffb2104": "1. Let H = number of rows and W = number of columns in the input grid. 2. Repeat the following until no cell moves in an iteration:  \n  a. Create a snapshot S of the current grid.  \n  b. Initialize moved = false.  \n  c. For each row r from 0 to H-1 and each column c from 0 to W-2:  \n     i. If S[r][c] > 0 and S[r][c+1] == 0, then record a move of value v = S[r][c] from (r,c) to (r,c+1).  \n  d. If no moves were recorded in step 2.c, exit the loop.  \n  e. Otherwise, for each recorded move from (r,c) to (r,c+1):  \n     i. Set grid[r][c] = 0.  \n     ii. Set grid[r][c+1] = v.  \n     iii. Set moved = true.  \n3. After the loop, the grid is the output: all nonzero values have been shifted right as far as possible in a 2048-style slide, preserving the relative arrangement of each colored shape.",
    "f21745ec": "1. Identify all non-zero connected components:\n   a. Traverse the grid and for each cell with value v ≠ 0 not yet visited, perform a flood fill (4-connected) to collect all cells of value v into one component.\n   b. For each component, compute its bounding box: min_row, max_row, min_col, max_col, height H = max_row - min_row + 1, width W = max_col - min_col + 1, and record its original value v.\n2. Locate the pattern source rectangle:\n   a. For each component, check if any cell (r,c) in the component satisfies min_row < r < max_row and min_col < c < max_col. If so, designate this component as the pattern source and record pattern_H = H, pattern_W = W, pattern_value = v.\n   b. Build a boolean mask interior_mask of size pattern_H×pattern_W: for dr in 1..pattern_H-2 and dc in 1..pattern_W-2, set interior_mask[dr][dc] = true if grid[min_row+dr][min_col+dc] == pattern_value, else false.\n   c. Stop after finding the first such component.\n3. Clear the grid by setting all cells to 0.\n4. For each component whose bounding box dimensions H and W equal pattern_H and pattern_W:\n   a. Let v = component.value, and let (r0,c0) = (min_row, min_col) of that component.\n   b. For dr in 0..pattern_H-1 and dc in 0..pattern_W-1:\n      i. Let r = r0 + dr, c = c0 + dc.\n      ii. If dr == 0 or dr == pattern_H-1 or dc == 0 or dc == pattern_W-1, set grid[r][c] = v (outline).\n      iii. Else if interior_mask[dr][dc] is true, set grid[r][c] = v.\n      iv. Else leave grid[r][c] = 0.\n5. Return the modified grid."
}