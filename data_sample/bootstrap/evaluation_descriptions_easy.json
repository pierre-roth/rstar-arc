{
	"ba9d41b8": "First, make a copy of the input grid: grid_copy = [row[:] for row in grid]\n1. Prepare a visited set to hold processed (row,col) pairs.\n2. For each (r,c) in row-major order: if grid_copy[r][c] != 0 and (r,c) not in visited, let orig = grid_copy[r][c].\n3. Flood-fill from (r,c) collecting all 4-connected cells equal to orig, adding each to visited and storing their coordinates.\n4. Compute rMin,rMax from min and max of row indices and cMin,cMax from min and max of column indices of those cells.\n5. For rr in rMin..rMax and cc in cMin..cMax compute ((rr-rMin)+(cc-cMin))%2; if result == 0 set grid_copy[rr][cc]=orig else set grid_copy[rr][cc]=0.\n6. All other cells remain unchanged.\n7. Continue until no nonzero cell remains unvisited.\n8. Return the output grid.",
	"b15fca0b": "Find the two cells with value 2 in the grid.\nUse BFS on the grid treating cells with value 1 as walls and cells with value 0 (and 2) as passable to compute the shortest path between the two endpoints (cells with value 2).\nFor each cell on this path except the endpoints, set grid[r][c] = 4.\nReturn the modified grid.",
	"45737921": "1. Define background = 0.\n2. Initialize visited = set().\n3. For each cell (r,c): if grid[r][c] != background and (r,c) not in visited, perform a 4-directional flood fill to collect the connected component of non-background cells (an object) and mark them visited.\n4. Determine the two unique values val1 and val2 in this object.\n5. For each cell in the object: if its original value equals val1 set grid[r][c] = val2 else set grid[r][c] = val1.\n6. Return the modified grid.",
	"5783df64": "1. Compute N = len(grid) and S = N // 3.\n2. Initialize output = [[0,0,0] for _ in range(3)].\n3. For each block_i in range(3):\n4.   For each block_j in range(3):\n5.     For r in range(block_i*S, (block_i+1)*S):\n6.       For c in range(block_j*S, (block_j+1)*S):\n7.         If grid[r][c] != 0: set output[block_i][block_j] = grid[r][c]; break out of both loops scanning r and c for this block.\n8. Return output.",
	"f45f5ca7": "Step 1: Let background = 0\nStep 2: Initialize an output grid of the same dimensions as the input, filling every cell with background\nStep 3: Define a mapping dict for values in the first column to zero-based output column indices: {8: 1, 2: 2, 4: 3, 3: 4}\nStep 4: For each row index i from 0 to height-1:\n    • Let v = input_grid[i][0]\n    • If v != background, set output_grid[i][mapping[v]] = v\nStep 5: Return the output grid.",
	"aa300dc3": "1. Identify the background color as 0.\n2. Let rows = len(grid), cols = len(grid[0]), and initialize max_length = 0, best_start = None, best_dir = None.\n3. For each cell (i,j): if grid[i][j] == 0, then for each diagonal direction dir in [(1,1),(1,-1)]: compute prev_i = i - dir[0], prev_j = j - dir[1]; if (prev_i, prev_j) is out of bounds or grid[prev_i][prev_j] != 0, treat (i,j) as the start of a diagonal; set length = 0 and while True: ni = i + length*dir[0], nj = j + length*dir[1]; if ni<0 or ni>=rows or nj<0 or nj>=cols or grid[ni][nj] != 0: break; length += 1; if length > max_length: set max_length = length, best_start = (i,j), best_dir = dir.\n4. For k in range(max_length): set grid[best_start[0] + k*best_dir[0]][best_start[1] + k*best_dir[1]] = 8.\n5. Return the modified grid.",
	"332efdb3": "Background: the input grid is entirely zeros.\nDetermine the grid height and width.\nFor each row index i from 0 to height-1:\n  If i % 2 == 0:\n    Set every cell in row i to 1.\n  Else:\n    For each column index j from 0 to width-1:\n      If j % 2 == 0, set cell (i,j) to 1; otherwise set it to 0. \n Return the modified grid.",
	"3194b014": "Step 1: Treat cells with value 0 as background.\nStep 2: Use 4-connectivity (up, down, left, right) to find all connected regions of cells with the same non-zero integer.\nStep 3: For each region, count its cells to determine its size.\nStep 4: Identify the region with the largest size.\nStep 5: Let c be the integer value (color) of this largest region.\nStep 6: Return a new 3×3 grid (list of lists) where every cell equals c.",
	"45bbe264": "1. Define the background as value 0.\n2. Scan the input grid and record each non-zero cell’s coordinates (row i, column j) and its value v.\n3. Create a same-sized data structure where each cell holds an empty set of covering values.\n4. For each recorded cell at (i, j) with value v:\n   a. For every column index k in row i, add v to covering_sets[i][k].\n   b. For every row index k in column j, add v to covering_sets[k][j].\n5. Build the output grid by iterating over each cell (i, j):\n   – If covering_sets[i][j] is empty, output 0.\n   – If it contains exactly one value x, output x.\n   – If it contains more than one value, output 2. \n6. Return the output grid.",
	"833dafe3": "1. Import numpy as np.\n2. Convert the input grid to a NumPy array g.\n3. Create left by flipping g horizontally: left = np.fliplr(g).\n4. Concatenate left and g side by side: combined = np.concatenate((left, g), axis=1).\n5. Create top by flipping combined vertically: top = np.flipud(combined).\n6. Stack top above combined: result = np.concatenate((top, combined), axis=0).\n7. Convert result back to a list of lists and return it.",
	"d37a1ef5": "Step 1: Identify all cells with value != 0 and compute the minimum and maximum row and column indices of this set to get min_row, max_row, min_col, max_col (the outer bounding box on a background of 0).\nStep 2: Identify all cells with value == 5 and compute the minimum and maximum row and column indices of this set to get min_row_5, max_row_5, min_col_5, max_col_5 (the inner bounding box).\nStep 3: For each row r in range(min_row, max_row+1) and column c in range(min_col, max_col+1), if r is between min_row_5 and max_row_5 inclusive and c is between min_col_5 and max_col_5 inclusive, leave grid[r][c] unchanged; otherwise set grid[r][c] = 2. \nStep 4: Return the modified grid.",
	"358ba94e": "Use background color 0. Find all connected components of non‐zero cells using 4‐connectivity. For each component, compute its bounding box (min_row, min_col) to (max_row, max_col). Within each bounding box, count how many cells have value 0. Select the component whose bounding box contains the maximum number of zeros. Crop the original grid to that bounding box and return the resulting subgrid.",
	"f3cdc58f": "Let R be the number of rows and C be the number of columns in the input grid\nBackground color is 0\nLet m be the maximum value in the input grid\nCreate an output grid of size R×C filled with 0\nFor each k from 1 to m inclusive:\n  Let c be the count of cells equal to k in the input grid\n  For i from 0 to c-1:\n    Set output_grid[R−1−i][k−1] = k\nReturn the output grid"
}