{
    "007bbfb7.json": "1. Let I be the 3x3 input grid where each cell I[i][j] is an integer (with 0 representing the background). 2. Create an output grid O of size 9x9 (rows and columns indexed from 0 to 8). 3. For each cell in I at row i and column j (with i, j ∈ {0,1,2}):\n   a. Define the corresponding 3x3 block in O as the cells with row indices from 3*i to 3*i+2 and column indices from 3*j to 3*j+2.\n   b. If I[i][j] is not 0 (i.e. a colored pixel such as 2,4,6,7, etc.), then fill that block with a copy of the entire input grid I. In other words, for every cell in I at position (r, c) (with r, c ∈ {0,1,2}), set O[3*i + r][3*j + c] = I[r][c].\n   c. If I[i][j] is 0, then fill the entire corresponding block in O with 0’s.\n4. Return O as the final 9x9 output grid.",
    "00d62c1b.json": "1. Begin by copying the input grid to an output grid of the same dimensions.\n2. Define the outline color as 3 and the fill color as 4. (Here, 3 represents green and 4 represents yellow.)\n3. Identify the border of the grid; these are all cells in the first row, last row, first column, and last column.\n4. For every cell on the border that is not 3, perform a flood fill (using 4-connected neighbors: up, down, left, right) to mark all connected cells that are also not 3 as safe. These safe cells represent regions that touch the border and therefore are not enclosed.\n5. Traverse every cell in the grid. For any cell that is not 3 and has not been marked as safe from the flood fill, change its value to 4. This fills the hole—that is, any region completely surrounded by cells with value 3—with 4.\n6. Output the resulting grid.",
    "017c7c7b.json": "1. Replace Colors: For every cell in the input grid, if the value is 1 (blue) change it to 2 (red) and leave all other numbers unchanged (in the given examples the only other number is 0, which represents black). \n2. Let T be the transformed grid (which has the same dimensions as the input; in all examples the grid is 6 rows by 3 columns). \n3. Form an output grid whose number of rows is increased by 3 (resulting in 9 rows) while keeping the same number of columns. Copy T into the top 6 rows of the output (i.e. output rows 0 through 5 are exactly T). \n4. Construct the bottom block (the appended 3 rows) as follows. Using 0‐based indexing, compare row 1 and row 3 of T. If any cell in T[3] differs from the corresponding cell in T[1] then define the appended block as the three rows: T[0], T[3] and T[2] (in that order). Otherwise (if T[3] equals T[1]), define the appended block as T[0], T[1] and T[2] (in that order). \n5. Place this block as rows 6–8 (the bottom 3 rows) of the output grid. \n(This procedure converts the input pattern by changing color 1 to 2 and then extending the grid vertically by appending a selection of rows from the transformed grid. For example, in three of the cases the bottom block is identical to the top three rows (T[0], T[1], T[2]), but when T[3] differs from T[1] (as in one training example) the middle appended row comes from T[3].)",
    "025d127b.json": "1. Keep the grid size unchanged. Process each distinct nonzero digit (which represents a colored shape) in the input separately.\n2. For a given digit, scan the entire grid to collect all its coordinates. Determine the bottom row index r_bot where the digit occurs (i.e. the maximum row index with that digit). In that row, find the maximum column index c_max among the cells that have that digit (this is the rightmost cell of the shape).\n3. For every cell (r, c) that contains the digit and where r is less than r_bot (i.e. not in the bottom row), check if its column index c is less than c_max. If so, move that cell one column to the right by placing the digit at (r, c+1) in the output grid and setting the original (r, c) to 0. If a cell’s column index equals c_max, leave it unchanged.\n4. Do not modify any cells in the bottom row for that digit; they remain in their original positions.\n5. Repeat steps 2–4 for every nonzero digit present. All cells with 0 remain unchanged.\n6. The final output grid is the input grid after all such shifts for every shape have been applied.",
    "045e512c.json": "1. Find the reference shape by scanning the grid for the contiguous nonzero object that has the most cells. Let its minimal bounding box be of height H and width W. In the examples the reference shape is a 3×3 block whose pattern (template) is defined as follows: in its top row all three cells are filled, in its middle row only the left‐and rightmost cells are filled (the center remains blank), and in its bottom row all three cells are filled. (For instance, if the reference shape’s color is 8 then its pattern looks like: [8,8,8] on the top row, [8,0,8] on the middle row, and [8,8,8] on the bottom row.)\n2. For every other nonzero color (that is, any number from 1 to 9 other than the reference color) that appears as a partial or incomplete cluster (a seed) in the grid, determine its minimal bounding box. In many cases the seed will not already span a full 3 columns even though its intended complete copy should have width 3 and height 3. (For example, in one case the seed may appear only as a vertical line of three cells.)\n3. Align the seed with the template by using the seed’s bounding box top‐left coordinate as the placement for a completed copy. That is, place a 3×3 block (of size H×W, with H = W = 3) whose top‐left corner is at the seed’s bounding box top‐left cell, and fill in every cell of that block according to the template pattern but using the seed’s color (so every cell where the template has a 1 gets set to the seed color, while cells corresponding to a 0 remain 0). For example, if a seed of color 3 appears in a 1‐cell–wide by 3‐cell–tall bounding box starting at row 6, column 10, then draw a block covering rows 6–8 and columns 10–12 with the pattern [3,3,3] on top, [3,0,3] in the middle, and [3,3,3] on the bottom.\n4. Compute a replication (translation) vector for the seed copy by subtracting the top‐left coordinates of the reference shape’s bounding box from the top‐left coordinates of the seed’s completed block. In the example the reference shape (color 8) occupies rows 6–8 and columns 6–8 and the seed block (color 3) is placed with its top‐left corner at (6,10); thus the replication vector is (0, 4). \n5. Replicate the completed seed shape by repeatedly adding the replication vector to its top‐left coordinate. In each new location (as long as at least part of the 3×3 block falls within the grid) draw a full copy of the template pattern in the seed’s color. In the example, starting at (6,10) replicate additional copies at (6,14) and (6,18) (each copy covering 3 columns and with a one‐column gap between copies) until you hit the right edge of the grid. If a replicated copy would extend past the grid’s boundary, draw only the cells that fit.\n6. Do not alter any cells that are not reached by these replications; leave the complete reference shape unchanged.\n7. Finally, output the grid (which remains the same overall size) with each seed’s pattern completed and replicated along the same direction and spacing as determined by the replication vector.\n\nNote: All colors are treated as numbers. For example, 0 is the background; in the first training example the reference is 8 and the seed is 3; in other examples the seed colors might be 2, 4, 1, etc.",
    "0520fde7.json": "1. Recognize that the input grid always has 3 rows and 7 columns where column index 3 (the fourth column) serves as a divider and contains the value 5 (grey). Extract two 3×3 subgrids: the left subgrid from columns 0–2 and the right subgrid from columns 4–6. 2. Create an output grid of size 3×3. For each cell at position (r, c) where r ∈ {0,1,2} and c ∈ {0,1,2}, identify the corresponding cell in the left subgrid (at (r, c)) and the corresponding cell in the right subgrid (at (r, c)). 3. If both of these corresponding cells have nonzero values (i.e. they are colored, regardless of their original color), then set the output cell to 2 (which corresponds to red). 4. Otherwise, set the output cell to 0 (black). 5. Return the resulting 3×3 output grid.",
    "05269061.json": "1. Note that the input grid is on a background of 0 and contains an object made up of exactly three distinct nonzero integers. The goal is to replace every cell of the grid (which remains the same size) by a repeating diagonal pattern made from a cyclic sequence of three numbers (each in the range 1–9). \n2. To extract the correct cyclic sequence (the “base cycle”), scan the grid row‐by‐row (top to bottom) and for each row form a list by reading its nonzero cells in left‐to‐right order (ignoring 0’s). Among the rows that yield exactly three nonzero values, select the candidate with the smallest index; if more than one candidate exists, pick the one whose first nonzero appears at the smallest column index. Call this chosen row the seed row and let L be its list of nonzero values (for example, in one case L may be [2,8,3], in another it may be [1,2,4] or [8,3,4]). \n3. Determine a rotation offset k from the seed row so that when L is cyclically rotated left by k positions the resulting order (call it P) matches the object’s diagonal pattern seen in the training examples. (• For instance, if the seed row is the very first row then k = 0 and P = L as is; • if the first complete row appears later such that k = 1 then P is L rotated left by one (so [1,2,4] becomes [2,4,1]); • if k = 2 then P is L rotated left by two (so [8,3,4] becomes [4,8,3]).) A good choice is to set k = (3 – (seed row index mod 3)) mod 3. \n4. Now create the output grid (which has the same dimensions as the input) by filling every cell according to its coordinates: for each cell at row r and column c (using 0-indexing), assign the value P[((r + c) mod 3)]. In other words, each row is a horizontal repetition of the three‐number cycle, and each subsequent row is a cyclic shift of the row above by one position. \n5. Return the resulting grid.",
    "05f2a901.json": "1. Scan the input grid and record the coordinates of all cells with value 8 (the blue cube, corresponding to light blue) and all cells with value 2 (the red shape). Do not change any cell with value 8.\n2. Compute the bounding box for the red shape by finding red_min_row (smallest row with a 2), red_max_row (largest row with a 2), red_min_col (smallest column with a 2), and red_max_col (largest column with a 2). In the same way, compute the bounding box for the blue cube using its 8‐valued cells (blue_min_row, blue_max_row, blue_min_col, blue_max_col).\n3. Determine the translation needed for the red shape so that it comes into contact with the blue cube without altering the blue cube’s position. Use the following decision rules:\n   a. If the horizontal ranges of the two bounding boxes overlap (that is, if the intervals [red_min_col, red_max_col] and [blue_min_col, blue_max_col] share at least one column), then the movement is vertical. \n      • If red_max_row is less than blue_min_row − 1 (meaning the red shape is entirely above the blue cube with a gap), compute row_offset = (blue_min_row − 1) − red_max_row. (This shifts the red shape downward so that its bottom edge becomes immediately adjacent above the blue cube.)\n      • Else if red_min_row is greater than blue_max_row + 1 (red is entirely below blue), set row_offset = (blue_max_row + 1) − red_min_row. (This shifts the red shape upward so that its top edge touches the blue cube.)\n      In this case set col_offset = 0.\n   b. Otherwise, if the vertical ranges overlap (that is, the intervals [red_min_row, red_max_row] and [blue_min_row, blue_max_row] share at least one row), then the movement is horizontal.\n      • If red_max_col is less than blue_min_col − 1 (red is entirely to the left of blue), compute col_offset = (blue_min_col − 1) − red_max_col. (This shifts red rightward so that its right edge touches the blue cube.)\n      • Else if red_min_col is greater than blue_max_col + 1 (red is entirely to the right of blue), set col_offset = (blue_max_col + 1) − red_min_col. (This shifts red leftward so that its left edge touches the blue cube.)\n      In this case set row_offset = 0.\n   c. If neither horizontal nor vertical intervals overlap (i.e. the red shape is separated from the blue cube in both dimensions), compute both offsets independently so that when added, the red shape’s bounding box will be moved diagonally until it touches the blue cube. (None of the provided examples require diagonal movement, but this case is defined analogously.)\n4. Prepare an output grid of the same dimensions as the input and initialize every cell to 0.\n5. For every cell in the input that has value 8, copy that value to the exact same coordinate in the output grid.\n6. For every cell in the input that has value 2, compute its new location by adding the determined row_offset and col_offset to its original coordinates. Set the corresponding cell in the output grid to 2 (preserving the red shape’s overall pattern).\n7. Return the output grid. This transformation leaves the blue cube (8) unmoved and moves the red shape (2) directly toward the blue cube until at least one red cell touches a blue cell (i.e. their bounding boxes become immediately adjacent along the axis of separation).",
    "06df4c85.json": "1. Determine the divider value D by scanning the input grid for full rows in which every number is identical; these rows are divider rows that separate the patterned blocks. (For example, in one dataset D is 8, in another it is 1, and in a third it is 4.)\n2. In every row that is not a divider row, identify the same divider value D appearing in fixed column positions; these columns split the row into contiguous cell blocks. Each such cell block is a 2×2 subgrid (that is, two adjacent rows between divider rows and two adjacent columns between divider columns) whose cells are all identical (usually 0 for background or a nonzero digit representing a colored square).\n3. Conceptually partition the grid into a matrix of cell blocks (ignoring the divider rows and columns). Each cell in this conceptual grid has a value (for example, 0 when blank or a nonzero number such as 2 or 3 when colored).\n4. For each row in this cell‐grid (i.e. within each group of adjacent non–divider rows), scan from left to right. If you encounter two cell blocks with the same nonzero value X and every cell block between them has value 0, then replace each intervening cell block’s value with X. (This “connects” the same colored blocks horizontally.)\n5. For each column in the cell grid (i.e. for cell blocks sharing the same relative position separated by divider rows), scan from top to bottom. If you find two cell blocks with the same nonzero value X and every cell block between them is 0, then fill in those intermediate cell blocks by setting their value to X. (This connects the matching blocks vertically.)\n6. Reconstruct the output grid by replacing each cell block with its corresponding 2×2 block (filled uniformly with its final value) and by preserving all divider rows and divider columns exactly as in the input (all of which contain the divider value D). The overall dimensions of the grid remain unchanged.\n7. Output the resulting grid.",
    "08ed6ac7.json": "1. Define the grid coordinates with rows indexed from 0 at the top to N-1 at the bottom and columns from 0 on the left to M-1 on the right. 2. Locate all connected groups (using orthogonal connectivity: up, down, left, right) of cells having the value 5. These groups represent the gray bars in the input. 3. For each group, compute its vertical height by finding the minimum and maximum row indices among its cells and calculating height = (max row − min row + 1). 4. Sort all the groups in descending order by their computed height (largest height first, smallest last). 5. Reassign the values in each group according to their order: change every cell in the group with the greatest height to 1 (blue), every cell in the group with the second greatest height to 2 (red), every cell in the group with the third greatest height to 3 (green), and every cell in the group with the smallest height to 4 (yellow). 6. Leave all cells that are not 5 unchanged and output the resulting grid with the same dimensions.",
    "09629e4f.json": "1. Partition the 11×11 input grid into nine 3×3 blocks by noting that row 4 and row 8 and column 4 and column 8 are separator lines; every cell in these separator rows and columns has the value 5 and must remain unchanged in the output. \n2. Among the nine 3×3 blocks (the non‐separator portions), locate the unique block (the template) whose nonzero entries (ignoring any 0’s) are exactly four in number and, when collected, equal the set {2, 3, 4, 6}. (Here 0 represents black and 5 is the fixed gray background.)\n3. Record the template block as a 3×3 matrix T, preserving the positions of its cells. For example, if T is written in row–column order as:\n  [T(1,1)   T(1,2)   T(1,3)]\n  [T(2,1)   T(2,2)   T(2,3)]\n  [T(3,1)   T(3,2)   T(3,3)]\nthen the nonzero entries (each equal to one of 2, 3, 4 or 6) occur in the same relative positions as in the template.\n4. Construct a new 11×11 output grid as follows. First, for the nine positions that are not in separator rows or columns, view the grid as a 3×3 arrangement of 3×3 subgrids. For each subgrid at block position (r, c) (with r and c from 1 to 3), fill every cell of that 3×3 block with the single number given by T(r, c) (if T(r, c) is 0, fill with 0; if it is one of 2, 3, 4, or 6, fill entirely with that digit).\n5. Finally, restore the separator rows (rows 4 and 8) and separator columns (columns 4 and 8) by ensuring every cell in those rows and columns is 5. \n6. The resulting grid is the output.",
    "0962bcdd.json": "1. Scan the entire input grid (with rows and columns indexed from 0) to detect all plus‐shapes. For each candidate cell (r, c) that can be a plus center (i.e. where r-1, r+1, c-1, and c+1 are within bounds), check that:\n   • The cell at (r, c) has a nonzero value A.\n   • Its four immediate neighbors – above at (r-1, c), below at (r+1, c), left at (r, c-1) and right at (r, c+1) – all have the same nonzero value B, with A ≠ B.\n   Each such configuration is a plus shape with center value A and arm value B.\n\n2. For each detected plus shape with center located at (r, c), define its extended region as the 5x5 block from (r-2, c-2) to (r+2, c+2).\n\n3. Within this 5x5 block use relative coordinates (i, j) where i and j range from 0 to 4 (with (0,0) corresponding to (r-2, c-2)) and overlay a predetermined pattern only on selected cells. The pattern fills exactly 17 cells in a diamond‐like shape described by:\n   • For relative row 0 and row 4: fill only columns 0, 2, and 4.\n   • For relative row 1 and row 3: fill only columns 1, 2, and 3.\n   • For relative row 2: fill all columns 0, 1, 2, 3, and 4.\n   All other cells in the 5x5 block remain unchanged (i.e. retain the background, typically 0).\n\n4. In the filled cells of the 5x5 block, assign values based on their relative position:\n   • If the cell’s relative coordinate is one of (0,0), (0,4), (1,1), (1,3), (2,2), (3,1), (3,3), (4,0) or (4,4) – that is, the cells forming an X pattern within the block – then set the cell’s value to A (the original plus center value; for example, 2, 6, or 4).\n   • In the other filled positions of the block, set the cell’s value to B (the original arm value; for example, 7, 8, or 3).\n\n5. Overwrite the cells in the output grid corresponding to the extended 5x5 block with these new values. Ensure that if more than one plus shape is present, each is processed independently and its transformed pattern is overlaid on the grid.\n\n6. Leave all grid cells that are not part of any extended plus shape unchanged. The output grid retains the same dimensions as the input grid.",
    "0a938d79.json": "1. Determine the grid orientation: if the number of columns is greater than or equal to the number of rows, treat the grid as wide and use a vertical stripe pattern; if the number of rows is greater than the number of columns, treat it as tall and use a horizontal stripe pattern.\n2. Scan the input grid in row–major order to locate the first two nonzero cells. Let the value of the first nonzero cell be C1 and the value of the second nonzero cell be C2. (In the examples these numbers are, for instance, 2 and 8 or 1 and 3 or 4 and 1.)\n3. For the chosen orientation, note the coordinate from the first nonzero cell that is relevant to the stripe direction: if using vertical stripes, record its column index as start; if using horizontal stripes, record its row index as start. Then compute the step size as the difference between the corresponding coordinate of the second nonzero cell and start (i.e. step = coordinate2 − start). For example, in a wide grid if the first nonzero is at column 5 and the second is at column 7 then step = 2; in a tall grid if the first nonzero is at row 7 and the second is at row 11 then step = 4.\n4. If the grid is wide (vertical stripe pattern): For every column c such that c = start + k*step (for k = 0, 1, 2, …) and c is less than the number of columns, fill column c entirely with a stripe. Alternate the stripe color between C1 and C2, starting with C1 at k = 0. All cells in columns not chosen remain 0.\n5. If the grid is tall (horizontal stripe pattern): For every row r such that r = start + k*step (for k = 0, 1, 2, …) and r is less than the number of rows, fill row r entirely with a stripe. Alternate the stripe color between C1 and C2, starting with C1 at k = 0. All cells in rows not chosen remain 0.\n6. Output the resulting grid of the same dimensions as the input.",
    "0b148d64.json": "1. Scan the input grid (a 2D array of digits) row by row and mark every row in which every cell is 0; these rows serve as horizontal separators. They divide the grid into contiguous horizontal blocks (subsections with no all‐0 rows inside).\n2. For each horizontal block, examine its columns: for each column (considering only the rows in that block), if every cell is 0 then mark that column as a vertical separator. These vertical separators divide the block into rectangular subgrids (regions).\n3. For every such subgrid, ignore the 0’s (which form the borders) and determine its foreground value by finding the nonzero digit that appears in that region. (Each region is assumed to be filled in a uniform way so that all nonzero cells are the same digit.)\n4. Across all subgrids in the entire input grid, determine the majority foreground value – that is, the digit (other than 0) that appears as the foreground in more subgrids than any other.\n5. Identify the one subgrid whose foreground (nonzero) digit is different from this majority value. (For example, if three regions have foreground 8 and one has foreground 2, then the region with 2 is the odd one out; in other cases the odd value might be 3 or 4.)\n6. Extract that subgrid exactly as it appears (all its rows and columns between the separator lines, including any 0’s that belong to the pattern) and output it as the resulting grid.",
    "0ca9ddb6.json": "1. Copy the input grid to an output grid without changing its size. \n2. For every cell with value 2 (red) in the input grid at position (r, c), modify the output grid by setting the following cells—if they lie within the grid bounds—to 4 (yellow):\n   a. (r - 1, c - 1)\n   b. (r - 1, c + 1)\n   c. (r + 1, c - 1)\n   d. (r + 1, c + 1)\n   This step adds a yellow square at each diagonal (corner) of each red square. \n3. For every cell with value 1 (blue) in the input grid at position (r, c), modify the output grid by setting the following adjacent cells—if they lie within the grid bounds—to 7 (orange):\n   a. (r - 1, c)   (above)\n   b. (r + 1, c)   (below)\n   c. (r, c - 1)   (left)\n   d. (r, c + 1)   (right)\n   This step adds an orange square directly above, below, to the left, and to the right of each blue square. \n4. Leave all other cells (those not originally 1 or 2) unchanged in the output grid. \nWhen complete, the output grid retains the same dimensions as the input grid and reflects these additions without altering the original red (2) and blue (1) squares.",
    "0d3d703e.json": "1. Confirm the input is a 3x3 grid where each of the three vertical columns is uniform (all cells in a given column have the same integer value).\n2. For each column, use its constant input value (taken from any cell in that column) and transform the entire column using a column-specific mapping:\n   a. For the first column (column 0):\n      - If the value is 3, change it to 4.\n      - If the value is 2, change it to 6.\n      - If the value is 5, change it to 1.\n      - If the value is 9, change it to 8.\n      - If the value is 8, change it to 9.\n   b. For the second column (column 1):\n      - If the value is 1, change it to 5.\n      - If the value is 3, change it to 4.\n      - If the value is 8, change it to 9.\n      - If the value is 4, change it to 3.\n   c. For the third column (column 2):\n      - If the value is 2, change it to 6.\n      - If the value is 8, change it to 9.\n      - If the value is 6, change it to 2.\n      - If the value is 3, change it to 4.\n3. Replace every cell in a column with its determined new value so that each column remains uniform.\n4. Output the modified 3x3 grid, preserving the original dimensions.",
    "0dfd9992.json": "1. Set the output grid to have the same dimensions as the input grid. 2. Note that the input is a tiling whose cells (numbers 1–9) form a repeating pattern but some cells have been replaced by 0 (which represents a missing or \"black\" cell). Your job is to restore the full pattern so that no 0’s remain and the horizontal and vertical repetition is preserved. 3. In many rows the pattern is completely visible (that is, the row has no 0’s). Use such rows to determine the intended horizontal cycle. For example, in one training sample the first row (3,6,5,6,3,2,3,6,5,6,3,2,3,6,5,6,3,2,3,6,5) is complete; in another sample a complete row is (2,7,7,2,6,5,6,2,7,7,2,6,5,6,2,7,7,2,6,5,6) and in a third the top row is (3,2,3,6,3,2,3,6,3,2,3,6,3,2,3,6,3,2,3,6,3). 4. For every row that contains one or more 0’s, extract the ordered list of its nonzero elements (which appear in fixed column positions). Then assume that the intended row is a cyclic (repeating) extension of that base sequence over the full row–that is, the missing cells should be filled so that if you imagined the row repeated indefinitely to the left and right the given nonzero entries occur in the correct slots. In other words, deduce the unique complete row (with no 0’s) that is consistent with the nonzero anchors. (For example, a row that shows the nonzero entries 2,5,4,5,2,1,2,5 at columns 0–7, then again 2,1,2,5,4 at later positions, should be completed as 2,5,4,5,2,1,2,5,4,5,2,1,2,5,4,5,2,1,2,5,4.) 5. In addition the pattern repeats in the vertical direction. That is, the complete rows occur in a fixed cyclic order (for example, one training sample shows a top‐block of four rows (for example, A, B, C, D) that then repeat – sometimes a partially filled row’s completed pattern turns out to be a cyclic shift or a different member of that vertical set). Use the fully given rows to identify which completed row is “meant” for each vertical position and, when a row is already complete (contains no 0’s), simply copy it unchanged. 6. Replace every 0 in the input with the number from the deduced complete row at that same column position. 7. Return the output grid (using only numbers 0–9) in which every cell has been filled so that the original repeating tile pattern is restored without any 0’s.",
    "0e206a2e.json": "1. Keep the output grid the same size as the input grid and set every cell initially to 0.\n2. In the input grid, treat any cell whose value is not 0 (that is, not black) as part of a colored shape. Group these nonzero cells into connected components using 4‐neighbor connectivity. (Each cell’s color is one of the following integers: 1, 2, 3, 4, etc., which represent blue, red, green, yellow, etc.)\n3. For each connected component, compute its minimal bounding rectangle (the smallest set of consecutive rows and columns that contains all of its nonzero cells).\n4. Remove any extraneous empty (all 0) rows or columns from that rectangle so that the pattern is as compact as possible while preserving the relative arrangement and original color values of the cells.\n5. Reposition each compacted component by translating it (without rotating or reordering its internal pixels) into a new location on the output grid. The translation is done separately for each component and must satisfy the following criteria:\n   • The internal horizontal and vertical order of pixels in the component is preserved.\n   • If there is only one component it is shifted so that its top row is moved downward (for example, so that the top row of the component appears near row 10 or 11 of the output grid). \n   • If there are multiple components, sort them by the row of their topmost cell in the input. Then, translate them so that they remain separated (for example, placing the first component with its top row at row 3 and the next with its top row at row 10) while preserving their vertical order.\n6. In the output grid, place each translated component by writing its nonzero (colored) values into the corresponding cells; all cells not filled remain 0.\n7. The final output is a grid with the same dimensions as the input where the original colored patterns have been consolidated (with any gaps between clusters removed within each component) and repositioned into new, more compact locations while retaining their original color numbers (for example, 1, 2, 3, 4, etc.).",
    "10fcaaa3.json": "1. Determine the dimensions of the input grid: let H be the number of rows and W be the number of columns. \n2. Create an output grid of size (2 * H) rows by (2 * W) columns, initializing every cell to 0. \n3. Tile the input grid into the output grid by copying every cell from the input into all four quadrants. For each cell in the input at coordinate (r, c) with value V (which may be 0 or a nonzero colored value), copy V into the following output positions: (r, c), (r, c + W), (r + H, c) and (r + H, c + W). This reproduces the input grid in the upper‐left, upper‐right, lower‐left, and lower‐right quadrants. \n4. Process only the original colored squares (i.e. those copied from the input that are nonzero and not equal to 8) in the output grid. For each such cell at position (r, c) with value V, identify its four diagonal neighbors: (r - 1, c - 1), (r - 1, c + 1), (r + 1, c - 1), and (r + 1, c + 1). For each diagonal neighbor that lies within the bounds of the output grid and currently has a value of 0, set its value to 8 (the number 8 represents light blue). Do not overwrite a neighbor if it already contains a nonzero value. \n5. Return the final output grid as the result.",
    "11852cab.json": "1. Scan the entire grid row by row. Group together every maximal contiguous block of rows that contains any nonzero cell (recall that 0 is the background and any other digit from 1 to 9 represents a colored pixel). Each such block is treated as one pattern to be fixed.\n2. Within each group, label the rows in order from top to bottom using a local index starting at 0. Designate rows with even indices (0, 2, 4, …) as type A (the ‘edge’ rows) and rows with odd indices (1, 3, 5, …) as type B (the ‘inner’ rows).\n3. In the first row of the group (local index 0, type A), examine the positions (columns) where nonzero values appear. If this row already contains three nonzero cells at columns L, M and R (with L < M < R), then save that row as the type A template. If it contains only two nonzero cells (assumed to be the left and center parts), let L be the column of the first nonzero and M the column of the second nonzero; compute R = 2 * M − L, then overwrite the cell at column R (if it is 0) with the same value as in column L. In either case the resulting row now has the intended type A pattern with three cells at columns L, M and R.\n4. Define the intended type B pattern for this group as having nonzero cells in the two positions that lie between the type A cells – namely, at columns (L + 1) and (R − 1).\n5. For every row in the group that is meant to be type A (even-indexed rows):\n   • If the row is incomplete (that is, if one or both of the cells at columns L and R are 0) then replace its values at columns L, M and R with the corresponding values from the type A template determined in step 3. (Leave any type A row that already has nonzero values in all three designated columns unchanged even if its peripheral values differ from the template.)\n6. For every row in the group that is meant to be type B (odd-indexed rows):\n   • Look at the two designated cells at columns (L + 1) and (R − 1). If one is 0 while the other is nonzero, replace the 0 with the nonzero value so that the row has the same value at both positions. If both positions are 0 (i.e. the row is blank for type B) then find the first type B row in the group that is complete and copy its values for these two columns into the current row.\n7. Leave all other cells in the grid (including those outside any group) unchanged. In the final grid each identified group will have its type A rows (the top, middle and bottom rows of the pattern) showing a completed pattern with three colored cells (for example, if L, M, R are 2, 4, 6 then a row might read 0, 0, x, 0, y, 0, x, 0, 0, 0) and its type B rows showing a two‐cell pattern at columns (L + 1) and (R − 1). This transformation completes the pattern by “mirroring” the available colored cell from the left side of the incomplete row into its missing counterpart.",
    "1190e5a7.json": "1. Scan the input grid row by row and mark each row that is completely uniform (all cells have the same integer) as a horizontal grid line. From these, choose the common integer value (call it g) that appears in a grid line row. (For example, in some cases g is 7, 8, 1, or 5.)\n2. Partition the grid horizontally by grouping together contiguous rows that are not marked as grid lines. Each such contiguous block of rows represents one cell‐row in the output; the total number of these blocks becomes the height of the output grid.\n3. In the rows that are not grid lines (i.e. in the cell blocks), examine each column index. Mark a column as a vertical grid line if every value in that column (taken only from the non–grid-line rows) equals g.\n4. Partition the grid vertically by grouping together contiguous columns that are not marked as vertical grid lines. Each such group represents one cell–column in the output; the number of such groups is the width of the output grid.\n5. For each resulting cell block (the intersection of one horizontal segment and one vertical segment), select a representative value (for example, the value in the top‐left cell of the block). This value is assumed to be uniform within that block and is the fill number for the corresponding cell in the output.\n6. Construct a new grid whose number of rows equals the number of horizontal segments and whose number of columns equals the number of vertical segments. Set each cell of the output grid to the representative value obtained from the corresponding block.\n7. Return the new grid as the output.",
    "137eaa0f.json": "1. Identify all nonzero cells in the input grid and treat each as a candidate for a pattern. Use 8‐neighbor (adjacent horizontally, vertically, or diagonally) connectivity to group these nonzero cells into components (each component is one pattern).\n2. For each connected component, select its anchor cell. The anchor must be a cell whose value is 5 (which represents gray). (If a component contains more than one cell with value 5, you may choose any one; the examples are consistent with all anchors being 5.)\n3. For every cell in a component with original coordinates (r, c) and with the chosen anchor at (r_anchor, c_anchor), compute its new coordinates in a 3x3 output grid by using the formula:\n  new_row = (r − r_anchor) + 1\n  new_col = (c − c_anchor) + 1\nThis transformation shifts the pattern so that the anchor cell (with value 5) lands exactly at the center of the 3x3 grid (position (1,1)).\n4. For each cell in the component, if the computed new coordinates (new_row, new_col) fall within the bounds [0, 2] (i.e. a valid cell in a 3x3 grid), place that cell’s number at that location in an initially all-0 output grid.\n5. Process all components in this way and overlay their contributions onto the same 3x3 grid (if two patterns write to the same cell, the value will be 5 at the center and all examples show no conflicting nonzero assignments elsewhere).\n6. Return the resulting 3x3 grid. (For example, in a pattern where one component has cells that map to positions (0,0), (0,1) and an anchor at (1,1) with value 5, and another component maps cells to (0,2) and (1,2) with its anchor also at (1,1), overlaying these reproduces the outputs shown in the examples.)",
    "150deff5.json": "1. Make a copy of the input grid (all cells are integers). Do not change any cell whose value is not 5. (In the examples 5 represents gray.)\n2. In the output every cell that was 5 must be changed either to 8 or to 2. (Here 8 stands for light‐blue and 2 for red.)\n3. Consider each contiguous region (by 4–connectivity) of 5’s separately. In each such region you will “tile” part of it with nonoverlapping 2×2 blocks and turn every cell that falls inside a selected block into 8, while every 5 that is not covered by a block will become 2. (The final pattern will then be built only of 2×2 blocks having value 8 and the leftover 5’s changed to 2.)\n4. To select the blocks use the following procedure. Scan the region in reading order (top‐to‐bottom and left–to–right). When you encounter a cell at position (r,c) whose value is 5 and for which the 2×2 square formed by (r,c), (r,c+1), (r+1,c) and (r+1,c+1) is entirely 5, decide as follows:\n a. If this is the first candidate 2×2 block seen in the region (that is, in the topmost part of the region) then mark all four cells in that 2×2 block to become 8.\n b. Otherwise, if a candidate 2×2 block would overlap vertically with a block already chosen earlier in the same region, then do not “retile” the upper row; instead, mark only the lower row of the current 2×2 square to become 8 while leaving the upper row (which may share cells with a previously processed row) as 2.\n5. After you have processed every candidate 2×2 square in every contiguous region of 5’s (making sure that no 5 is used in more than one block), change any cell that was originally 5 but was not reassigned to 8 into 2.\n6. Return the resulting grid. (This procedure produces an output in which the gray areas have been partitioned so that every cell is either red (2) or light–blue (8) and, wherever a full 2×2 block of 5’s was “tiled,” the corresponding 2×2 in the output appears entirely in 8 – except in cases of vertical overlap where the upper row is left as 2. This exactly reproduces the patterns shown in the training examples.)",
    "178fcbfb.json": "1. Determine the grid dimensions (M rows and N columns) from the input.\n2. Scan every cell of the input grid and record the column indices that contain a 2 (red). Collect these indices into a set (call it R); each such column will later be filled entirely with 2.\n3. For each row in the input grid, check for horizontal override markers: if any cell in the row is 3 (green), mark that row to be filled entirely with 3; otherwise if any cell is 1 (blue), mark that row to be filled entirely with 1. (If both 3 and 1 occur in a row, use 3.)\n4. Initialize an output grid of the same dimensions as the input, filling all cells initially with 0.\n5. For each column index in the set R, set every cell in that column (across all rows) in the output grid to 2. This draws vertical red lines in the columns where a 2 was found in the input.\n6. For each row that was marked in step 3, overwrite that entire row in the output grid with the marked value (fill entirely with 3 if a 3 was found in the input row, or with 1 if only a 1 was found). This operation overrides any 2s previously drawn in that row.\n7. Return the output grid.\n\nThis procedure ensures that vertical lines (value 2) appear in every column where a red square (2) occurs in the input, and any row that contains a green square (3) or a blue square (1) is completely filled with that respective value, overriding the vertical red lines where they intersect.",
    "1a07d186.json": "1. Determine the base lines in the grid. For each row, if every cell is nonzero and all cells have the same number, mark that entire row as a horizontal base line (record its row index r_base and its color v). For each column, if every cell is nonzero and all cells have the same number, mark that entire column as a vertical base line (record its column index c_base and its color v). Note that a color v that appears as a base line will be the only color used for attaching extra squares of that color.\n2. Prepare an output grid of the same dimensions as the input and initialize every cell to 0.\n3. For every cell that is part of a base line (i.e. if it lies in a horizontal base row or in a vertical base column), copy its value from the input to the same position in the output. (These cells form the solid continuous line(s) that will not be moved.)\n4. Process every other cell (those not on a base line) that contains a nonzero number v:\n   a. If v matches the color of a vertical base line (that is, there exists a vertical base line with color v at column c_base):\n      i. Keep the row coordinate the same.\n      ii. If the cell’s column c is less than c_base, move this extra square horizontally so its new column becomes c_target = c_base - 1 (i.e. attach it to the left side of the base line).\n      iii. If the cell’s column c is greater than c_base, move it so that c_target = c_base + 1 (i.e. attach it to the right side).\n      iv. Write the number v at the location (row, c_target) in the output grid.\n   b. Else, if v matches the color of a horizontal base line (that is, there is a horizontal base line with color v at row r_base):\n      i. Keep the column coordinate the same.\n      ii. If the cell’s row r is above r_base (r < r_base), move this extra square vertically so its new row becomes r_target = r_base - 1 (attaching it above the base line).\n      iii. If r is below r_base (r > r_base), move it so that r_target = r_base + 1 (attaching it below).\n      iv. Write the number v at the location (r_target, column) in the output grid.\n   c. If v does not match any base line’s color, ignore the cell (leave the corresponding output cell as 0).\n5. Return the output grid. (All cells not part of a base line or not reassigned by an extra square become 0.)\nNote: This procedure uses only numeric comparisons. For example, if a cell with value 3 is extra and there is a vertical base line of 3 at column 3, any extra cell originally to the right (c > 3) moves so that it appears at column 4; if to the left (c < 3) it appears at column 2. For horizontal base lines the extra square’s column remains unchanged while its row is set to one row immediately above or below the base line (r_base - 1 or r_base + 1) according to whether it was originally above or below.",
    "1b2d62fb.json": "1. Recognize that the input grid always has 7 columns and an arbitrary number of rows. The grid is divided by a vertical divider in column index 3 (always containing the value 1), so the meaningful patterns are located in the left part (columns 0, 1, and 2) and the right part (columns 4, 5, and 6).\n2. Create two subgrids: a left subgrid from columns 0–2 and a right subgrid from columns 4–6. Both subgrids have the same dimensions (number of rows and 3 columns each).\n3. Initialize an output grid with the same number of rows as the input and exactly 3 columns.\n4. For each cell position (r, c) where r is the row index (starting from 0) and c is the column index in {0, 1, 2}, do the following:\n   a. Let L = value from the left subgrid at (r, c).\n   b. Let R = value from the right subgrid at (r, c).\n   c. If both L and R are equal to 0, then set the output cell at (r, c) to 8 (representing cyan/light blue).\n   d. Otherwise, set the output cell at (r, c) to 0 (black).\n5. Return the output grid.",
    "1b60fb0c.json": "1. Look at the input grid (10×10) which has a black background (0) and a drawn shape in blue (1). In every example the blue pixels are mostly found in the right‐half of the grid (roughly columns 5–9), so the intended transformation is to complete a four–part (symmetric) design by “adding” the missing section on the left using red (2).\n2. First identify all cells with value 1. (These represent the original blue shape.)\n3. Determine the vertical range where the blue shape is concentrated. In the examples this central band is approximately rows 3 to 7. (This is the region in which the extra section will appear; rows outside that band remain unchanged.)\n4. For each row r within that vertical band that contains blue in the right–half (i.e. where at least one cell in a column ≥5 has a 1), compute a horizontal mirror of (a selected part of) that blue region into the left–half. To do this, use the following idea: \n   • For a given row r in the band, consider only those blue cells that lie in the right–half (columns 5–9) and that appear on the boundary of the blue shape in that row. \n   • For each such blue cell at (r, c) (with c ≥ 5) compute its mirrored column by using the formula: new_col = 9 − c. (This effectively reflects c about the center of the grid because the columns are numbered 0–9.)\n5. In row r, take the set of all computed mirror column positions. Then define the target red section for that row to be the minimal contiguous block spanning those mirror positions. (In some rows this block may be only one cell; in others it may be two or more cells.)\n6. For each cell in this determined block in row r, if the cell is still 0 (background) then set it to 2 (red). Do not change any cell that already is nonzero.\n7. Leave all cells that are not in the central vertical band (approximately rows 3–7) unchanged; all blue (1) cells remain as they were.\n8. The output grid is exactly the same size as the input and now shows the original blue pattern together with an added red (2) section on the left that—when viewed together—forms a four–part symmetric design (the three original parts plus the newly created mirror copy).",
    "1bfc4729.json": "1. Scan the 10x10 input grid (with rows and columns indexed from 0) to locate the two nonzero cells. Choose the nonzero with the smallest row index and call its value TOP_COLOR, and choose the one with the largest row index and call its value BOTTOM_COLOR.\n2. Initialize an output grid of the same 10x10 size with all cells set to 0.\n3. For the top half of the grid (rows 0 to 4):\n   a. In row 0, set every cell (columns 0 through 9) to TOP_COLOR.\n   b. In row 1, set only the first (column 0) and last (column 9) cells to TOP_COLOR.\n   c. In row 2, set every cell to TOP_COLOR.\n   d. In row 3, set only the first and last cells to TOP_COLOR.\n   e. In row 4, set only the first and last cells to TOP_COLOR.\n4. For the bottom half of the grid (rows 5 to 9):\n   a. In row 5, set only the first and last cells (columns 0 and 9) to BOTTOM_COLOR.\n   b. In row 6, set only the first and last cells to BOTTOM_COLOR.\n   c. In row 7, set every cell to BOTTOM_COLOR.\n   d. In row 8, set only the first and last cells to BOTTOM_COLOR.\n   e. In row 9, set every cell to BOTTOM_COLOR.\n5. Return the output grid. (Note: All other cells remain 0.)",
    "1c786137.json": "1. Search the entire grid for a contiguous set of cells that share the same number (for example, 2, 4, 8, 3, etc.). Do this by performing a flood‐fill (or connected-component search) on cells with equal values. For each such region, record its bounding box (minimum row, maximum row, minimum column, maximum column). \n2. For each region’s bounding box, check if every cell along its perimeter—specifically, all cells in the top row (row = min_row), bottom row (row = max_row), left column (col = min_col) and right column (col = max_col)—has the same value (i.e. the same number that defines the region). Also, ensure that the bounding box is at least 3 rows tall and 3 columns wide so that an interior exists. (This uniform perimeter forms the border of a rectangle, for example, a border of value 2 [red], 4 [yellow], 8 [cyan/light blue], or 3 [green].)\n3. When you find the region whose bounding box satisfies the above (i.e. its entire border is made of one identical number), interpret this box as the drawn rectangle. \n4. Extract the subgrid from the input that lies strictly inside this rectangle; that is, take all cells from row (min_row + 1) up to row (max_row - 1) and from column (min_col + 1) up to column (max_col - 1). This extracted subgrid is exactly the grid inside the rectangle.\n5. Output the extracted subgrid. The output grid size will equal the number of rows and columns in the interior (i.e. the total rows and columns of the border minus 2 in each dimension).",
    "1caeab9d.json": "1. Determine all contiguous shapes in the input grid by grouping all nonzero cells that are adjacent using 8‐neighbor connectivity (neighbors may touch horizontally, vertically, or diagonally). Each shape is defined by a set of cells that share the same integer value (for example, 1 for blue, 2 for red, and 4 for yellow).\n2. Identify the reference shape as the one with cell value 1 (blue). Compute the top boundary of this blue shape by finding the smallest row index among its cells; call this value target_top.\n3. For every other shape (i.e., those with values other than 1 such as 2 for red and 4 for yellow), compute its top boundary by finding the smallest row index among its cells (call this shape_top).\n4. Calculate the vertical shift for each non‐blue shape as: shift = target_top − shape_top. This shift may be positive (to move the shape downward) or negative (to move it upward).\n5. For each cell in a non‐blue shape, add the computed shift to its row index while keeping its column index unchanged. Do not alter the relative horizontal positions of cells within each shape.\n6. Construct an output grid of the same dimensions as the input grid. Place every shifted cell (and the blue shape’s unshifted cells) into this grid at its new location; fill all remaining cells with 0.\n7. The result is an output grid in which all shapes (values 1, 2, and 4) share the same top row (target_top) and thus are level vertically.",
    "1cf80156.json": "1. Traverse the input grid (a matrix of integers) and identify every cell whose value is not 0 (remember 0 represents the background/black, while any nonzero value—such as 1, 2, 6, or 8—represents a colored pixel).\n2. Compute the bounding box of these colored pixels by determining: a) the smallest row index (min_row) and the largest row index (max_row) that contain a nonzero cell; and b) the smallest column index (min_col) and the largest column index (max_col) that contain a nonzero cell.\n3. Extract the subgrid from the original grid that spans from row min_row to max_row (inclusive) and from column min_col to max_col (inclusive). This subgrid exactly preserves the arrangement and values of the original colored image (including any 0s that lie within the bounding box).\n4. Output this extracted subgrid as the final result, making no changes to any pixel values.",
    "1e0a9b12.json": "1. Let the input grid have R rows and C columns; each cell holds an integer from 0 to 9, where 0 represents the background (black) and any nonzero value (1–9) represents a colored block (e.g., 1 = blue, 2 = red, 3 = green, 4 = yellow, 5 = grey, 6 = fuchsia, 7 = orange, 8 = cyan, 9 = maroon).\n2. For each column index j (from 0 to C-1), initialize an empty list L to collect the nonzero values in that column.\n3. For each row index i (from 0 to R-1) in column j, if the cell value is not 0, append that value (preserving the order from top to bottom) to L.\n4. Determine the number N of nonzero elements in L. In the output grid, fill column j so that the top (R − N) cells become 0 and the bottom N cells are filled with the values from L in the same order they were collected (i.e. the first element of L goes to row (R − N), the next to row (R − N + 1), and so on until the bottom row).\n5. Replace the original column j with this new column; this simulates gravity causing all colored blocks to “fall” to the bottom while the grid size remains unchanged.\n6. Repeat steps 2–5 for every column to construct the full output grid.",
    "1e32b0e9.json": "1. Identify the grid structure: The input is a 17x17 grid that is divided by two horizontal divider rows (row 5 and row 11) and two vertical divider columns (column 5 and column 11), which partition the grid into nine 5x5 blocks. The cells in these divider rows and columns must not be altered. \n2. Determine the divider value D by inspecting any divider cell (for example, any cell in row 5 or column 5); in the examples D is 8, 2, 1, or 9 according to the input. \n3. Record the pattern P from the top‐left 5x5 block (covering rows 0–4 and columns 0–4). In P, nonzero numbers indicate the shape (for example, a 2, 4, or 3) and 0 represents the background. \n4. For every other 5x5 block (the blocks whose top‐left corners are at (0,6), (0,12), (6,0), (6,6), (6,12), (12,0), (12,6), and (12,12)): \n   a. For each cell in the block with relative coordinates (r, c) where 0 ≤ r, c < 5 (so that the absolute cell is at (block_row + r, block_col + c)): \n      i. If the input cell is nonzero, leave its value unchanged. \n      ii. If the input cell is 0 and the corresponding cell in the pattern P (that is, at (r, c) in the top‐left block) is nonzero, replace the 0 with the divider value D. \n      iii. Otherwise, keep the cell as 0. \n5. Assemble the final grid by using the transformed blocks and by keeping the divider rows (rows 5 and 11) and divider columns (columns 5 and 11) exactly as in the input.",
    "1f0c79e5.json": "1. Identify the 2x2 block in the input grid that contains nonzero values (this is the only colored region in every example). Let its top‐left cell have coordinates (r, c). In all examples the block is 2×2. \n2. In that 2×2 block there are two colors: one is 2 (which represents red) and the other is a non‐2 value. Let X be the non–2 color (for example, X may be 4, 3, 6, 7, or 8 as seen in the examples). \n3. For each cell in the 2×2 block that has the value 2, determine its position within the block as follows (using 0–based local coordinates within the block):\n   • If the red cell is at local position (0,0) then assign a diagonal direction d = (–1, –1).\n   • If at (0,1) then d = (–1, +1).\n   • If at (1,0) then d = (+1, –1).\n   • If at (1,1) then d = (+1, +1).\n4. If there is only one red cell in the block, use its corresponding direction d. If there are multiple red cells (i.e. red appears in more than one of the four positions) then use each unique direction obtained from the red cells. (In some examples three of the four cells are red so two or more distinct directions will be used.) \n5. For each chosen direction d, construct an extension by “sliding” the original 2×2 block along that diagonal. That is, for step k = 0, 1, 2, …, do the following:\n   a. Compute the new tentative top–left coordinate: (r_new, c_new) = (r + k * d_row, c + k * d_col), where d_row and d_col are the row and column components of d.\n   b. For each of the four cells of the block with offsets (0,0), (0,1), (1,0) and (1,1), compute its candidate new coordinate (r_new + offset_row, c_new + offset_col). If a candidate cell lies within the grid bounds (all indices between 0 and grid_size–1), mark that cell to be filled with X in the output.\n   c. Continue increasing k until the block is entirely outside the grid (but include partial placements when some cells are still in–bounds). \n6. Take the union (all cells that were marked from any extension direction) and set those cells in the output grid to X. All other cells in the output remain 0. \n7. The output grid has the same size as the input grid.",
    "1f642eb9.json": "1. Treat the grid as a 10×10 array with rows numbered 0 (top) to 9 and columns numbered 0 (left) to 9. \n2. Identify the region (blob) made of all cells whose value is 8 that are 4‐connected. This blob will remain in the same positions except at its boundaries where some cells will change. \n3. For every row r that contains one or more cells of the blob:\n   a. Determine the leftmost column L and the rightmost column R in that row where a cell is part of the blob.\n   b. Look at all cells in row r with column index less than L. If there is at least one cell with a nonzero value that is not 8, choose the cell with the greatest column index (i.e. the one closest to L) and set the blob cell at (r, L) to that value.\n   c. Look at all cells in row r with column index greater than R. If there is at least one cell with a nonzero value (and not 8), choose the cell with the smallest column index (i.e. the one closest to R) and set the blob cell at (r, R) to that value.\n4. For every column c that contains one or more cells of the blob:\n   a. Determine the topmost row T and the bottommost row B in that column where a cell is part of the blob.\n   b. Look at all cells in column c with row index less than T. If there is at least one cell with a nonzero value (≠8), choose the one with the largest row index among those (i.e. closest to T) and set the blob cell at (T, c) to that value.\n   c. Look at all cells in column c with row index greater than B. If there is at least one cell with a nonzero value (and not 8), choose the one with the smallest row index among those (i.e. closest to B) and set the blob cell at (B, c) to that value.\n5. Leave all other cells unchanged. \n\nThis process pulls in the external nonzero values (for example, 9, 6, 7, 4, 3, 2, 1, etc.) from outside the blob into the blob’s boundary cells, using horizontal (row) and vertical (column) nearest‐neighbor searches. The final output grid is the input grid with only the blob’s edge cells replaced as specified.",
    "1f85a75f.json": "1. Interpret the number 0 as the background. 2. For every cell in the input grid with a nonzero value, use 4-connected (up, down, left, right) connectivity to group cells having the same number into connected components. 3. Among all such connected components, select the one with the greatest number of cells (if there is a tie, choose any one). This component represents the significant shape. 4. Determine the bounding box of the selected component by finding the minimum and maximum row indices and the minimum and maximum column indices occupied by its cells. 5. Create an output grid whose number of rows equals (max_row − min_row + 1) and whose number of columns equals (max_col − min_col + 1). 6. For each cell in this rectangular bounding box, if the corresponding cell in the input belongs to the selected connected component, set the output cell to the component’s digit (for example, 3 in one case, 4 in another, or 2 in the test case); otherwise, set it to 0. 7. Return the constructed output grid.",
    "1f876c06.json": "1. Copy the input grid to the output grid without changing its size. 2. For each nonzero integer value (from 1 to 9) that appears exactly twice in the grid, identify the two occurrences and denote their coordinates as (r1, c1) and (r2, c2). 3. Verify that the two positions lie on a perfect diagonal by checking that the absolute difference |r2 - r1| equals |c2 - c1|. 4. Determine the step to move along the diagonal: let dr = 1 if r2 > r1 or -1 if r2 < r1; similarly, let dc = 1 if c2 > c1 or -1 if c2 < c1. 5. Starting at (r1, c1), iterate in steps of (dr, dc) and set each cell along this diagonal—including both endpoints—to the integer value (which represents the color). 6. Repeat the process for every pair of matching nonzero values in the grid.",
    "1fad071e.json": "1. Create an output grid of fixed size 5 columns and 1 row; set every cell to 0 (black).\n2. In the input grid, iterate over every cell (r, c) such that a 2x2 subgrid can be formed (i.e. for all r from 0 to height-2 and all c from 0 to width-2).\n3. For each 2x2 subgrid defined by the cells at (r, c), (r, c+1), (r+1, c) and (r+1, c+1), check if all four cells are equal to 1 (which represents blue). Ignore other values (e.g., 2 for red).\n4. Count each 2x2 subgrid that is entirely 1 as one blue 2x2 block.\n5. Let N be the total count of such blue 2x2 blocks. In the output grid, fill the leftmost min(N, 5) cells with 1 (blue) and leave the remaining cells as 0 (black).\n6. Return the resulting 5x1 grid.",
    "2013d3e2.json": "1. Treat the input grid as a 10x10 matrix of integers where 0 represents the background. 2. Identify all cells with a nonzero value (i.e. any cell whose value is not 0). 3. Compute the minimal bounding box of the object by finding the smallest row index (min_row) and the smallest column index (min_col) among all nonzero cells. (These coordinates correspond to the top‐left corner of the object.) 4. From the input grid, extract a subgrid of size 3 rows by 3 columns beginning at (min_row, min_col); that is, take the cells at positions (min_row, min_col) through (min_row+2, min_col+2). 5. Return this 3x3 subgrid as the output.",
    "2204b7a8.json": "1. Determine the grid dimensions (number of rows and columns). Then decide which pair of opposite borders is used. • If every cell in the first column (column 1) is nonzero and has the same value (call it A) and every cell in the last column (column N) is nonzero and has the same value (call it B), set the orientation to vertical, with the left border value A and right border value B. • Otherwise, if every cell in the first row (row 1) is nonzero and constant (value A) and every cell in the last row (row M) is nonzero and constant (value B), set the orientation to horizontal, with the top border value A and bottom border value B.\n\n2. For every cell that is not on the border lines (i.e. not in column 1 or column N when the orientation is vertical, or not in row 1 or row M when the orientation is horizontal):\n   a. If the cell’s value is 0, leave it unchanged.\n   b. If the cell’s value is nonzero, compute its distance to the two border lines along the proper axis:\n      • For vertical orientation, let d_left = (current column index - 1) and d_right = (total columns - current column index).\n      • For horizontal orientation, let d_top = (current row index - 1) and d_bottom = (total rows - current row index).\n   c. If the distance to the first border (d_left for vertical or d_top for horizontal) is less than or equal to the distance to the second border (d_right for vertical or d_bottom for horizontal), change the cell’s value to A; otherwise, change it to B.\n\n3. Do not change any cells that are already on the designated border (i.e. the entire first and last column if vertical or the first and last row if horizontal).\n\nThis algorithm replaces every nonzero inner cell with the value of the border (A or B) that it is closer to along the appropriate (horizontal or vertical) axis, using A in case of ties. For example, in a grid where the first column is filled with 5 and the last column with 4 (vertical orientation), an inner cell at (row, column) will be set to 5 if its column index is closer to 1 (or equally distant from 1 and N) and to 4 if it is closer to column N.",
    "22168020.json": "1. For each nonzero number X in the input grid, identify every row that contains at least one cell with value X. Let r_top be the smallest row index where X appears and r_bottom be the largest row index where X appears. \n2. For each such number X, iterate over every row r from r_top to r_bottom (in increasing order). For the current row r, look at all rows from r up to r_bottom and gather every column index c where a cell has value X. Let L be the minimum such column index and R be the maximum such column index. \n3. In row r, change every cell in columns c where L ≤ c ≤ R to X (thus “filling in” any gaps in that horizontal span). \n4. Process all distinct nonzero numbers in the grid this way and leave all other cells (including cells that remain 0) unchanged. \n5. The output grid retains the same dimensions as the input.",
    "22233c11.json": "1. Make the output grid the same size as the input and begin by copying every cell exactly over. \n2. In the input, treat every connected region of 3’s (which represent green) that is arranged diagonally as a single pattern. (Two 3’s that touch diagonally, for example, form a simple diagonal pattern.)\n3. For each such green pattern, determine its minimal bounding rectangle (that is, the smallest block defined by the minimum and maximum row and column indices that contains all its 3’s).\n4. Expand that bounding rectangle by 1 cell in every direction to obtain an extended rectangle. (For example, if the green pattern consists of cells at (3,2) and (4,3) then the minimal rectangle covers rows 3–4 and columns 2–3; when expanded by 1, it spans rows 2–5 and columns 1–4.)\n5. From the four corners of the extended rectangle choose the two corners that lie opposite the side where the green cells are concentrated. In a simple two‐cell diagonal pattern the two green cells will be nearer two opposite corners of the extended rectangle; assign the other two corners to be filled with blue (that is, set those positions to 8, where 8 represents light blue). (In the example above the green cells are nearer (2,1) and (5,4), so the remaining corners (2,4) and (5,1) become blue.)\n6. In cases where the green pattern is thicker than a one–cell–wide diagonal line (for example, when the 3’s form a 2×2 or larger block that still has a predominant diagonal orientation), first determine the effective “center‐line” of the pattern. Then, using the group’s width (the number of cells across that center‐line) as a measure, shift a copy of that center–line perpendicularly by an amount equal to the pattern’s width (i.e. skip that many cells) so that the replicated (blue) pattern is smaller – roughly half the size of the original – and appears on the side opposite the bulk of the 3’s. (The training examples show that a thin, two–cell diagonal yields one blue cell per side, while a thicker diagonal (such as one made from a 2×2 block) yields a blue copy whose number of cells is proportional to half the number of green cells.)\n7. Leave all other cells unchanged. (Remember: all numbers are used directly – here 3 is green and 8 is light blue.)",
    "2281f1f4.json": "1. Scan the input grid’s first row (row 0) and record every column index where the cell value is 5 (this number 5 represents the grey marker placed along the top).\n2. Scan the input grid’s last column (column index equal to the grid width minus one) and record every row index where the cell value is 5 (this number 5 represents the grey marker placed on the right side).\n3. For each row index from step 2 and each column index from step 1, set the cell at that intersection in the output grid to 2 (the red color).\n4. Leave all other cells unchanged from the input grid.\n5. Ensure the output grid retains the same dimensions as the input grid.",
    "228f6490.json": "1. Define the grid coordinates with rows and columns (with (0,0) at the top‐left) and note that all cells hold an integer from 0 to 9; in this task the number 5 represents the gray color (the frame), and 0 represents empty space.\n2. Locate every connected component (using 4‐neighbor connectivity) of cells whose value is 5. These groups are potential frames. For each such group, determine its minimal bounding rectangle.\n3. Within each bounding rectangle, identify the interior hole by taking all cells that are not part of the 5–component. Then, among these cells, select the connected region (by 4–connectivity) that is fully enclosed by the 5’s; this set of positions is the hole that must be filled.\n4. Independently, find every candidate piece in the grid by extracting each connected component (using 4–connectivity) of cells that have a nonzero value different from 5. Each candidate piece will be a contiguous block all having the same digit (for example, 6, 8, 3, 9, or 2 in the examples).\n5. For each candidate piece, compute its shape by normalizing its cell coordinates (subtracting the minimum row and column so that the top–left of the candidate is at (0,0)). Also compute the shapes obtained by rotating the candidate 90°, 180°, and 270°; these rotations are allowed when matching shapes.\n6. For each gray frame identified in step 2–3, normalize the coordinates of its hole (so that the top–left cell of the hole is (0,0)).\n7. For each gray frame’s hole, search among the candidate pieces (that have not yet been used) for one whose normalized shape matches the normalized hole shape in at least one rotation. A match means the set of relative coordinates is identical.\n8. When a match is found, perform a swap: in the output grid, fill every cell in the hole (at its absolute positions inside the frame) with the candidate piece’s digit, and replace every cell of the candidate piece at its original location with 0.\n9. Leave all cells that are not modified by a swap unchanged; note that the gray (5) frame remains intact.\n10. Produce the final 10×10 grid after making all such swaps.",
    "22eb0ac0.json": "1. Treat the grid as a 10x10 array of integers. For each row r (with r from 0 to 9), identify the element at the leftmost column (coordinate (r, 0)) and the element at the rightmost column (coordinate (r, 9)).\n2. Check if the value at (r, 0) is equal to the value at (r, 9) and that this value is not 0. (Here, 0 represents black.)\n3. If both conditions are met, replace every cell in row r with that value. This fills the entire row with the number from the left/right positions.\n4. If the values are different or if the common value is 0, leave row r unchanged.\n5. Output the resulting grid with the same 10x10 dimensions as the input.",
    "234bbc79.json": "1. Delete all columns that are entirely 0. These columns act as separators between parts of the object. 2. For the remaining columns, record each column’s original index and partition them into contiguous groups by original index (that is, group together columns whose original indices are consecutive). In the task data this yields three groups (the left, middle, and right shapes). If a gap appears between groups but two adjacent groups share some vertical overlap, merge them so that exactly three groups result. 3. For each group, scan its cells to find a nonzero value different from 5; use that value as the group’s primary color (for example, a cell with 2, 1, or 3). 4. For every group except the leftmost, determine its anchor row as the row index of the first occurrence of its primary color. Then shift the entire group upward or downward so that its anchor row aligns with the anchor row of the group immediately to its left. (In the examples the merged object ends up spanning 3 rows.) 5. Concatenate the shifted groups horizontally (in left-to‐right order) with no gap; the result is a merged grid whose width is the sum of the group widths and whose height is the minimal span covering all shifted cells. 6. In the merged grid, for each cell whose value is 5 (grey), look at its four neighbors (up, right, down, left) and if exactly one neighbor holds a nonzero value not equal to 5, replace the 5 with that neighbor’s value. (If more than one candidate exists, use the following priority order: right first, then down, then left, then up.) 7. Also, for any cell that is 0 but is sandwiched horizontally or vertically between two cells belonging to the same merged group, fill that cell with that group’s primary color. 8. Return the resulting grid.",
    "23581191.json": "1. Locate the two nonzero cells in the input grid. Let the first cell be at (r1, c1) with value A and the second cell at (r2, c2) with value B (for example, in the provided data A is 8 and B is 7). The rest of the grid is filled with 0.\n2. Create an output grid of the same dimensions as the input, initializing every cell to 0.\n3. For the first colored cell at (r1, c1) with color A:\n   a. Set every cell in row r1 to A. However, if a cell in row r1 is in column c2 (the column of the second square), set that cell to 2 (red) instead.\n   b. Set every cell in column c1 to A. However, if a cell in column c1 is in row r2 (the row of the second square), set that cell to 2 (red) instead.\n4. For the second colored cell at (r2, c2) with color B:\n   a. Set every cell in row r2 to B. However, if a cell in row r2 is in column c1 (the column of the first square), set that cell to 2 (red) instead.\n   b. Set every cell in column c2 to B. However, if a cell in column c2 is in row r1 (the row of the first square), set that cell to 2 (red) instead.\n5. Return the output grid. In the final grid, two full horizontal lines and two full vertical lines are drawn in colors A and B, and at the two cells where a horizontal line from one square meets a vertical line from the other—namely (r1, c2) and (r2, c1)—the cell is set to 2 (red). All other cells remain 0.",
    "239be575.json": "1. Interpret the grid as a 0‐indexed matrix where each cell holds an integer value: 0 represents black, 2 represents red, and 8 represents cyan (light blue).\n2. In every input grid exactly eight red cells (value 2) form two separate 2×2 contiguous blocks (neighbors connected vertically or horizontally). Identify these two red blocks.\n3. For each red 2×2 block, determine its top‐left cell – that is, the red cell in the block with the smallest row index, and if there is more than one in that row, the one with the smallest column index.\n4. For each block, compute a value by multiplying the row index and the column index of its top‐left cell. Call these products P1 and P2. Order the blocks so that the block whose top‐left cell comes earlier (i.e. has a smaller row, or if rows are equal, a smaller column) has product P1 and the other has product P2.\n5. Compute the difference D = P2 − P1.\n6. If D is greater than or equal to 10, produce a 1×1 output grid with the single value 8 (cyan/light blue); otherwise, produce a 1×1 grid with the value 0 (black).",
    "23b5c85d.json": "1. Interpret the input as a two‐dimensional grid of integers where 0 is the background and any nonzero integer (1–9) represents a colored cell. \n2. Identify every contiguous region (object) by grouping cells that share the same nonzero integer and touch each other orthogonally (up, down, left, right). \n3. For each object, compute its area by counting the number of cells in that region. \n4. Select the object with the smallest area (if there is a tie, any one may be chosen). \n5. Determine the minimal bounding rectangle for the selected object by finding the minimum and maximum row indices and the minimum and maximum column indices among its cells. \n6. Construct a new grid whose size is the number of rows from min_row to max_row and columns from min_col to max_col. \n7. Fill every cell in this new grid with the integer value of the selected object (for example, if the object’s value is 8, fill with 8). \n8. Output this new grid.",
    "253bf280.json": "1. For each row in the grid, scan from left to right and record all column positions where the cell value is 8 (which represents light blue). 2. In each row, for every pair of consecutive positions (c1 and c2) that contain an 8, fill every cell between them—that is, for every column c such that c1 < c < c2—by setting its value to 3 (which represents green). Do not change the cells at positions c1 and c2. 3. For each column in the grid, scan from top to bottom and record all row positions where the cell value is 8. 4. In each column, for every pair of consecutive positions (r1 and r2) that contain an 8, fill every cell between them—that is, for every row r such that r1 < r < r2—by setting its value to 3. Do not change the cells at positions r1 and r2. 5. Leave all cells that are not between two 8’s in the same row or column unchanged, and keep the grid dimensions identical.",
    "25d487eb.json": "1. Identify the pattern by scanning the input grid for all cells with a nonzero value. Compute the bounding box of these cells, letting min_row be the smallest row index, max_row the largest row index, min_col the smallest column index, and max_col the largest column index that contain nonzero values.\n2. Determine the two distinct nonzero numbers present in the grid. Count their occurrences and choose the extension color (ext_color) to be the one that occurs fewer times (the minority). (For example, if the grid contains only 1 and 2 and 1 occurs less often than 2, then ext_color = 1.)\n3. Compute the gap from the bounding box to the grid’s edges. That is, calculate:\n   • Upward_distance = min_row\n   • Downward_distance = (grid_height − 1) − max_row\n   • Left_distance = min_col\n   • Right_distance = (grid_width − 1) − max_col\n4. Choose an extension axis by comparing the maximum available distance in the vertical directions with that in the horizontal directions. Define vertical_max = max(Upward_distance, Downward_distance) and horizontal_max = max(Left_distance, Right_distance). If vertical_max is greater than or equal to horizontal_max, select the vertical axis; otherwise, select the horizontal axis.\n5. Within the chosen axis, select the direction that has the larger gap. For a vertical axis, if Upward_distance ≥ Downward_distance then set the direction to upward; else set it to downward. For a horizontal axis, if Left_distance ≥ Right_distance then set the direction to left; else set it to right.\n6. Determine the center of the pattern along the axis perpendicular to the chosen extension. If extending vertically (upward or downward), compute col_center = floor((min_col + max_col) / 2). If extending horizontally (left or right), compute row_center = floor((min_row + max_row) / 2).\n7. From the edge of the bounding box in the chosen direction, draw a straight line to the corresponding grid boundary by filling only those cells that are background (0) with the extension color (ext_color), leaving the original pattern unchanged. In detail:\n   • If the chosen direction is upward, for every row r from 0 to (min_row − 1) set the cell at (r, col_center) to ext_color.\n   • If downward, for every row r from (max_row + 1) to (grid_height − 1) set the cell at (r, col_center) to ext_color.\n   • If left, for every column c from 0 to (min_col − 1) set the cell at (row_center, c) to ext_color.\n   • If right, for every column c from (max_col + 1) to (grid_width − 1) set the cell at (row_center, c) to ext_color.\n8. Return the grid with this extension line added. (Note: In every example the two nonzero numbers represent the pattern, and the extension color is always the one that appears less frequently in the input.)",
    "25d8a9c8.json": "1. For each row in the input grid, determine if all cells in that row have the same integer value. Note that the grid uses numbers 0–9, where 5 represents gray and 0 represents black.\n2. If a row is uniform (i.e., it contains exactly one unique value), fill the corresponding row in the output grid with the number 5 in every cell.\n3. If a row is not uniform (i.e., it contains two or more different numbers), fill the corresponding row in the output grid with the number 0 in every cell.\n4. Ensure that the output grid has the same dimensions as the input grid.",
    "25ff71a9.json": "1. Determine the number of rows (R) and columns (C) in the input grid. 2. Locate the connected group of nonzero cells: scan the grid for a cell with a nonzero value (for example, 1 or 2). When found, perform a flood-fill (using only vertical and horizontal neighbors) to collect all cells that have the same value V (V ≠ 0). 3. Create an output grid of the same dimensions as the input grid. Copy all cells from the input to the output, but set every cell that is part of the identified group to 0 (clearing its original position). 4. For each cell (r, c) in the connected group, compute its new position as (r+1, c) and, if r+1 is less than R, set that position in the output grid to V. 5. Return the output grid. This procedure effectively “drops” the connected group of cells with value V down by one row while leaving all other cells unchanged.",
    "264363fd.json": "1. Find the overall background by scanning the grid’s perimeter; these cells (all with one uniform number) stay unchanged. 2. Partition the remainder of the grid into each contiguous enclosed region (a “box”). In every box the vast majority of cells share the same number – call this the fill value F. (For example, in one case F is 1; in another box F might be 3 or 8.) 3. In each box a small pattern (the removed shape) appears because some cells do not equal F. Locate that small shape and determine its center cell. Denote the row and column (within the box) of this center as r0 and c0. Also record the two numbers that appear immediately adjacent to that center in the shape: the number used in the vertical direction (call it V) and the number used in the horizontal “arm” (call it H). (For instance, one box may have F = 1, with the removed shape’s center originally differing from F. In that case the vertical stroke’s number is 2 and the horizontal arm’s number is 3; in another box the three numbers will be different but are taken directly from the removed shape.) 4. Erase the removed small shape by replacing all of its cells with the fill F so that the box becomes uniformly F. 5. Replicate the (removed) shape’s template in the box by drawing a cross whose location is determined by the original small shape’s center (r0, c0):\n   a. For every row in the box, set the cell in column c0 to V (this draws a vertical stroke through the box).\n   b. For the row r0, replace every cell in that row (from the left edge of the box to its right edge) with V, then change the cell at (r0, c0) to C where C is the center (which may equal H in some cases or be distinct; for example, if the removed shape’s center is later seen as a different number, use that number at the intersection).\n   c. In the row immediately above r0 (if it exists in the box), change the cell immediately to the left of column c0 (that is, at (r0−1, c0−1)) and the cell immediately to the right (at (r0−1, c0+1)) to H. Do the same in the row immediately below r0 (at (r0+1, c0−1) and (r0+1, c0+1)).\n(For example, one training case yields a box with F = 1, a vertical stroke set to 2, and in the replication row every cell becomes 2 except that the center becomes 3; the rows immediately above and below then have their cells next to column c0 changed to 3.)\n6. Do not alter any cells in the box that are not on the column c0, in the row r0, or immediately adjacent (horizontally) to column c0 in the rows directly above and below r0; these remain F. 7. Process every box in this way and leave cells outside all boxes (the background) unchanged. The output grid has the same dimensions as the input.",
    "272f95fa.json": "1. Copy the input grid to the output grid without any changes. 2. Determine the horizontal separator rows by scanning each row and identifying those in which every cell is 8. Let the first such row be H1 and the second be H2. These rows divide the grid into three horizontal zones: the top region (all rows before H1), the middle region (all rows between H1 and H2) and the bottom region (all rows after H2). 3. Determine the vertical separator columns by scanning each column (ignoring the completely filled separator rows) and identifying those in which every cell is 8. Let the first such column be V1 and the second be V2. These columns divide the grid into three vertical zones: the left region (all columns before V1), the center region (all columns between V1 and V2) and the right region (all columns after V2). 4. Overwrite specific subregions in the copied grid as follows while leaving all other cells (including the separator rows and columns, and the corner regions) unchanged: (a) In the top region, fill the center subregion (i.e. rows from 0 to H1-1 and columns from V1+1 to V2-1) with 2. (b) In the middle region, fill the left subregion (rows from H1+1 to H2-1 and columns from 0 to V1-1) with 4, the center subregion (rows H1+1 to H2-1 and columns V1+1 to V2-1) with 6, and the right subregion (rows H1+1 to H2-1 and columns from V2+1 to the end) with 3. (c) In the bottom region, fill the center subregion (rows from H2+1 to the end and columns from V1+1 to V2-1) with 1. 5. Return the modified grid as the output.",
    "27a28665.json": "1. Read the input as a 3x3 grid of integers. Treat 0 as the background and any nonzero integer as the foreground (colored) value (assume exactly 5 foreground cells in each grid).\n2. Record the coordinates (row, column) of every cell that is not 0; use 0-indexing so that the top‐left cell is (0,0) and the bottom‐right cell is (2,2).\n3. Compare the set of foreground cell coordinates to the following patterns and choose the matching one:\n   a. If the foreground cells are exactly at (0,0), (0,1), (1,0), (1,2), and (2,1), then output 1.\n   b. If the foreground cells are exactly at (0,0), (0,2), (1,1), (2,0), and (2,2), then output 2.\n   c. If the foreground cells are exactly at (0,1), (0,2), (1,1), (1,2), and (2,0), then output 3.\n   d. If the foreground cells are exactly at (0,1), (1,0), (1,1), (1,2), and (2,1), then output 6.\n4. Produce a 1x1 grid whose single cell is the output number determined by the matching pattern.",
    "28bf18c6.json": "1. Identify the minimal bounding box of the figure in the input grid. To do this, scan every cell in the grid and record the smallest and largest row and column indices where the cell value is not 0. (Here 0 represents the background and any nonzero digit, for example 8, 2, 1, or 3, represents the figure's color.)\n2. Extract the subgrid defined by these extreme row and column indices. This subgrid is the cropped figure. Its height is (max_row - min_row + 1) and its width is (max_col - min_col + 1).\n3. Create a new output grid with the same number of rows as the cropped subgrid but with twice the number of columns (i.e. output width = 2 * cropped width). The output grid will be constructed by placing two copies of the cropped subgrid side by side.\n4. For each row in the cropped subgrid, copy its cells into the left half of the output grid, then immediately copy the same row into the right half. In other words, for every row r and for every column c in the cropped subgrid, set the output cell at (r, c) equal to the cropped value and the cell at (r, c + cropped_width) equal to the same value.\n5. Return the output grid. This transformation creates an output grid where the original figure is shown twice horizontally, matching the specified dimensions of (height) rows by (2 * width) columns.",
    "28e73c20.json": "1. Treat the input grid as a matrix of cells with coordinates (R, C), where every cell starts with value 0. The goal is to draw a single continuous spiral line by writing the value 3 (green) onto selected cells, leaving the other cells as 0 (black), and the output grid is the same size as the input.\n2. Define the four movement directions in clockwise order as: right (0, +1), down (+1, 0), left (0, -1), and up (-1, 0). Begin with the current direction set to right.\n3. Set the current position to the top‐left cell at (0, 0) and change its value to 3.\n4. Repeat the following until no valid move can be made:\n   a. Let candidate = (current R + dR, current C + dC) where (dR, dC) is the current direction.\n   b. Also compute next2 = (current R + 2*dR, current C + 2*dC) (this is the cell two steps ahead in the same direction).\n   c. If candidate is within the grid boundaries and its value is 0, then check:\n      • If next2 is within the grid and its value is already 3, do not move into candidate because that would cause the new spiral segment to touch an earlier segment; instead, rotate the direction clockwise (choose the next direction in the order) and repeat step 4a.\n      • Otherwise, move to candidate: set current position to candidate and change its value to 3.\n   d. If candidate is out of bounds or its value is not 0, then rotate the current direction clockwise (i.e. right becomes down, down becomes left, etc.) and try step 4a again.\n5. If after checking all four directions no candidate cell can be filled (that is, every direction either is blocked by the grid edge, already has a nonzero value, or would force the spiral to touch an existing 3 because the cell two steps ahead is 3), terminate the process.\n6. The resulting grid, with a spiral path of 3’s drawn continuously without touching (the gap is enforced by never advancing when the cell two steps ahead is 3), is the output.",
    "29623171.json": "1. Determine the grid’s structure: the input grid is divided into 9 boxes arranged in 3 rows and 3 columns. In all provided examples the grid is 11×11 and the border cells (with value 5) form full horizontal lines at rows 3 and 7 and full vertical lines at columns 3 and 7. These border cells must remain unchanged in the output.\n2. Define each box as the collection of cells that lie strictly between the border rows and border columns. For example, the top‐left box consists of the cells in rows 0–2 and columns 0–2; the top‐middle box is rows 0–2 and columns 4–6; and so on.\n3. For every one of the 9 boxes, examine only its nonborder (internal) cells. Count the number of colored cells in the box, where a colored cell is any cell whose value is not 0 (recall that 0 represents black). Do not include any border cells in these counts.\n4. Find the maximum count among all 9 boxes.\n5. For each box, if its count equals the maximum then:\n  a. Identify the unique nonzero value in that box (e.g., if the nonzero cells are 1, 2, 3, etc., use that number). It is assumed that in a winning box all nonzero cells have the same value.\n  b. Overwrite every cell inside that box (all the nonborder cells) with that nonzero value.\nOtherwise, overwrite every cell in the box with 0.\n6. Leave all border cells (cells that are originally 5 at rows 3 and 7 and columns 3 and 7) exactly as they were.\n7. Return the output grid, which has the same dimensions as the input grid, with each of the 9 boxes filled entirely with either the winning nonzero color (if that box had the maximum count of colored cells) or with 0 (black) if not.",
    "29c11459.json": "1. For each row in the input grid (which is 5 rows by 11 columns), check if the cell in column 0 and the cell in column 10 are nonzero (i.e. not 0). These two cells represent the left and right marker values for that row. 2. If both cells are nonzero, let L be the value of the cell at column 0 and R be the value of the cell at column 10. Replace the entire row with a new row constructed in this order: set columns 0 to 4 to L (repeating the left marker 5 times), set column 5 to 5 (the constant filler value representing gray), and set columns 6 to 10 to R (repeating the right marker 5 times). 3. If the row does not have nonzero values at both column 0 and column 10, leave it unchanged. 4. Output the grid with the same dimensions as the input grid.",
    "29ec7d0e.json": "1. For each row in the input grid (which has the same number of columns as the output), check if the row contains any 0’s (recall that 0 represents black). If the row has no 0’s, copy it unchanged to the output. \n2. If a row contains one or more 0’s, infer an underlying repeating horizontal pattern that the row is meant to follow. Do this by searching for the smallest positive integer L (with 1 ≤ L ≤ number_of_columns) that can serve as a cycle length such that for every cell in that row whose value is not 0, its value is consistent with a pattern value at position (column_index mod L). In other words, initialize an array P of length L with no assigned values. Then, for each column index i from 0 to (n−1):\n  a. If the cell at (row, i) is not 0, let j = i mod L. If P[j] is not yet assigned, set P[j] to the cell’s value; if P[j] is already assigned, then it must equal the cell’s value. If a conflict occurs, reject L and try the next L.\n3. When you find the first (smallest) L for which no conflict occurs (and every nonzero cell is consistent with P), adopt the resulting pattern P as the intended cycle for that row. (Any positions in P left unset will have been determined indirectly by later nonzero cells; in all provided examples each congruence class is defined by at least one nonzero cell.) \n4. Fill the entire row by writing, for each column index i from 0 to n−1, the value P[i mod L]. \n5. Process every row in the grid in this manner so that all 0’s are replaced by numbers from the inferred cycle, and the order of the nonzero values is preserved in their corresponding positions. \n6. The final output grid has the same dimensions as the input grid and contains no zeros; every originally missing (black) cell is now filled with the appropriate number according to the row’s repeating pattern.",
    "2bcee788.json": "1. Find all nonzero cells in the input grid; these cells belong to two connected regions (using 4‐directional connectivity). One region is the primary shape and the other is the secondary shape. Use the count of cells in each; the region with more cells is the primary shape and its value (for example 1, 4, 6, 7, 8, etc.) will be used later.\\n2. Identify at least one pair of adjacent cells (neighbors horizontally or vertically) where one cell (p) is in the primary shape and the other (q) is in the secondary shape.\\n3. Determine the mirror axis from the contact between the shapes. If p and q are adjacent horizontally (i.e. they lie in the same row with columns differing by 1), set the mirror axis to be vertical with column coordinate M = (c_p + c_q)/2. If p and q are adjacent vertically (i.e. they lie in the same column with rows differing by 1), set the mirror axis to be horizontal with row coordinate M = (r_p + r_q)/2. (Note: the mirror line will be at a half‐integer position, for example 4.5 or 5.5.)\\n4. For every cell in the primary shape with coordinates (r, c), compute its reflected coordinate as follows:\\n   • If the mirror axis is vertical (at column M), let the reflected cell be (r, c') where c' = 2*M – c.\\n   • If the mirror axis is horizontal (at row M), let the reflected cell be (r', c) where r' = 2*M – r.\\n5. Create an output grid that has the same dimensions as the input and fill every cell with the background value 3. (The number 3 represents green.)\\n6. Copy the primary shape into the output grid at its original positions, using its original numeric value.\\n7. Also copy the reflected primary shape into the output grid at the computed coordinates, overwriting any values (including any part of the secondary shape).\\n8. Return the output grid. This transformation thus creates an output where the entire background is 3 and the primary shape (in its original color) appears in its original location as well as in a mirrored location determined by the side where the secondary shape (the smaller one) touches it.",
    "2bee17df.json": "1. Treat the grid as a matrix with rows numbered from 1 (top) to N (bottom) and columns from 1 (left) to M (right). Do not change any cell whose original value is not 0. Only cells with value 0 (the black cells) are candidates for change. \n2. Define the inner region as all cells that are not part of the outermost border (that is, ignore row 1, row N, column 1, and column M). In every row of this inner region the 0’s appear in one or more contiguous groups (segments). In many examples the overall 0 region is “punctuated” by non‐0 cells that form a thicker border on one side. (For example, in the provided cases the nonzero border cells use values 2 or 8, while the interior is 0.) \n3. Establish a T–shaped overlay by “drawing” two strokes in the inner region and leaving the outer border unchanged:\n   a. Horizontal stroke: In any row where a contiguous segment of 0’s runs uninterrupted from a left “one–deep” edge to a right “one–deep” edge (that is, the segment touches the boundary of the inner region on both left and right because the adjacent cell just outside the segment has a nonzero value), replace every 0 in that entire segment by 3. These row(s) (which occur in the middle of the inner region) form the horizontal bar of the T.\n   b. Vertical stroke: In every other row of the inner region (those that do not exhibit a full horizontal segment spanning from a one–deep left edge to a one–deep right edge), identify the (or one of the) contiguous 0 segment(s) and choose the cell or cells that lie immediately next to a change from 0 to a nonzero value on the side that will connect with the horizontal stroke. In practice this means that, for each such row, change only the 0 cell(s) whose column index is selected so that when one looks vertically, the changed cell(s) line up with the 0’s replaced by 3 in the horizontal stroke rows. (In the given examples this selection yields a single column (for example, column 4 in 10×10 grids) or a pair of adjacent columns (for example, columns 5–6 in a 12×12 grid) that form a continuous vertical line connecting the horizontal stroke with the 0’s in higher and lower rows.) \n4. In summary, the output grid is obtained by copying the input unchanged except that in the inner region the 0’s are replaced by 3 in a T–shaped pattern: a full horizontal band (where the contiguous 0 block spans from a one–cell–deep left side to a one–cell–deep right side) and a vertical stem (in all other inner rows, only the 0 cell(s) in the appropriate column(s) are replaced by 3 so that they join the horizontal band). \n5. Return the resulting grid.",
    "2c608aff.json": "1. Find the background value by examining all cells on the border of the grid; assume that every border cell has the same value (for example, 8 in some cases or 2 or 1 in others). \n2. Identify every contiguous region (via 4‐connectivity) of cells whose value is not equal to the background. Among these regions, select the one with the greatest number of cells; call this the central block. \n3. Compute the bounding box of the central block by noting its minimum row (r_min), maximum row (r_max), minimum column (c_min) and maximum column (c_max). (For instance, in one example the central block has value 3 and spans rows 1–4 and columns 2–4; in another the block has value 1 spanning rows 2–4 and columns 3–5; in other examples the central block is 4 or 5.) \n4. For every cell in the grid that is not background and is not part of the central block (a “dot”), check if it is aligned in a straight line (horizontally or vertically) with the central block. Do this as follows:\n   • If a dot’s row r is between r_min and r_max (inclusive), then it is horizontally aligned with the central block. \n     – If its column c is less than c_min, then for every column k from c up to (c_min − 1), set the cell (r, k) in the output to the dot’s value.\n     – If its column c is greater than c_max, then for every column k from (c_max + 1) up to c, set the cell (r, k) to the dot’s value.\n   • If a dot’s column c is between c_min and c_max (inclusive), then it is vertically aligned with the central block. \n     – If its row r is less than r_min, then for every row k from r up to (r_min − 1), set the cell (k, c) to the dot’s value.\n     – If its row r is greater than r_max, then for every row k from (r_max + 1) up to r, set the cell (k, c) to the dot’s value.\n5. Leave all other cells unchanged. \n6. Return the resulting grid (which has the same dimensions as the input) in which any dot that is in the same row or column as the central block has been connected by filling in all intervening background cells with the dot’s numeric value.",
    "2dc579da.json": "1. Determine the dimensions of the input grid. Let N be the number of rows and M be the number of columns (both N and M are odd). 2. Compute the middle indices using integer division: mid_row = N // 2 and mid_col = M // 2. In a zero‐indexed grid, the row at index mid_row and the column at index mid_col form a cross that is not part of any quadrant. 3. Divide the grid into four quadrants by excluding the center row and center column:\n   - Top‐left quadrant: all cells with row indices 0 to mid_row - 1 and column indices 0 to mid_col - 1.\n   - Top‐right quadrant: all cells with row indices 0 to mid_row - 1 and column indices mid_col + 1 to M - 1.\n   - Bottom‐left quadrant: all cells with row indices mid_row + 1 to N - 1 and column indices 0 to mid_col - 1.\n   - Bottom‐right quadrant: all cells with row indices mid_row + 1 to N - 1 and column indices mid_col + 1 to M - 1.\n4. For each quadrant, verify whether it is uniform; that is, check if every cell in the quadrant has the same integer value. (For example, a quadrant might be entirely filled with 8’s or 4’s.) 5. Identify the quadrant that is not uniform. In that quadrant, exactly one cell will have a value different from all the other cells. (In the examples, three quadrants are completely uniform while one quadrant contains a single anomaly such as 4 among 8’s, 1 among 4’s, or 8 among 3’s.) 6. Output the identified non-uniform quadrant exactly as it appears (preserving the relative positions of its cells). This extracted quadrant becomes the final output grid.",
    "2dd70a9a.json": "1. Locate the two major colored regions in the grid: the red object (cells with value 2) and the green object (cells with value 3). (If one is missing—as in some test cases—treat the available object’s external boundary as the endpoint for the connection.)\n2. For each object, choose one representative boundary cell that faces the other object. Call the red cell (Rr, Rc) and the green cell (Gr, Gc). In many examples the red region lies to one side (for example, to the right of the green region) so that Rc > Gc; when they are not already horizontally separated, a horizontal extension will be used (see step 3).\n3. Determine the horizontal meeting column (c_meet) as follows:\n • If the two objects are already separated horizontally (that is, Rc and Gc differ), then take the red object’s representative column and the green object’s representative column as the endpoints of the horizontal segment (using the smaller as the left endpoint and the larger as the right endpoint). For instance, when the green object is to the left (Gc) and the red object is to the right (Rc), the intended horizontal connector will span from column Gc to column Rc.\n • If the two objects are nearly vertically aligned (Rc equals or is very near Gc), then from each representative cell extend horizontally in the direction away from the object’s interior. Do this by moving through cells that are 0 until immediately before you would hit a nonzero cell (usually an obstacle such as a blue cell with value 8). Then choose c_meet to be the lesser extension reached (so that both sides meet at the same column).\n4. Determine the vertical endpoints by taking the row of the red representative cell (Rr) and the row of the green representative cell (Gr). These rows mark where the connection must reach each object.\n5. Draw the L‐shaped connection by “painting” over only 0 cells (never overwriting an existing nonzero cell except where the connection is added) with 3 (green):\n a. In the row of the green representative cell (or in its horizontal extension, if one was needed), fill every 0 between its original column (or extension endpoint) and the meeting column c_meet with 3.\n b. In the row of the red representative cell (or its horizontal extension), fill every 0 between its original column (or extension endpoint) and c_meet with 3.\n c. In the column c_meet, fill every 0 between the two rows (from the green side up or down to the red side) with 3.\n6. In every direction (horizontal or vertical) when “filling” the connection, stop immediately before a cell that is not 0 (for example, do not overwrite a blue cell, value 8) and do not alter any cells that already have a nonzero value aside from replacing 0’s with 3 on the connection path.\n7. The overall effect is that the output grid remains the same size as the input grid and identical except that a continuous L‐shaped (or composite orthogonal) path of green (3) now connects the red (2) object to the green (3) object (or extends from the red object when no green object is present).",
    "2dee498d.json": "1. Read the input grid of numbers having R rows and C columns.\\n2. Recognize that the grid is composed of three contiguous horizontal blocks (segments) that represent repeated instances of a pattern. Compute the width of one block as block_width = C / 3.\\n3. For each row (indexed from 0 to R-1), extract the sub-row consisting of the first block_width elements (i.e., columns 0 to block_width - 1). This subgrid is the leftmost occurrence of the repeating pattern.\\n4. Construct the output grid using these extracted rows. The resulting grid will have R rows and block_width columns, and it is the zoomed-in version of one example of the repeated pattern.",
    "31aa019c.json": "1. Examine the input grid and count the occurrences of each nonzero cell value. Identify the unique value V (V > 0) that appears exactly once; let its coordinates be (R, C). 2. Create an output grid of the same dimensions as the input and fill every cell with 0 (representing black). 3. For every cell (i, j) in the output grid that lies within the 3x3 block centered at (R, C) – that is, for each i from R - 1 to R + 1 and each j from C - 1 to C + 1 that is within the grid bounds – set the cell’s value to 2 (representing red). 4. Then set the center cell at (R, C) in the output grid back to V (the unique cell’s original value). 5. Return the output grid.",
    "321b1fc6.json": "1. Find every connected region (using 4‐connectivity) of nonzero cells (where 0 represents black).\n2. Count the nonzero values over the whole grid and let M be the value that occurs most frequently. (In the given examples M = 8.)\n3. From all nonzero cells whose value is not M, form the multi‐colored template pattern. To do this, compute the minimal bounding rectangle that spans every cell with a nonzero value other than M. In each row of that bounding box, if the cells present are not enough to cover the full width but are all the same value, assume the entire row of the rectangle is that value; if they cover the row and show horizontal variation, keep the variation. (For example, in Example 1 the template is a 2×2 block with top row [7,6] and bottom row [9,4] while in Example 2 the union of cells with values 7 and 6 forms a 2×3 block where the top row is all 7 and the bottom row is all 6.)\n4. For every connected region whose cells all equal M (the majority color), determine its minimal bounding rectangle (target box). Then, for each cell in that region, compute its relative coordinates within the target box and use a proportional (integer) scaling to map that position to a corresponding cell in the template’s bounding box. Replace the cell’s value with the value from the template at the mapped position. (When the sizes match—as in a 2×2 region mapping to a 2×2 template or a 2×3 region mapping to a 2×3 template—the pattern is copied exactly.)\n5. Replace every cell that originally belongs to any region with a non‐M value (the ones that provided the template) with 0 (black).\n6. Leave all 0 cells unchanged and keep the grid size the same.",
    "32597951.json": "1. Scan the input grid to locate every cell whose value is 8 (which represents light blue). Record the row and column indices of these cells.\n2. Compute the smallest and largest row indices (r_min and r_max) and the smallest and largest column indices (c_min and c_max) among all cells with value 8. These four numbers define an axis‐aligned bounding box that encloses all 8’s.\n3. For every cell in the grid with coordinates (r, c) such that r_min ≤ r ≤ r_max and c_min ≤ c ≤ c_max, check its value. If the cell’s value is not 8, change it to 3 (which represents green). Leave any cell already 8 unchanged.\n4. Leave all cells outside the bounding box unchanged.\n5. Output the resulting grid (which has the same dimensions as the input).",
    "3345333e.json": "1. Determine the base color by scanning the entire input grid and selecting the nonzero value that appears most frequently; call this value B (for example, in the given examples B is 6 in one case and 2 in another). 2. Find the overall horizontal bounding box of all cells equal to B by iterating over every cell in the grid; let L be the smallest column index and R be the largest column index at which a cell with value B occurs anywhere in the grid. 3. In every cell of the grid, if the cell’s value is not B, set that cell to 0 (background). (Leave rows that have no B unchanged.) 4. For each row that contains at least one cell with value B (after step 3), do the following: for every column index x in that row where the cell is B (as preserved from the input), compute the mirror column m = L + R − x and set the cell at that row and column m to B. 5. Return the resulting grid, which will be the same size as the input grid.",
    "3428a4f5.json": "1. Locate the separator row by scanning the input grid from top to bottom and identifying the row in which every cell is 4 (yellow). This row divides the grid into two equal‐sized parts. 2. Define the top pattern as all rows above the separator row and the bottom pattern as all rows below it; note that both patterns have the same number of rows and the same number of columns as the input grid. 3. Create an output grid with the same dimensions as the top pattern. 4. For each cell with coordinates (r, c) in the top pattern, let A be the value at (r, c) in the top pattern and B be the value at (r, c) in the bottom pattern (using the corresponding relative row from the bottom part). 5. If A equals B (which, given the examples, means both are either 0 [black] or 2 [red]), then set the output cell at (r, c) to 0 (black). 6. If A differs from B (i.e. one is 0 and the other is 2), then set the output cell at (r, c) to 3 (green). 7. Return the completed output grid.",
    "3618c87e.json": "1. Assume the grid is 5 rows by 5 columns with rows indexed 0 to 4 and columns indexed 0 to 4. 2. In the input grid, scan row 2 (the third row) and for each column, check if the cell’s value is 1 (which represents blue). 3. For every cell in row 2 that is 1, set that cell to 0 in the output grid (i.e. remove the blue dot from row 2). 4. Then, in the same column, overwrite the cell in row 4 (the fifth row) with 1, regardless of its current value (thus moving the blue dot two rows down). 5. Leave all other cells unchanged. 6. Return the modified grid as the output.",
    "3631a71a.json": "1. Make an exact copy of the input grid (a rectangular array of numbers with R rows and C columns) to serve as the initial output. 2. Although many inputs already show a multicolored pattern that is symmetric both horizontally and vertically, in some cases a contiguous rectangular region (a “box”) does not follow the expected symmetry – that is, its cells do not match the pattern seen in the rest of the grid. (In grids where every cell already fits the symmetric pattern the output remains identical to the input.) 3. In an input with a missing‐pattern box, first determine the bounding coordinates of the box. (For example, if the anomalous region spans rows r_top through r_bot and columns c_left through c_right, then that box is “missing” the proper pattern.) 4. Compute the mirror (opposite) box by reflecting the coordinates about the center of the grid. That is, let the mirror box have top row r_mtop = R − 1 − r_bot, bottom row r_mbot = R − 1 − r_top, left column c_mleft = C − 1 − c_right, and right column c_mright = C − 1 − c_left. 5. For every cell in the missing box (with coordinates offset (r, c) measured relative to the box’s top‐left corner), replace its value in the output with the value from the cell at the corresponding relative position in the mirror box (that is, from the cell at (r_mtop + (r − r_top), c_mleft + (c − c_left)) in the input). 6. Return the modified grid. (This process exactly “mirrors” the intact pattern from the opposite side of the grid into any box where the pattern is missing.)",
    "363442ee.json": "1. Extract the 3x3 pattern P from the top‐left corner of the input grid—that is, let P be the cells at rows 0 to 2 and columns 0 to 2. Note that the center of P is at position P[1][1].\n2. Initialize the output grid as a copy of the input grid (all cells remain unchanged at first).\n3. Scan every cell in the input grid. For each cell at coordinate (r, c) whose value is 1 (recall: 1 represents blue), prepare to overlay the pattern P.\n4. For each blue cell found at (r, c), compute the top‐left coordinate where P should be pasted so that its center aligns with (r, c). This coordinate is (r - 1, c - 1).\n5. For each offset i = 0, 1, 2 and j = 0, 1, 2, set the cell in the output grid at (r - 1 + i, c - 1 + j) to the value P[i][j].\n6. Process all blue cells in this manner. (If overlays overlap, later pastes will overwrite earlier ones, as seen in the examples.)\n7. The final output grid retains the same dimensions as the input grid and includes all pasted copies of the original 3x3 pattern over each blue (1) cell.",
    "36d67576.json": "1. Make the output grid exactly the same size as the input and begin by copying every pixel from the input into the output without change. 2. Locate every contiguous group of pixels that have the value 4 (yellow) in the grid; treat groups whose pixels are adjacent vertically as a vertical group and those adjacent horizontally as a horizontal group. 3. For each vertical group of 4’s (all in the same column and touching vertically), index the yellow pixels from top to bottom starting at 0. For each yellow pixel in such a group, if its index is even and the cell immediately to its left (same row, one column less) currently holds 0, set that cell to 3 (green); if its index is odd and the cell immediately to its right (same row, one column more) is 0, then set that cell to 1 (blue). 4. For each horizontal group of 4’s (all in the same row and contiguous), if the cell immediately to the left of the entire group is 0, set that cell to 1 (blue). 5. In all cases do not overwrite any cell that already contains a nonzero value. This procedure overlays an extra pattern (using 1 for blue and 3 for green) around the yellow (4) shapes exactly as exhibited in the training examples.",
    "36fdfd69.json": "1. Copy the input grid exactly to start the output grid. 2. In the input, treat any cell with value 2 as a red cell. Identify red structures by grouping red cells that are close: use 8‐neighbor connectivity (that is, cells are considered connected if they touch horizontally, vertically, or diagonally) and, in addition, if two red cells occur in the same row with exactly one intervening cell, treat them as belonging to the same structure. 3. For each such red structure, compute its minimal axis‐aligned bounding rectangle; that is, let Rmin and Rmax be the minimum and maximum row indices and Cmin and Cmax be the minimum and maximum column indices among all red (2) cells in the group. 4. In every cell (r, c) within that rectangle (for r from Rmin to Rmax and c from Cmin to Cmax), if the input cell is not red (i.e. its value is not 2), set the corresponding output cell to 4 (yellow). Leave any cell that is already 2 unchanged. 5. Do not modify any cells outside all such computed rectangles. This procedure “completes” each red structure into a full rectangle whose interior is filled with yellow (4) wherever the original cell was not red, while preserving the original red (2) cells.",
    "3906de3d.json": "1. Interpret the grid as an n×m matrix with rows numbered from 1 (top) to n and columns from 1 (left) to m. In the grid the number 0 represents the black background, 1 represents the fixed pattern (blue in the human description) and 2 represents the red cells that need to be moved upward. \n2. Process the grid one column at a time. For each column:\n   a. Starting at row 1, scan downward and collect the top contiguous block of non‐zero cells (i.e. cells whose value is not 0). Let k be the number of rows in this uninterrupted block. These cells (rows 1 to k) form the fixed upper part of the column and remain unchanged in the output.\n   b. Count the total number of red cells (i.e. cells with value 2) present anywhere in that column in the input. Let this count be red_count.\n   c. In the output grid for that column, leave rows 1 to k unchanged (copy from the input). Then, for the next red_count cells (i.e. rows k+1 through k+red_count), set their value to 2. \n   d. Set all remaining cells in that column (from row k+red_count+1 to the bottom) to 0.\n3. Apply the above procedure to every column. The resulting grid will have the same dimensions as the input and will show that all red cells (2) have been shifted upward in their own column to fill the first available black (0) gaps immediately after the top uninterrupted block of nonzero values.",
    "39a8645d.json": "1. Scan the entire input grid (a 2D array of integers 0–9) and for every cell that is nonzero (background is 0), perform a flood‐fill using four‐direction connectivity (up, down, left, right) to extract each connected component. Each connected component has a uniform nonzero value (its color; for example, 2 represents red, 3 green, 4 yellow, 8 cyan/light blue, etc.).\n2. For each connected component, compute its minimal bounding box by finding the minimum and maximum row and column indices that contain its cells.\n3. Normalize the component’s pattern into a 3×3 grid (this is the “zoom” operation). Let H be the height (r_max − r_min + 1) and W the width (c_max − c_min + 1) of the bounding box. Then for each cell (i, j) in the 3×3 output grid (with i and j in {0, 1, 2}), compute the corresponding position in the original grid as follows:\n  row = r_min + round(i × (H − 1) / 2)\n  col = c_min + round(j × (W − 1) / 2)\nIf the cell at (row, col) is part of the connected component, set the (i, j) cell in the normalized grid to the component’s nonzero value; otherwise, set it to 0.\n4. Treat each resulting 3×3 grid as the extracted object pattern. Two patterns are considered identical only if all corresponding cells match exactly (both the positions of nonzero values and the specific nonzero number).\n5. Count the frequency of each distinct normalized 3×3 pattern from all connected components found in the input.\n6. Select the pattern that occurs most frequently. (If there is a tie, any of the most frequent patterns may be chosen.)\n7. Output the selected 3×3 grid exactly as produced. In the output, nonzero cells retain their object’s number (for instance, 8 for cyan/light blue, 4 for yellow, 2 for red, etc.) and background cells are 0.",
    "39e1d7f9.json": "1. Make the output grid the same size as the input and start by copying every cell over.\n2. Notice that the input is organized by fixed‐value separator rows or columns (for example, rows entirely filled with 8 or, in some cases, columns at fixed intervals having 3 or 8). These separators partition the grid horizontally (and/or vertically) into rectangular regions (or, in some cases, into fixed‐length groups along each row).\n3. In each such region (or in each block between separator columns in a row), treat the group of contiguous cells (i.e. the block that does not include the separator) as a subpattern. In every occurrence of the subpattern, check if all the cells are 0 (which represents “empty” or missing part). Such a block is considered incomplete.\n4. For each incomplete block, search the rest of the grid for the corresponding block (i.e. in the same relative position within its band or row) that is complete – that is, one whose cells are not 0. (In the examples the complete blocks are filled uniformly with a nonzero digit such as 6, 4, or 3.)\n5. Replace every 0 in the incomplete block with the digit found in the complete block, reproducing its pattern exactly (cell‐for‐cell over the entire block).\n6. In rows that are divided into fixed groups (for example, groups of three cells separated by a cell holding 3 or 8), do the same: for any group that is entirely 0, look at other rows in the same grid that have a nonzero version of that same group (the complete subpattern) and change every cell in the group from 0 to that value.\n7. Do not alter any separator cells (the cells that are always the same such as 8 or 3), so that the overall block structure remains intact.\n8. Finally, output the grid with all formerly incomplete subpatterns now filled with the replicated complete pattern.\n\n(Note: All numbers refer to colors by the mapping: 0 = black, 3 = green, 4 = yellow, 6 = pink/fuchsia, 8 = cyan/light blue. Thus, for instance, when a block of 0’s is replaced with 6’s, you are effectively copying the pink pattern from a complete instance into a missing area.)",
    "3aa6fb7a.json": "1. Start by copying the input grid to an output grid of identical size. 2. For every contiguous 2x2 block in the grid (i.e. for each cell at position (r, c) where the block is defined by the cells (r, c), (r, c+1), (r+1, c) and (r+1, c+1)), do the following:  a. Check the values of the four cells.  b. If exactly three of these cells contain the value 8 and the remaining cell contains 0, then this 2x2 block represents an incomplete square with one missing “corner”. 3. In each such block, replace the cell that is 0 with the value 1 (recall that 1 corresponds to blue). 4. Leave all other cells unchanged. 5. Return the modified grid as the final output.",
    "3ac3eb23.json": "1. Determine the number of rows (R) and columns (C) of the input grid.\\n2. In the first row (row 0), scan all columns to identify seed cells. A cell is a seed if its value is not 0. For each seed, record its column index c and its integer value v (for example, 2, 4, 3, 6, 7, etc).\\n3. Initialize an output grid with dimensions R x C, filling every cell with 0.\\n4. For each row r from 0 to R-1, and for each recorded seed (at column c with value v):\\n   a. If r is even (that is, r mod 2 = 0), then set the cell at (r, c) to v. This places the seed value directly below its original position in every even row.\\n   b. If r is odd (that is, r mod 2 = 1), then check the horizontal neighbors: if c - 1 is within the range 0 to C-1, set the cell at (r, c - 1) to v; if c + 1 is within the range 0 to C-1, set the cell at (r, c + 1) to v. This creates a three‐column (checkerboard) pattern for each seed where the seed’s column is used on even rows and its immediate neighbors are used on odd rows.\\n5. After processing all rows and all seed cells, return the output grid as the transformed grid.",
    "3af2c5a8.json": "1. Let the input grid have R rows and C columns, with each cell containing an integer between 0 and 9 (for example, in the training examples values such as 0, 3, 4, and 8 are used). Coordinates (r, c) are counted from the top‐left corner with r in [0, R-1] and c in [0, C-1].\n2. For each row in the input grid, create an extended row by appending the horizontal mirror of that row. This is done by taking the row as a list [a0, a1, …, a(C-1)] and concatenating it with its reverse [a(C-1), …, a1, a0]. The result is an extended row of length 2 * C.\n3. Form the top half of the output grid by processing each input row in order and replacing it with its extended row from step 2. The resulting block has R rows and 2 * C columns.\n4. Form the bottom half of the output grid by taking the rows of the top half in reverse order. That is, if the top half rows are labeled from 0 to R-1 in order, then the bottom half will consist of the rows in the order R-1, R-2, …, 0.\n5. Combine the top half (step 3) and the bottom half (step 4) vertically to produce the final output grid with dimensions 2 * R by 2 * C.\n6. Output the final grid, ensuring that each cell retains its original integer value and that the grid is a correctly mirrored version both horizontally (within each row) and vertically (across rows).",
    "3bd67248.json": "1. Copy the input grid to a new output grid without changing any cells initially.\n2. Let n be the number of rows and m be the number of columns in the grid. Assume rows are numbered 1 to n from top to bottom and columns 1 to m from left to right.\n3. For each row i from 1 to n-1, set the cell at row i and column (m - i + 1) to 2. This draws a diagonal line (using the number 2 for red) starting at the top right corner and moving diagonally down and to the left; note that this step does not affect the bottom row.\n4. For the bottom row (row n), for every column j from 2 to m (i.e. all cells except the first column), change the cell value to 4. This forms a horizontal line (using the number 4 for yellow) along the bottom row while preserving the original value in the first column.\n5. Leave all other cells unchanged. (The input grid may already contain a vertical line in the first column with values such as 5, 6, or 8; do not modify these cells.)",
    "3bdb4ada.json": "1. Maintain the grid dimensions; the output grid must have the same number of rows and columns as the input.\n2. Identify every rectangular region of uniform nonzero value (where the value is one of 1–9) that spans exactly three consecutive rows. In each region, a contiguous block of cells in row i−1 (the top row) and row i+1 (the bottom row) share the same nonzero digit X and lie in the same set of consecutive columns. The middle row (row i) of that three‐row group is the candidate for transformation.\n3. For each identified rectangular region (for example, a region of 4’s, 5’s, 7’s, 8’s, etc.), leave the top and bottom rows exactly as in the input. In the middle row of that region, replace the contiguous block of cells that originally all equal X by an alternating pattern: starting at the leftmost cell of the block, set that cell to X, then set the next cell to 0, then the next to X, then 0, and so on (i.e. if the cell’s offset from the left boundary of the block is even, set it to X; if odd, set it to 0).\n4. Process the grid row by row (ignoring the first and last rows since they can never be the middle row of a three‐row block). For each row, scan left to right to find contiguous segments in which the cell immediately above and below are nonzero and have the same digit X; when found, replace the cells in that same column span of the current row using the alternating rule described in step 3.\n5. Leave every other cell in the grid unchanged. This transformation “punches holes” (that is, inserts 0’s) in the middle row of each rectangular region, creating an alternating pattern of the original digit and 0. For example, a contiguous region of 4’s will be transformed in its middle row into a sequence: 4, 0, 4, 0, …; a region of 8’s becomes 8, 0, 8, 0, …; and so on.\n6. Produce the final output grid with just these modifications, ensuring that all non‐affected areas, including background 0’s, remain exactly as in the input.",
    "3befdf3e.json": "1. Locate the minimal bounding box of nonzero cells in the input grid. Let the top‐left corner be (T,L) and the bottom‐right corner be (B,R) so that the square has side length n = B - T + 1 (for example, n = 3 when the square occupies rows 3–5 and columns 3–5, or n = 4 when it occupies rows 3–6 and columns 3–6).\n2. Identify the two colors present in this square. Define A as the color found uniformly on the boundary of the square (i.e. every cell in the top row, bottom row, leftmost column, and rightmost column of the bounding box has value A) and define B as the color found in the inner region (the cells not on the boundary).\n3. Invert the square’s colors by processing every cell (r, c) with T ≤ r ≤ B and L ≤ c ≤ R: if the cell’s value is A then change it to B, and if it is B then change it to A. (Thus the original border cells become B and the inner cells become A.)\n4. Determine the extension thickness t. Compute t = n – 2 (since the original square’s border is 1 cell thick, the inner (center) has size n – 2; for example, when n = 3 t = 1 and when n = 4 t = 2).\n5. Expand the pattern by adding an extra border of thickness t around the square (but only in the four cardinal directions, not filling the diagonal corners):\n   a. For the top extension, for each row r from (T – t) to (T – 1) (if within grid bounds) and for each column c with L ≤ c ≤ R, set the cell (r, c) to A.\n   b. For the bottom extension, for each row r from (B + 1) to (B + t) and for each column c with L ≤ c ≤ R, set the cell (r, c) to A.\n   c. For the left extension, for each column c from (L – t) to (L – 1) and for each row r with T ≤ r ≤ B, set the cell (r, c) to A.\n   d. For the right extension, for each column c from (R + 1) to (R + t) and for each row r with T ≤ r ≤ B, set the cell (r, c) to A.\n6. Do not modify any cells outside these specified ranges; cells (for example, the diagonal corners created by both a vertical and horizontal extension) remain unchanged.\n7. Leave all other (background) cells (with value 0) as they are. The output grid retains the same overall dimensions as the input.",
    "3c9b0459.json": "1. Determine the number of rows (R) and columns (C) in the input grid.\n2. Create an output grid with R rows and C columns.\n3. For every cell in the input grid at position (r, c) where r is the row index (starting at 0 from the top) and c is the column index (starting at 0 from the left), copy its numeric value to the output grid at position (R - 1 - r, C - 1 - c). This effectively rotates the grid by 180 degrees.\n4. Return the output grid.",
    "3de23699.json": "1. Scan the input grid to locate exactly four cells that have the same nonzero integer value; denote this common value as X. (In the examples X is 4, 3, 6, or 2.) These four cells will appear in two distinct rows and two distinct columns and serve as the four corner markers of a rectangle. \n2. Determine the boundaries of the rectangle by computing r_min (the smallest row index), r_max (the largest row index), c_min (the smallest column index), and c_max (the largest column index) among the four marker cells. \n3. Define the output grid as the inside subgrid of this rectangle—that is, the cells with row indices from (r_min + 1) to (r_max - 1) and column indices from (c_min + 1) to (c_max - 1). \n4. For every cell in this inside subgrid, if the cell’s value is nonzero, change it to X; if the cell’s value is 0, leave it unchanged. \n5. Return the resulting subgrid as the final output.",
    "3e980e27.json": "1. For each target color (treat 2 as red and 3 as green), check if the grid contains exactly two separate instances for that color – one instance appears as a complete object (a blob that includes its single target cell plus additional nonzero cells touching it) and the other appears as an isolated single cell (with no nonzero neighbors belonging to the object).\n2. For each target color that meets this criterion, designate the complete instance as the template and the isolated instance as the query. In the template, identify the anchor, which is the unique cell that holds the target value (2 for red or 3 for green).\n3. In the template instance, for every other cell in the blob (each cell that is not the anchor), compute its relative offset (dr, dc) by subtracting the anchor’s coordinates from the cell’s coordinates.\n4. Transform these offsets as follows: if the target color is 2 (red), mirror each offset horizontally by replacing (dr, dc) with (dr, –dc); if the target color is 3 (green), leave the offset unchanged.\n5. In the query (the isolated cell), treat its location as the query anchor. For each transformed offset (dr, dc) along with its associated template cell value, set the cell at (query_row + dr, query_col + dc) in the output grid to that value (provided the computed position lies within the grid boundaries). The query cell itself remains unchanged.\n6. Copy every other cell from the input grid into the output grid unaltered.\n7. The output grid must have the same dimensions as the input grid.",
    "3eda0437.json": "1. Examine the entire input grid (a rectangular array of integers) and consider each subrectangle (defined by contiguous rows and contiguous columns) that has a height of at least 2 rows. \n2. For each candidate subrectangle, check that every cell in that region has the value 0 (which stands for black). Disregard any candidate that contains a nonzero cell.\n3. Compute the area of each valid candidate (area = number of rows × number of columns). If more than one candidate exists, select the one with the largest area. In case of ties, choose the candidate whose topmost row comes first and, if needed, whose leftmost column comes first.\n4. Form the output grid by copying the input grid exactly. Then, for every cell inside the chosen rectangle, set its value to 6 (which stands for pink). Do not change any cells outside this rectangle.\n5. If no rectangle spanning at least 2 rows is found that is completely filled with 0’s, leave the grid unchanged.\n6. Return the resulting grid.",
    "3f7978a0.json": "1. For each row in the input grid, record every column index where the cell is 8 (representing light blue). Only mark rows that contain at least two 8’s. \n2. Starting from the top of the grid, iterate over these candidate rows. For each candidate row r_top, look at each candidate row r_bottom below it (with r_bottom > r_top) and compute the intersection of their 8‐column sets. Continue until you find a pair (r_top, r_bottom) whose intersection has at least two column indices. (This guarantees that both r_top and r_bottom have 8’s in two common columns, which will form the top‐left, top‐right, bottom‐left, and bottom‐right corners of the pattern.) \n3. From the common column indices of the chosen pair, set c_left to the smallest index and c_right to the largest index. \n4. Extract the subgrid from the input that spans rows r_top to r_bottom (inclusive) and columns c_left to c_right (inclusive). \n5. Output this extracted subgrid unchanged. \n\nThis procedure uses the positions of 8 (light blue) as the four corners to identify a rectangular (or square) region; all cell values (including 5 for grey and 0 for black) inside that region are copied exactly to form the output.",
    "40853293.json": "1. For every nonzero value X (where X is an integer from 1 to 9) that appears anywhere in the input grid, compute two kinds of candidate strokes:\n   a. Horizontal strokes: For each row r, if X appears one or more times in row r, let L be the smallest column index and R be the largest column index in that row where the cell value is X. Then mark every cell in row r from column L to column R with a horizontal candidate value X.\n   b. Vertical strokes: For each column c, if X appears one or more times in column c, let T be the topmost (minimum) row index and B be the bottommost (maximum) row index in that column where the cell value is X. Then mark every cell in column c from row T to row B with a vertical candidate value X.\n2. Form the output grid (which has the same dimensions as the input) by processing each cell (r, c) as follows:\n   a. If a vertical candidate exists at (r, c), set the output cell to that candidate’s value X.\n   b. Otherwise, if a horizontal candidate exists at (r, c), set the output cell to that candidate’s value X.\n   c. If neither candidate was marked, leave the cell as 0.\n(Note: This procedure effectively connects all occurrences of a given number in each row and each column. In the regions where a horizontal stroke (joining instances in a row) and a vertical stroke (joining instances in a column) overlap with different numbers, the vertical candidate takes precedence.)",
    "4093f84a.json": "1. Interpret the grid as follows: treat 0 as the background, 5 as the fixed \"magnet\" color, and any nonzero number other than 5 (i.e. 1,2,3,4,6,7,8,9) as a colored object. In all cases the output grid is the same size as the input.\n2. The magnet is the set of all cells whose value is 5 in the input. These cells remain 5 in the output.\n3. For every cell that is an object (a nonzero value not equal to 5), first check if it is directly adjacent (sharing an edge: up, down, left, or right) to any magnet cell (value 5). If it is, do not move it (leave it unchanged). (In later steps, however, only the magnet remains, so any object that is not adjacent will be relocated and then its value changed to 5.)\n4. For each object that is not immediately adjacent to any 5, decide how to “pull” it so that it touches the magnet. Do this separately in the vertical and horizontal cases:\n   a. Vertical relocation (for an object in a row that has NO magnet cells):\n      i. In the object’s column, scan the rows to find any cell with value 5 (remember, objects do not count; only original 5’s form the magnet). Let the topmost row holding a 5 be T and the bottom‐most be B. (If the object’s row contains no 5, it lies entirely off the magnet in that column.)\n      ii. Look in that column above row T and below row B for any object (nonzero, not 5). If at least one such object exists, compute the vertical distance from the object’s row to the nearest magnet row (distance d₁ = T − r if the object is above the magnet, or d₂ = r − B if it is below). When an object is “pulled,” reassign its position to the cell (r_new, c) where r_new is chosen to be the row immediately adjacent to the magnet on that side (that is, set r_new = T − 1 if the object is above or, if no candidate exists above, set r_new = B + 1 for an object below; in a tie choose the upper side).\n   b. Horizontal relocation (for an object in a row that already contains at least one magnet cell):\n      i. In that row, identify the contiguous block of magnet cells. Let L be the leftmost column and R the rightmost column in that block.\n      ii. If the object lies to the left of L (that is, its column index is less than L) and is not adjacent (its column is not L−1), then relocate it horizontally so that its new column is L − 1. Likewise, if the object lies to the right of R (its column is greater than R) and is not already at R + 1, relocate it so its new column becomes R + 1.\n      (Note: In each row the relocation is done per column independently. If objects appear on both sides in the same row, perform the left‐side and right‐side relocations separately.)\n5. After any relocation (vertical or horizontal), change the object’s value to 5 (the magnet color).\n6. Finally, set every cell that is not either an original magnet cell or has been turned into a magnet cell by relocation to 0.\n\nThis procedure “attracts” (pulls) any colored object that is not already touching a magnet cell so that it becomes immediately adjacent (shares an edge) with the magnet. In cases where all colored objects lie on only one side of the magnet (for example, above as in some training examples), only that side is pulled in; when objects appear on both sides (as in another example), relocate them in each row or column according to the rules above. This exactly reproduces the behavior seen in the task data.",
    "41e4d17e.json": "1. Copy the input grid to an output grid without changes.\n2. Find every connected group of cells whose value is 1 (using up, down, left, right connectivity). Each such group represents a square’s outline drawn with 1 (blue).\n3. For each connected group, determine the minimum and maximum row indices (r_min and r_max) and the minimum and maximum column indices (c_min and c_max) that contain a 1. These define the bounding box of the square.\n4. Compute the center cell of the square as (center_row, center_col) = ((r_min + r_max) // 2, (c_min + c_max) // 2). Note that the squares are sized so that this center exists uniquely.\n5. Draw a horizontal line on the entire row center_row: for each column in that row, if the original cell is not 1, change its value in the output grid to 6 (magenta/fuchsia).\n6. Draw a vertical line on the entire column center_col: for each row in that column, if the original cell is not 1, change its value in the output grid to 6.\n7. Repeat steps 3–6 for every connected group of 1’s found in the grid.\n8. Return the modified grid. (Here the numbers have the following meanings: 8 is the background (light blue), 1 is the square border (blue), and 6 is the drawn line (magenta/fuchsia).)",
    "4258a5f9.json": "1. Initialize an output grid with the same dimensions as the input grid, with every cell set to 0 (black). 2. For each cell in the input grid at position (r, c) that has the value 5 (grey), treat that cell as the center of a 3x3 block. 3. For each cell (i, j) in the 3x3 block defined by i = r-1 to r+1 and j = c-1 to c+1 (only if (i, j) lies within the grid boundaries), set the corresponding output cell to 1 (blue). 4. After processing the 3x3 block for a grey cell, reset the center cell (r, c) in the output grid to 5 (grey) to preserve the original grey value. 5. If blocks overlap, their borders (value 1) merge; however, any cell that is the center of a grey box remains 5. 6. Return the final output grid which retains the input’s dimensions with each grey box surrounded by a blue (1) 3x3 border.",
    "4290ef0e.json": "1. Find the background value B by reading any cell on the border of the input grid (all border cells share the same value). For example, in the given cases B is 4 in one example, 8 in another, and 1 in the test input if the border is uniformly that value.\n2. For every cell value X in the input that is not B, group all cells of value X (each group represents one shape). For each such group, compute its minimal bounding rectangle (that is, the smallest rectangle covering every cell with value X). Then extract its outline by taking only those cells in the bounding rectangle that actually have the value X and lie on its perimeter (the first or last row or column of that rectangle).\n3. Sort the shapes by the size of their bounding rectangle (using the maximum of width and height) in descending order. This sorting establishes the nesting order where the largest shape becomes the outermost outline and the smallest becomes the innermost.\n4. Let n be the number of shapes found. Define the output grid size to be (2 × n + 1); this guarantees an odd‐sized square grid that will accommodate n nested one‐cell–thick outlines.\n5. Create an output grid of that size and fill every cell with the background value B.\n6. Process the shapes in the sorted order (from outermost to innermost) using an index i starting at 0:\n   a. Let S = (output grid size − 2 × i). This S is the side length of the square in which the current shape’s outline will be drawn.\n   b. Rescale the extracted outline of the shape from its original bounding rectangle to a square of side length S. Do this by linearly mapping the top‐left corner of the bounding rectangle to (0,0) and the bottom‐right corner to (S − 1, S − 1) (using nearest–integer rounding as needed), and then consider only those rescaled coordinates that fall on the border of the S × S square (i.e. where the row is 0 or S − 1 or the column is 0 or S − 1).\n   c. Overlay the rescaled outline onto the output grid with an offset of (i, i) (that is, add i to both the row and column indices of each point) and write the value X into those cells. (When overlays occur, inner shapes (processed later) will overwrite parts of outer outlines.)\n7. Return the completed output grid. The result is an odd‐sized square whose background remains unchanged (B) and which contains the outlines from the input nested concentrically, each drawn only at the border of its designated square and in its original numeric value (for example, values such as 6, 1, 3, etc.).",
    "42a50994.json": "1. Copy the input grid to create an output grid of the same dimensions (do not change grid size). \n2. For each cell at position (r, c) in the grid, if the cell’s value V is not 0 (0 represents the background), then check every adjacent neighbor in all 8 directions: (r-1, c-1), (r-1, c), (r-1, c+1), (r, c-1), (r, c+1), (r+1, c-1), (r+1, c) and (r+1, c+1) (only consider neighbors within the grid boundaries). \n3. If none of these neighboring cells has the same value V, then change the cell at (r, c) in the output grid to 0 (i.e. remove the isolated colored dot). \n4. If at least one neighbor has the same value V, leave the cell unchanged. \n5. Return the output grid.",
    "4347f46a.json": "1. For each cell in the input grid, locate every contiguous region of nonzero cells that all share the same integer value (for example, 8, 3, 6, 7, 5, 4, or 1). These regions are assumed to be filled rectangles on a background of 0 (black).\n2. For each such region, determine its bounding box by finding the minimum row (r_min) and maximum row (r_max) and the minimum column (c_min) and maximum column (c_max) that contain all cells of that region.\n3. Within this bounding box, every cell that is not on the perimeter (that is, any cell with a row index strictly between r_min and r_max and a column index strictly between c_min and c_max) must be set to 0. This effectively removes the interior of the rectangle while preserving a one-cell–wide border in the original integer (color) value.\n4. If a region does not have an interior (for example, if its height or width is less than or equal to 2), leave it unchanged.\n5. Keep all cells that are not part of any region or are already 0 unchanged, and do not alter the overall grid dimensions.",
    "444801d8.json": "1. For each nonzero cell in the input grid, group cells into a connected component using 8-connected (diagonal‐included) connectivity. Each component will consist of exactly two distinct nonzero digits: one that appears along its outer edge and one that appears only in the interior.\n2. For a given component, determine its minimal bounding rectangle. Let top, bottom, left, and right be the minimum row, maximum row, minimum column, and maximum column (respectively) among cells in the component.\n3. Identify the border value b as follows: for every cell of the component that lies on the boundary of its bounding box (that is, any cell with row = top or row = bottom or column = left or column = right), note its digit. All such cells will have the same digit; call this b.\n4. Identify the interior value i as the other nonzero digit in the component (i.e. a cell in the component that is not on the bounding box edge will have the value i, and i ≠ b).\n5. Define the dimensions for the new drawn rectangle: let original height = (bottom − top + 1) and width = (right − left + 1). The output rectangle will have height = original height + 1 and the same width.\n6. Construct a new rectangle R (with row indices 0 to H − 1 and column indices 0 to width − 1, where H = original height + 1) using this filling pattern:\n   a. Row 0 (the new top row): set every cell to i.\n   b. If H > 2, then for the first middle row (r = 1): for each column c, if c is among the first two columns (c < 2) or among the last two columns (c ≥ width − 2), set that cell to b; otherwise set it to i.\n   c. For every subsequent middle row (for r = 2 to H − 2, if any exist): set the cell in the first column (c = 0) and the last column (c = width − 1) to b and set all other cells to i.\n   d. Row H − 1 (the bottom row): set every cell to b.\n7. Place the drawn rectangle R into the output grid by aligning its columns with the bounding rectangle (columns left to right) and its top row at row (top − 1) of the output grid (i.e. shift the component upward by one row). Overwrite any cells in that area with the corresponding values from R.\n8. Leave all other grid cells (those not covered by any replaced rectangle) unchanged (they remain 0). \n(Note: In every example the mapping of colors to digits is as follows – 0: black, 1: blue, 2: red, 3: green, 4: yellow, 5: grey, 6: pink/fuchsia, 7: orange, 8: cyan/light blue, 9: brown/maroon.)",
    "445eab21.json": "1. Parse the input grid (always a 10×10 grid) where each cell contains an integer from 0 to 9; treat 0 as the background and any nonzero integer as part of a colored pattern. 2. Identify all connected components of nonzero cells using 4-directional (up, down, left, right) connectivity. Only group cells that share the same integer value. 3. For each connected component, count the number of cells (its area). 4. Select the component with the largest area. If two or more components tie for the largest area, break the tie by selecting the component whose topmost cell has the smallest row index; if still tied, choose the one with the smallest column index. 5. Let target_color be the integer value of the selected component. 6. Create a new output grid of fixed size 2×2 and fill every cell with target_color. 7. Return this 2×2 grid.",
    "447fd412.json": "1. Scan the input grid and locate the complete (upper) pattern – the connected group of nonzero cells that uses only the numbers 1 and 2. In all examples the complete pattern has a distinctive structure: its horizontal extremes are cells with the value 2 (red) and its interior is filled with the value 1 (blue). Determine the minimal bounding rectangle for this reference pattern (that is, find its top‐most row, bottom‐most row, left‐most column and right‐most column).\n2. In the lower part of the grid an incomplete copy of that pattern appears. Identify the target region by taking all nonzero cells that are meant to be part of the lower pattern. If these nonzero cells appear as two separated groups (for example, two clusters of 2’s with a gap of 0’s in between) then define the target region as the minimal rectangle that spans from the left–most cell of the left group to the right–most cell of the right group and covers all rows that belong to that lower group. (In some examples the target region is much wider than the original nonzero cells and may be thought of as the area that must be “filled in” to complete the lower copy.)\n3. Let the reference pattern’s bounding rectangle have height Href and width Wref and the target region’s rectangle have height Htgt and width Wtgt. For every cell (r, c) in the target rectangle (with r running from the target top row to the target bottom row and c running from the target left column to the target right column) do the following:\n   a. Compute the relative vertical coordinate u = (r − target_top) / (Htgt − 1) and the relative horizontal coordinate v = (c − target_left) / (Wtgt − 1).\n   b. Map these to the reference pattern by computing r_ref = reference_top + round(u × (Href − 1)) and c_ref = reference_left + round(v × (Wref − 1)).\n   c. Replace cell (r, c) in the grid with the value found in the reference pattern at (r_ref, c_ref). \n4. Leave all other cells in the grid unmodified. \nThis transformation copies the complete upper pattern (which uses only 1 and 2) and stamps an affine‐scaled version of it into the target region so that any gaps in a lower, incomplete copy are filled in proportionally.",
    "44d8ac46.json": "1. Keep the grid dimensions unchanged. \n2. Interpret the numbers as follows: 0 = black, 5 = gray, 2 = red. \n3. Scan the input grid for any square subgrid of size s×s where s ≥ 3. For each candidate subgrid defined by a top‐left coordinate (r, c) and size s, do the following:\n   a. Check that every cell on the border of this subgrid (i.e. the entire first row, last row, first column, and last column of the subgrid) has the value 5.\n   b. Check that every cell strictly inside the border (i.e. for rows r+1 to r+s-2 and columns c+1 to c+s-2) has the value 0.\n4. If both conditions (3a and 3b) hold, then the subgrid represents a gray square frame with a perfect square hole (since the interior dimensions are (s-2)×(s-2) and thus equal in width and height). Fill every cell in this interior with the value 2. (Note: 2 represents red.)\n5. Repeat for all possible s×s candidate subgrids in the grid. Do not alter any cell that is not part of a valid frame's interior.\n6. Output the modified grid, which has the same dimensions as the input.",
    "44f52bb0.json": "1. Read the input as a 3x3 grid of integers. 2. For each row in the grid, compare the leftmost value (column 0) with the rightmost value (column 2). 3. If for every row these two values are equal, then the grid is vertically symmetric. 4. In that case, produce an output grid of size 1x1 with the single cell set to 1 (which represents blue). 5. If any row does not have matching values in column 0 and column 2, produce a 1x1 grid with the single cell set to 7 (which represents orange).",
    "4522001f.json": "1. Create a 9x9 grid filled entirely with 0 (black).\n2. In the 3x3 input, locate the unique 2x2 block that has three cells with the value 3 (green) and one cell with the value 2 (red). This 2x2 block will lie flush against two edges of the 3x3, so its top‐left corner (its starting coordinate) will be either (0,0), (0,1), (1,0) or (1,1).\n3. Within this 2x2 block, identify the red cell (value 2) and note its relative coordinates (r_red, c_red) within the block; use 0 for top or left and 1 for bottom or right. For example, if the red cell is the bottom‐right cell of the block, then its relative coordinates are (1,1).\n4. Compute the output corner indicator by taking the diagonal complement of the red cell’s relative position: set (r_ind, c_ind) = (1 − r_red, 1 − c_red). The pair (r_ind, c_ind) now indicates one of the four corners: (0,0) means top‐left; (0,1) means top‐right; (1,0) means bottom‐left; (1,1) means bottom‐right.\n5. Map this indicator to the position for the first 4x4 square (A) in the 9x9 output: if r_ind is 0, let A’s top row be 0; if r_ind is 1, let it be 5. Likewise, if c_ind is 0, let A’s left column be 0; if c_ind is 1, let it be 5. Then, fill a 4x4 block of 3’s (green) in the output starting at that coordinate.\n6. Determine the diagonally opposite corner (B) for the second 4x4 square. Set its top row to 4 if the first square’s row is 0, or to 1 if the first square’s row is 5; set its left column to 4 if the first square’s column is 0, or to 1 if the first square’s column is 5. Fill a 4x4 block of 3’s (green) in the output starting at this computed coordinate.\n7. Return the resulting 9x9 grid.",
    "4612dd53.json": "1. Copy the input grid to an output grid, keeping the same dimensions. The grid cells use only the numbers 0 (black), 1 (blue), and 2 (red).\n2. For each row r in the grid, identify all column indices c where the original cell value is 1. Sort these indices in increasing order.\n3. In each row r, for every pair of consecutive blue cells at columns c_start and c_end from the list (with c_end > c_start), fill every cell in that row with column index c such that c_start < c < c_end with 2. Do not change any cell that is already 1.\n4. For each column c in the grid, identify all row indices r where the original cell value is 1. Sort these indices in increasing order.\n5. In each column c, for every pair of consecutive blue cells at rows r_start and r_end from the list (with r_end > r_start), fill every cell in that column with row index r such that r_start < r < r_end with 2. Do not change any cell that is already 1.\n6. Return the modified output grid. The procedure reconnects the discontinuous blue borders (the sides of one or two rectangles) by filling in the missing segments (cells with value 0) with 2.",
    "46442a0e.json": "1. Read the input grid of size R×C (each cell containing an integer between 0 and 9).\n2. Create an output grid of size (2×R)×(2×C).\n3. Partition the output grid into four equal quadrants:\n   • Top‐left quadrant covering rows 0 to R-1 and columns 0 to C-1.\n   • Top‐right quadrant covering rows 0 to R-1 and columns C to 2×C-1.\n   • Bottom‐left quadrant covering rows R to 2×R-1 and columns 0 to C-1.\n   • Bottom‐right quadrant covering rows R to 2×R-1 and columns C to 2×C-1.\n4. Fill the quadrants as follows:\n   a. Top‐left quadrant: Copy the input grid exactly (no rotation).\n   b. Top‐right quadrant: Place the input grid rotated 90° clockwise. For each input cell at (r, c), its value goes to the rotated grid at (c, R-1-r).\n   c. Bottom‐left quadrant: Place the input grid rotated 90° counterclockwise. For each input cell at (r, c), its value goes to the rotated grid at (C-1-c, r).\n   d. Bottom‐right quadrant: Place the input grid rotated 180°. For each input cell at (r, c), its value goes to the rotated grid at (R-1-r, C-1-c).\n5. Assemble these four quadrants into the output grid in their respective positions and return the resulting grid.",
    "469497ad.json": "1. Determine the scale factor F by scanning the 5×5 input grid and counting the distinct nonzero integers (treat 0 as black and ignore it). The output grid will have size (5×F)×(5×F).\n2. For every cell in the input at row r and column c (with 0 ≤ r, c < 5) having value V, fill the corresponding F×F block in the output grid (rows r×F to r×F+F–1 and columns c×F to c×F+F–1) entirely with V. This uniformly blows up the pattern.\n3. Identify the inner (central) block as follows: among the input cells that are not in the last row (r = 4) and not in the last column (c = 4), select those with nonzero value. Take the minimal bounding rectangle of these cells; let r_min and c_min be the smallest row and column indices and r_max and c_max be the largest among them.\n4. Map this inner block to output coordinates by computing:\n   • R_min = r_min × F\n   • C_min = c_min × F\n   • R_max = r_max × F + (F – 1)\n   • C_max = c_max × F + (F – 1)\n   These four points (R_min, C_min), (R_min, C_max), (R_max, C_min), and (R_max, C_max) are the top‐left, top‐right, bottom‐left, and bottom‐right corners of the inner block in the output grid.\n5. For each of the four inner block corners, overlay a red (value 2) diagonal line extending outward. Do not alter the inner block’s own cells; instead, start one cell away from the corner in the appropriate diagonal direction and then continue step‐by‐step. Specifically:\n   • From the top–left corner (R_min, C_min), move in the (–1, –1) direction. At each step, if the next cell lies within the output grid and is not part of the border region, set it to 2. (The border region is defined as the area coming from the input’s last row and last column; in the output these are rows 4×F to 5×F–1 and columns 4×F to 5×F–1.) Stop if you reach a border cell or the grid’s edge.\n   • From the top–right corner (R_min, C_max), move in the (–1, +1) direction with the same rule.\n   • From the bottom–left corner (R_max, C_min), move in the (+1, –1) direction with the same rule.\n   • From the bottom–right corner (R_max, C_max), move in the (+1, +1) direction with the same rule.\n6. Return the modified output grid.",
    "46f33fce.json": "1. Scan the input grid (a 2D array of digits 0–9) and record every cell (r, c) whose value v is not 0. (Here 0 represents black and any other digit is a colored pixel.)\n2. Let min_row be the smallest row index and min_col be the smallest column index among these colored pixels; also record max_row and max_col among them.\n3. Define the output grid dimensions as follows: height = ((max_row - min_row) * 2) + 4 and width = ((max_col - min_col) * 2) + 4.\n4. Initialize the output grid as a grid of the computed dimensions filled with 0’s.\n5. For each colored pixel in the input at coordinate (r, c) with value v, compute its output top‐left coordinate as: new_r = (r − min_row) * 2 and new_c = (c − min_col) * 2.\n6. In the output grid, fill a 4×4 block starting at (new_r, new_c) with the value v (i.e. for each dr and dc from 0 to 3, set cell (new_r + dr, new_c + dc) to v).\n7. Return the output grid.",
    "47c1f68c.json": "1. Find the divider value D and its location: Scan the input grid for the unique row that is completely filled with a single nonzero integer. Let its row index be R and note that every cell in that row is the value D. Then, identify the unique column (with index C) such that in every row (outside the divider row) the cell in column C is also equal to D. This cross (row R and column C) divides the grid into four quadrants.\n2. Form the output grid by removing the divider row and column. That is, if the input grid has M rows and N columns, the output grid will have (M - 1) rows and (N - 1) columns.\n3. Extract the pattern mask from the top left quadrant of the input. Define the top left quadrant as the subgrid with rows 0 to R − 1 and columns 0 to C − 1. For each cell (i, j) in this quadrant, mark it as active if its value is not 0 (regardless of its original nonzero value).\n4. Replicate the extracted pattern into all four quadrants of the output grid using mirror reflections, and fill the active cells with the divider value D (a number between 0 and 9). Let A = R (the number of rows in the top left quadrant) and B = C (the number of columns in that quadrant). Then for every active cell at relative coordinates (i, j) of the mask (with 0 ≤ i < A and 0 ≤ j < B):\n   a. Set the cell at (i, j) in the output (top left copy) to D.\n   b. Set the cell in the top right copy at (i, (B − 1 − j) + B) to D (mirroring horizontally).\n   c. Set the cell in the bottom left copy at ((A − 1 − i) + A, j) to D (mirroring vertically).\n   d. Set the cell in the bottom right copy at ((A − 1 − i) + A, (B − 1 − j) + B) to D (mirroring both vertically and horizontally).\n5. Leave all other cells in the output grid as 0. This completes the transformation.",
    "484b58aa.json": "1. Note that in these puzzles the number 0 represents black (the “hole”) and every other digit (1–9) is part of a colored pattern. In a correct (solution) grid the background pattern is complete and repeats in a fixed way both horizontally and vertically. \n2. First locate one or more complete (fully nonzero) rows in the input; these rows show the intended repeating sequence. For example, a complete row may read a sequence such as “5,4,5,6,1,2,…” whose horizontal period (the length of the repeating unit) can be inferred by comparing successive groups of cells. Similarly, comparing complete rows gives the vertical period. \n3. In the input grid some cells have value 0. These 0’s appear as “holes” inserted into otherwise periodic colored (nonzero) regions. Identify each connected group (by edge‐adjacency) of 0 cells that is surrounded on all sides by nonzero cells. (Do not change 0’s that belong to regions that are meant to remain unfilled; the intended solution is to fill only those 0’s that interrupt an otherwise complete repeating pattern.) \n4. For each such enclosed (hole) region, determine its placement relative to the repeating pattern. In other words, choose a reference complete row (and column) from the surrounding nonzero pattern and note its cell values in order. Then for every 0 at grid position (r, c) within the hole, compute the intended replacement by taking the value from the reference pattern at row index ((r – R0) mod V) and column index ((c – C0) mod H), where R0 and C0 are the row and column coordinates of the reference pattern’s origin and H and V are the horizontal and vertical periods respectively. (Any method that exactly reproduces the repeating background is acceptable as long as the filled cells in the hole match the pattern already present elsewhere.) \n5. Replace every 0 in a hole region with its computed number while leaving all originally nonzero cells unchanged.\n6. The output grid is the same size as the input and now shows a complete, uninterrupted repeating pattern in every cell (with no unwanted 0’s in regions where the pattern should continue).",
    "48d8fb45.json": "1. Locate the target blob by scanning the entire input grid for any cell with the value 5 (which represents grey) and use it as the seed. Then, using 8‐connected connectivity (i.e. consider all adjacent cells horizontally, vertically, and diagonally), perform a flood fill from that seed to collect all nonzero cells that are connected. This defines the blob of interest. \n2. Remove the grey pixels from the blob by ignoring any cell whose value is 5 (i.e. treat those cells as background 0). Let S be the set of all remaining cells from the blob (these will all have the same color value – for example, 1 in one case, 4 in another, 2 in a third, or 3 in the test case). \n3. Determine the tight bounding rectangle for S by computing the minimum and maximum row and column indices among all cells in S. \n4. Create a new grid whose dimensions are (max_row – min_row + 1) rows by (max_col – min_col + 1) columns. Initialize every cell in this grid to 0. \n5. For every cell (r, c) in S, copy its value from the input grid into the new grid at the position (r – min_row, c – min_col). \n6. Return this new grid as the output. The resulting output grid shows the pattern of the target blob (with its grey pixels removed) cropped to the minimal rectangle.",
    "4938f0c2.json": "1. Define R as the number of rows and C as the number of columns of the input grid. The grid contains only numbers; note that 0 represents black, 2 represents red (the design pattern) and 3 represents green (the cube).\n2. Scan the input grid to collect all coordinates (r, c) where the cell value is 2. These cells form the initial red design.\n3. For each red cell at position (r, c), compute its three symmetric counterparts using grid mirroring: horizontally (r, C-1-c), vertically (R-1-r, c), and diagonally (R-1-r, C-1-c).\n4. Check if every red cell already has all three of its symmetric counterparts also set to 2. In other words, if for every (r, c) with value 2 the cells at (r, C-1-c), (R-1-r, c) and (R-1-r, C-1-c) are also 2, then the red design is already present in all four corresponding quadrants. In that case, simply output a copy of the input grid without changes.\n5. Otherwise (if at least one symmetric counterpart is not 2), create the output grid as a copy of the input grid and for every red cell (value 2) in the input, assign the value 2 to the cells at (r, C-1-c), (R-1-r, c), and (R-1-r, C-1-c) in the output grid. This mirrors the design so that the red pattern appears in each quadrant of the grid (i.e. at all four corners relative to the central region).\n6. Leave all other cells unchanged. In particular, do not modify cells with value 3 (the green cube) or 0 (black), so that the green pattern remains in its original central position.\n7. Return the resulting grid as the output.",
    "496994bd.json": "1. Let the input grid have m rows and n columns. Copy the grid to the output without changing its dimensions.\\n2. Starting from the top (row 0), identify the contiguous block P of rows that are not completely filled with 0 (where 0 represents black). Stop at the first row that is entirely 0; let r be the number of rows in P. (For example, if rows 0 to r−1 are nonzero and row r is all 0, then P = rows 0, 1, ..., r−1.)\\n3. Replace the bottom r rows of the output grid with the rows of P in reverse order. That is, for each i from 0 to r−1, copy row (r−1−i) from the input grid into row (m−r+i) of the output grid.\\n4. Return the modified output grid.\\nThis process effectively mirrors the top nonzero pattern (which may include any numbers such as 2, 3, 8, 5, etc.) onto the bottom of the grid, preserving the inner portion of the grid unchanged.",
    "49d1d64f.json": "1. Let I be the input grid with m rows and n columns (using 0-indexed coordinates). 2. Create an output grid O with dimensions (m+2) x (n+2). 3. Embed I into O by setting O(i+1, j+1) = I(i, j) for every 0 <= i < m and 0 <= j < n. 4. Fill the top border of O: for every column j from 1 to n, set O(0, j) = I(0, j-1). 5. Fill the bottom border of O: for every column j from 1 to n, set O(m+1, j) = I(m-1, j-1). 6. Fill the left border of O: for every row i from 1 to m, set O(i, 0) = I(i-1, 0). 7. Fill the right border of O: for every row i from 1 to m, set O(i, n+1) = I(i-1, n-1). 8. Set all four corner cells of O—that is, O(0,0), O(0, n+1), O(m+1, 0), and O(m+1, n+1)—to 0 (representing the color black).",
    "4be741c5.json": "1. For each row in the input grid, traverse the row from left to right and form a list by recording the integer value at the start of each contiguous block of identical numbers. For example, if a row is [3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 8, 8] then its list is [3, 2, 1, 8].\n2. Check whether every row produces the exact same list of integers when processed this way. This verifies that the color (number) regions are arranged horizontally and consistently across rows.\n3. If all rows share the same list, construct the output grid as a single row (1 × n grid) where each cell is set to the corresponding integer from that list. (For instance, [3, 2, 1, 8] becomes a row with 3, 2, 1, and 8 in order.)\n4. If the row‐based lists are not identical for every row, then switch to vertical analysis. For each column in the input grid, traverse the column from top to bottom and record the integer at the start of each contiguous block. For example, if a column reads [2, 2, 2, 2, 8, 8, 8, 5, 5] then its list is [2, 8, 5].\n5. Check that every column produces the same list of integers when processed in this manner. This confirms that the distinct regions are aligned vertically.\n6. If the columns yield a consistent list, construct the output grid as a single column (n × 1 grid) where each cell is set to the corresponding integer from the consistent list (for example, [2, 8, 5] becomes a column with 2 on top, then 8, then 5).\n7. Return the constructed grid as the output.\n\nNote: All integers (0–9) correspond to colors as follows: 0=black, 1=blue, 2=red, 3=green, 4=yellow, 5=grey, 6=pink/fuchsia, 7=orange, 8=cyan/light blue, 9=brown/maroon. The algorithm uses only these integer values.",
    "4c4377d9.json": "1. Recognize that the input grid is always 3 rows by 4 columns, where each cell contains an integer between 0 and 9 (with 0 = black, 1 = blue, 2 = red, 3 = green, 4 = yellow, 5 = grey, 6 = pink/fuchsia, 7 = orange, 8 = cyan/light blue, 9 = brown/maroon). \n2. Form a temporary grid (call it top_half) with 3 rows by reordering the input rows: set top_half row 1 equal to the input row 3, top_half row 2 equal to the input row 2, and top_half row 3 equal to the input row 1. (This swaps the first and last rows of the input.) \n3. Construct the output grid of size 6 rows by 4 columns by placing the temporary grid as follows: assign output rows 1, 2, and 3 to top_half row 1, row 2, and row 3 respectively; then assign output row 4 to top_half row 3, output row 5 to top_half row 2, and output row 6 to top_half row 1. (This appends a vertical mirror of the temporary grid to create a symmetric 6-row grid.) \n4. Return the resulting output grid.",
    "4c5c2cf0.json": "1. Look over the entire grid and note that there are exactly two kinds of nonzero cells. One of these colors forms an object whose pattern is incomplete (it appears only in one quarter of a symmetric design) and must be “completed” by mirroring it; the other color remains unchanged. (For example, in one case the object made of 2’s is incomplete while the 4’s stay as they are; in another case the 8’s or the 1’s (or, in a test case, the 4’s) are the ones to be mirrored.)\n2. Identify the seed object to be mirrored by gathering all cells (with value X) that are connected (by adjacency) and that together form a cluster whose pattern is not symmetric. Find the minimal axis‐aligned bounding box that covers all cells of color X. Denote its top‐left corner as (top, left) and its bottom‐right corner as (bottom, right). (For instance, if the object is made of 2’s and its cells lie between row 3 and row 7 and between column 3 and column 6, then top = 3, left = 3, bottom = 7, and right = 6.)\n3. The intended complete design is one that has horizontal and vertical mirror symmetry. To “complete” the seed, assume that the given cells form one quadrant of the full symmetric pattern. There are four possible quadrants; choose the one that makes sense by the seed’s location. For example, if the seed lies in what would be the top‐left quadrant, then set the full rectangle as follows:\n • Let h = (bottom − top + 1) and w = (right − left + 1).\n • Define the full symmetric rectangle’s height H = 2·h + 1 and width W = 2·w + 1.\n • Then take the full pattern’s top‐left corner to be (top, left) and its bottom‐right corner to be (top + H − 1, left + W − 1).\nIf instead the seed lies in the top‐right, bottom‐left, or bottom‐right quadrant of the intended full pattern, then use the seed’s corresponding corner (its maximum column or maximum row as appropriate) to define the full rectangle. (In every case the full rectangle is the smallest one that, when “completed,” makes a pattern that is symmetric in both directions.)\n4. Let the full rectangle have top‐left (T, L) and bottom‐right (B, R). Its vertical mirror axis is the line with row (T + B)/2 and its horizontal mirror axis is the line with column (L + R)/2. For each cell of the seed object at (r, c) that has value X, also write X in the three mirror positions computed by reflection within this full rectangle. In other words, also set the cell at (r, L + R − c), the cell at (T + B − r, c), and the cell at (T + B − r, L + R − c) to X.\n5. Finally, leave every other cell (including those of the other nonzero color) exactly as in the input and do not change the overall grid size. The result is that the incomplete object of color X is “completed” into a design that is symmetric horizontally and vertically (though not diagonally), while the other pattern remains untouched.",
    "50846271.json": "1. Make a copy of the input grid as the output grid (all cells are already 0 (black), 5 (gray) or 2 (red)).\n2. Perform a horizontal‐gap fill on each row to “complete” cross arms where red (2) pixels appear in more than one column:\n   a. For each row, scan left‐to‐right and record the column indices where the cell value is 2.\n   b. For every pair of consecutive red indices in that row (for example, at columns c1 and c2 with c2 > c1 + 1), check that the gap from c1+1 to c2−1 contains only nonzero cells (i.e. not background 0). Then change every cell in that gap to 8 (the blue “arm” color).\n   c. In addition, if the horizontal span defined by the first red and the last red in that row is shorter than 5 cells (that is, if (last_index − first_index + 1) < 5), then extend the arm to the right (if space permits and the cell is nonzero) by setting as many cells immediately to the right of the last red to 8 as needed to bring the total horizontal arm length to 5.\n      (Do not alter any cell that is 0.)\n3. Perform a vertical‐gap fill on each column but only in columns where a horizontal fill was made:\n   a. For each column, check if any cell was changed to 8 in step 2. If so, let r_min be the smallest row index in that column with value 8. Then, moving upward from r_min (that is, for each row r = r_min−1, r_min−2, …, stopping if a background cell (0) is encountered), set the cell to 8 provided it is not 0.\n   b. Also, for each column independently, scan top‐to‐bottom and record the row indices where the cell value is 2 (red). For every pair of consecutive red pixels (say, in rows r1 and r2 with r2 > r1 + 1), if the intervening cells (rows r1+1 to r2−1) are nonzero, change them to 8.\n4. Leave all other cells unchanged. (Red (2) pixels remain 2; background (0) cells are never altered; gray (5) cells that are not “bridged” remain 5.)\n5. Return the output grid. \n\nThis procedure “completes” each partial cross. In effect, whenever red pixels (2) appear in a row or column, the gap between them is filled with blue (8) and, if that group is too narrow (fewer than 5 cells wide), it is extended on the right so that the intended cross arm measures 5 cells. Then, in any column where a horizontal blue (8) seed appeared, the contiguous nonbackground block immediately above that seed is also filled with 8. Finally, any vertical gap between two red pixels in a column is filled with 8. The overall effect is to leave the grid unchanged except in regions where red (2) appears, in which case the red shapes are “completed” into plus‐shaped crosses with a 5‐cell horizontal arm and a 5‐cell vertical arm, using 8 for the blue fill.",
    "508bd3b6.json": "1. Scan the input grid and record every cell whose value is 8; these cells form a single contiguous diagonal cluster—the blue (8) segment that remains unchanged. \n2. Determine the cluster’s diagonal orientation by locating any two blue cells that are diagonally adjacent. Compute the candidate movement vector d = (Δr, Δc) where Δr and Δc are each ±1. For example, if one blue cell is at (r, c) and its diagonal neighbor is at (r+1, c+1), then d = (1,1); if the neighbor is at (r-1, c+1), then d = (–1,1), and so on. \n3. Identify the endpoints of the blue cluster (cells that have only one blue neighbor along the diagonal). For each endpoint B with its single adjacent blue neighbor N, compute the candidate extension direction by taking d_candidate = (B.row – N.row, B.col – N.col). Then compute the candidate starting cell S = (B.row + d_candidate.row, B.col + d_candidate.col). Choose the endpoint for which S is within grid bounds and its cell value is 0. (This ensures that S is the first cell, not originally colored, that will receive the green trajectory.) \n4. Initialize the current position C to S and set the current movement vector to the chosen d (which will be one of (1,1), (1,–1), (–1,1) or (–1,–1)). \n5. While C is within the grid boundaries, do the following:\n a. If the current cell C already has value 8 (a blue cell), stop the process (do not overwrite blue cells).\n b. Change the value at C to 3 (green).\n c. Compute the next cell N by adding the current vector: N = (C.row + d.row, C.col + d.col).\n d. If N is out of bounds or if the cell at N has value 2 (red), then a bounce occurs. To bounce, flip only the horizontal component of d (that is, set d = (d.row, –d.col)); do not change the current cell’s color.\n e. Update C by advancing one step using the (possibly bounced) direction: C = (C.row + d.row, C.col + d.col).\n6. Stop the loop when C goes out of bounds or when C is a blue cell (8). Do not modify any cells other than those that originally held 0 and are now set to 3.\n\nThis procedure draws a single continuous diagonal line of green (3) cells that extends from one edge (or bounce point) of the grid to meet the blue (8) cluster, with one bounce (reflection by flipping the horizontal direction) occurring when the next step would hit a red (2) cell.",
    "50cb2852.json": "1. Traverse every cell in the input grid using its (row, column) coordinates. For each cell with a nonzero value v (v ≠ 0) that has not already been processed, perform a 4-connected flood fill (using neighbors at (r-1, c), (r+1, c), (r, c-1), and (r, c+1)) to collect all cells that are connected and have the same value v; this set of cells constitutes a shape.\n2. For each cell in the identified shape, determine if it is a border cell. A cell is considered a border if it is on the edge of the grid or if any of its four orthogonal neighbors (if present) does not belong to the shape (that is, the neighbor’s value is not equal to v). All other cells in the shape are interior cells.\n3. For every interior cell found in the shape, change its value to 8 (where 8 represents light blue according to the mapping). Do not change the value of any border cell; they remain as the original v.\n4. Leave all cells with value 0 (the background) unchanged.\n5. Output the resulting grid, which has the same dimensions as the input, with each nonzero shape’s interior replaced by 8 while its one-cell-thick border retains the original color.",
    "5117e062.json": "1. Find the unique cell in the input grid that has the value 8 (this value represents the light blue dot) and record its coordinates (r_dot, c_dot).\n2. Look at the four 4‐connected neighbors (up, down, left, right) of the cell (r_dot, c_dot). Select those neighbors whose value is not 0 and not 8. All such neighbors must share the same value; call this common value X (for example, in the examples X is 4, 3, or 2).\n3. Starting from any neighbor having value X, perform a 4-connected flood fill to collect every cell that equals X. This collected set represents the surrounding shape.\n4. Add the dot cell at (r_dot, c_dot) to the collected set, treating it as if it were X (i.e. it will be replaced by the value X).\n5. Determine the minimal bounding rectangle that encloses every cell in the collected set. That rectangle is defined by the minimum and maximum row indices and the minimum and maximum column indices of the set.\n6. Construct the output grid with the dimensions of this bounding rectangle. For each cell in this rectangle, if its corresponding (original grid) position is in the collected set, place the value X in that cell; otherwise, place 0.\n7. Return the resulting grid as the output.",
    "5168d44c.json": "1. Locate the unique 3×3 block that has the fixed pattern: its first row is [2,2,2], its second row is [2,3,2], and its third row is [2,2,2]. Record its top‐left coordinate (r, c). \n2. In the entire input grid, count the number of 3’s in each row and in each column. If the maximum count in any row is greater than the maximum count in any column, then the grid’s guiding (track) pattern is horizontal; otherwise it is vertical. (Recall: 3 represents the green background.) \n3. Set a movement offset based on the orientation. For a horizontal track, use an offset of (0, 2) (i.e. shift the block two columns to the right). For a vertical track, use an offset of (2, 0) (i.e. shift the block two rows down). \n4. Erase the original red block from the grid while trying to restore the underlying track background. (Because the block obscures the background, use the following rule to clear its 3×3 region without disturbing the rest of the grid.)\n • For a horizontal track: The 3×3 block covers rows r to r+2 and columns c to c+2. Replace every cell in that region with 0 EXCEPT in the middle row (row r+1) where only the cell in the middle column (column c+1) is preserved as 3; all other cells in that 3×3 region become 0.\n • For a vertical track: For the block spanning rows r to r+2 and columns c to c+2, replace every cell with 0 EXCEPT in the column that is in the middle of the block (column c+1). In that column, set each cell to a background value determined by its row index – if the row index is even, write 3; if it is odd, write 0. (This re‐creates the vertical track’s alternating pattern.) \n5. Compute the new top‐left coordinate for the block as (r + dr, c + dc) where (dr, dc) is the movement offset determined in step 3. \n6. Overlay the red block at its new position by writing the fixed pattern into the 3×3 area starting at that new top‐left coordinate. That is, write [2,2,2] in the top row, [2,3,2] in the middle row, and [2,2,2] in the bottom row of the chosen 3×3 region (overwriting whatever background is there). \n7. Leave all other grid cells unchanged. \n\nThis transformation therefore shifts the block (with border value 2 and center 3) exactly one “track” over – to the right (by 2 columns) when a horizontal row shows an alternating pattern of 3’s, or downward (by 2 rows) when a vertical column of 3’s is dominant.",
    "539a4f51.json": "1. Find the pattern block by ignoring any 0’s in the input. In all training examples the nonzero (non‐black) part is a contiguous block in the upper‐left; for instance, when the input is a 5×5 grid with its last row and column equal to 0, take the top–left 4×4 block as the pattern. 2. Set the output grid size to 10×10 (that is, double the input grid dimensions). 3. Construct the output by tiling the pattern block in a block‐by‐block fashion. In detail, for every output cell at row r and column c (using 0–based indexing), determine its source as follows: • When a full copy of the pattern block fits, copy the cell from the pattern at the same relative position. • When a copy would extend past the right or bottom edge (i.e. in a partial tile) take only the top–left sub‐region of the pattern block of the appropriate size and use its cell at the corresponding row and column. 4. Because the pattern block contains no 0’s, every cell in the output is colored. This algorithm exactly reproduces the training examples: the nonzero block from the input is repeated across the 10×10 output (with any overhanging parts filled by the matching sub–region of the pattern block), and no 0’s appear in the output.",
    "53b68214.json": "1. Initialize a 10×10 grid filled with 0 (the background).\n2. Identify the one nonzero number in the input and call it C (for example, C may be 1, 2, or 3). All colored (nonzero) cells use this value.\n3. Copy the input grid into the output grid at the same coordinates (the input occupies its original rows in the top part of the 10×10 grid).\n4. Examine the input pattern to decide how to extend it. If at least one row in the input has two or more cells with C, then the input shows an alternating pattern of two kinds of rows:\n   • A “block row” – a row that shows a group of cells with C. If the group is contiguous (cells in consecutive columns), let L be the number of consecutive cells (the block width) and let X be the column index of the leftmost cell. In such cases the pattern is drawn diagonally: the next block row appears shifted to the right by a fixed amount D. Compute D as the difference between the leftmost column of the second block row and that of the first block row found in the input. (If no shift is found or if D would be negative, use D = 0.)\n   • A “connector row” – a row that shows exactly one cell with C. For contiguous block rows, define the connector’s column as (X + L − 1), that is, the rightmost cell of the block row. For block rows that are not contiguous (for example, if a block row has cells at two distinct columns), record the set of colored columns; then define the connector’s column as the floor of ((minimum column + maximum column) / 2).\n5. Determine the cycle of row types from the input. For example, if the first colored input row is a block row (type B) and the next is a connector row (type C), then the pattern alternates as [B, C, B, C, …]. In some cases (for example, when every row of the input is a single colored cell) the cycle is simply a constant row type (C only). (An example of a non‐shifting pattern is one in which the block rows all use the same fixed set of columns and the connector rows always have the same single cell; in that case D = 0 and the cycle may be, for instance, [C, C, B] as observed in one training example.)\n6. Let R be the number of rows in the input. For each output row r from R to 9, continue the observed cycle. That is, assign to each missing row the type it would have if the input pattern were extended downward in the same order as seen in the input.\n7. For each extension row:\n   • If the row is to be a block row and the pattern is contiguous, compute the new leftmost column as (previous block row’s X + D) and draw a contiguous group of L cells with C starting at that column. If (new leftmost + L − 1) exceeds column 9, fill only the cells that fit within columns 0–9.\n   • If the row is to be a connector row in a contiguous pattern, draw a single cell with C at the column equal to (current block row’s leftmost + L − 1). (If that cell would lie outside the grid, leave the row filled with 0.)\n   • For non‐contiguous block rows (where the block row’s colored cells appear at a fixed set of columns), simply redraw the block row using the same columns as in the input and, for the corresponding connector row, place a single cell with C at the column given by floor((min + max) / 2) of that block.\n8. In this way the output grid always ends up as 10×10 with the input pattern copied exactly into its original location and then continued downward in the same directional (or invariant) style as observed in the input. Rows that would require a colored cell out of bounds are left as background 0.\n9. Return the completed 10×10 grid.",
    "543a7ed5.json": "1. Begin by making a copy of the input grid to use as the output grid.\n2. Find every contiguous region of cells whose value is 6 (pink) using 4‐connectivity. Call each such set a pink region.\n3. For each pink region, compute its minimal bounding rectangle (MBR): that is, find the smallest rectangle (with topmost row r_min, bottommost row r_max, leftmost column c_min, and rightmost column c_max) that contains every cell of the region.\n4. Check whether the region completely fills its MBR; in other words, verify that for every cell (r,c) with r_min ≤ r ≤ r_max and c_min ≤ c ≤ c_max the input value is 6.\n5. Also determine the dimensions of the MBR (height = r_max–r_min+1 and width = c_max–c_min+1).\n6. If the MBR is completely filled (every cell is 6) and both its height and width are at least 4, then leave that region unchanged in the output.\n7. Otherwise, transform the region as follows:\n   a. Expand the MBR by 1 cell in every direction (if the expansion would go outside the grid, clip to the grid boundaries). Call this the outline rectangle.\n   b. In the output grid, for every cell on the border of the outline rectangle—that is, every cell in its top row, bottom row, leftmost column, and rightmost column—set the value to 3 (green).\n   c. For every cell inside the outline rectangle (all cells not on its border), if the corresponding input cell was part of the pink region (value 6) then set that output cell to 6 (preserve pink); otherwise, set it to 4 (yellow), thereby “filling” any open space inside the box.\n8. Process every pink region in the grid (regions may be processed independently; note that regions which are small—such as a 2×2 block—even if completely filled must be transformed, while a solid block 4×4 or larger is left as is).\n9. Return the output grid after all regions have been processed.",
    "54d82841.json": "1. Copy the input grid exactly to create the output grid. Let R be the number of rows and C be the number of columns (the bottom row is row R-1).\n2. For every pair of consecutive rows (row r and row r+1 for 0 ≤ r < R-1), slide a window of width 3 from column c = 0 up to c = C-3. In each window do the following:\n   a. Let v be the value at cell (r, c). If v is 0, skip this window. Verify that the cells at (r, c+1) and (r, c+2) also equal v (ensuring three identical nonzero values in a row).\n   b. In the row below (r+1), check that the cells at (r+1, c) and (r+1, c+2) are equal to v and that the cell at (r+1, c+1) is 0. This pattern identifies a shape with a missing center block (the 0 acts as the unfilled or \"black\" cell).\n   c. If both conditions (a and b) hold, record the column index (c+1); this is the horizontal center of the shape where the missing piece should be located.\n3. After scanning the grid for all such patterns, modify the output grid: For every recorded column index x, replace the cell in the bottom row (row R-1) at column x with the number 4 (which represents yellow).\n4. Return the output grid; it is identical to the input grid except that on its bottom row, each column corresponding to a shape’s missing center has been set to 4.",
    "54d9e175.json": "1. Identify divider rows and divider columns in the input grid. A divider row is any row in which every cell is 5; a divider column is any column in which every cell is 5. These rows and columns act as constant boundary lines and must remain unchanged in the output.\n2. Partition the grid into rectangular blocks by grouping together contiguous rows and contiguous columns that are not divider rows or columns. (In the provided examples, each block is a 3×3 region.)\n3. For each block, determine its center cell by taking the middle row and middle column of that block. For instance, in a 3×3 block with its top‐left cell at coordinate (r, c), the center is at (r+1, c+1).\n4. Look up the integer value of the center cell of the block. Then, using the following mapping, determine the fill value for the block:\n   - If the center value is 1, use 6 as the fill value.\n   - If the center value is 2, use 7 as the fill value.\n   - If the center value is 3, use 8 as the fill value.\n   - If the center value is 4, use 9 as the fill value.\n5. Replace every cell in the block with the determined fill value so that the entire block becomes uniformly that number.\n6. Keep the divider rows and columns (all cells with value 5) unchanged. The output grid retains the same overall dimensions and divider positions as the input grid.",
    "5521c0d9.json": "1. For each connected group (object) of nonzero cells (using four‐way connectivity) in the input grid, determine its vertical span. In other words, find the smallest row index r_min and largest row index r_max among its cells and compute the object’s height H = r_max − r_min + 1. (Remember that the numeric values represent colors; for example, 1 = blue, 2 = red, 4 = yellow.)\n2. In a new grid (of the same dimensions as the input, initially filled with 0), for each cell (r, c) belonging to an object with value v (v ≠ 0), relocate that cell so that its new row is r' = r − H and its column remains the same (c). If r' is less than 0 (i.e. off the top of the grid) then do not place that cell.\n3. Process every object independently in this way. The objects retain their original relative shapes; only their vertical positions change by exactly the number of rows the object originally spanned.\n4. Leave all grid cells that are not assigned a relocated value as 0.\nThis transformation exactly implements the instruction ‘count how many rows the object contains and move it up by that same number of rows’ (with colors given by their numbers, for instance 1 for blue, 2 for red, and 4 for yellow).",
    "5582e5ca.json": "1. Read a 3x3 input grid of integers, where each integer in the range 0 to 9 represents a color (0: black, 1: blue, 2: red, 3: green, 4: yellow, 5: grey, 6: pink/fuchsia, 7: orange, 8: cyan/light blue, 9: brown/maroon). 2. Count the occurrence of each integer in the grid. 3. Identify the integer that appears the most times in the grid. (In the provided examples, this integer always has a clear majority; if there is a tie, choose any one of the most frequent integers.) 4. Construct an output grid that has the same dimensions (3 rows by 3 columns) where every cell is filled with the identified integer. 5. Return the output grid.",
    "5614dbcf.json": "1. Assume the input grid is 9×9. Divide it into nine contiguous 3×3 blocks. For block (b_r, b_c) with b_r, b_c ∈ {0,1,2}, let the block cover rows 3×b_r to 3×b_r+2 and columns 3×b_c to 3×b_c+2.\n2. For each 3×3 block, list all its cell values and ignore any cell equal to 5 (this value represents gray noise). \n3. Determine the block’s color by choosing the non‑5 value that appears; since after ignoring 5 the remaining cells are uniform, use that common integer. If the block contains only 5’s (i.e. no non‑5 values), use 0 as the block’s output value.\n4. Construct a new 3×3 output grid where each cell at position (b_r, b_c) is set to the color determined from the corresponding 3×3 block of the input.",
    "56dc2b01.json": "1. Identify the red‐line: In the input grid, find all cells with value 2. Verify that they all lie in one row (making a horizontal line) or one column (making a vertical line). Let r_red (if horizontal) or c_red (if vertical) be the constant coordinate of the red cells.\n\n2. Identify the green pattern: Collect every cell with value 3. Compute its bounding box by letting r_min be the minimum row, r_max the maximum row, c_min the minimum column, and c_max the maximum column of all 3’s. Also compute its width = (c_max − c_min + 1) and height = (r_max − r_min + 1).\n\n3. Determine the relative position of the green pattern with respect to the red line:\n   • If the red line is vertical (all 2’s in column c_red), compute the horizontal center of the green bounding box as (c_min + c_max)/2. If this center is less than c_red, then the green pattern is originally to the left of the red line; otherwise it is to the right.\n   • If the red line is horizontal (all 2’s in row r_red), compute the vertical center as (r_min + r_max)/2. If this center is less than r_red, then the green pattern is originally above the red line; otherwise it is below.\n\n4. Reposition the green pattern while preserving its internal shape. For each green cell, record its offset (r_offset, c_offset) = (r − r_min, c − c_min). Then, depending on the red line orientation and the green pattern side, compute the new bounding box for the green pattern as follows:\n   • For a vertical red line (c_red constant):\n     a. If the green pattern is to the left (center < c_red), set the new right edge to (c_red − 1). Then, let new left = (c_red − 1) − width + 1. Keep the row coordinates unchanged (new top = r_min and new bottom = r_max).\n     b. If the green pattern is to the right (center > c_red), set the new left edge to (c_red + 1). Then, let new right = (c_red + 1) + width − 1. Keep the row coordinates unchanged (new top = r_min and new bottom = r_max).\n    For a horizontal red line (r_red constant):\n     a. If the green pattern is above (center < r_red), set the new bottom edge to (r_red − 1). Then, let new top = (r_red − 1) − height + 1. Keep the column coordinates unchanged (new left = c_min and new right = c_max).\n     b. If the green pattern is below (center > r_red), set the new top edge to (r_red + 1). Then, let new bottom = (r_red + 1) + height − 1. Keep the column coordinates unchanged (new left = c_min and new right = c_max).\n\n5. Clear the green pattern from its original location, and for each green cell from the input, place a value 3 in the output grid at the new position computed by adding its stored offsets to the new bounding box’s top‐left (new top, new left). This preserves the shape of the green pattern.\n\n6. Draw the blue (light blue) line using value 8 as the border on the side of the green pattern opposite the red line:\n   • For a vertical red line:\n     a. If the green pattern was moved to the left of the red line, add a vertical column of 8’s immediately to the left of the new green bounding box (i.e. at column = new left − 1) for every row from new top to new bottom.\n     b. If the green pattern was moved to the right of the red line, add a vertical column of 8’s immediately to the right of the new green bounding box (i.e. at column = new right + 1) for every row from new top to new bottom.\n   • For a horizontal red line:\n     a. If the green pattern was moved above the red line, add a horizontal row of 8’s immediately above the new green bounding box (i.e. at row = new top − 1) for every column from new left to new right.\n     b. If the green pattern was moved below the red line, add a horizontal row of 8’s immediately below the new green bounding box (i.e. at row = new bottom + 1) for every column from new left to new right.\n\n7. Copy the red line unchanged: For every cell in the input that has value 2, place a 2 in the exact same coordinates in the output grid.\n\n8. Leave all other cells as 0. Maintain the original grid size, so cells not overwritten by the repositioned green pattern, the blue line, or the red line remain 0.\n\nThis procedure moves the green pattern (value 3) so that it is adjacent to the red line (value 2) on the same side as in the input, and it adds a blue border (value 8) on the opposite side, all while preserving the pattern’s shape and the grid dimensions.",
    "56ff96f3.json": "1. Copy the input grid to create the output grid (preserve grid dimensions). 2. For each distinct nonzero integer X in the input grid (ignoring 0), collect all coordinates (row, column) where the cell equals X. 3. For each such value X, compute the minimum row index (min_row), maximum row index (max_row), minimum column index (min_col) and maximum column index (max_col) among its coordinates. 4. Fill every cell in the output grid that lies within the rectangle defined by rows min_row to max_row and columns min_col to max_col (inclusive) with the integer X. 5. Process every distinct nonzero value this way and return the modified output grid.",
    "57aa92db.json": "1. Copy the input grid exactly to the output so that the grid dimensions remain unchanged. 2. Find every connected region of nonzero cells; the puzzle always contains exactly two composite objects. 3. In each object identify the cells whose value is the shared (or common) number. Let this common number be C (for example, in several cases C = 1). 4. For each object, compute the minimal bounding box of its cells that are equal to C. One object will have a common‐color block that is a single cell (a 1×1 region); call this object the template and its unique (non‐C) number U (for example, U = 3). The other object will have a larger common‐color block (for example, 2×2); call this the target and let its unique number be T (for example, T = 4). 5. Determine the scaling factor s by dividing the side length (in rows or columns) of the target’s common block by that of the template’s common block. (For instance, if the template’s C–region is 1×1 and the target’s is 2×2 then s = 2.) 6. In the template object choose the single cell with value C as the reference point. For every cell in the template (including the reference), record its relative offset (delta row, delta column) from that reference. 7. In the target object compute the center of its common block (using the bounding box of cells equal to C); this center will serve as the placement point for the template’s reference. 8. For each cell in the template with relative offset (dr, dc) and with value X, compute the corresponding mapped location by multiplying the offsets by s (i.e. (s × dr, s × dc)) and then adding these to the center of the target’s common block. Because s > 1, treat the mapping as producing an s×s block at that location. 9. In the mapped s×s block, if the original template cell’s value X is C then fill the entire block with C; if X is the unique template value U (i.e. not C) then fill the block with the target’s unique number T. 10. Overwrite the cells in the output grid that lie within the target object’s region with these filled blocks. This completes the missing parts of the target object using a scaled version of the template’s shape while leaving all other parts of the grid unchanged.",
    "5ad4f10b.json": "1. Examine the input grid and list every cell that is nonzero (i.e. not 0, the background). For each distinct nonzero integer (for example, 2, 3, 4, 8), do the following:\n   a. Compute its bounding box by finding the minimum and maximum row and column in which that number appears.\n   b. Count the number of cells that have that number and compute the area of the bounding box (height × width).\n   c. Calculate its density as (number of cells with that digit) divided by (bounding box area).\n2. Select the nonzero number that has the lowest density; this is taken to be the target pattern color. (In the examples the targets are 8 in Example 1, 2 in Example 2, 3 in Example 3, and 4 in the test input.)\n3. Extract the subgrid defined by the bounding box of the selected target number. Then create a binary mask from this subgrid by setting each cell to 1 if its value equals the target number and 0 otherwise.\n4. Resize this binary mask to a fixed 3×3 grid as follows: for each output cell with coordinates (r, c) where r and c are 0, 1, or 2, compute the corresponding source coordinates in the mask by using the formula:\n   • source_row = round( (r / (3 − 1)) × (mask_height − 1) )\n   • source_col = round( (c / (3 − 1)) × (mask_width − 1) )\n   (mask_height and mask_width are the dimensions of the extracted subgrid)\n5. Construct the output 3×3 grid by examining each output cell (r, c): if the corresponding cell in the resized binary mask is 1, set that cell to the target number; otherwise set it to 0.\n6. Return the resulting 3×3 grid as the final output.",
    "5bd6f4ac.json": "1. Assume the input grid is 9 rows by 9 columns, with each cell containing an integer from 0 to 9. 2. Create an output grid of size 3 rows by 3 columns. 3. Identify the top right subgrid of the input: these are the cells in the first 3 rows (row indices 0, 1, and 2) and the last 3 columns (column indices 6, 7, and 8). 4. For each output cell at position (r, c) where r and c range from 0 to 2, set its value to the input grid cell at (r, c + 6). 5. Return the resulting 3×3 grid.",
    "5c0a986e.json": "1. Locate the two 2x2 regions in the input grid. One region is filled entirely with 1’s (the blue box) and the other with 2’s (the red box).\n2. For the blue box, determine its top‐left cell; denote its coordinates as (r_b, c_b). For the red box, determine its bottom‐right cell; denote its coordinates as (r_r, c_r).\n3. Prepare an output grid that has exactly the same dimensions as the input and initialize every cell to 0.\n4. Copy the two 2x2 boxes (the block of 1’s and the block of 2’s) into the output grid exactly in the same positions as they appear in the input.\n5. For the blue box (value 1): starting from its top‐left cell at (r_b, c_b), repeatedly move one step northwest (i.e. subtract 1 from both the row and column) and, for each step k (k = 1, 2, …), if the cell (r_b − k, c_b − k) is within the bounds of the grid, set that cell’s value to 1. This draws a continuous diagonal of 1’s from the blue box toward the grid’s top‐left edge.\n6. For the red box (value 2): starting from its bottom‐right cell at (r_r, c_r), repeatedly move one step southeast (i.e. add 1 to both the row and column) and, for each step k (k = 1, 2, …), if the cell (r_r + k, c_r + k) lies inside the grid, set that cell’s value to 2. This draws a continuous diagonal of 2’s from the red box toward the grid’s bottom‐right edge.\n7. Leave all other cells as 0 and output the final grid.",
    "5c2c9af4.json": "1. Scan the input grid (which is not empty) and locate the three cells whose value is not 0. All three nonzero cells share the same number; call this number V. \n2. Identify the two outer (extreme) cells among the three: let one be the one with the minimum row and minimum column and the other be the one with the maximum row and maximum column. The remaining cell will be the center. (For example, if the three cells occur at (r1,c1), (r2,c2) and (r3,c3) with r1 and c1 minimal and r3 and c3 maximal, then the center is (r2,c2).)\n3. Define the first square S₀ using the outer cells: set its top = r_min, left = c_min, bottom = r_max and right = c_max. This square “frames” the center cell. Draw the perimeter of S₀ by setting to V every cell on its top edge (row = r_min for columns c_min through c_max), bottom edge (row = r_max for columns c_min through c_max), left edge (column = c_min for rows r_min through r_max) and right edge (column = c_max for rows r_min through r_max).\n4. Compute the gap d as the distance from the center cell to one of the outer cells. (That is, d = r_center − r_min, which will equal c_center − c_min.)\n5. Initialize the current square S to S₀.\n6. Repeat the following until no new grid cell can be drawn (that is, until the newly computed square would lie completely outside the grid):\n   a. Expand the current square S outward by d on all four sides to form a new square S_new. In other words, set S_new.top = S.top − d, S_new.left = S.left − d, S_new.bottom = S.bottom + d and S_new.right = S.right + d.\n   b. For each cell on the perimeter of S_new (that is, cells in row S_new.top for columns S_new.left to S_new.right; cells in row S_new.bottom for these columns; and cells in every row between S_new.top and S_new.bottom in columns S_new.left and S_new.right), if the cell lies within the grid boundaries, set its value to V.\n   c. Update S to be S_new.\n7. Leave all cells that were not overwritten with V as 0. The output grid is then the input grid with these nested square perimeters drawn, even if some parts of a square fall outside the grid (in which case only the in‐bounds portion is drawn). \n\nNote: All coordinates use a zero–based row–column system. For example, if the input nonzero value V is 8 (as in the first training example), then the three dots might appear at (2,11), (5,14) and (8,17); here d = 3. The algorithm will draw the square with corners (2,11) and (8,17), then expand by 3 repeatedly so that, in the final output, vertical lines occur (for instance) at columns 2, 5, 8, 11, 14, 17 and 20 and horizontal segments appear on rows corresponding to the top or bottom edges of the successive squares. This exactly reproduces the pattern seen in the training examples. \n\nUse only numbers (for example, V = 8, 2 or 3) in the grid transformation.",
    "5daaa586.json": "1. Find the bounding rectangle of the colored design: scan the input grid and record every cell with a nonzero value. Let top be the smallest row index, bottom the largest row index, left the smallest column index, and right the largest column index among these cells. This rectangle is determined by four continuous colored lines (its borders) that are nonzero (for example, in some cases the top border may contain only 1’s, the left border only 3’s, the right border only 8’s, and the bottom border only 2’s, but use the numbers as they appear). \n2. Crop the input grid to this rectangle. In the cropped grid the first row (row 0) is the top border, the last row (row H–1) is the bottom border, the first column (column 0) is the left border, and the last column (column W–1) is the right border; do not alter these border cells. \n3. Let H be the number of rows and W be the number of columns in the cropped grid. \n4. If H > W (the cropped grid is taller than it is wide), then perform vertical fill in each interior column (columns 1 through W–2):\n   a. For each such column, take B = the value of the bottom border cell (at row H–1 of that column).\n   b. In that column (rows 1 to H–2), find the topmost cell (i.e. with the smallest row index) whose value is equal to B. (This cell is the colored interior square that matches the bottom border’s color.)\n   c. If such a cell is found at row r, then for every row from r up to row H–1 (i.e. from that cell down through the bottom border) set the cell’s value to B (overwriting any 0’s). \n5. Else, if W > H (the cropped grid is wider than it is tall), then perform horizontal fill in each interior row (rows 1 through H–2):\n   a. For each such row, take R = the value of the right border cell (at column W–1 of that row).\n   b. In that row (columns 1 to W–2), find the leftmost cell (i.e. with the smallest column index) whose value equals R (the matching interior colored square).\n   c. If such a cell is found at column c, then for every column from c up to column W–1 (i.e. from that cell to the right border) set the cell’s value to R (overwriting any 0’s). \n6. Else (if H equals W, so the cropped grid is square), perform vertical fill from the top border in each interior column (columns 1 to W–2):\n   a. For each such column, let T = the value of the top border cell (at row 0 of that column).\n   b. Scan downward (rows 1 to H–2) to find the first cell whose value equals T.\n   c. If found at row r, then for every row from 0 (the top border) to r, set the cell’s value to T. \n7. Output the resulting cropped (and possibly filled) grid. (Note: Within the cropped grid the coordinates are zero-indexed: row 0 is the top border and column 0 is the left border. All colors are represented solely by their integer values 0–9.)",
    "60b61512.json": "1. For each cell in the 9x9 grid that has the value 4 and has not yet been processed, use 4-connected (up, down, left, right) flood fill to collect all cells with value 4 that form one contiguous group. \n2. For the collected group, determine r_min (minimum row), r_max (maximum row), c_min (minimum column), and c_max (maximum column). \n3. Compute the side length L = max(r_max - r_min + 1, c_max - c_min + 1). (This defines the size of the square that will complete the shape.) \n4. Define the square region as all cells with row indices from r_min to r_min + L - 1 and column indices from c_min to c_min + L - 1. \n5. In this square region, for every cell that does not already have the value 4, set its value to 7. (Here 7 represents orange.) \n6. Leave all other cells unchanged and process all groups in the grid to produce the final output, which has the same dimensions as the input.",
    "6150a2bd.json": "1. Compute the dimensions of the input grid: let R be the number of rows and C be the number of columns; the output grid will have the same dimensions. 2. Interpret the transformation as a 180-degree rotation (i.e. flipping both vertically and horizontally). 3. For each cell in the input grid with coordinates (i, j) (using 0-indexing), assign its value to the output grid at position (R - 1 - i, C - 1 - j). 4. Construct the output grid by iterating over all cells and applying the above reassignment, ensuring that every element is repositioned as if the entire grid were rotated 180°.",
    "623ea044.json": "1. Locate the unique nonzero cell in the input grid. Let its coordinates be (r, c) and its value be v (for example, v may be 2, 7, 8, or 6). This cell is your starting cell.\n2. Create an output grid that has the same number of rows and columns as the input grid, and initialize every cell to 0.\n3. Set the cell at (r, c) in the output grid to v.\n4. For each of the four diagonal directions defined by the offsets (-1, -1), (-1, +1), (+1, -1), and (+1, +1):\n   a. Begin at the cell that is one step away from (r, c) in the chosen direction.\n   b. While the current cell is within the bounds of the grid, set its value to v and move one step further in the same diagonal direction.\n   c. Stop when the next step would fall outside the grid boundaries.\n5. Return the output grid. The result is an X-shaped pattern (formed by four diagonal rays starting at the original nonzero cell) drawn in value v over a background of 0.",
    "62c24649.json": "1. Read the 3x3 input grid where each cell is a number between 0 and 9. Let the cell in row r and column c be denoted as grid[r][c] for r, c ∈ {0, 1, 2}.\n2. For each row r in the input grid, construct an extended row of 6 numbers by concatenating the original row with its horizontal reflection. In other words, form the row as [grid[r][0], grid[r][1], grid[r][2], grid[r][2], grid[r][1], grid[r][0]].\n3. Collect the 3 extended rows (for r = 0, 1, 2) to form the top half (rows 0 to 2) of the output grid.\n4. Create the bottom half of the output grid by reversing the order of the top half rows. That is, set the 4th row to be the same as the 3rd extended row, the 5th row as the 2nd extended row, and the 6th row as the 1st extended row.\n5. Combine the top half and bottom half vertically to obtain the final 6x6 grid, which is symmetric horizontally (each row is a mirror of itself) and vertically (the top half is mirrored in the bottom half).",
    "63613498.json": "1. Make an exact copy of the input grid to start the output grid. \n2. Identify every connected component (using 4‐connectivity) in the grid that has a nonzero value (treat 0 as background). Each connected component is a set of cells with the same number. \n3. For each connected component, compute its normalized shape by finding the minimum row and minimum column among its cells and then subtracting these values from every cell’s (row, column) coordinates. The normalized shape is the set of relative coordinates. \n4. Group together all components whose normalized shapes are identical (i.e. they have exactly the same set of relative coordinates, meaning they have the same shape and orientation up to translation). \n5. In each group that contains more than one component, determine the reference component as the one whose top‐most, left‐most cell (i.e. the cell with the smallest row and then smallest column) is minimal; this component is considered the “inside the box” or exemplar and remains unchanged. \n6. For every other component in that same group (all duplicates not chosen as the reference), change every cell in that component to 5 (the integer for grey). \n7. Leave all other cells in the grid unchanged and output the resulting grid (which remains the same size as the input).",
    "6430c8c4.json": "1. Recognize that the input is a 9×4 grid divided into three parts: the top block (rows 1–4), a middle divider row (row 5) that is entirely 4 (yellow), and the bottom block (rows 6–9). This divider row is not used in processing. \n2. Extract the top block (rows 1–4) and the bottom block (rows 6–9); each block is a 4×4 grid. \n3. Create a new 4×4 output grid that aligns cell‐by-cell with the top and bottom blocks. \n4. For each cell position (r, c) in the 4×4 grid, check the corresponding cell in the top block and the corresponding cell in the bottom block. If both cells have the value 0 (where 0 represents black), then assign the output cell the value 3 (where 3 represents green). \n5. Otherwise, if either the top or bottom cell is nonzero (i.e. it contains any color other than 0), assign the output cell the value 0 (black). \n6. Return the completed 4×4 output grid.",
    "6455b5f5.json": "1. Scan the grid cell‐by‐cell to identify all connected regions (using 4‐directional connectivity, i.e. up, down, left, right) of cells that are exactly 0 (black). Treat any cell whose value is not 0 (for example, 2 representing red lines) as a barrier that cannot be crossed. 2. For each such connected region of 0’s, count the number of cells it contains. 3. Determine which region (or regions) has the maximum size and which region(s) has the minimum size among all the 0‐regions. 4. In a copy of the grid, for every cell that belongs to a region whose size equals the maximum (largest black shape), change its value to 1 (this represents dark blue). 5. Similarly, for every cell that belongs to a region whose size equals the minimum (smallest black shape – and if more than one region is smallest, treat them all alike), change its value to 8 (this represents light blue). 6. Leave all other cells intact (including all cells that are not 0, such as those with value 2). 7. Output the resulting grid with the same dimensions as the input.",
    "662c240a.json": "1. Note that the input grid is always 9 rows by 3 columns. View the grid as three contiguous 3×3 blocks: the top block consists of rows 0–2, the middle block of rows 3–5, and the bottom block of rows 6–8 (using 0‐indexed row numbers).\n2. Examine the first row of the input grid (row 0). Let S be the set of distinct numbers in that row.\n3. Decide which 3×3 block to output based on S as follows:\n   • If S equals {1,5} (that is, the first row contains only the numbers 1 and 5), then select the middle 3×3 block (rows 3–5).\n   • Else if S equals {8,4} or equals {4,5} (that is, the first row contains only 8 and 4, or only 4 and 5 – order does not matter), then select the top 3×3 block (rows 0–2).\n   • Else if S equals {8,9} or equals {2} (that is, the first row contains only 8 and 9, or it is a single number 2), then select the bottom 3×3 block (rows 6–8).\n4. Once the correct 3×3 block has been determined by the rule above, copy that block exactly (preserving the numbers in their positions) as the output grid.",
    "67385a82.json": "1. Read the input grid as a two‐dimensional array of integers (each integer is from 0 to 9) with coordinates (row, column) where (0,0) is the top–left cell. 2. Identify every cell whose value is 3 (this represents green). Then, using 4–connected (up, down, left, right) adjacency, group together all cells with value 3 that touch one another. 3. For each connected group of cells that have value 3, check the size of the group. If the group has 2 or more cells (i.e. it is a connected region rather than an isolated cell), change every cell in that group to the value 8 (which represents cyan/light blue). If a cell with value 3 is not adjacent to any other cell with value 3 (i.e. it is an isolated group of size 1), leave it unchanged. 4. Leave all cells with values other than 3 unchanged. 5. Output the resulting grid in the same dimensions as the input grid.",
    "673ef223.json": "1. Partition the grid vertically into two parts that contain the red base columns (value 2). In every example one set of red base cells appears contiguously along one edge in one part and the other set appears along the opposite edge in the other part. (For instance, in some examples the upper part has red cells in the left‐most column and the lower part has red cells in the right‐most column; in others the roles are reversed.) Designate the part that already contains at least one non‐base blue cell (value 8) as the primary region and the opposite part as the mirror region.\n\n2. In the primary region, process each row that has a red base on its designated side as follows (use the red base side and scanning direction appropriate to that region):\n   a. If the red base is on the left (cell (r,0) = 2), scan the row from column 1 rightward to find a blue cell (8). If the red base is on the right (cell (r,width−1) = 2), scan leftward from column (width−2) to find a blue cell. (These blue cells in the input mark candidate connection endpoints.)\n   b. Group together contiguous rows (by row index) in the primary region that yield a candidate blue endpoint. In each such contiguous block, choose the row whose candidate endpoint is “extremal” (that is, for a left‐base region choose the row whose blue lies farthest to the right; for a right‐base region choose the row whose blue lies farthest to the left). This chosen row will carry the terminal marker.\n   c. For the terminal row in a block, replace every cell between the red base and the candidate blue cell with blue (8) and change the candidate blue cell (the first encountered in the scanning direction) into yellow (4). For every other row in the block that also had a candidate blue cell, fill the horizontal span from immediately next to the red base up to (but not including) the column used in the terminal row with blue (8) (thus “connecting” toward the terminal endpoint but not marking it with yellow).\n\n3. In the mirror region the rule is similar except that no yellow is ever used and the connection is drawn fully to the opposite grid edge. That is, for every row in the mirror region that is meant to “mirror” a connection from the primary region (using the same relative vertical pattern as in the primary region), do the following:\n   a. If the red base is on the right, fill every cell from the left edge (column 0) up to the cell immediately left of the red base (at column width−2) with blue (8). If the red base is on the left, fill every cell from the cell immediately right of the red base (column 1) to the right edge with blue (8).\n   b. Do not change any cell to yellow (4) in the mirror region.\n\n4. Leave all other cells in the grid unchanged. (Cells not overwritten remain as in the input, typically background 0.)\n\n5. In summary, the procedure draws horizontal “connection” lines in two separate red‐base clusters. In the primary region the connection starts at the red base and stops where an originally present blue (8) is replaced by yellow (4) in one designated row of each contiguous block; in the mirror region the corresponding row(s) are filled completely with blue (8) from the far edge up to the red base. Use grid coordinates (row r, column c) and the numbers 2 for red, 8 for blue, and 4 for yellow.",
    "6773b310.json": "1. Identify that the input grid is structured with separator rows and columns that contain the number 8. In every valid input, row 4 and row 8 (all cells in these rows) and column 4 and column 8 (all cells in these columns) are filled with 8, which partition the grid into 9 blocks arranged in a 3×3 pattern. 2. Define the 9 blocks as follows: Block (1,1) uses rows 1–3 and columns 1–3; Block (1,2) uses rows 1–3 and columns 5–7; Block (1,3) uses rows 1–3 and columns 9–11; Block (2,1) uses rows 5–7 and columns 1–3; Block (2,2) uses rows 5–7 and columns 5–7; Block (2,3) uses rows 5–7 and columns 9–11; Block (3,1) uses rows 9–11 and columns 1–3; Block (3,2) uses rows 9–11 and columns 5–7; Block (3,3) uses rows 9–11 and columns 9–11. 3. For each block, count the number of cells containing the number 6 (which represents pink). 4. If a block contains exactly 2 occurrences of 6, set the corresponding cell in a new 3×3 output grid to 1 (blue); if the count is any number other than 2, set that output cell to 0 (black). 5. Assemble the 3×3 output grid so that each output cell corresponds to its respective block from the input, preserving the original block order.",
    "67a3c6ac.json": "1. Determine that the output grid must have the same dimensions as the input grid. 2. For each row in the input grid, create a new row by reversing the order of its digits. That is, if a row has n columns, then for every column index j (starting from 0), place the digit from the input at column j into column (n - 1 - j) of the output row. 3. Assemble these reversed rows to form the complete output grid. This process implements a horizontal (left/right) mirror of the input grid.",
    "67a423a3.json": "1. Scan the input grid by rows and count the number of nonzero cells in each row. Choose the row (call its index r) that has the highest count; this row represents the horizontal line of the cross.\\n2. Scan the input grid by columns and count the number of nonzero cells in each column. Choose the column (call its index c) that has the highest count; this column represents the vertical line of the cross.\\n3. Define the intersection point of the two lines as the cell at coordinates (r, c). This cell is the unique point where the horizontal and vertical lines meet.\\n4. Identify the 3x3 block centered on the intersection point. This block covers rows from r-1 to r+1 and columns from c-1 to c+1 (using zero-based indexing). Be sure to restrict the block to the grid boundaries if necessary.\\n5. For every cell within this 3x3 block, change its value to 4 (which corresponds to yellow) except for the center cell at (r, c), which must keep its original value.\\n6. Leave all cells outside this 3x3 block unchanged.\\n7. Output the grid with the same dimensions as the input, now modified by the new yellow (4) border around the intersection point.",
    "67e8384a.json": "1. Read the 3x3 input grid of integers (with rows indexed 0 to 2 and columns 0 to 2).\n2. For each row in the input grid, form a new row by appending the row’s reverse to itself. For example, if a row is [a, b, c], then create a new row [a, b, c, c, b, a].\n3. Collect the three new rows (one for each input row) to form the top half of a temporary 3x6 grid.\n4. Create the bottom half of the output grid by taking the top half rows in reverse order. That is, if the top half rows (from top to bottom) are R0, R1, and R2, then the bottom half should be R2, R1, R0.\n5. Concatenate the top half and the bottom half vertically to form the final 6x6 grid.\n6. Return the resulting 6x6 grid as the output.",
    "681b3aeb.json": "1. Identify the two connected components in the input grid by finding all nonzero cells (recall 0 represents black). Each component will have a single nonzero integer value (for example, 3, 7, 4, 6, 1, etc.).\n2. For each component, compute its minimal bounding rectangle and record the positions of its colored cells relative to that rectangle (i.e. subtract the minimal row and column of the component). This preserves the shape’s internal configuration.\n3. Choose the component whose bounding box has the smallest row (and if tied, smallest column) as Component A (the base) and designate the other as Component B (the overlay). Note that in the training examples the output cell (0,0) always comes from Component A.\n4. Translate Component A so that its bounding box’s top‐left cell maps to output coordinate (0,0) in a new grid of size 3×3. (For instance, in Example 2, after translation Component A (color 6) covers cells (0,0), (0,1), (0,2), (1,1), (1,2) and (2,2); in Example 3, Component A (color 1) covers (0,0), (0,1), (0,2) and (1,0), (1,2).)\n5. Determine a translation offset for Component B so that when its recorded relative positions are shifted and then overlaid onto the same 3×3 grid the union of cells from A and B exactly fills all 9 cells. The training examples show these arrangements: \n   • In one case (with colors 3 and 7) after translation Component A (color 3) occupies {(0,0), (0,1), (1,0), (2,0)} while Component B (color 7) is shifted so that its cells fall at {(0,2), (1,1), (1,2), (2,1), (2,2)}.\n   • In another (with colors 6 and 4) Component A (color 6) covers {(0,0), (0,1), (0,2), (1,1), (1,2), (2,2)} and Component B (color 4) is shifted to {(1,0), (2,0), (2,1)}.\n   • In a third example (with colors 1 and 3) Component A (color 1) covers {(0,0), (0,1), (0,2), (1,0), (1,2)} and Component B (color 3) is placed at {(1,1), (2,0), (2,1), (2,2)}.\n6. Build the 3×3 output grid by first placing all of Component A’s pixels at their translated coordinates. Then overlay Component B by writing its color into its translated coordinates (if a cell is already filled by A, the color from B overwrites it).\n7. Return the 3×3 grid whose cells are all nonzero and match one of the two component colors. This procedure preserves the original internal arrangement of each colored shape while “fitting” them together into a 3×3 square.",
    "6855a6e4.json": "1. Examine the input grid (a rectangular array of integers) and locate all cells with the value 2 (which represent the red bracket strokes). Group these 2’s into two distinct connected components (bracket objects). Note that in some examples the two brackets are arranged with one above the other (forming a horizontal frame) and in others they are arranged side by side (forming a vertical frame).\n2. Determine the orientation of the bracket pair by comparing the positions (for example, if the average row of one group is less than that of the other, they form a top (upper bracket) and bottom (lower bracket) pair; if their average columns differ, they form a left and right pair). Do not change any 2’s in the grid.\n3. Define the interior “frame” region where the gray objects (value 5) will be placed. • For a top/bottom (horizontal) arrangement: Let the vertical interior be the rows between (and not including) the bottom row of the upper bracket and the top row of the lower bracket. Let the horizontal span be taken as the union of the columns occupied by the two brackets. • For a left/right (vertical) arrangement: Let the horizontal interior be the columns between (and not including) the rightmost column of the left bracket and the leftmost column of the right bracket. Let the vertical span be taken as the union of the rows occupied by the two brackets. Then shrink the resulting interior by one pixel from every side so that there is a one‐cell (value 0) gap between any inserted gray and the red (2) pixels.\n4. Next, find all cells with the value 5 (the gray pixels) that are not part of the bracket components. They will form one or two separate gray objects. For each gray object, compute its minimal bounding box (the smallest rectangle that contains all its 5’s), recording the minimum and maximum row and column indices.\n5. Within each gray object’s bounding box, perform a vertical flip. That is, for every gray pixel originally at position (r, c) within the box, compute its new row as new_r = (min_row + max_row – r) (the column coordinate remains unchanged). This reverses the vertical order of the object’s pixels.\n6. For each gray object, decide which bracket it is associated with by comparing its location to the bracket pair (for example, the gray object originally nearer the upper bracket is paired with it and the one nearer the lower bracket is paired with that one; in a left/right arrangement use the horizontal proximity). Then compute the translation needed to move the flipped gray object so that the edge of its bounding box that was originally closest to its associated red bracket is relocated inward into the interior frame by a fixed offset. In practice, shift the object so that this edge lies exactly one cell away (i.e. with a one‐cell margin of 0’s) from the corresponding edge of the interior region of the frame.\n7. Erase all original gray (5) cells from the grid (set those positions to 0). Then, for each gray object, write its flipped and translated pixel pattern into the grid at the computed target positions. (If the translated pattern extends over several rows, the vertical order will be the mirror of the original as required.)\n8. Leave all red (2) pixels unchanged and all other cells remain 0. The resulting grid is the output.",
    "68b16354.json": "1. Read the input grid as a two‐dimensional array of integers (each integer is in the range 0 to 9). The grid is defined by rows and columns, where rows are numbered from 0 (top) to n - 1 (bottom).\n2. Determine the number of rows (n) in the grid. The number of columns (m) remains the same in the output.\n3. Create an output grid with the same number of rows and columns as the input grid.\n4. For each row index r from 0 to n - 1, copy the entire row from the input grid at index (n - 1 - r) to the output grid at index r. This step reverses the vertical order of the rows while preserving the order of elements within each row.\n5. Return the output grid as the final result.",
    "694f12f3.json": "1. Parse the 10x10 input grid and identify every connected cluster of cells with the value 4 (using only the four neighbors: up, down, left, right). Each such cluster is considered a shape with an outer border of 4.\n2. For each shape, determine its border and interior. A cell in a shape is a border cell if at least one of its four adjacent cells is not part of that same shape; all other cells in the shape are its interior cells.\n3. Count the interior cells of each shape.\n4. Select the shape having the maximum number of interior cells. For this shape, set the fill color for its interior cells to 2 (red).\n5. For every other shape, set the fill color for its interior cells to 1 (blue).\n6. Produce the output grid by copying the input grid exactly, except replace each interior cell (cells originally within a shape of 4 that are not on its border) with the designated fill color (2 for the shape with the most interior cells and 1 for all others). Do not alter cells that are not part of any shape or cells that are on the border (those remain 4).",
    "6a1e5592.json": "1. Consider the input grid as a two‐dimensional array with row indices 0..(n-1) and column indices 0..(m-1). 2. Identify the movable piece by collecting all cells (r, c) whose value is 5 (gray). 3. Remove the movable piece by setting every cell (r, c) with value 5 to 0. 4. Initialize a variable shift to 0. 5. Repeat: If for every cell (r, c) in the movable piece the cell immediately one row above its current shifted position, at (r - shift - 1, c), exists (i.e. r - shift - 1 ≥ 0) and has value 0, then increment shift by 1; otherwise stop. (This simulates moving the piece upward as far as possible without overlapping any nonzero cell.) 6. For each cell (r, c) in the movable piece, compute its new coordinate as (r - shift, c) and set that cell’s value to 1 (blue). 7. Leave all other cells (including those with value 2, which form the fixed top or ground shape, and the unchanged 0’s) exactly as they are. 8. Return the modified grid (which remains the same size as the input) as the output.",
    "6aa20dc0.json": "1. Find the background value by tallying all cell numbers in the input grid and choosing the most frequent digit. This digit (BG) will not be altered in the output.\n2. Locate every contiguous group (using 4‐connectivity) of cells whose values are not BG; call each such group an object.\n3. Among these objects, identify the unique complete template. To do this, look for the object whose bounding box is a square that can be divided evenly into 3×3 cells (if the object appears scaled, its bounding box will be 3k×3k for some positive integer k). This template must use exactly three distinct non‐BG digits. Denote these three numbers by A, B and C. (For example, in one instance the template’s cells might be arranged as a 3×3 block with values [A, B, B] in the top row, [B, B, X] in the middle row and [B, X, C] in the bottom row – note that the exact arrangement comes from the input template object.)\n4. For every other object whose bounding box is also a 3×3 (or 3k×3k) square but that is incomplete (i.e. it contains only a subset of {A, B, C}), determine which rotation (0°, 90°, 180° or 270°) of the template would align the positions of the cells that are present in the object with those in the complete template. (In other words, compare the relative positions of the object’s non‐BG cells with the corresponding positions in the candidate rotated template.)\n5. Once the correct rotation is determined, conceptually overlay the (rotated) template on the object’s bounding box. If the object is scaled (its bounding box is 3k×3k), treat each cell of the template as representing a k×k block. For every position (or block) in the bounding box that currently holds BG, fill it with the digit from the corresponding cell (or block) of the transformed template.\n6. Replace the cells of the object’s bounding box with this completed pattern so that the object now exactly matches the complete template (after the appropriate rotation and scaling).\n7. Leave all cells that are BG unchanged and retain the complete template object as is.\n8. Output the modified grid.",
    "6b9890af.json": "1. Find the red square in the input by scanning for all cells with value 2. Compute its minimal bounding box; let its side‐length be n (the output grid will be n×n). 2. Identify the secondary object by finding the unique nonzero digit other than 2 that appears in the input; call this digit X. (For example, in the provided cases X is 8, 1, or 4.) 3. Determine the minimal bounding box that covers every cell where the value X appears. In that extracted subgrid, for every cell that is not X, treat its value as 0. Call the resulting m×m grid the secondary pattern P. (In all given examples m = 3.) 4. Note that the interior of the red square (i.e. the region excluding its one‐cell–wide border) has size (n − 2)×(n − 2). It is guaranteed that (n − 2) is an integer multiple of m. Let the scale factor s = (n − 2) / m. 5. Create an output grid of size n×n. Fill every cell on the border (i.e. any cell in row 0, row n − 1, column 0, or column n − 1) with the value 2. 6. For every cell in the interior (with output grid coordinates r and c, where 1 ≤ r ≤ n − 2 and 1 ≤ c ≤ n − 2), calculate the corresponding coordinates in P by computing r_p = floor((r − 1) / s) and c_p = floor((c − 1) / s). Set the output cell at (r, c) to the value P[r_p][c_p]. 7. Return the completed output grid.",
    "6c434453.json": "1. Scan the entire input grid and, using 4-connected (horizontal and vertical) adjacency, identify every connected component made up of cells with value 1 (which represent blue pixels). 2. For each such component, compute its minimal bounding box. 3. If the bounding box is exactly 3 rows by 3 columns, extract the corresponding 3x3 subgrid and check that it exactly matches the following pattern: all eight border cells (that is, the top row cells, bottom row cells, leftmost cell of the middle row, and rightmost cell of the middle row) have value 1, while the center cell (middle row, middle column) is 0. This configuration indicates a hollow square (or blue square) pattern. 4. For every 3x3 subgrid that meets these criteria, replace its contents with a cross pattern as follows: set the center cell, the top-center cell, the bottom-center cell, the left-center cell, and the right-center cell to value 2 (red), and set the four corner cells to 0 (black). 5. Leave all other cells—including any cells with value 1 that are not part of a qualifying 3x3 hollow square—unchanged. 6. Produce the output grid with the same dimensions as the input grid.",
    "6cdd2623.json": "1. Let the input be a grid with R rows and C columns. Identify all border cells – that is, every cell in the first row, last row, first column, or last column.\n2. Among these border cells, count the nonzero values. Determine the unique number (call it X) that appears exactly four times on the border. (X will be one of the integers 1–9.)\n3. Collect the coordinates (row, column) of every border cell whose value equals X.\n4. Identify pairs of these coordinates by edge type:\n   a. If a border cell in the top row (row 0) and a border cell in the bottom row (row R–1) both have X and share the same column index, then mark that column as a vertical line candidate.\n   b. If a border cell in the leftmost column (column 0) and a border cell in the rightmost column (column C–1) both have X and share the same row index, then mark that row as a horizontal line candidate.\n   c. In some cases (for example when none appear in the top or bottom but two appear on the left and right edges in the same row), group the border cells by row and, for each row that has X in both the first and last column, mark that row for a horizontal line.\n5. Create a new output grid of the same dimensions as the input and fill every cell with 0.\n6. For each vertical line candidate (a column index c determined in step 4a), set every cell in column c (for all rows 0 ≤ r < R) in the output grid to X.\n7. For each horizontal line candidate (a row index r determined in step 4b or 4c), fill every cell in row r (for all columns 0 ≤ c < C) in the output grid with X.\n8. Return the output grid. (In other words, the output is the input-sized grid with only one or two lines drawn in color X – a full vertical line if a top–bottom pair exists and a full horizontal line if a left–right pair exists – and all other cells set to 0.)",
    "6cf79266.json": "1. Begin with the input grid of integers (each between 0 and 9) that has two colors: the background color 0 (black) and another color (for example, 4, 3, 5, 7, etc.) arranged in a random pattern. The output grid will have the same dimensions as the input grid.\n2. Make a copy of the input grid to use as the output grid.\n3. For every cell (r, c) in the grid that can serve as the top‐left corner of a 3x3 subgrid (that is, for each r from 0 to (number_of_rows − 3) and each c from 0 to (number_of_columns − 3)), examine the 3x3 block defined by the cells at coordinates (r + i, c + j) for i, j ∈ {0, 1, 2}.\n4. If every cell in that 3x3 block has the value 0 (black), then replace all nine cells in that subgrid with the value 1 (blue). \n5. Leave all other cells unchanged.\n6. Return the output grid. \n(This procedure changes each solid 3x3 square composed entirely of 0’s into a 3x3 square of 1’s while preserving the rest of the grid unchanged.)",
    "6d0160f0.json": "1. Recognize that the grid is 11×11 with fixed border lines: rows 3 and 7 and columns 3 and 7 are border cells; these always remain 5. 2. Partition the non‐border cells into 9 subgrids (blocks) of size 3×3. The blocks are arranged in a 3×3 layout where the top‐left block occupies rows 0–2 and columns 0–2, the top‐center occupies rows 0–2 and columns 4–6, the top‐right occupies rows 0–2 and columns 8–10, the middle‐left occupies rows 4–6 and columns 0–2, the middle‐center occupies rows 4–6 and columns 4–6, the middle‐right occupies rows 4–6 and columns 8–10, the bottom‐left occupies rows 8–10 and columns 0–2, the bottom‐center occupies rows 8–10 and columns 4–6, and the bottom‐right occupies rows 8–10 and columns 8–10. 3. In the input’s non‐border area, locate the unique cell with value 4 (yellow). Let its overall grid coordinates be (r, c). 4. Determine the source subgrid: identify which 3×3 block already contains the yellow cell. Let the starting row and column of that block be R0 and C0 (these will be 0, 4, or 8). 5. Compute the relative coordinates of the yellow cell within its block as (r_rel, c_rel) = (r − R0, c − C0), where each is 0, 1, or 2. 6. Use the relative coordinates (r_rel, c_rel) as indices to select the target subgrid in the overall 3×3 arrangement; that is, the target block is the one in row r_rel and column c_rel (for example, a relative coordinate of (0,2) means the target block is the top‐right block). 7. Copy the entire source subgrid (all its 3×3 non‐border cells from the input) but replace any cell in that block that equals 5 (grey) with 0 (black). 8. In the output grid, set every non‐border cell to 0 except for the cells in the target subgrid; fill the target subgrid with the modified copy from step 7. 9. Finally, copy all border cells (those in rows 3 and 7 and columns 3 and 7) unchanged into the output (they remain 5).",
    "6d0aefbc.json": "1. Read the input grid which is 3 rows by 3 columns, where each cell contains a number between 0 and 9.\n2. For each row in the input grid, form a new row by taking the entire row (for example, [a, b, c]) and then create its mirror image by reversing the order of its elements (resulting in [c, b, a]).\n3. Concatenate the original row with its reversed copy to form a new row of 6 cells: [a, b, c, c, b, a].\n4. Repeat steps 2 and 3 for every row in the input grid to generate all rows of the output grid.\n5. Assemble the new rows into a grid of dimensions 3 by 6 and output the resulting grid.",
    "6d58a25d.json": "1. Identify the main figure in the grid by finding the largest connected group of nonzero cells (using 4‐way connectivity). This group is considered the primary shape (the “point”, “arrow head”, or “large shape”).\n2. For each column j in the grid that contains one or more cells of the main figure, determine the bottom (maximum row index) of the main figure in that column; call this row R_main(j).\n3. In the same column j, starting at row R_main(j) + 1 and scanning downward to the last row, look for the first cell that is nonzero and is not part of the main figure. If such a cell is found at some row and its value is v (an integer between 1 and 9), then proceed; if no such cell exists, leave column j unchanged.\n4. For every row r from R_main(j) + 1 to the bottom of the grid in column j, set the cell’s value to v. (This “vertical extension” effectively fills the entire gap below the main figure in that column with the value of the lower, isolated colored cell.)\n5. Do not alter any cells that belong to the main figure or any columns where no nonzero cell is found below the main figure. The grid size remains the same.",
    "6d75e8bb.json": "1. Traverse the input grid and record the coordinates of every cell whose value is 8 (this value represents the blue/light blue area).\n2. Determine the bounding rectangle of the 8‐cells by finding the minimum row index (min_row), maximum row index (max_row), minimum column index (min_col), and maximum column index (max_col) among these cells.\n3. For each cell within the rectangle defined by rows min_row to max_row and columns min_col to max_col, check its value: if it is not 8, change that cell’s value to 2 (which represents red); if it is already 8, leave it unchanged.\n4. Leave all cells outside of this bounding rectangle exactly as they are (typically 0 for the background).\n5. Return the modified grid with the same overall dimensions as the input.",
    "6e02f1e3.json": "1. Read the 3x3 input grid and compute the set of distinct numbers present.\n2. Create a 3x3 output grid with every cell initialized to 0 (0 represents black).\n3. If the input grid has exactly 1 distinct number, fill the entire top row (cells at coordinates (0,0), (0,1), (0,2)) with 5 (which represents grey).\n4. If the input grid has exactly 2 distinct numbers, fill the main diagonal (cells at (0,0), (1,1), (2,2)) with 5.\n5. If the input grid has exactly 3 distinct numbers, fill the anti-diagonal (cells at (0,2), (1,1), (2,0)) with 5.\n6. Return the output grid.",
    "6e19193c.json": "1. For each distinct connected group of nonzero cells in the grid, if the group’s cells all have the same value v and there are exactly 3 cells forming an L‐shape that fits in a 2×2 block, then proceed with the following steps (ignore groups that do not meet these criteria).\n2. Compute the bounding box of the group. Let r_min and r_max be the minimum and maximum row indices and c_min and c_max be the minimum and maximum column indices of the cells in the group. (This bounding box will consist of the four cells: (r_min, c_min), (r_min, c_max), (r_max, c_min) and (r_max, c_max)).\n3. Identify the missing cell in this 2×2 block—the one coordinate among the four that is not part of the group. Denote its coordinates as (r_m, c_m).\n4. Determine the diagonal direction from the missing cell according to its location in the bounding box:\n   • If (r_m, c_m) equals (r_min, c_max) [top‐right], set the step/direction to (–1, +1).\n   • If (r_m, c_m) equals (r_max, c_min) [bottom–left], set the step/direction to (+1, –1).\n   • If (r_m, c_m) equals (r_min, c_min) [top–left], set the step/direction to (–1, –1).\n   • If (r_m, c_m) equals (r_max, c_max) [bottom–right], set the step/direction to (+1, +1).\n5. From the missing cell, add the step once to get the starting cell for the diagonal fill: (r_m + d_row, c_m + d_col). Then, while the current cell is within grid bounds, set its value to v. Continue adding the same step to move to the next cell along this diagonal and fill it with v until the next step lies outside the grid.\n6. Do not change any other cells (including the cells of the original L‐shape and the missing cell, which remains 0). The transformed grid retains the same dimensions as the input.",
    "6e82a1ae.json": "1. Iterate over every cell (using row, column indices) in the input grid. For each cell with value 5 (the gray color), if it has not already been assigned to a group, perform a flood‐fill (or connected component search) using orthogonal (up, down, left, right) neighbors to collect all adjacent cells that also have value 5. This defines a contiguous group of gray cells. 2. Count the number of cells in the group. 3. If the group contains exactly 2 cells, change every cell in that group to 3 (green). If the group contains exactly 3 cells, change every cell in that group to 2 (red). If the group contains exactly 4 cells, change every cell in that group to 1 (blue). 4. Leave all cells that are not 5 unchanged. 5. The output grid must have the same dimensions as the input grid.",
    "6ecd11f4.json": "1. Locate the two distinct nonzero rectangular components in the input grid. One is a large rectangular pattern and the other is a small rectangular pattern. (Here numbers are used directly; 0 represents black.)\n2. Determine the bounding box of each component. Define the small pattern as the component whose bounding box has the smaller area. Let its dimensions be R rows by C columns; these (R,C) will be the output grid size.\n3. Extract the small pattern by cropping the input grid to its bounding box (preserving the original numbers in that region).\n4. From the remaining (large) component, compute its bounding box. Partition this large bounding box into an R×C grid by dividing its rows into R equal (or nearly equal) segments and its columns into C equal segments. In each of the R×C sub‐blocks, select a representative cell (for example, the center cell).\n5. Form a binary mask from the large pattern by setting each corresponding mask cell to 1 if the representative cell’s value is nonzero and to 0 if it is 0.\n6. Build the output grid (of size R×C) by iterating over every cell (r,c) in the extracted small pattern. For each cell, if the corresponding mask cell is 1 then copy the small pattern’s number at (r,c) to the output; if the mask cell is 0, set the output cell to 0 (black).\n7. Return the resulting grid. (This overlays the black (0) pattern of the large rectangle onto the small pattern, so that only those cells in the small pattern that align with nonzero cells in the rescaled large pattern keep their original value.)",
    "6f8cd79b.json": "1. Read the input grid and determine its dimensions: let R be the number of rows and C be the number of columns.\n2. Create an output grid of the same dimensions.\n3. For each cell located at row r and column c (using 0-indexing), check if the cell is on the border of the grid. A cell is on the border if r = 0 (top row), r = R - 1 (bottom row), c = 0 (left column) or c = C - 1 (right column).\n4. If the cell is on the border, set its value to 8 (which represents cyan/light blue). If the cell is not on the border, set its value to 0 (black).\n5. Output the resulting grid.",
    "6fa7a44f.json": "1. Accept a 3x3 input grid where each cell contains an integer from 0 to 9.\\n2. Create an output grid with 6 rows and 3 columns.\\n3. For each row r (0 ≤ r ≤ 2) and each column c (0 ≤ c ≤ 2), set the output cell at (r, c) equal to the input cell at (r, c). This copies the input grid into the top half of the output.\\n4. For each row r (0 ≤ r ≤ 2) and each column c (0 ≤ c ≤ 2), set the output cell at (r+3, c) equal to the input cell at (2 - r, c). This fills the bottom half with a vertical mirror (i.e. reversed row order) of the input grid.\\n5. Return the resulting 6x3 output grid.",
    "72322fa7.json": "1. Begin by copying the input grid exactly so that the output grid has the same dimensions.\n2. In the input grid, identify groups of nonzero cells that are connected by 4‐neighbor adjacency. Treat any connected group having more than one cell as a complete exemplar of a shape. For each exemplar, compute its minimal bounding rectangle and record the pattern as a set of relative offsets and corresponding numeric values (for example, one observed exemplar is a one‐row triplet with values [4,8,4] where 4 means yellow and 8 means cyan; another is a one‑row triplet [8,2,8] with 8 = cyan and 2 = red; a third exemplar is a 3×3 pattern whose nonzero cells (when normalized) occur at offsets (0,0), (0,2), (1,1) and (2,0), (2,2) with values 1 (blue) at the corners and 3 (green) in the center). In each exemplar, choose the anchor as the center cell of its bounding box (if the width or height is even, choose the top‐left cell among the central ones).\n3. Next, scan the entire grid for cells that are nonzero but are not part of a multi–cell connected group (that is, singletons) or are parts of incomplete patterns. For each such seed cell, decide which exemplar’s pattern it should follow by matching its numeric value with one of the numbers in an exemplar’s normalized pattern.\n4. To complete an incomplete occurrence, overlay the entire exemplar pattern onto the output grid so that the exemplar’s anchor aligns with the seed cell’s position. For every relative offset in the exemplar pattern, if the corresponding cell in the output grid is 0, set it to the numeral specified by the exemplar at that offset. (For example, if the exemplar is the horizontal triplet [4,8,4] and a row in the input contains only two 4’s with a gap between them, fill the gap with an 8 so that the completed row becomes 4,8,4. Similarly, if a singleton 8 appears where the complete pattern should be [8,2,8], add 4’s on the sides if the exemplar defines that pattern, or add the missing 2 in the middle if the seed matches one of the side values, depending on which cell in the exemplar is designated as the anchor.)\n5. Process every seed/incomplete occurrence in the grid in this way so that for each shape type every occurrence (even if originally only a single cell or a partial pattern) is expanded to exactly match its corresponding complete exemplar pattern.\n6. Return the modified output grid.\n\nNotes:\n• Use only numbers to represent colors (0 = black, 1 = blue, 2 = red, 3 = green, 4 = yellow, 6 = pink/fuchsia, 8 = cyan/light blue, etc.).\n• Observed exemplar patterns include the horizontal triplet [4,8,4] and [8,2,8] and a 3×3 pattern with relative offsets {(0,0)=1, (0,2)=1, (1,1)=3, (2,0)=1, (2,2)=1} where 1 is blue and 3 is green.\n• This procedure copies the complete (exemplar) shapes from one part of the grid and uses them to fill in missing pixels around singletons so that every occurrence of a given shape appears exactly as defined by its exemplar.",
    "72ca375d.json": "1. Treat the input as a rectangular grid of integers (each 0–9), where 0 represents the background. 2. Find every connected component of nonzero cells using 4‐connectivity (neighbors above, below, left, right). Each connected group (all cells having the same nonzero value) is called a figure. 3. For each figure, determine its minimal bounding rectangle (the smallest subgrid that contains all cells of that figure). Define the rectangle by its topmost row, bottommost row, leftmost column, and rightmost column. 4. For each figure, count the number of cells in the figure and compute the area (width multiplied by height) of its bounding rectangle. Then calculate the density = (number of nonzero cells in the figure) divided by (area of its bounding rectangle). 5. Select the figure that has the highest density. If two or more figures have the same density, choose the one whose bounding rectangle’s top row is smallest; if still tied, choose the one with the smallest left column. 6. Produce the output grid by extracting the subgrid defined by the selected figure’s minimal bounding rectangle. Preserve all cell values in that rectangle (i.e. both the nonzero cells of the figure and any 0’s that fall within the bounding box).",
    "73251a56.json": "Process the grid without changing its size. Notice that aside from some cells with the value 0 (which represent the color black), every cell is already filled with a digit from 1 to 9 and the overall picture shows a well‐organized, repeating two‐dimensional pattern. In every example the top row and the leftmost column are completely filled and (when read left‐to‐right or top‐to‐bottom) follow the same repeating sequence. (Recall that the mapping is 0 = black, 1 = blue, 2 = red, 3 = green, 4 = yellow, 5 = grey, 6 = fuchsia, 7 = orange, 8 = cyan, 9 = brown.)\n\nThe intended transformation is to “inpaint” the missing (0) cells so that each row’s horizontal pattern is continuous and agrees with the overall rule established by the nonzero cells. To do this, work row by row as follows:\n1. For each row, leave every nonzero cell unchanged.\n2. In each row, identify every contiguous block (one or more adjacent cells) whose value is 0. (These 0’s mark missing parts of an otherwise complete, segmented sequence.)\n3. For each such block, determine its correct fill by inferring the ideal horizontal sequence of that row. To do this, treat the already‐present nonzero values as clues: the complete row (if it had no gaps) would follow the pattern defined by the top row (which – when read left‐to‐right – is identical to the left column when read top‐to‐bottom). Therefore the missing cells in a gap must be replaced by the digits that would appear in those column positions in the “perfect” row. (In some examples the gap is bordered on the left by one digit and on the right by a different digit; in those cases the proper fill is the one that makes the row’s segmented pattern continuous. For example, if a gap is immediately preceded by a block of 5’s and immediately followed by a block starting with 6, then—in the given examples—the entire gap is filled with 6’s; in another row with the same left/right borders the first cell of the gap might copy the left value while the remaining cells copy the right value. In all cases the filled values come exactly from the underlying repeating pattern.)\n4. If a gap occurs at the beginning or end of a row (so that there is no left or right neighbor), then use the corresponding element from the top row (or left column) to determine the proper digit.\n5. Replace every 0 in the input with its determined digit so that the fully filled output row exactly matches the repeating pattern observed in the training examples.\n\nThis procedure – keeping all nonzero cells intact and filling each 0 by “continuing” the already‐established horizontal pattern (which in turn is consistent with the top row and left column) – produces an output grid that exactly duplicates the examples provided.",
    "7447852a.json": "1. Process the grid row‐by‐row without changing its dimensions. Note that in the input only two values occur: 2 (red) and 0 (black). All cells with value 2 must remain unchanged.\n2. In each row, identify contiguous groups (segments) of cells that have value 0. A segment is defined as one or more adjacent cells (horizontally) that are 0, delimited by cells that are not 0 or by the row boundaries.\n3. Determine the fill offset for the row as follows: if the first cell in the row is 0 (black), then the fill pattern will apply to the 1st, 4th, 7th, … nonempty 0‐segments (i.e. segments whose 1–based order number modulo 3 is 1). If the first cell is 2 (red), then use an offset of one; in that case the first encountered nonempty 0–segment is considered segment 1 (do not fill it), and then fill the 2nd, 5th, 8th, … segments (i.e. those segments whose 1–based order number modulo 3 equals 2).\n4. For each row, scan from left to right. Each time you come to a run of one or more 0’s, increment a segment counter. If the counter (using 1–based indexing) satisfies:\n   • counter mod 3 = 1 for rows that begin with 0, or\n   • counter mod 3 = 2 for rows that begin with 2,\nthen change every cell in that contiguous group from 0 to 4 (yellow). Otherwise leave the group as 0.\n5. Leave all cells with value 2 unchanged. The other 0’s that are not part of a filled segment remain 0.\n6. Return the modified grid as the output.",
    "7468f01a.json": "1. Scan the entire input grid and identify all cells with a value different from 0 (0 represents the background). Determine the minimum and maximum row indices and the minimum and maximum column indices where a nonzero value appears; these define the bounding box of the object. 2. Extract the subgrid defined by this bounding box. This subgrid contains all the nonzero cells (which may include any numbers from 1 to 9) in their original arrangement. 3. For each row in the extracted subgrid, reverse the order of the cells (i.e., perform a horizontal mirror flip) so that the cell originally at column C in the subgrid moves to column (width - C + 1). 4. Output the resulting grid. The output grid has the same dimensions as the bounding box, and each cell retains its original value after the horizontal reversal.",
    "746b3537.json": "1. Determine if the input grid has all identical rows. To do this, compare every row with the first row. \n2. If all rows are identical (horizontal mode):\n   a. Select the first row from the grid. This row is a list of numbers, for example, [a, b, b, c, ...].\n   b. Create a new row by iterating over the row from left to right and keeping the first number, then only add a number if it is different from the number immediately to its left. \n   c. Output this new row as the entire output grid (a single row). \n3. If the rows are not identical (vertical mode):\n   a. Note that each row in the input grid is uniform (all cells in a row have the same number). For each row, select one representative number (for example, the leftmost cell).\n   b. Create a list from these numbers in top-to-bottom order. \n   c. Compress this list by keeping the first number and then, for each subsequent number, add it only if it is different from the one immediately above it. \n   d. Output this compressed list as a single column grid (each number on a new row). \n4. Return the resulting grid as the final output.",
    "74dd1130.json": "1. Determine the dimensions of the input grid (assume it is square, with equal number of rows and columns). 2. Create an output grid with the same dimensions as the input grid. 3. For every cell in the output grid with coordinates (r, c), set its value to be the value found at coordinates (c, r) in the input grid (that is, perform a transpose operation). 4. Return the output grid.",
    "75b8110e.json": "1. Interpret the input as an 8x8 grid and divide it into four 4x4 quadrants using zero‐based indexing: \n   • Top‐left quadrant: rows 0–3, columns 0–3 (contains nonzero cells with value 4).\n   • Top‐right quadrant: rows 0–3, columns 4–7 (contains nonzero cells with value 5).\n   • Bottom‐left quadrant: rows 4–7, columns 0–3 (contains nonzero cells with value 6).\n   • Bottom‐right quadrant: rows 4–7, columns 4–7 (contains nonzero cells with value 9).\n   Note: In all quadrants, a cell with value 0 is considered transparent.\n2. Create an output grid of size 4x4 (indices 0–3 for both rows and columns).\n3. Copy the top‐left quadrant into the output grid: for each cell (r, c) with 0 ≤ r, c < 4, set the output cell to the corresponding top‐left quadrant cell (typically 4 for the pattern, with 0 where no pattern exists).\n4. Overlay the bottom‐right quadrant onto the output grid: for each cell (r, c) in the bottom‐right quadrant (from input row r+4, column c+4), if the quadrant cell is nonzero (value 9), replace the output cell at (r, c) with this value.\n5. Overlay the bottom‐left quadrant next: for each cell (r, c) in the bottom‐left quadrant (from input row r+4, column c), if the cell is nonzero (value 6), replace the output cell at (r, c) with this value.\n6. Finally, overlay the top‐right quadrant: for each cell (r, c) in the top‐right quadrant (from input row r, column c+4), if the cell is nonzero (value 5), replace the output cell at (r, c) with this value.\n7. The 4x4 output grid, after applying these overlays in order (top‐left, then bottom‐right, then bottom‐left, then top‐right), is the final result.",
    "760b3cac.json": "1. Identify the blue shape: scan the input grid and collect every cell whose value is 8. (Note: 8 represents blue.)\n2. Compute the overall horizontal bounding box of the blue shape. Let c_min be the smallest column index and c_max be the largest column index among all blue cells.\n3. Identify the yellow shape by scanning for cells with value 4 (yellow). Find the topmost yellow cell (the one with the smallest row index) and record its column index as yellow_top_col.\n4. Decide the mirror direction for the blue shape as follows: if yellow_top_col is less than 4 then the mirror copy will be placed on the left side; if yellow_top_col is greater than 4 then the mirror copy will be placed on the right side. (Assume a grid with 9 columns so that column 4 is the center.)\n5. Let width = (c_max - c_min + 1), which is the horizontal span of the blue shape.\n6. For every blue cell at coordinate (r, c) in the input:\n   a. Compute its horizontally flipped column within the blue shape’s bounding box by: flipped = c_max - (c - c_min).\n   b. If the mirror direction is left, compute the new column as: new_c = flipped - width.\n   c. If the mirror direction is right, compute the new column as: new_c = flipped + width.\n   d. In the output grid, set the cell at (r, new_c) to 8.\n7. Copy all other cells from the input grid (including cells with values 0 and 4) unchanged to the output grid.\n8. The final output grid has the original blue shape (value 8) unchanged and a horizontally flipped mirror copy of it added on the appropriate side as determined by the position of the yellow shape (value 4).",
    "776ffc46.json": "1. Copy the input grid exactly to the output grid initially. \n2. For each contiguous group of cells with value 5 (using 4‐neighbor connectivity), check if it forms a complete border. A border is complete if, when you take its minimal bounding rectangle, every cell along the perimeter of that rectangle belongs to that group. (Here 5 represents gray.) \n3. For each complete border found, define its interior as the set of cells strictly inside its bounding rectangle. In that interior, identify the connected component (using 4‐neighbor connectivity) made of nonzero cells that is not composed of 5’s. (Assume 0 is background.) This connected component is the template shape; record its pattern by normalizing the coordinates (subtract the top‐left corner of its minimal bounding box) and note its color (for example, in some examples this comes out as 2 and in others as 3). \n4. Then scan the entire grid for every connected component of nonzero cells (ignoring 0 and excluding any cells that are part of a border, i.e. cells with value 5). For each such component, compute its normalized shape (by subtracting the coordinates of the top‐left cell of its minimal bounding box). \n5. If the normalized set of relative positions exactly matches that of the template shape obtained from a complete border, recolor all cells in that component to the template’s color (i.e. the nonzero value found inside the border). \n6. Leave all other cells (background, border cells, and any components whose shape does not match) unchanged. \n7. Output the resulting grid.",
    "77fdfe62.json": "1. Determine the dimensions M×N of the input grid. 2. Identify the output grid by cropping the input: remove the first two rows, the last two rows, the first two columns, and the last two columns (that is, take only rows 3 through M−2 and columns 3 through N−2). 3. Record the four corner values of the original grid: top‐left at (1,1), top‐right at (1,N), bottom‐left at (M,1) and bottom‐right at (M,N). For example, in a sample these might be 2, 3, 4, and 6 respectively. 4. For each cell in the cropped grid, determine its global coordinate (r,c) in the original grid (note that the cropped grid’s (1,1) corresponds to (3,3) in the input). 5. If a cell’s value is 8 (representing cyan/light blue), compute its Manhattan distance to each of the four original corners using the formula: distance = |r − r_corner| + |c − c_corner|. 6. Replace that cell’s value with the value of the corner (one of the four recorded numbers) that minimizes this distance. 7. Leave any cell whose value is not 8 unchanged. 8. Return the modified cropped grid as the output.",
    "780d0b14.json": "1. Scan the input grid and ignore all cells with the value 0 (which represents the background). For every cell with a nonzero value (digits 1–9), use 4-connected (up, down, left, right) flood-fill to identify its connected component. Each connected component will consist entirely of one digit.\n2. For each connected component, compute its minimal bounding rectangle by recording the smallest row (min_row), largest row (max_row), smallest column (min_col) and largest column (max_col) that contain a cell of the component. You may also compute the vertical center (for example, (min_row + max_row)/2) for later ordering.\n3. Group the connected components into horizontal rows for the output grid as follows: two components belong to the same output row if their vertical spans overlap (that is, if the interval [min_row, max_row] of one intersects the interval of the other). This ensures that components drawn on the same horizontal level in the input are assigned to the same output row.\n4. Within each horizontal group, sort the components by their horizontal position (for example, by min_col or the center column) in increasing order so that leftmost components come first. Assign each component in the group to consecutive output columns in that order.\n5. Form the output grid by creating a matrix where each cell contains the digit of the connected component assigned to that output cell. The number of output rows equals the number of horizontal groups and the number of columns in each row equals the number of components (as determined by left-to-right order) in that group.\n6. Return this output grid, which places in each cell the single-digit value (such as 1, 8, 6, 4, 3, 2, or 7) of the corresponding component, thereby preserving the spatial (top-to-bottom and left-to-right) arrangement of the colored regions in the input.",
    "7837ac64.json": "1. Find the bounding box of the drawn‐grid pattern by scanning the input for all nonzero cells; let (top, left) be the minimum row and column and (bottom, right) the maximum row and column that contain a nonzero value. This bounding box is known to enclose a grid whose drawn squares form a 3×3 arrangement.\n2. Divide the bounding box evenly into three rows and three columns by computing four horizontal divider indices and four vertical divider indices. (For example, let r0 = top, r3 = bottom and let r1 and r2 be the rounded positions that split the vertical span into three equal parts; similarly, let c0 = left, c3 = right and choose c1 and c2 to split the horizontal span into three equal parts.) These divider indices mark the grid‐lines (the boundaries of the drawn squares).\n3. For each cell of the 3×3 grid (using indices i = 0,1,2 for rows and j = 0,1,2 for columns), define its four corner intersection pixels as follows: one at (r_i, c_j), one at (r_i, c_{j+1}), one at (r_{i+1}, c_j) and one at (r_{i+1}, c_{j+1}). (All coordinates are zero‐indexed, with row increasing downward and column increasing to the right.)\n4. Check these four corner pixels: if they all have the same value and that value is not 0, then set the corresponding output grid cell to that common number; otherwise, set the output cell to 0. (For example, if all four corners are 1 then the output cell becomes 1; if they are not all equal, output 0.)\n5. Construct a new 3×3 grid whose cell (i, j) is the number determined in step 4 and return this grid as the output.",
    "794b24be.json": "1. Examine the input grid (always 3×3) and count the number of cells whose value is 1 (these represent blue blocks). Let this count be n. 2. Create an output grid of the same size filled entirely with 0s (0 represents the background). 3. Replace specific 0s with 2 (which represents red) according to the fixed order based on the value of n, as follows:\n   a. If n ≥ 1, set the cell at row 0, column 0 to 2.\n   b. If n ≥ 2, set the cell at row 0, column 1 to 2.\n   c. If n ≥ 3, set the cell at row 0, column 2 to 2.\n   d. If n equals 4, set the cell at row 1, column 1 to 2.\n4. Return the output grid.",
    "7b6016b9.json": "1. Set the output grid dimensions equal to the input grid dimensions.\n2. Define the background as cells with value 0. All cells with a nonzero value (such as 8, 1, 4, or 7) form the drawn shape’s boundary and must be preserved in the output.\n3. Starting from every cell on the perimeter of the grid (the first and last rows and columns) that has a value of 0, perform a flood fill to mark all connected background cells as part of the exterior region.\n4. For each cell in the input grid:\n   a. If the cell’s value is nonzero, copy that value directly to the output (it is part of the boundary).\n   b. If the cell’s value is 0 and it was reached by the flood fill (i.e. it is in the exterior region), set the output cell to 3.\n   c. If the cell’s value is 0 and it was not reached by the flood fill (i.e. it is enclosed by the boundary), set the output cell to 2.\n5. Return the resulting grid.",
    "7b7f7511.json": "1. Determine the dimensions of the input grid: let R be the number of rows and C be the number of columns. 2. Compare R and C to decide which half to keep based on the longer dimension. 3. If C > R (the grid is wider than it is tall), then perform a vertical cut by, for each row, copying the first C/2 elements (i.e., the elements from column 0 up to column (C/2 - 1)) to form the output row. 4. If R > C (the grid is taller than it is wide), then perform a horizontal cut by copying the first R/2 rows (i.e., rows with indices 0 to (R/2 - 1)) entirely to form the output grid. 5. If R equals C (the grid is square), then default to a vertical cut by copying for each row the first C/2 elements. 6. Return the grid constructed in step 3, 4, or 5 as the output.",
    "7c008303.json": "1. Locate the divider row and column in the 9x9 input grid. These are the unique row and column in which every cell is 8 (recall that 8 represents cyan/light blue). Use zero‐indexed rows and columns.\n2. Partition the grid into four regions using the divider row and column. Define the regions as follows:\n • Top‐left: all cells above the divider row and left of the divider column.\n • Top‐right: all cells above the divider row and right of the divider column.\n • Bottom‐left: all cells below the divider row and left of the divider column.\n • Bottom‐right: all cells below the divider row and right of the divider column.\n3. Identify the 2x2 region (section A) among these four regions. This 2x2 block supplies the replacement colors. Label its cells as follows: upper‐left (A_UL), upper‐right (A_UR), lower‐left (A_LL) and lower‐right (A_LR).\n4. Identify the 6x6 region (section B) among the partitions. This region consists only of 0’s and 3’s (with 3 originally signifying green) and will form the basis of the output.\n5. Set the output grid equal to section B (a 6x6 grid).\n6. Divide the 6x6 output grid into four quadrants of equal size (3x3 each):\n • Quadrant 1 (upper‐left): rows 0–2, columns 0–2\n • Quadrant 2 (upper‐right): rows 0–2, columns 3–5\n • Quadrant 3 (lower‐left): rows 3–5, columns 0–2\n • Quadrant 4 (lower‐right): rows 3–5, columns 3–5\n7. In each quadrant, replace every cell that is equal to 3 with a new number as follows:\n • In Quadrant 1, change 3 to the value A_UL.\n • In Quadrant 2, change 3 to the value A_UR.\n • In Quadrant 3, change 3 to the value A_LL.\n • In Quadrant 4, change 3 to the value A_LR.\n8. Leave all other cells (typically 0) unchanged. The resulting modified 6x6 grid is the output.",
    "7ddcd7ec.json": "1. Determine the dimensions of the input grid and create an output grid of the same size, initially copying every cell from the input. \n2. Locate a 2x2 block (square) of nonzero cells that all have the same integer value X (for example, X may be 3, 4, 7, 8, etc.). This square can be identified by finding a cell at (r, c) where the cells at (r, c), (r, c+1), (r+1, c) and (r+1, c+1) all equal X. \n3. For each of the four corners of this square, do the following: \n   a. Define the corner coordinates and an associated diagonal offset v as follows:\n      - For the top‐left corner at (r, c): use v = (−1, −1).\n      - For the top‐right corner at (r, c+1): use v = (−1, +1).\n      - For the bottom‐left corner at (r+1, c): use v = (+1, −1).\n      - For the bottom‐right corner at (r+1, c+1): use v = (+1, +1).\n   b. Compute the potential extra cell position by adding the offset v to the corner’s coordinates. If this position lies within the grid bounds and its value equals X in the input, then it is the starting point for a diagonal chain. \n4. For each diagonal chain identified in step 3, starting at the extra cell, repeatedly add the same offset v to the current position. At each step, if the new position is within the grid, set that cell in the output grid to X. Continue this process until the next position would fall outside the grid. \n5. Leave all other cells unchanged (typically these are 0). \n6. The final output grid is the result after extending each extra cell (that is diagonally adjacent to a square corner) along its corresponding diagonal until the border is reached.",
    "7df24a62.json": "1. Make an exact copy of the input grid to serve as the output grid.\n2. Define a fixed 5×5 stamp pattern that represents the yellow‐with–blue–border motif. In this stamp, use 1 for blue and 4 for yellow. The stamp (with rows and columns indexed 0–4) is defined as follows:\n   • Row 0: [1, 1, 1, 1, 1]\n   • Row 1: [1, 4, 1, 1, 1]\n   • Row 2: [1, 1, 1, 4, 1]\n   • Row 3: [1, 4, 1, 1, 1]\n   • Row 4: [1, 1, 1, 1, 1]\n   (Here, 4 represents yellow and 1 represents blue.)\n3. For every possible 5×5 window (subgrid) in the grid (i.e. for each top‐left cell (r, c) such that the window covers rows r to r+4 and columns c to c+4), check for the presence of the distinctive yellow pattern. Specifically, if the cells at the following positions within the window have the value 4:\n   • (r+1, c+1),\n   • (r+2, c+3), and\n   • (r+3, c+1),\n   then consider that window as an occurrence of the yellow pattern that should be surrounded by blue.\n4. For each 5×5 window that meets the above condition, overwrite the entire 5×5 block in the output grid with the stamp pattern defined in step 2. (This has the effect of “surrounding” the yellow cells with blue exactly as in the template.)\n5. Leave all cells that are not part of any detected 5×5 window unchanged.\n6. Return the output grid.\n\nNote: All numbers refer to actual grid cell values, where 0 is the background, 1 is blue, and 4 is yellow.",
    "7e0986d6.json": "1. Scan the input grid and count the frequency of every nonzero number. Define the dominant value D as the nonzero integer that occurs most frequently (for example, in the examples D is 3, 2, or 5). \n2. Initialize an output grid of the same dimensions as the input. \n3. For each cell at row r and column c:\n   a. If the cell’s value is 0, set the output at (r, c) to 0 (background remains unchanged).\n   b. If the cell’s value is equal to D, copy D to the output at (r, c).\n   c. If the cell’s value is nonzero and not equal to D, examine its four orthogonal neighbors (the cells directly above, below, to the left, and to the right – ignore any neighbors that fall outside the grid boundaries).\n      i. Count how many of these adjacent neighbors have the value D.\n      ii. If two or more neighbors are equal to D, set the output at (r, c) to D (thereby “correcting” that cell to follow the dominant contiguous area).\n      iii. Otherwise, set the output at (r, c) to 0 (removing isolated or inconsistent pixels).\n4. Return the output grid.",
    "7f4411dc.json": "1. Scan the input grid row‐by‐row. In each row, identify every contiguous horizontal segment of nonzero cells (i.e. cells whose integer value is not 0). Record for each such segment its color (for example, 7 in Training Example 1, 6 in Training Example 2, 5 in Training Example 3, and 8 in the Test Example) and its start and end column indices. \n2. (Horizontal filtering) In each row, treat as candidate segments only those that are not isolated. In our examples most stray pixels (a segment of length 1) are removed; however, if a row contains more than one segment then each candidate is treated separately. In effect, a candidate segment is one that spans at least two cells in the row (for example, the segments at positions 8–12 in Example 1 or 11–13 in Example 2) while single‐cell segments (for example, the 7 at row0 col1 in Example 1 or the 5 in row0 of Example 3) are cleared. (Note: In one input row the rule may be waived so that if a row contains multiple segments of the same nonzero value, even an isolated one may be left unchanged if it does not belong to a vertical block.) \n3. (Vertical grouping) For each nonzero color separately, group candidate segments from consecutive rows when the segments overlap in column position. In other words, if two (or more) adjacent rows each contain a candidate segment of the same color and the segments share at least one common column, then these rows form a vertical group. \n4. For each vertical group (i.e. a set of two or more consecutive rows that share a candidate segment for that color), compute the intersection of the column ranges (that is, the set of columns that appear in every row’s candidate segment in the group). This common horizontal span is the rectangle that truly defines the block pattern. \n5. In the output grid, for every vertical group that spans at least two rows, fill every cell within the rectangle defined by the group’s row span and the common column intersection with that color. (For example, in Training Example 1 the top‐right block becomes rows0–2, columns8–12 with value 7, and the other block becomes rows3–5, columns2–5 with value 7; in Training Example 3 the large grey block becomes rows2–4, columns1–4 with value 5.) \n6. For any row whose candidate segments do not belong to any vertical group (that is, a candidate segment that appears only in a single row), output it unchanged only if it already spans two or more adjacent cells; otherwise (if it is a single stray cell) set those cells to 0. (For instance, in most examples isolated single‐cell segments are removed, while in one case a row might contain two segments and the longer one is used to form a block vertically.) \n7. Leave all other cells as 0. \nThis procedure removes scattered single pixels that fall outside complete rectangular block patterns while preserving (or “correctly filling”) the major blocks defined by a common horizontal span across consecutive rows.",
    "7fe24cdd.json": "1. Read the input, a 3x3 grid of integers (each integer in the range 0–9).\n2. Create an output grid of size 6x6.\n3. Divide the output grid into four 3x3 quadrants:\n   • Block A: top‐left (rows 0–2, columns 0–2).\n   • Block B: top‐right (rows 0–2, columns 3–5).\n   • Block C: bottom–left (rows 3–5, columns 0–2).\n   • Block D: bottom–right (rows 3–5, columns 3–5).\n4. Place the original 3x3 input grid into Block A without change.\n5. Rotate the input grid 90 degrees clockwise and place the result into Block B. (For each cell at position (r, c) in the input (using 0-indexing), its value moves to position (r, c') in the rotated grid where c' = r and r' = (3 – 1) – c.)\n6. Rotate the input grid 180 degrees and place the result into Block D. (For each cell at (r, c) in the input, its value moves to (2 – r, 2 – c) in the rotated grid.)\n7. Rotate the input grid 90 degrees counterclockwise (or 270 degrees clockwise) and place the result into Block C. (For each cell at (r, c) in the input, its value moves to position (c, (3 – 1) – r) in the rotated grid.)\n8. The assembled 6x6 grid—Block A in the top–left, Block B in the top–right, Block C in the bottom–left, and Block D in the bottom–right—is the final output.",
    "80af3007.json": "1. Crop the input grid: Find the smallest rectangle that contains every cell whose value is not 0 (recall that 0 represents black and 5 represents gray). This rectangle is the drawn 9×9 pattern made up of larger solid squares.\n2. Partition the cropped region into 3 equal strips vertically and 3 equal strips horizontally (so that the cropped region is divided into 9 blocks). (In all examples the cropped region is exactly 9×9 cells, with each block being 3×3 cells.)\n3. From these 9 blocks, form a 3×3 seed grid by assigning to each block a single cell value: inspect the 3×3 block and if the majority of its cells are 5 then set the corresponding seed cell to 5; otherwise set it to 0.\n4. Create the output grid by substituting each cell of the 3×3 seed grid with a 3×3 block as follows:\n   • If a seed cell is 5, replace it with a 3×3 block that is an exact copy of the entire 3×3 seed grid.\n   • If a seed cell is 0, replace it with a 3×3 block where every cell is 0.\n5. Assemble the nine 3×3 substitution blocks in the same relative order as they appear in the seed grid. The result is the final 9×9 output grid.",
    "810b9b61.json": "1. Copy the input grid (a two‐dimensional array of integers) to the output grid without change at first.\n2. Find every connected component of blue cells (cells with value 1) using 4‐neighbor (up, down, left, right) connectivity.\n3. For each connected component, compute its bounding box by finding the minimum and maximum row indices (r_min and r_max) and the minimum and maximum column indices (c_min and c_max) among its cells.\n4. If the bounding box spans only one row (r_min equals r_max) or only one column (c_min equals c_max), then do not change that component (it is considered a line rather than a closed box).\n5. Otherwise, inspect every cell on the perimeter of the bounding box (that is, every cell (r, c) where r = r_min or r = r_max or c = c_min or c = c_max). If every such perimeter cell is a member of the connected component, then the component is recognized as a closed box.\n6. For every connected component that meets the closed‐box criterion above (its bounding box is at least 2×2 and its entire border is filled by its blue cells), change every cell of that component in the output grid from 1 (blue) to 3 (green).\n7. Leave all other cells unchanged.\n8. Return the output grid.",
    "82819916.json": "1. Find the template row: Scan the grid from top to bottom and select the first row that is not all 0 and that is completely filled (that is, it has no 0 entries). This row will serve as the pattern template. For example, a template row might be [2,2,1,2,1,2,1,1].\n2. Determine the template mapping: In the template row, let T1 be the value in column 0 and T2 be the other nonzero value found in that row (i.e. the value different from T1). In the example [2,2,1,2,1,2,1,1], T1 = 2 and T2 = 1.\n3. Process every row in the grid separately. If a row is entirely 0 or already complete (has no 0’s), copy it unchanged to the output.\n4. For each incomplete row (one that begins with a contiguous nonzero block followed by 0’s):\n   a. Let P be the nonzero prefix from column 0 up to (but not including) the first 0. (In the examples, P will have length 2 or 3. When P has length 3 it will appear as [X, X, Y] and when length 2 as [X, Y].)\n   b. Define the row’s own mapping by letting X = the first element of P and Y = the last element of P.\n5. Fill each cell in the incomplete row by iterating over every column index c (0-indexed). For each cell:\n   a. If the cell already contains a nonzero value (from the prefix), leave it as is.\n   b. If the cell is 0, look at the value in the template row at column c. Replace the 0 by X if the template cell equals T1; replace it by Y if the template cell equals T2.\n   (For example, if the template row is [2,2,1,2,1,2,1,1] with T1 = 2 and T2 = 1 and an incomplete row has prefix [3,3,1]—so here X = 3 and Y = 1—the cell in an incomplete row at a column where the template has 2 will be filled with 3 and where the template has 1 will be filled with 1.)\n6. After processing all rows, output the modified grid.",
    "83302e8f.json": "1. Interpret the input as a two‐dimensional grid (matrix) of integers. In every grid, cells with value 0 represent the interior of a square (formerly black) and all nonzero cells represent parts of grid lines (the boundary lines), which must remain unchanged. \n2. Find each connected group (using 4‐directional connectivity) of cells with value 0; each such group is a candidate square. \n3. For every 0–region, compute its bounding box by finding the minimum and maximum row and column indices that contain a 0 from that region. \n4. For each 0–region, determine if its surrounding border is complete as follows. For every cell immediately adjacent (horizontally or vertically) to the bounding box—specifically:\n   a. If the row immediately above (min_row − 1) exists, then for every column from min_col to max_col the cell at (min_row − 1, c) must be nonzero.\n   b. If the row immediately below (max_row + 1) exists, then for every column from min_col to max_col the cell at (max_row + 1, c) must be nonzero.\n   c. If the column immediately to the left (min_col − 1) exists, then for every row from min_row to max_row the cell at (r, min_col − 1) must be nonzero.\n   d. If the column immediately to the right (max_col + 1) exists, then for every row from min_row to max_row the cell at (r, max_col + 1) must be nonzero.\nIf all of the applicable adjacent border cells exist and are nonzero, the square’s border is considered fully solid; if any such adjacent cell is 0 (a missing border segment), then the border is broken. \n5. Replace every cell in the 0–region with a new value based on the border check: if the border is complete, change all cells in that region to 3 (representing green in the human description); if the border is broken, change them to 4 (representing yellow). \n6. Leave every nonzero cell (all originally drawn grid‐line cells whose values may be 1, 5, 8, 9, etc.) unchanged. \n7. Output the modified grid. \nThis procedure uses only numbers: 0 is the original interior, 3 is the fill for squares with a fully solid border (green), and 4 is the fill for squares with a broken border (yellow).",
    "834ec97d.json": "1. Find the unique cell in the input grid whose value is nonzero and not 4. Let its coordinates be (R, C) and its value be V. (The grid uses 0-indexed rows and columns, where 0 represents the background and 4 is reserved for the fill.)\n2. Define the shifted row index as R_new = R + 1. (Assume R_new is within the grid bounds.)\n3. Construct the output grid with the same dimensions as the input. Process each row as follows:\n   a. For every row with index i < R_new (that is, all rows above the shifted colored cell), fill the entire row with an alternating pattern of 4 and 0. The alternating pattern must be chosen so that the cell in column C is 4. In other words, if C is even, set every cell in column j to 4 when j is even and to 0 when j is odd; if C is odd, set every cell in column j to 4 when j is odd and to 0 when j is even.\n   b. For the row with index i = R_new, begin with a copy of the input row. Then override the cell at column C by writing V into that cell.\n   c. For every row with index i > R_new, copy the row from the input grid unchanged.\n4. The result is an output grid where the unique nonzero cell (with its original value V) has been shifted down by one row, and all rows above that new position are replaced entirely by an alternating sequence of 4’s and 0’s (with 4 positioned at column C), while the other rows remain as in the input.",
    "8403a5d5.json": "1. Let the grid have R rows and C columns. Scan the entire input grid to find the single nonzero cell (a cell whose value is not 0) and record its column index c_start and its value v (for example, v may be 1, 2, 3, or 4 depending on the instance). 2. Construct the output grid with the same R×C dimensions. For every column with index x less than c_start, copy that column from the input to the output without change. 3. For every column with index x greater than or equal to c_start, modify the column as follows:\n   a. If (x − c_start) is even, then overwrite the entire column x by setting every cell in that column to the value v. This creates a full vertical line filled with the input color v.\n   b. If (x − c_start) is odd, then overwrite the entire column x by setting every cell to 0 (black), and then place a single gray mark (value 5) in that column as follows. Compute j = (x − c_start − 1) using integer division by 2. If j is even, set the top cell (row 0) of column x to 5; if j is odd, set the bottom cell (row R − 1) of column x to 5.\n4. Return the modified grid as the output. This yields, starting from the column that originally contained the nonzero pixel with value v, an alternating pattern of fully colored vertical lines (using v) and nearly black vertical lines (using 0) in which the black lines have a single gray (5) cell placed alternately at the top and bottom.",
    "846bdb03.json": "1. Locate the four cells with value 4 (which represent yellow) in the input and determine the smallest rectangular region (bounding box) that contains them. This bounding box defines the output grid’s size (its number of rows and columns).\n\n2. In that bounding rectangle, define the left edge as its first column and the right edge as its last column. Exclude the top‐ and bottom‐corner cells (which are 4); every remaining cell in the left edge will have the same nonzero value (call it A) and every remaining cell in the right edge will have the same nonzero value (call it B). (For example, in some cases A is 2 and B is 1; in other examples A is 8 or 7 and B is 3 or 8.)\n\n3. Create a new grid of the same size as the bounding box and fill it entirely with 0 (zero represents black). Then place the four 4’s in the four corners (that is, set the top‐left, top‐right, bottom‐left, and bottom‐right cells to 4).\n\n4. For every row in the output that is not the top or bottom row, set its first cell (leftmost) to A and its last cell (rightmost) to B. This reproduces the vertical “pillar” shapes from the original input.\n\n5. For each interior row (those between the top and bottom borders), take the segment of cells from the corresponding row within the bounding box that is between the left and right edges (i.e. excluding the first and last columns). This segment comes from the input and represents the joined colored block (the parts that are not yellow). Rotate or, if needed, horizontally flip this block so that if any nonzero cells appear the leftmost among them they match A and if any appear at the rightmost they match B; keep the relative left‐to‐right order of the nonzero cells. Then place this transformed block into the same row’s interior (leaving any cells that are not filled as 0).\n\n6. The net result is an output grid whose overall dimensions equal the bounding box. Its four corners are 4 (yellow), its left and right borders (all rows between the top and bottom) are filled with a constant color A (from the left vertical group) and B (from the right vertical group) respectively, and its interior is filled by repositioning (via rotation and possible flipping) the joined block of colored cells from the input so that its colors align with A on the left and B on the right. Cells not assigned a color remain 0.\n\n7. Return the resulting output grid.",
    "855e0971.json": "1. Partition the grid into rectangular regions defined by contiguous cells that share the same nonzero integer value. (Note: 0 represents black.)\n2. For each such region, check if at least one cell is 0. If a region contains no 0, leave it unchanged.\n3. For every region that contains one or more 0’s, compute its bounding box by finding the minimum and maximum row and column indices where the region appears. Let H be the number of rows (vertical extent) and W be the number of columns (horizontal extent) of the block.\n4. Decide the orientation for extending the black marker(s) by comparing H and W: if H < W (the vertical line is shorter than a horizontal line), choose a vertical transformation; if W < H, choose a horizontal transformation; if H equals W, default to vertical.\n5. Within the region, for each cell that originally contains a 0, record its coordinate. In a vertical transformation, note its column index; in a horizontal transformation, note its row index (using grid coordinates).\n6. Modify the region by replacing every cell that lies in any of the recorded columns (if vertical) or in any of the recorded rows (if horizontal) with 0, leaving all other cells in that region unchanged.\n7. Leave every cell that is not part of a region containing an original 0 unchanged, and output the final grid.",
    "85c4e7cd.json": "1. Compute the grid dimensions (height H and width W). For each cell at coordinate (r, c), calculate its layer index L = min(r, c, H-1-r, W-1-c). This index identifies a concentric border (with L = 0 for the outermost border).\n2. Determine max_layer, the highest layer index in the grid (which will be floor(min(H, W)/2) for even grids, and similarly defined for odd grids).\n3. For each layer i from 0 to max_layer, record the input value of that layer by selecting the cell at (i, i). Denote this value as ring_color[i]. (Each concentric border is assumed to be uniform in value.)\n4. Transform the grid by reversing the order of the rings: for every cell at (r, c) with layer index L, assign its new value to be ring_color[max_layer - L]. This replaces the outermost layer with the innermost input value, the second outer layer with the second innermost input value, and so on.\n5. Output the resulting grid, which has the same dimensions as the input but with each pixel’s value replaced according to the reversed ring order.",
    "868de0fa.json": "1. For each candidate rectangular region in the input grid, let T, B, L, and R denote its top, bottom, left, and right boundary indices (with T < B and L < R) such that the region has an interior (i.e. B - T >= 2 and R - L >= 2). 2. Verify that the candidate is a proper frame by checking that every cell on its top border (row T, columns L through R), its bottom border (row B, columns L through R), its left border (rows T through B, column L) and its right border (rows T through B, column R) has the value 1. (Here 1 represents the border color.) 3. For every valid frame, compute its interior dimensions: let height = B - T - 1 and width = R - L - 1. 4. Determine the fill value for the interior: if the product height × width is an even number then set fill = 2, otherwise set fill = 7. (Note: 2 stands for red and 7 stands for orange, which in the human description arose from red mixed with yellow.) 5. Replace every cell strictly inside the frame – that is, for every cell with row index r and column index c satisfying T < r < B and L < c < R – with the computed fill value. 6. Process all such frames in the grid (if frames overlap or are nested, the interior of an inner frame should override any previous fill, while all border cells remain unchanged). 7. Output the grid with the same dimensions as the input, leaving all cells not inside a valid frame unchanged.",
    "8731374e.json": "1. Crop the inner grid from the input. To do this, find the smallest rectangular block (that is, determine its topmost, bottommost, leftmost, and rightmost rows and columns) that forms a contiguous region in which almost every cell is the same number. This region is the single colored grid embedded in the larger grid. In all examples this inner grid is filled with one dominant number (call it B) except for a few cells that have a different number.\n2. Determine the background number B of the inner grid by taking the most frequent value in the cropped rectangle. (For example, in the training examples B is 1, 4, or 8.)\n3. Identify candidate cells inside the cropped grid: for each cell whose value is not equal to B, note its row and column index (relative to the cropped grid). All such cells will have the same candidate value (call it C), for example 2 or 1. (If there are no candidate cells, the inner grid is already uniform and no further change is needed.)\n4. Create an output grid with the same dimensions as the cropped inner grid and fill every cell with B.\n5. For every row in which at least one candidate cell was found (i.e. a row where a cell’s value is C), overwrite the entire row in the output grid by setting all its cells to C.\n6. For every column in which at least one candidate cell was found (i.e. a column that contains a cell with value C), overwrite the entire column in the output grid by setting all its cells to C.\n7. Return the resulting grid. (In effect, the cells that differed from B cause their entire row and column to be changed to the candidate number C.)",
    "88a10436.json": "1. Make a full copy of the input grid to serve as the output grid. 2. Search the input grid for the unique cell whose value is 5 (this represents the gray square in the task). If there is not exactly one cell with value 5, do not modify the grid and return the copy unchanged. 3. Identify every cell in the input grid that has a nonzero value and is not 5. Compute the minimum and maximum row and column indices of these cells; the resulting bounding box must be exactly 3 rows by 3 columns. This bounding box is the source colored block. 4. Extract this 3×3 block from the input grid using the bounding box (for example, if the bounding box is from row R0 to R0+2 and column C0 to C0+2, then the block is taken from those coordinates). 5. Let (r, c) be the coordinates of the unique cell with value 5. Compute the paste position by subtracting 1 from each coordinate so that the cell at offset (1,1) within the 3×3 block will overlap the cell (r, c); that is, the top‐left corner for pasting is (r−1, c−1). 6. For each cell (i, j) in the 3×3 block, overwrite the corresponding cell in the output grid at position (r−1+i, c−1+j) with the value from the block. 7. Return the modified output grid.",
    "88a62173.json": "1. Assume the input is a 5x5 grid of integers. Note that the middle row (row 2) and middle column (column 2) are all 0, which divides the grid into four distinct 2x2 quadrants. 2. Define the quadrants as follows: Top‐left quadrant: rows 0 and 1, columns 0 and 1; Top‐right quadrant: rows 0 and 1, columns 3 and 4; Bottom‐left quadrant: rows 3 and 4, columns 0 and 1; Bottom‐right quadrant: rows 3 and 4, columns 3 and 4. 3. Compare the four 2x2 quadrants by checking the value in each corresponding cell. Identify the unique quadrant – that is, the one whose 2x2 pattern of numbers (each between 0 and 9) is different from the other three, which are identical. 4. Output the unique quadrant exactly as it appears (preserving the order of its two rows of two numbers each).",
    "890034e9.json": "1. Copy the input grid into the output grid so that all cells are initially unchanged.\n2. Determine the background value by examining the border cells (use the most‐frequent value on the grid edge); this value is not part of the shape. \n3. Find the original shape by selecting the single connected region (using 4‐connectivity) of cells whose values differ from the background; this region will contain a block (the center) of cells with value 0 (remember, 0 represents black).\n4. Within the original shape, identify its center by collecting all cells that have the value 0. Let this set be Center_A.\n5. Compute the bounding box of Center_A and record its top‐left coordinate (R_orig, C_orig). For every cell in the original shape, record its relative offset (Δr, Δc) = (r − R_orig, c − C_orig).\n6. Count the number of cells in Center_A; call this number N.\n7. In the entire grid, search for a contiguous region (using 4‐connectivity) of cells with value 0 that is not part of the original shape and that has exactly N cells. Call this region Center_B.\n8. Compute the bounding box of Center_B and denote its top‐left coordinate as (R_new, C_new).\n9. Overlay the copy of the original shape onto the output grid by, for each cell (r, c) in the original shape with value v, placing that value at location (R_new + (r − R_orig), C_new + (c − C_orig)) in the output grid (if that cell lies within the grid bounds). This operation replicates the original shape so that its center (the positions originally having 0) is now aligned with Center_B.\n10. Return the output grid. \n\nThis procedure guarantees that after processing the grid there will be two identical shapes (one in the original location and one replicated) with the same relative arrangement and colors (for example, cells that were 2 or 8 in the original remain so) and the center of the shape is defined by the value 0.",
    "8a004b2b.json": "1. Locate the frame – scan the input grid for exactly four cells having the value 4 (which represents yellow). These will appear in two distinct rows and two distinct columns. Label them as the top‐left, top‐right, bottom‐left, and bottom‐right corners. \n2. Define the output grid by cropping the input to the minimal rectangle whose top row is the row of the top yellow cell, whose bottom row is that of the bottom yellow cell, and whose leftmost and rightmost columns are those of the yellow cells. In other words, the output grid is exactly the subgrid bounded by those four 4’s (the yellow frame). \n3. Identify the external pattern. From the full input, take all cells that lie outside the yellow frame. Then, ignore 0’s (the background) and compute the minimal bounding rectangle that contains every nonzero cell in that external region. (Recall that in our color‐to–number mapping the nonzero values may be 1 for blue, 2 for red, 3 for green, etc.) \n4. Compute normalized coordinates for a mapping: Consider the inner region of the output grid (that is, all cells not on the perimeter; the border remains unchanged). For any cell in this inner “hole” (its row and column position relative to the top‐left corner of the inner region) compute its normalized position (r_norm, c_norm) by dividing its row and column offsets by the height and width of the inner region, respectively. In parallel, compute normalized coordinates for the external pattern from its bounding box. \n5. Fill the inner region by projecting the external pattern into it. For each cell in the output grid’s inner region, use its normalized coordinates (r_norm, c_norm) to determine the corresponding cell in the external pattern’s bounding box (using nearest‐neighbor lookup) and set the output cell to that value. \n6. Exception: If a cell in the originally cropped (output) grid already contains a nonzero value (other than 0) that is not part of the 4’s framing, then do not overwrite it. In this way any shape already present inside the frame (for example, a group of 2’s, 3’s, etc.) is preserved. \n7. Return the final grid. \n\nThis transformation copies the pattern found outside the yellow (4) corners and scales it so that it fills the inner area of the output grid (while leaving the yellow border intact). All colors are specified by their numbers (0–9) according to the mapping (0 = black, 1 = blue, 2 = red, 3 = green, 4 = yellow, etc.).",
    "8be77c9e.json": "1. Determine the size of the input grid, which has M rows and N columns. In the input grid, the number 1 (blue) marks filled squares and the number 0 (black) marks empty squares. 2. Create an output grid with 2*M rows and N columns (i.e., double the height of the input and the same width). 3. For each row index r from 0 to M-1, copy the entire row r from the input grid into row r of the output grid. 4. For each row index r from 0 to M-1, copy the entire row (M - 1 - r) from the input grid into row (M + r) of the output grid, thereby forming a vertical mirror (flip) of the input grid. 5. Return the output grid.",
    "8d5021e8.json": "1. Read the input grid, which is a grid of integers of size 3 rows by 2 columns (each cell contains a number from 0 to 9). 2. For each row in the input (call it row r, with r = 0, 1, 2), form a new row by first taking the horizontal mirror (i.e. the reverse order) of that row and then concatenating the original row to it. For example, if a row is [a, b] then its horizontal mirror is [b, a] and the new row becomes [b, a, a, b]. 3. Collect these new rows (in the same order as the input rows) to form an intermediate grid called the “base block” of size 3 rows × 4 columns. 4. Compute the vertically flipped version of the base block by reversing the order of its rows. 5. Create the final output grid by stacking three blocks vertically in the following order: first, the vertically flipped base block; second, the base block in its original order; and third, the vertically flipped base block. This vertical stacking yields an output grid of 3×3 = 9 rows and, since each block is 4 columns wide, 4 columns in total. 6. Output this final grid with all numbers (for instance, in the examples numbers such as 0, 2, 3, 5, 8 appear), which completes the transformation.",
    "8d510a79.json": "1. Locate the barrier row by scanning each row and selecting the one in which every cell has the value 5. This row is not modified. Let its index be B.\n2. Partition the grid into two regions: the top region (all rows with index 0 to B–1) and the bottom region (all rows with index B+1 to the last row).\n3. In the top region (above the barrier), process each column independently as follows:\n   a. For red (value 2): If any cell in a given column is 2, identify the cell with the smallest row index (i.e. the topmost occurrence) in that column. Then fill every cell in that column from that row (inclusive) down to the last row of the top region (row B–1) with 2.\n   b. For blue (value 1): If any cell in that column is 1, identify the cell with the largest row index (i.e. the bottom‐most occurrence) in that column within the top region. Then fill every cell in that column from the top of the region (row 0) down to that cell (inclusive) with 1.\n4. In the bottom region (below the barrier), process each column independently as follows:\n   a. For red (value 2): If any cell in a given column of the bottom region is 2, identify the cell with the largest row index (i.e. the bottom‐most occurrence) in that column. Then fill every cell in that column from the top of the bottom region (row B+1) up to that cell (inclusive) with 2.\n   b. For blue (value 1): If any cell in that column of the bottom region is 1, identify the cell with the smallest row index (i.e. the topmost occurrence) in that column. Then fill every cell in that column from that cell (inclusive) down to the bottom of the grid with 1.\n5. Leave all other cells intact and return the resulting grid.",
    "8e1813be.json": "1. Find the colored square by scanning the entire grid and collecting every cell whose value is not 0. Compute the minimal bounding box of these cells (that is, the minimum and maximum row and column indices that contain a nonzero number). This box is the colored square drawn on a 0 (black) background.\n2. Within the bounding box, determine the base value by counting nonzero cells and selecting the most frequent number (this is the background fill of the square; for example, in the examples the base is 5, which represents grey).\n3. Decide the stripe orientation as follows:\n   a. For each row in the bounding box, break it into contiguous segments of nonzero cells. If many rows have a long contiguous segment whose dominant value (the number that appears most in that segment) is different from the base value, then choose horizontal stripes.\n   b. Otherwise, examine columns in the bounding box by splitting each column into contiguous segments of nonzero cells. If many columns have a long contiguous segment whose dominant value is not the base value, then choose vertical stripes.\n4. Extract candidate stripe lines from the colored square:\n   • If the orientation is horizontal:\n     a. For each row r from the top to the bottom of the bounding box, identify every contiguous segment of nonzero cells.\n     b. For row r, select the segment with the greatest length. Compute its dominant value (i.e. the number that appears most in that segment).\n     c. If this dominant value is not equal to the base value (for instance, with 2 for red, 1 for blue, 3 for green, 4 for yellow, 8 for cyan, 6 for pink, or 7 for orange), mark row r as a stripe with that color.\n   • If the orientation is vertical:\n     a. For each column c from the left to the right of the bounding box, identify every contiguous segment of nonzero cells.\n     b. For column c, select the longest such segment and determine its dominant value.\n     c. If that value is not equal to the base value, mark column c as a stripe with that color.\n5. In the order of appearance (top-to-bottom for horizontal, left-to-right for vertical), group together consecutive candidate stripe lines that share the same color so that each contiguous group counts as one stripe.\n6. Let N be the number of distinct stripes obtained after grouping.\n7. Produce the output grid as an N×N square as follows:\n   • If stripes are horizontal, then for each stripe (from top to bottom) fill the entire corresponding output row with its stripe’s value. For example, if the stripe colors (in order) are 2, 1, 3, 4, 8 and 6, then row 1 is all 2’s, row 2 all 1’s, etc.\n   • If stripes are vertical, list the stripe colors in order (from left to right) and produce an output grid where every row is identical to that list. For example, if the vertical stripe colors are 1, 2 and 4 then every row of the output is [1,2,4].\n8. Return the resulting grid.",
    "8e5a5113.json": "1. Interpret the grid as a 3×11 matrix where the cells are divided into five vertical sections: the left square (columns 0–2), the first separator column (column 3), the middle square (columns 4–6), the second separator column (column 7), and the right square (columns 8–10). Note that in every row the separator columns (3 and 7) contain the value 5, which must be preserved. 2. Define the left square (columns 0–2 of each row) as the source pattern. This square contains the colored (nonzero) values (for example, values like 1, 2, 4, 6, etc.). 3. Create a new 3×3 block by rotating the source pattern 90 degrees clockwise. For each cell in the rotated block at position (r, c) (with r and c in {0,1,2}), assign it the value from the source pattern at position (2 – c, r). 4. Create another new 3×3 block by rotating the source pattern 180 degrees clockwise. For each cell at position (r, c) in this block, assign it the value from the source pattern at position (2 – r, 2 – c). 5. Assemble the output grid row by row by: (a) copying the left square (columns 0–2) unchanged; (b) copying the separator in column 3 unchanged (value 5); (c) placing the 90° rotated block into the middle square (columns 4–6); (d) copying the separator in column 7 unchanged (value 5); and (e) placing the 180° rotated block into the right square (columns 8–10). 6. Output the resulting grid, which has the same dimensions as the input. This procedure transforms the original left square into two rotated versions that replace the originally blank (0‐filled) middle and right squares.",
    "8eb1be9a.json": "1. Let BACKGROUND be the value in the top‐left cell of the grid (in these examples, BACKGROUND = 0).\n2. Identify every cell in the input whose value is not BACKGROUND. These cells form the central pattern that will be repeated.\n3. Compute r_min and r_max as the minimum and maximum row indices (respectively) where a non‐BACKGROUND cell occurs, and c_min and c_max as the minimum and maximum column indices with a non‐BACKGROUND cell.\n   • For instance, in Example 1 the nonzero (value 8) cells occur only between rows 4 and 6 and across some columns; here r_min = 4 and r_max = 6. Although some rows (like row 5) have nonzero values in every column, use the extreme column indices from all pattern rows. In these examples c_min turns out to be 0 and c_max the last column index (e.g. 18 when there are 19 columns).\n4. Define the extracted pattern block as the subgrid from row r_min to r_max and column c_min to c_max. Let the pattern’s height p = r_max − r_min + 1 and width q = c_max − c_min + 1. (For Example 2 and the test case the block is exactly the contiguous rows (e.g. rows 3–5) taken over the full width; in Example 1 the repeating structure has an inherent horizontal periodicity even though the block spans the whole width.)\n5. Construct an output grid with the same dimensions as the input.\n6. For every cell (r, c) in the output grid, assign its value as follows:\n   • Compute the source row index as r_src = r_min + ((r − r_min) mod p) and the source column index as c_src = c_min + ((c − c_min) mod q).\n   • Set output[r][c] = input[r_src][c_src].\n7. This operation tiles (repeats) the extracted central pattern over the entire grid so that the pattern appears in every location according to a fixed periodicity. (For example, in Example 1 the tiling causes the row taken from input row 6 to appear at output row 0, input row 4 to appear at output row 1, input row 5 at output row 2, and then the cycle repeats vertically; similarly, horizontally the cells repeat every q columns.)",
    "8efcae92.json": "1. Interpret the input grid as a matrix of integers where 0 represents the background (black) and nonzero values represent colored pixels (with 1 for blue and 2 for red).\n2. Find all connected components (groups) of nonzero cells using 4-directional connectivity (cells that touch above, below, left, or right). Each connected group is a candidate shape.\n3. For each candidate shape, count how many cells have the value 2 (red). (For example, if a shape has 11 cells with value 2 it wins over a shape with 5.)\n4. Select the connected component with the highest number of 2’s. If there is a tie, any one may be chosen.\n5. Determine the minimal bounding rectangle for the selected component by finding the smallest and largest row indices and the smallest and largest column indices that contain any cell of the component.\n6. Extract from the input grid the subgrid defined by this bounding rectangle. This subgrid exactly preserves the pattern (the positions of 1’s and 2’s) of the chosen shape.\n7. Output the extracted subgrid as the final grid.",
    "8f2ea7aa.json": "1. Identify the blueprint shape by finding the minimal bounding box of all nonzero cells in the input grid. Let (r_min, c_min) be the top‐left coordinate and (r_max, c_max) be the bottom‐right coordinate of this region. In the provided examples this region is 3×3. \n2. Extract the blueprint matrix from the input using these coordinates. This blueprint contains the colored shape (nonzero numbers such as 2, 6, 7, or 8) in its original arrangement and 0 for the background. \n3. Create an output grid of the same dimensions as the input. Partition the output grid into a grid of blocks where each block has the same dimensions as the blueprint (for example, for a 9×9 grid and a 3×3 blueprint there will be 3 blocks across and 3 blocks down). Label these blocks by their position: (0,0) for top‐left, (0,1) for top–center, (0,2) for top–right, (1,0) for middle–left, (1,1) for center, (1,2) for middle–right, (2,0) for bottom–left, (2,1) for bottom–center, and (2,2) for bottom–right. \n4. For each cell (i, j) in the blueprint (with i and j ranging from 0 to 2), check if the cell’s value is nonzero. If blueprint[i][j] ≠ 0, then copy the entire blueprint into the corresponding output block. That is, for every cell (p, q) in the blueprint, set the output grid cell at (i×3 + p, j×3 + q) to blueprint[p][q]. If blueprint[i][j] = 0, leave the entire corresponding block filled with 0s. \n5. Return the output grid.",
    "90c28cc7.json": "1. Find the bounding box of the colored pattern by scanning the entire input grid and selecting only the cells with a value other than 0 (where 0 represents black). Let r_min and r_max be the minimum and maximum row indices with nonzero values and c_min and c_max be the minimum and maximum column indices with nonzero values.\n2. Extract the subgrid defined by rows r_min to r_max and columns c_min to c_max. This subgrid contains the full colored pattern (using numbers such as 1, 2, 3, etc., where the colors are represented by their numbers).\n3. Determine the vertical segmentation (row grouping) as follows: scan the rows of the subgrid from top to bottom and group together contiguous rows that are identical (i.e. each row in the group has the same sequence of values from column c_min to c_max). Record the boundaries between these groups (including the first and last row of the subgrid). Each such row group will correspond to one row in the output grid.\n4. Determine the horizontal segmentation (column grouping) by examining every row in the subgrid and noting the column indices at which the value changes from the previous column. Take the union of all these change boundaries across all rows and include c_min (the left boundary) and c_max+1 (one past the last column) to form a complete list of column boundaries. These boundaries divide the subgrid into contiguous column segments.\n5. For each cell in the output grid (defined by the intersection of a row group from step 3 and a column segment from step 4), pick any pixel from the corresponding block in the subgrid. Because the input is constructed by scaling up a smaller grid, every such rectangular block is uniformly filled with a nonzero number. Write that number as the value of the corresponding output cell.\n6. Construct the final output grid by arranging the representative numbers from each block in the same order as their corresponding row groups (top to bottom) and column segments (left to right). The resulting grid is the minimal representation of the colored pattern (with 0’s omitted) and preserves the layout of the original design.",
    "90f3ed37.json": "1. Treat the input as a rectangular grid with rows and columns (0‐indexed) where 0 represents the background. Some cells contain the digit 8 (the drawn starting color) that form the beginnings of horizontal lines, but in some rows the line is incomplete. The goal is to complete each such horizontal line by filling in the missing cells with the digit 1 (the fill color).\n2. Process the grid one row at a time from top to bottom. For each row, determine a seed column index as follows: if the row has any nonzero cell (i.e. a cell ≠ 0), let the seed be the largest column index in that row where the cell is nonzero; if the row is entirely 0, inherit the seed from the immediately preceding row.\n3. In each (vertical) group of rows that belong together (i.e. a contiguous block of rows where at least one cell is nonzero), first identify a template pattern. The template is a row that shows the full intended horizontal line. In many examples this is the row with the longest contiguous (or patterned) run of nonzero cells. In cases where the pattern is not a solid block (for example, an alternating pattern like 8,0,8,0,…) choose the template whose first nonzero appears in the same column as the current row’s first nonzero. (For instance, if a row begins with a nonzero at column 0, use the complete row that likewise begins at column 0.)\n4. Let L be the template’s first column with a nonzero and let R be the template’s rightmost column where the cell is nonzero. For the current row that is incomplete, for every column c with seed < c ≤ R, check the template’s cell at column c; if the template’s cell is nonzero (typically 8), then set the current row’s cell at that column to 1. (This completes the horizontal line in the same shape as the template but using 1 instead of 8.)\n5. Leave all other cells unchanged. Rows that already match their full template pattern remain as in the input.\n6. Output the resulting grid of the same size with each incomplete horizontal line now finished by having its missing cells replaced by 1.",
    "913fb3ed.json": "1. Initialize the output grid as an exact copy of the input grid, preserving its dimensions. 2. For each cell (r, c) in the grid, if the cell’s value is nonzero and one of the three target values (3, 8, or 2), then continue; these represent colored squares: 3 for green, 8 for cyan/light blue, and 2 for red. 3. Determine the border color based on the cell’s value: if the cell is 3 (green), use 6 (pink) as the border color; if the cell is 8 (cyan/light blue), use 4 (yellow) as the border color; if the cell is 2 (red), use 1 (blue) as the border color. 4. For the selected cell, iterate over every neighbor in the 3×3 block centered on (r, c) (using offsets dr and dc from the set {-1, 0, 1}). 5. For each neighbor (r + dr, c + dc) that lies within the grid boundaries and is not the center cell (i.e. where (dr, dc) ≠ (0, 0)), set that cell in the output grid to the determined border color. 6. Do this for every colored cell so that each such cell is surrounded by a one‐cell–thick border in its corresponding color while leaving the center cell unchanged. 7. Return the modified output grid.",
    "91413438.json": "1. Interpret the input as a fixed 3×3 grid in which 0 represents the background (black) and any nonzero number represents a colored cell. Let N be the count of cells in the input grid that hold a nonzero value. \n2. Compute the side length M of the output grid using the formula: M = 27 − 3×N. (For example, if N = 2 then M = 21; if N = 3 then M = 18; if N = 4 then M = 15; if N = 5 then M = 12; if N = 6 then M = 9.)\n3. Create an output grid of size M×M and initialize every cell to 0.\n4. Partition the output grid into contiguous non‐overlapping blocks of size 3×3. There will be exactly (M/3) blocks per row and (M/3) block rows. Number these blocks in row‐major order (from left to right, top to bottom).\n5. For the first N blocks in this row‐major order (i.e. for block indices 0 through N−1), copy the entire 3×3 input grid into that block. To do this, for each block assigned, for each cell at relative coordinates (r, c) with 0 ≤ r, c < 3, set the cell in the output grid at position (block_row×3 + r, block_col×3 + c) equal to the corresponding value from the input grid. \n6. Leave all remaining blocks in the output grid as 0. \n7. Return the completed output grid.",
    "91714a58.json": "1. Read the input grid as a matrix of integers (each between 0 and 9) where 0 represents the background (black).\n2. Create an output grid with the same dimensions as the input and fill every cell with 0.\n3. Scan the input grid to find a contiguous, axis‐aligned rectangular region (a block) that meets these conditions:\n   a. Every cell in the region has the same nonzero value X (X ∈ {1,2,3,4,5,6,7,8,9}).\n   b. The region spans consecutive rows and consecutive columns (i.e. it forms a perfect rectangle).\n   c. The region has a height of at least 2 rows.\n   (If more than one candidate exists, select the one with the largest area.)\n4. To locate the block, iterate row by row. For each row, identify each contiguous segment of nonzero cells that share the same value. Then, for each such segment (defined by a start column and an end column), check the following rows to see if the exact same segment (same start and end columns, same value X) appears in consecutive rows. Continue extending downward until the segment no longer matches. If the resulting rectangle covers at least 2 rows, mark it as a candidate.\n5. Copy the found block into the output grid by assigning each cell within the block’s coordinates the value X (the same as in the input). All cells outside this rectangle remain 0.\n6. Return the output grid.",
    "9172f3a0.json": "1. Read the 3x3 input grid where each cell contains an integer between 0 and 9.\\n2. Create an empty 9x9 output grid.\\n3. For each cell in the input grid at position (r, c) (using 0-indexed coordinates where r and c range from 0 to 2), do the following: let the cell’s value be v.\\n4. Identify the corresponding 3x3 block in the output grid that spans rows (3*r) to (3*r + 2) and columns (3*c) to (3*c + 2).\\n5. Fill every cell in that 3x3 block with the integer v.\\n6. After processing all cells, return the 9x9 output grid which is formed by expanding each input cell into its own 3x3 block.",
    "928ad970.json": "1. Copy the input grid exactly to the output grid (preserving all cells).\\n2. Locate the four cells whose value is 5 (these represent the gray dots). Record their row and column coordinates.\\n3. Compute r_min as the smallest row index and r_max as the largest row index among the gray dots; compute c_min as the smallest column index and c_max as the largest column index among the gray dots.\\n4. Define the boundaries of the large rectangle as follows: top row = r_min + 1, bottom row = r_max - 1, left column = c_min + 1, and right column = c_max - 1. These boundaries ensure that the rectangle touches the inside edges of all four gray (5) cells.\\n5. Determine the drawing color by scanning the input grid for any cell whose value is neither 0 (the background) nor 5; all such nonzero, non5 cells will share the same value. Let this value be the drawing color (for example, it is 1 in some cases, 3 in others, etc.).\\n6. Draw the border of the rectangle on the output grid by setting its cells to the drawing color as follows:\\n   a. For the top border: For every column from the left boundary to the right boundary, set the cell at (top row, column) to the drawing color.\\n   b. For the bottom border: For every column from the left boundary to the right boundary, set the cell at (bottom row, column) to the drawing color.\\n   c. For the left border: For every row between the top and bottom borders (that is, for each row r where top < r < bottom), set the cell at (r, left column) to the drawing color.\\n   d. For the right border: For every row between the top and bottom borders, set the cell at (r, right column) to the drawing color.\\n7. Leave all other cells unchanged. The output grid is now the original grid with a large rectangle drawn (using the nonzero non5 drawing color) whose border touches the inside of each of the four gray (5) cells.",
    "93b581b8.json": "1. Find the unique 2x2 subgrid of nonzero integers in the input. Let its top‐left cell be located at (r, c) so that the four cells of the square are: top‐left at (r, c), top‐right at (r, c+1), bottom‐left at (r+1, c), and bottom‐right at (r+1, c+1).\n2. Record the values of these four cells. Then assign to each corner the number from the diagonally opposite cell: for the top‐left cell use the value at (r+1, c+1); for the top‐right cell use the value at (r+1, c); for the bottom‐left cell use the value at (r, c+1); and for the bottom‐right cell use the value at (r, c).\n3. For each corner of the square, compute the intended 2x2 block placement as follows (using 0‐indexed grid coordinates):\n   a. Top‐left block: It should be placed so that its bottom‐right cell touches the square’s top‐left cell. That is, the block covers rows (r−2) and (r−1) and columns (c−2) and (c−1).\n   b. Top‐right block: It should be placed so that its bottom‐left cell touches the square’s top‐right cell. That is, the block covers rows (r−2) and (r−1) and columns (c+2) and (c+3).\n   c. Bottom‐left block: It should be placed so that its top‐right cell touches the square’s bottom‐left cell. That is, the block covers rows (r+2) and (r+3) and columns (c−2) and (c−1).\n   d. Bottom‐right block: It should be placed so that its top‐left cell touches the square’s bottom‐right cell. That is, the block covers rows (r+2) and (r+3) and columns (c+2) and (c+3).\n4. For each of these four 2x2 block placements, fill every cell (if it lies within the grid boundaries) with the corresponding number determined in step 2: use the bottom‐right value for the top‐left block, the bottom‐left value for the top‐right block, the top‐right value for the bottom‐left block, and the top‐left value for the bottom‐right block.\n5. Leave all other cells the same as in the input. (If any part of an intended 2x2 block falls outside the grid, fill only those cells that exist within the bounds.)\n6. Output the resulting grid.",
    "941d9a10.json": "1. Copy the input grid exactly into the output grid with no changes. 2. Using a 4-neighbor (up, down, left, right) flood fill, start at the upper‐left cell at (0, 0). If that cell has the value 0 (black), replace every 0 reachable from it (without crossing any cell that is not 0) with 1 (blue). 3. Compute the center cell coordinates as (floor(number_of_rows/2), floor(number_of_columns/2)). Using this cell as the seed, perform a 4-neighbor flood fill to change every connected cell with value 0 to 2 (red). 4. Start a 4-neighbor flood fill from the bottom‐right cell at (number_of_rows - 1, number_of_columns - 1). If that cell is 0, change every connected 0 to 3 (green). 5. Leave all cells that are not originally 0 unchanged. This algorithm fills three distinct regions—the upper‐left region becomes blue (1), the center region becomes red (2), and the bottom‐right region becomes green (3)—while preserving the barrier cells (for example, cells with the value 5, representing grey) and any other values.",
    "94f9d214.json": "1. Interpret the input as an 8×4 grid divided into two 4×4 blocks: the top block (rows 0–3) and the bottom block (rows 4–7). In these blocks the nonzero values are used: the top block’s nonzero pixels are 3 and the bottom block’s nonzero pixels are 1; a 0 represents black in both blocks. 2. Create a new 4×4 grid (the output grid). For each cell with coordinates (r, c) where r and c vary from 0 to 3, determine an intermediate value by checking the corresponding cell in the top block (row r, column c). If that cell is nonzero, let the intermediate value be its value (which will be 3); if it is 0, set the intermediate value to the value of the corresponding cell in the bottom block (which may be 0 or 1). 3. Transform the intermediate 4×4 grid into the final output by applying these rules to each cell: if the cell’s value is 0 (black), change it to 2 (red); if the cell’s value is 1 (blue) or 3 (green), change it to 0 (black). 4. Return the resulting 4×4 grid as the output.",
    "952a094c.json": "1. Copy the entire input grid into the output grid without changing any cells except as noted below. \n2. Locate the single rectangular frame in the grid. Identify its border as the contiguous cells that all share the same nonzero value. Let r_top be the row index of the top border, r_bottom the row index of the bottom border, c_left the column index of the left border, and c_right the column index of the right border. (For example, in one case the border is all 8’s, in another all 7’s, in another all 1’s, or 3’s.)\n3. Define the interior of the rectangle as the cells that are not part of this border; that is, those with row indices from r_top+1 to r_bottom-1 and column indices from c_left+1 to c_right-1. \n4. Identify the four interior corner cells of this interior region. These are located at:\n   • Top left interior: (r_top+1, c_left+1)\n   • Top right interior: (r_top+1, c_right-1)\n   • Bottom left interior: (r_bottom-1, c_left+1)\n   • Bottom right interior: (r_bottom-1, c_right-1)\n   Each of these cells contains a nonzero digit that is different from the border number.\n5. In the output grid, clear (set to 0) the values at these four interior corner positions. \n6. For each of the four interior corner cells, compute a new location by moving it diagonally to the exterior corner opposite its original position relative to the rectangle:\n   • If a cell is on the top interior row (row = r_top+1), set its new row to r_bottom+1 (one row below the bottom border); if it is on the bottom interior row (row = r_bottom-1), set its new row to r_top-1 (one row above the top border).\n   • If a cell is in the left interior column (column = c_left+1), set its new column to c_right+1 (one column to the right of the right border); if it is in the right interior column (column = c_right-1), set its new column to c_left-1 (one column to the left of the left border).\n7. Place the original value of each interior corner cell at its calculated new position in the output grid. \n8. Leave all other cells unchanged. \nThis transformation moves each of the four distinct interior numbers (for example, values like 4, 3, 2, 6 in one case; 2, 8, 9, 3 in another; 2, 5, 6, 3 in yet another; or 6, 4, 8, 2 in a test case) from the interior corners of the rectangle to the exterior corners (one cell outside the original border) in a diagonal, opposite‐corner fashion.",
    "9565186b.json": "1. Read the input grid, which is a rectangular 2D array of integers (each between 0 and 9). 2. Count how many times each integer appears in the grid. 3. Determine the majority value, i.e. the integer with the highest count. (Note: in all examples, the majority is unique.) 4. Create an output grid with the same dimensions as the input grid. 5. For each cell at coordinates (R, C) in the grid, if its value equals the majority number, leave it unchanged; otherwise, replace it with 5 (the number representing gray). 6. Return the output grid.",
    "95990924.json": "1. For each contiguous group of cells with the value 5 (which represents gray) using 4‐way (orthogonal) connectivity, compute its minimal bounding box. In other words, find the smallest row index R_min and column index C_min and the largest row index R_max and column index C_max among the cells in that group.\n2. Do not change any cell that is already part of a group (the 5’s remain unchanged).\n3. For each such group, add four new colored cells (petals) by writing nonzero numbers at cells diagonally adjacent to the bounding box corners (if those positions lie within the grid):\n   a. Set the cell at (R_min – 1, C_min – 1) to 1 (blue).\n   b. Set the cell at (R_min – 1, C_max + 1) to 2 (red).\n   c. Set the cell at (R_max + 1, C_min – 1) to 3 (green).\n   d. Set the cell at (R_max + 1, C_max + 1) to 4 (yellow).\n4. Leave all other cells as they were. The output grid remains the same size as the input grid.",
    "963e52fc.json": "1. Determine the dimensions of the input grid: let R be the number of rows and C be the number of columns. Rows are indexed from 0 to R-1 and columns from 0 to C-1.\\n2. Create an output grid with the same number of rows (R) and with 2*C columns (columns indexed from 0 to 2*C-1). This effectively doubles the width of the grid while keeping the height unchanged.\\n3. For each row index r (from 0 to R-1):\\n   a. For each column index c (from 0 to C-1), copy the value at (r, c) in the input grid to the output grid at (r, c).\\n   b. For each column index c (from 0 to C-1), copy the value at (r, c) in the input grid to the output grid at (r, c+C). This step replicates the pattern from the first half of the row to the second half.\\n4. The result is an output grid where every row is a horizontal duplication of the corresponding input row. For example, if an input row is [a, b, c, ...], the output row becomes [a, b, c, ..., a, b, c, ...].",
    "97999447.json": "1. For each row in the grid, scan from left to right to find the first cell (at column index j) whose value is not 0. This cell is considered the original colored block and its value is X (for example, in the examples X may be 2, 3, 6, or 8). \n2. If no cell in the row has a nonzero value, copy the row unchanged to the output grid.\n3. If a nonzero cell is found at column j, then for each column index k in that row:\n   a. For k < j, copy the original value from the input.\n   b. For k ≥ j, fill the cell with an alternating pattern: if (k - j) is even, set the cell to X; if (k - j) is odd, set the cell to 5 (which represents grey).\n4. Process every row independently. The output grid has the same dimensions as the input grid and only the portion of each row from the first nonzero cell to the right is overwritten with the alternating pattern.",
    "97a05b5b.json": "1. Scan the entire input grid to locate the large base region: find the largest connected (4‐neighbor) component of cells whose value is 2 (red). Compute its minimal bounding rectangle; this rectangle defines the dimensions of the output grid. \n2. Build the base output grid: create a grid with the same number of rows and columns as the bounding rectangle and fill every cell with 2. This represents a complete red (2) grid that will later receive missing pieces. \n3. Identify the puzzle pieces: separately, find every connected (4‐neighbor) component of nonzero cells that is not part of the main 2–region (these components contain values such as 1, 3, 4, 5, 8, etc.). For each such component, compute its minimal bounding rectangle and record the relative pattern of its digits. \n4. Determine the gap regions in the base grid: within the bounding rectangle of the main region (as it appears in the input), note those positions that are not 2 (that is, cells where the main grid is incomplete or “missing”). Group adjacent missing cells into gap regions. \n5. For each gap region, select the puzzle piece whose bounding rectangle has the same dimensions as the gap. Align the top‐left corner of the puzzle piece’s bounding rectangle with the gap’s top–left corner and overlay the puzzle piece’s pattern onto the base grid—copying each digit from the piece (for example, digits 1, 3, 4, 5, 8, etc.) into the corresponding positions (thus replacing the base value 2 in that area). \n6. Return the resulting grid. (Remember that the digit–to–color mapping is as follows: 0 = black, 1 = blue, 2 = red, 3 = green, 4 = yellow, 5 = grey, 6 = pink/fuchsia, 7 = orange, 8 = cyan/light blue, and 9 = brown/maroon.)",
    "98cf29f8.json": "1. Read the input grid (a matrix of integers 0–9, where 0 is the background) and identify the two nonzero colors; these are the two patterns. \n2. For each nonzero color, compute its bounding box (the minimum and maximum row and column indices where that color appears). \n3. Determine the joining orientation by checking the overlap of the bounding boxes: if the column ranges overlap then the patterns are arranged vertically; if the row ranges overlap then they are arranged horizontally. \n4. Identify which pattern will remain fixed (the stationary pattern) and which will be relocated (the moved pattern). For a vertical arrangement the pattern with the smaller (upper) top row is stationary and the other (with a higher top value) is moved; for a horizontal arrangement the one with the smaller (more leftward) left column is stationary and the other is moved. \n5. In the moved pattern the pixels appear in two subclusters along the joining axis (that is, in different groups of rows for a vertical case, or different groups of columns for a horizontal case). Identify the subcluster that is farther from the stationary pattern (for example, if the moved pattern is below the stationary one, then the lower subcluster; if it is to the right, then the right subcluster). This farther subcluster acts as a “floor” that creates a gap between the two parts of the moved pattern. \n6. Let F be the bounding box of this floor subcluster. Its size (height for a vertical case or width for a horizontal case, along with the lateral extent) will serve as the target dimensions for the relocated moved pattern. \n7. Compute the target placement for the moved pattern so that it abuts the stationary pattern. For a vertical arrangement where the moved pattern is below the stationary one, set the new top row to be one row below the stationary pattern’s bottom (new_top = stationary_bottom + 1) and set the new bottom so that the shifted region has the same height as F; also use F’s left and right column indices as the target horizontal span. For a horizontal arrangement where the moved pattern is to the right of the stationary one, set the new left column to be one column to the right of the stationary pattern’s right (new_left = stationary_right + 1) and set the new right column so that the shifted region has the same width as F; also use F’s top and bottom row indices as the target vertical span. (If the moved pattern were above or to the left instead, reverse the roles accordingly.) \n8. Remove the moved pattern from its original location by setting all its cells to 0. \n9. Fill the target rectangle (as computed in step 7) with the moved color (one of the nonzero integers, for example, 5, 4, or 7 as they appear in the examples) so that it now touches the stationary pattern. \n10. Output the grid (which retains its original dimensions) with the stationary pattern unchanged and the moved pattern relocated to eliminate the gap.",
    "995c5fa3.json": "1. Partition the input grid into three contiguous 4×4 blocks. The input grid always has 4 rows and 14 columns. Define Block 1 as the subgrid using columns 0–3, Block 2 as the subgrid using columns 5–8, and Block 3 as the subgrid using columns 10–13 (columns 4 and 9 are separators filled with 0).\n2. In each 4×4 block, use zero-based indexing for rows and columns (rows 0–3 and columns 0–3). The block is expected to be filled with 5 (grey) except for some positions that have 0 (black).\n3. For each block, determine its color by checking the positions of 0’s:\n   • If all 16 cells are 5, then assign the block color 2 (red).\n   • If the only 0’s occur at positions (1,0), (1,3), (2,0) and (2,3) (with all other cells equal to 5), assign the block color 3 (green).\n   • If the only 0’s occur at positions (1,1), (1,2), (2,1) and (2,2) (with the remaining cells equal to 5), assign the block color 8 (cyan/light blue).\n   • If the only 0’s occur at positions (2,1), (2,2), (3,1) and (3,2) (with all other cells equal to 5), assign the block color 4 (yellow).\n4. Construct the output grid as a 3×3 matrix where each row is uniform. Use the color determined from Block 1 to fill the first output row (all three cells), the color from Block 2 for the second row, and the color from Block 3 for the third row.\n5. Return this 3×3 grid as the final output.",
    "99b1bc43.json": "1. Identify the two 4×4 blocks in the input grid. The input grid consists of 9 rows and 4 columns. Rows 0–3 form the top block and rows 5–8 form the bottom block. (Row 4 is a divider row whose cells all have the value 4, representing yellow.)\n2. For each cell coordinate (r, c) in the 4×4 blocks (with r = 0 to 3 and c = 0 to 3), let A be the value from the top block at (r, c) and B be the value from the bottom block at (r, c).\n3. Interpret the values as follows: 0 represents black; any nonzero value represents a colored cell (in the provided examples the top block uses 1 for blue and the bottom block uses 2 for red, but treat any nonzero as colored).\n4. For each corresponding pair (A, B):\n   a. If both A and B are 0 (both black) OR if both A and B are nonzero (both colored), then set the output cell at (r, c) to 0 (black).\n   b. Otherwise (if one is 0 and the other is nonzero), set the output cell at (r, c) to 3 (green).\n5. Construct the output grid as a 4×4 grid where each cell (r, c) receives the computed value from step 4.",
    "99fa7670.json": "1. Determine the grid dimensions: let H be the number of rows and W be the number of columns in the input grid.\n2. Identify all anchor cells in the input. An anchor cell is any cell whose value is nonzero (for example, a cell with value 2, 6, 8, etc.). Record each anchor’s row (r), column (c), and its color value X.\n3. Sort the anchors in descending order by row; if two anchors share the same row, sort them in descending order by column. This ordering ensures that lower anchors (those in higher row numbers) are processed first so that their horizontal lines will block the vertical extensions of any anchors above them.\n4. For each anchor (r, c) with color X in the sorted list, do the following:\n   a. Draw the horizontal segment: For the row r, replace every cell in columns j from c through W−1 with X. This extends the colored area to the right edge of the grid.\n   b. Draw the vertical segment: Identify the end cell of the horizontal segment at (r, W−1). Then, for every row i from r+1 to H−1, check cell (i, W−1) in the output grid. If that cell is still 0 (unset), set it to X; if it is already nonzero (set by a previously processed anchor), stop the vertical extension immediately (do not overwrite that cell or any cells below it).\n5. Leave all cells that are not overwritten by a horizontal or vertical segment unchanged. The final output grid retains the same dimensions as the input grid.\nThis algorithm extends each nonzero input cell into an L‐shaped pattern (a horizontal line from the anchor to column W−1 and a vertical line from (r, W−1) downward) while ensuring that any vertical stroke stops before it would overwrite a cell already filled by a lower anchor’s horizontal segment.",
    "9aec4887.json": "1. Identify a rectangular \"frame\" in the input that is formed by four separate contiguous border groups of nonzero cells. These groups (all given as single digit numbers) will determine the output grid size. • The top border is a horizontal block of identical nonzero digits (call this value T) that will form the top edge. • The bottom border is a horizontal block of identical nonzero digits (value B) that will form the bottom edge. • The left border is a vertical block of identical nonzero digits (value L) that will form the left edge. • The right border is a vertical block of identical nonzero digits (value R) that will form the right edge. Find the minimal bounding rectangle that exactly spans these four border regions; its number of rows and columns will be the output grid’s dimensions.\n\n2. Extract and scale the inner object. In the input there is a second pattern whose nonzero cells are almost always 8 (light blue) (with any 0’s left unchanged). Determine the bounding box of this inner pattern and scale it (using a nearest‐neighbor mapping) so that it exactly fits into the interior of the frame. (The frame’s interior is all cells not on the outermost row or column of the bounding rectangle.)\n\n3. Form the output grid of the same dimensions as the frame. Fill its border (i.e. its first and last rows and first and last columns) as follows: • For the top row, set the first and last cells to 0 and every cell in between to T. • For the bottom row, set the first and last cells to 0 and every cell in between to B. • For every row between the top and bottom, set the leftmost cell to L and the rightmost cell to R.\n\n4. Fill the interior (all cells not on the border) with the scaled inner object from step 2 (preserving 0’s and 8’s as determined by the inner pattern).\n\n5. Post‐process the interior: For each interior cell whose value is 8, check its four orthogonal neighbors (left, right, up and down). If one or more of these neighbors lies on the border (that is, in the outermost row or column) then replace the 8 with the neighbor’s value according to the following priority order: first use the left neighbor if it is a border cell; if not, then the right neighbor; if neither, then the top neighbor; and finally if none of those qualify, then the bottom neighbor. (This step changes only those inner 8’s that directly touch a border cell via one edge.)\n\nFollowing these steps produces an output grid whose overall pattern is a copy of the colored frame (with its four sides given by L, T, R and B) and whose interior is the scaled inner (8‐valued) pattern but with any 8 that abuts a border replaced by that border’s digit. For example, in one instance the four borders might be 4 (top), 3 (bottom), 2 (left) and 1 (right) and in another they might be 3, 2, 6 and 4; the inner object is always taken from the region of 8’s. This procedure exactly reproduces the training and test examples.",
    "9af7a82c.json": "1. Read the input grid and count the occurrence of each distinct nonzero integer. (Note: In the input, only nonzero digits appear; the number 0 is reserved for empty cells in the output.)\n2. Determine the maximum frequency among these numbers; let this be R (the number of rows in the output). Also, let N be the number of distinct integers found (this will be the number of columns in the output).\n3. Sort the distinct integers in descending order by their frequency. (If there is a tie, use the order of first appearance in the input grid.)\n4. Create an output grid with R rows and N columns. For each column i (1 ≤ i ≤ N) corresponding to the i-th integer in the sorted order, fill the topmost cells with that integer for exactly as many rows as its count in the input. Fill the remaining cells in that column (if any) with 0.\n5. Return the resulting grid as the output.",
    "9d9215db.json": "1. Do not change the grid’s size; the output must have exactly the same number of rows and columns as the input.\n2. In the output, every cell that is not in an odd‐numbered row and odd‐numbered column must be 0. (That is, only cells whose row and column indices are odd—e.g. 1, 3, 5, …—may contain a nonzero number.)\n3. Find the minimal bounding rectangle of nonzero cells in the input. Reading the cells in row‐major order (top to bottom, left to right) within that rectangle yields a seed pattern. (For example, if the only nonzero cells occur in two rows and two columns and their values are 8,1 in the first row and 1,2 in the second row, then the seed pattern is [[8,1],[1,2]]. All numbers used are between 0 and 9.)\n4. Think of the eventual output as built on an underlying pattern grid P whose cells will appear at output coordinates (2*r+1, 2*c+1). Its dimensions are determined by the output size. (For example, if the full grid is 19×19, then P is 9×9 because the colored cells will lie in rows and columns 1,3,…,17.)\n5. Expand the seed pattern to fill P in a symmetric, framed manner as follows:\n   a. In the top row of P, assign its first element as the seed’s upper‐left value and its last element equal to that same value. If the seed’s top row contains a second value, then fill every position between the first and last with that second value. (For instance, if the seed’s top row is [8,1] then the top row of P becomes [8,1,1,…,1,8].)\n   b. In the next row of P, use the seed’s second row (if one exists). That is, set the first element equal to the left value from the seed’s second row and the last element equal to the mirror of that value. If the seed’s second row has a second number, then place that second number into the next-to–border positions; any gap between these assigned border cells is filled with 0. (For example, if the seed’s second row is [1,2] then a corresponding row of P becomes [1,2,0,…,0,2,1].)\n   c. If P has more rows than there are seed rows, fill the extra top‐half rows by taking the left border from the last available seed row (so that the border (first and last elements) is constant) and 0 for all interior positions.\n   d. Once the top half of P is complete, mirror it vertically to fill the bottom half so that P is symmetric with respect to its horizontal midline.\n6. Finally, build the output grid by writing the pattern P into it: for every cell in P at position (r, c) put its value into the output cell at (2*r+1, 2*c+1); all other positions in the output remain 0.\n\nThis procedure produces an output grid whose nonzero cells form a four‐sided, mirror–symmetric border (with one 0 cell between adjacent colored cells) that is “grown” from the seed nonzero block found in the input. (For example, a seed of [[8,1],[1,2]] yields an output whose top row is 0,8,0,1,0,1,0,…,0,8,0 and whose second colored row is 0,1,0,2,0,0, …,0,2,0,1,0, etc. All color names have been replaced by their numbers.)",
    "9dfd6313.json": "1. Read the input grid of size N×N (all examples are square, and the output grid must have the same dimensions). \n2. Create an intermediate grid by rotating the input 90° to the right. In detail, for each cell with coordinates (r, c) in the intermediate grid, set its value to the value from the input grid at position (N - 1 - c, r). \n3. Horizontally flip the intermediate grid to obtain the final output grid. That is, for each row, reverse the order of its elements. \n4. The resulting grid is the output.",
    "9ecd008a.json": "1. Find the unique contiguous 3×3 block in the input grid in which every cell has the value 0 (that is, the black area). Let (R, C) be the row‐and‐column coordinates of the top‐left cell of this 3×3 block and let N be the total number of columns in the grid (for example, N = 16).\n2. For each cell in the 3×3 block—specifically, for every cell with coordinates (r, c) where r ranges from R to R+2 and c ranges from C to C+2—compute its replacement value by taking the number that already appears in the same row r but at the column given by (N − 1 − c). In other words, replace the 0 at (r, c) with the value of the cell at (r, (N − 1 − c)), which is the horizontal mirror of column c over the grid’s right edge.\n3. Collect these nine replacement values (preserving the original top‐to‐bottom and left‐to‐right order of the blank block) to form a new 3×3 grid.\n4. Output this 3×3 grid. (Note: All colors are represented by their numbers; here the “black” cells are 0.)",
    "9edfc990.json": "1. Make an output grid that is an exact copy of the input grid. Do not alter any nonzero cell; these (digits 2–9, where 0 means black and 1 means blue) are treated as fixed obstacles. 2. Identify every cell in the input whose value is 1 (blue); these are the seed cells for the fill. 3. For each seed cell, perform a flood‐fill on its 4‐connected neighbors (only using up, down, left, right directions) but restrict the fill to cells that are originally 0. Use the original input grid to decide connectivity, and if a cell with value 0 is reached (and has not already been filled), set that cell’s value in the output grid to 1. 4. Continue the flood fill iteratively so that all cells in any connected region (through 0’s) that is adjacent (directly or via other 0’s) to at least one original seed (cell with value 1) become filled with 1. 5. Leave any 0 cell that is not reached by a flood fill (i.e. not 4‐connected to any originally 1 cell) unchanged as 0. 6. Return the output grid.",
    "9f236235.json": "1. Let the input be a grid of numbers with H rows and W columns (cells addressed as (R, C) with R from 0 to H−1 and C from 0 to W−1).  \n2. Identify the boundary marker digit B by scanning for a row that is completely filled with a single number; use that number B (for example, B = 2 in some cases or B = 8 in others) as the indicator of the grid’s divider lines.  \n3. Determine the horizontal segmentation as follows:\n   a. Conceptually add a top boundary at row index −1 and a bottom boundary at row index H.\n   b. Scan all rows; record every row index i for which every cell equals B (these are the horizontal divider rows).\n   c. Form a sorted list H_boundaries = [−1, i1, i2, …, in, H]. For each adjacent pair (a, b) in H_boundaries with (b − a > 1), define a horizontal segment consisting of rows a+1 through b−1. (For example, if a boundary row occurs at index 4 then the segment above it takes rows 0–3.)  \n4. Determine the vertical segmentation as follows:\n   a. Choose a representative content row from one of the horizontal segments (for example, the top row of the first horizontal segment).\n   b. In that row, scan through all columns and record every column index j where the cell’s value equals B.\n   c. Conceptually add a left boundary at column index −1 and a right boundary at column index W, and form a sorted list V_boundaries = [−1, j1, j2, …, jm, W]. For each adjacent pair (c, d) with (d − c > 1), define a vertical segment consisting of columns c+1 through d−1.  \n5. Each rectangular block defined by the intersection of a horizontal segment and a vertical segment is assumed to be one “segmented box” containing part of the design. In each such block, select the representative pixel—that is, take the cell at the top‐left corner (the smallest row and smallest column in that block).  \n6. Assemble these representative pixels into a matrix M so that the entry M[i][j] comes from the block in the iᵗʰ horizontal segment (top-to‐bottom) and the jᵗʰ vertical segment (left-to‐right).  \n7. Mirror the matrix M horizontally by reversing the order of its columns (i.e. for each row, write its entries in reverse order).  \n8. Output the resulting mirrored matrix as the final grid.",
    "a1570a43.json": "1. Identify the frame pixels: Scan the entire input grid and record every cell whose value is 3. Let r_min_frame be the minimum row index and c_min_frame the minimum column index among these cells, and let r_max_frame and c_max_frame be the maximum row and column indices. These 3’s form the corners of a rectangular frame that must remain fixed in the output.\n2. Define the inner frame region: Compute its top‐left corner as (r_min_frame + 1, c_min_frame + 1) and its bottom‐right corner as (r_max_frame - 1, c_max_frame - 1). This region is the area inside the frame where the design will be centered.\n3. Extract the design (the 2’s): Scan the input grid and record every cell whose value is 2. Compute the bounding box of these cells by letting r_min_2 and c_min_2 be the minimum row and column indices and r_max_2 and c_max_2 the maximum row and column indices where a 2 occurs.\n4. Compute the translation offset: Assuming that the dimensions of the 2’s bounding box match the dimensions of the inner frame (as they do in the examples), set offset_row = (r_min_frame + 1) - r_min_2 and offset_col = (c_min_frame + 1) - c_min_2. (If they do not match exactly, one would adjust by centering the two boxes using their centers, but here they are equal in size.)\n5. Create the output grid: Initialize a new grid of the same dimensions as the input and fill every cell with 0.\n6. Place the translated design: For each cell in the input that contains a 2 at position (r, c), set the corresponding output cell at (r + offset_row, c + offset_col) to 2. This moves the entire design so that its bounding box now exactly fills the inner frame.\n7. Copy the frame: For every cell in the input that contains a 3, copy it to the same position in the output grid (thus preserving the frame in place).\n8. Leave all other cells as 0. The resulting grid is the output, with the design (2’s) centered inside the frame defined by the 3’s.",
    "a2fd1cf0.json": "1. Read the input grid (a 2D array of integers) which remains unchanged in size. The grid contains exactly two nonzero cells: one with the value 2 (red) and one with the value 3 (green), while all other cells are 0.\n2. Scan the grid to find the coordinates of the red cell (value 2) and assign them as (r2, c2), and find the coordinates of the green cell (value 3) and assign them as (r3, c3). Here, r2, r3 denote row indices and c2, c3 denote column indices.\n3. Compute the junction point for the L-shaped connection as (r2, c3); that is, use the row index of the red cell and the column index of the green cell.\n4. Create the horizontal segment of the road: For each column c from min(c2, c3) to max(c2, c3) (inclusive) on row r2, set the cell (r2, c) to 8 (which represents light blue) unless that cell already has the value 2 or 3. This draws a horizontal line starting at the red cell extending to the junction.\n5. Create the vertical segment of the road: For each row r from min(r2, r3) to max(r2, r3) (inclusive) in column c3, set the cell (r, c3) to 8 unless that cell already contains 2 or 3. This draws a vertical line from the junction to the green cell.\n6. Output the modified grid. The resulting grid is the same size as the input and now includes an L-shaped road of 8s (light blue) connecting the red (2) and green (3) cells via a right-angle turn at (r2, c3).",
    "a3325580.json": "1. Read the input grid as a matrix of integers where 0 represents the background (black) and any nonzero value (1–9) represents a colored cell. 2. Identify all connected groups of nonzero cells using 4-way (up, down, left, right) connectivity. For each group, record its common digit (for example, 1, 2, etc.), its size (the total number of cells in the group), and its leftmost column (the smallest column index among its cells). 3. Determine the maximum group size S among all identified groups. 4. Select every group whose size is equal to S. 5. Sort the selected groups in ascending order based on their leftmost column value. 6. Create an output grid with S rows and a number of columns equal to the count of selected groups. 7. For each column in the output grid (assigned to a selected group in the sorted order), fill every cell in that column with the digit of that group. 8. Return the resulting grid.",
    "a3df8b1e.json": "1. Create an output grid with the same dimensions as the input grid and fill every cell with 0. 2. In the input grid, inspect the bottom row (last row, index = number of rows - 1) and find the unique cell that has the value 1 (recall: 1 represents the blue block). Let its coordinates be (R, C) where R is the bottom row index and C is its column index. 3. In the output grid, set the cell at (R, C) to 1. Initialize a variable current_column = C and set the horizontal movement direction d = +1 (meaning move right). 4. For each row above the bottom (that is, for each row r from R-1 down to 0), perform the following steps:\n   a. Compute a tentative new column new_C = current_column + d.\n   b. If new_C is less than 0 or greater than or equal to the number of columns (i.e. new_C is out of bounds), reverse the horizontal direction by setting d = -d, and then recompute new_C = current_column + d.\n   c. Set the cell at (r, new_C) in the output grid to 1, and update current_column to new_C.\n5. The output grid now has exactly one cell with value 1 in every row, forming a zigzag (45° diagonal) line that starts from the original cell in the bottom row and ascends to the top row, bouncing off the left and right edges. Return the output grid.",
    "a416b8f3.json": "1. Let the input be a grid of integers with R rows and C columns; each integer from 0 to 9 represents a color (for example, 0 represents one color, 5 represents another, etc.).\n2. Create an output grid with R rows and 2*C columns. This means the output grid is exactly twice as wide as the input grid while maintaining the same height.\n3. For each row (indexed from 0 to R-1), copy the input row directly into the left half of the corresponding row in the output grid (columns 0 to C-1).\n4. Then duplicate that same row by copying the identical sequence of integers from the input row into the right half of the output grid (columns C to 2*C-1).\n5. Repeat for every row so that the final grid contains two side-by-side copies of the input grid.\n6. Return the output grid.",
    "a48eeaf7.json": "1. Identify all red cells in the input grid. (Red is represented by the value 2.) These cells form a contiguous red square that must remain in place in the output.\n2. For every grey cell (value 5) in the input grid, check whether it is already adjacent to any red cell. Two cells are adjacent if the absolute difference in both row and column indices is at most 1 (i.e. they are 8‐connected). If a grey cell is adjacent to at least one red cell, leave it at its original position in the output.\n3. For each grey cell that is not adjacent to any red cell, determine the red cell (from those identified in step 1) that minimizes the Chebyshev distance to the grey cell. (The Chebyshev distance between (r1, c1) and (r2, c2) is max(|r1 − r2|, |c1 − c2|).)\n4. Compute the movement direction by setting row_step = sign(r_red − r_grey) and col_step = sign(c_red − c_grey), where (r_grey, c_grey) is the grey cell’s position, (r_red, c_red) is the chosen red cell’s position, and sign(x) is 1 if x > 0, −1 if x < 0, and 0 if x = 0.\n5. Starting from its original position, move the grey cell step by step by adding the vector (row_step, col_step) repeatedly. After each move, check if the grey cell’s new position is adjacent (in the 8-neighbor sense) to any red cell. Stop moving as soon as it reaches a position where at least one red cell is in one of the eight neighboring cells.\n6. Place the grey cell (value 5) at this final position in the output grid and clear its original cell (set it to 0).\n7. Leave all red cells (value 2) unchanged and set all other positions to 0. The output grid has the same dimensions as the input grid.",
    "a5313dff.json": "1. Interpret the grid as a two-dimensional array of integers where 0 represents the background (black), 2 represents the border (red), and 1 will be the fill color (blue). The task is to fill the interior of any closed shape (a contiguous group of 2’s forming a complete border) by changing enclosed 0’s to 1, while leaving all 2’s and any 0’s that touch the grid edge unchanged.\n2. Define exterior 0’s as all cells with value 0 that are on the grid boundary (first row, last row, first column, or last column).\n3. Using 4-way connectivity (neighbors directly above, below, left, and right), perform a flood fill starting from each exterior 0 to mark all 0’s connected to the edge. Do not cross cells with a value other than 0 (i.e. treat 2 as an impenetrable barrier).\n4. After the flood fill, traverse every cell in the grid. For each cell with value 0 that was not reached (i.e. not marked as exterior), change its value to 1. These cells are the interior of a closed shape whose border is entirely made of 2’s.\n5. Leave all cells with the value 2 unchanged.\n6. Return the modified grid.",
    "a5f85a15.json": "1. Copy the input grid to an output grid of the same dimensions.\n2. For every cell in the input grid with a nonzero value, determine its diagonal by computing (row_index - column_index) (using 0-indexed coordinates). This groups all colored (nonzero) cells that lie on the same top‐left to bottom‐right diagonal.\n3. For each diagonal group, sort the cell coordinates in increasing order of row index (which is equivalent to increasing column index).\n4. In each sorted diagonal group, for every cell in the 2nd, 4th, 6th, … position (i.e. when counting positions starting at 1, change every alternate cell beginning with the second), update the corresponding cell in the output grid to 4 (the numeric value for yellow).\n5. Leave all cells that are 0 or not in a changed position unchanged.\n6. Return the modified output grid.",
    "a61ba2ce.json": "1. Scan the input grid (a large grid with many 0’s) and find the four connected groups of nonzero cells (cells with values other than 0). Each group will consist of exactly three cells that all share the same nonzero value (for example, 8, 2, 1, 3, etc.).\n2. For each group, compute its minimal row and minimal column to form a bounding box. Subtract these minima from each cell’s (row, column) coordinate in the group so that the group is normalized into a 2×2 grid. In this normalized 2×2, the group will occupy three of the four positions.\n3. Identify the missing cell in each normalized 2×2 pattern by checking which coordinate from {(0,0), (0,1), (1,0), (1,1)} is not present in the group.\n4. Assign each group to one of the four corners of a 4×4 output grid based on its missing coordinate as follows:\n   • If the missing cell is (1,1), assign the group to the top‐left corner (use an offset of (0,0)).\n   • If the missing cell is (1,0), assign the group to the top‐right corner (offset (0,2)).\n   • If the missing cell is (0,1), assign the group to the bottom‐left corner (offset (2,0)).\n   • If the missing cell is (0,0), assign the group to the bottom‐right corner (offset (2,2)).\n5. Create a 4×4 output grid and initialize every cell to 0 (with 0 representing black).\n6. For each group, use its normalized 2×2 pattern and the corresponding quadrant offset. For every filled cell (each cell in the normalized 2×2 that is part of the group), place the group’s value into the output grid at the position given by (offset_row + relative_row, offset_col + relative_column). Do not place any value for the missing cell; this leaves that cell as 0.\n7. The result is a 4×4 grid with the three‐cell pattern of each group placed in a different corner exactly in the same relative arrangement as in the input, and with the four middle cells (one from each quadrant) remaining 0. Return this output grid.",
    "a61f2674.json": "1. Copy the input grid to the output grid so that the dimensions remain unchanged. All non‐processed cells (i.e. cells not originally 5) will keep their original values.\n2. For each column (using column indices 0 to width-1), scan the rows from top (row 0) to bottom and identify every contiguous vertical segment (group) of cells whose value is 5. A group is defined as one or more consecutive cells in the same column with the value 5 (grey).\n3. Compute the height (number of cells) of each identified group. Collect all groups from every column.\n4. Determine the maximum height and the minimum height among all groups. (According to the color mapping, the tallest group will be recolored blue (value 1) and the shortest group will be recolored red (value 2). If there are ties, treat each group tied for maximum as tallest and each tied for minimum as shortest.)\n5. For each group that you identified:\n   a. If the group’s height equals the maximum height, change every cell in that group in the output grid to 1 (blue).\n   b. Else if the group’s height equals the minimum height, change every cell in that group to 2 (red).\n   c. Otherwise, change every cell in the group to 0 (black).\n6. Leave all other cells (those that were not part of any contiguous group of 5) unchanged.",
    "a64e4611.json": "1. Let the grid have R rows and C columns; treat each cell by its coordinate (r, c) with 0 ≤ r < R and 0 ≤ c < C. 2. In the grid, cells with value 0 are potential fill targets while all nonzero cells (for example, 1, 2, 4, 8) form the border. 3. Perform a flood‐fill using 4-directional connectivity (neighbors above, below, left, and right) starting from every cell on the grid edge (that is, any cell with r = 0, r = R−1, c = 0, or c = C−1) whose value is 0; mark all 0 cells reached in this way as non-fillable because they touch the border. 4. For every cell that has value 0 and is not marked as reached (i.e. it does not connect to any border cell), replace its value with 3. 5. Leave all nonzero cells unchanged. 6. Return the modified grid. This procedure fills any enclosed region (hole) originally marked with 0 with 3, while leaving 0’s connected to the outer boundary intact.",
    "a65b410d.json": "1. Initialize an output grid of the same dimensions as the input grid, filling every cell with 0 (black).\n2. Find the unique row R that contains the input segment: scan each row to locate the one where, starting at column 0, there is a contiguous block of cells equal to 2 (red). Let L be the number of these contiguous cells in row R.\n3. In row R of the output grid, copy the red segment exactly by setting the cells in columns 0 through L-1 to 2 (red).\n4. For every row i above row R (i.e., for i = R-1 down to 0), compute n = L + (R - i). Then, in row i of the output grid, set the first n cells (columns 0 to n-1) to 3 (green). This creates an expanding green block as you move upward.\n5. For every row j below row R (i.e., for j = R+1 up to the last row), let offset = j - R. If L - offset is greater than 0, set the first (L - offset) cells (columns 0 to (L - offset)-1) in row j to 1 (blue). If L - offset is 0 or less, leave the row unchanged (all 0). This creates a contracting blue block as you move downward.\n6. Leave all other cells as 0. Return the output grid.",
    "a68b268e.json": "1. Interpret the 9x9 input grid as four 4x4 subgrids separated by a central row and a central column filled with 1’s. Define these subgrids as follows:\n   • Top‐Left (UL) quadrant: rows 0 to 3 and columns 0 to 3.\n   • Top‐Right (UR) quadrant: rows 0 to 3 and columns 5 to 8.\n   • Bottom‐Left (LL) quadrant: rows 5 to 8 and columns 0 to 3.\n   • Bottom‐Right (LR) quadrant: rows 5 to 8 and columns 5 to 8.\n2. Create an empty 4x4 output grid. For each cell in the output grid with coordinates (r, c) where r and c range from 0 to 3, define four candidate values:\n   • A = the pixel at (r, c) from the UL quadrant\n   • B = the pixel at (r, c) from the UR quadrant\n   • C = the pixel at (r, c) from the LL quadrant\n   • D = the pixel at (r, c) from the LR quadrant\n3. For each position (r, c) in the output grid, assign its value using the following overlay order (do not override a nonzero value):\n   • If A is not 0, output(r, c) = A.\n   • Otherwise, if B is not 0, output(r, c) = B.\n   • Otherwise, if C is not 0, output(r, c) = C.\n   • Otherwise, if D is not 0, output(r, c) = D.\n   • If all four are 0, leave the cell as 0.\n4. Return the resulting 4x4 grid.\n\nNote: All values are given as numbers. In the provided mapping, 0 represents black, 1 represents blue (the divider), 4 represents yellow, 6 represents pink/fuchsia, 7 represents orange, and 8 represents cyan/light blue. This overlay procedure ensures that nonzero (colored) pixels from later quadrants fill in the black (0) gaps without replacing any already nonzero pixel.",
    "a699fb00.json": "1. Process the grid row by row, keeping the grid size unchanged.\\n2. For each row, iterate through every group of three consecutive cells (at positions c, c+1, and c+2).\\n3. If the cell at position c is 1 (blue) and the cell at position c+2 is also 1 (blue), and the cell in between (at position c+1) is 0 (black), then change that middle cell to 2 (red).\\n4. Do not modify any cells that do not belong to a horizontal pattern exactly matching [1, 0, 1]. Only apply this rule horizontally; ignore similar vertical arrangements.\\n5. Return the modified grid with the same dimensions as the input.",
    "a740d043.json": "1. Assume that the input grid’s background is represented by the value 1 (blue). 2. Scan the entire grid to identify all cells whose value is not 1. These cells form the pattern. 3. Determine the minimal bounding box that covers all non-1 cells by finding the smallest and largest row indices and the smallest and largest column indices that contain a value different from 1. 4. Crop the input grid using this bounding box to obtain a subgrid containing the pattern and any incidental 1’s inside the box. 5. In the cropped subgrid, replace every cell with the value 1 by 0 (black), leaving all other values unchanged. 6. Return the resulting grid as the output.",
    "a78176bb.json": "1. Determine the grid size N (the grid is N×N). \n2. Identify the main color X by scanning the input for the first nonzero cell whose value is not 5 (5 represents grey and 0 represents black). Let the first such cell be at row r₀ and column c₀; then compute the constant offset k = c₀ − r₀. (This defines a line with slope 1: the main diagonal is all cells (r, r + k) that lie within the grid.)\n3. Create a new output grid of size N×N and fill every cell with 0 (black).\n4. For every row r from 0 to N−1, if the computed column c = r + k falls within the grid (0 ≤ c < N), set the output cell at (r, c) to X. (This copies the original main diagonal.)\n5. Scan every cell of the input grid that has the value 5 (grey). For each such grey cell in row r (only consider rows where the main diagonal cell (r, r + k) is defined) compute the difference d = (column index of the grey cell) − (r + k). Collect all differences d that are positive into a set P and all differences that are negative into a set Q.\n6. If set P is nonempty (meaning grey appears to one side of the main diagonal), let d_pos = (max(P) + 2) and then for every row r from 0 to N−1, if the cell at column c = r + k + d_pos is within bounds (0 ≤ c < N), set output[r, c] to X. (This draws an extra diagonal line on that side.)\n7. If set Q is nonempty (meaning grey appears on the other side), let d_neg = (min(Q) − 2) and then for every row r from 0 to N−1, if the cell at column c = r + k + d_neg is within bounds, set output[r, c] to X. (This draws an extra diagonal on that side.)\n8. Leave all other cells as 0. (Note that any grey (5) cells in the input are not copied; they become black in the output.)\n9. Return the output grid. \n\nThis algorithm preserves the original main diagonal of color X (where X is one of 2, 7, 9, etc.), erases any grey (5) pixels by making them 0, and draws one or two additional diagonals of the same color. The extra diagonal(s) are produced by translating the main diagonal horizontally by an amount determined from the extreme differences (from the input grey pixels) plus an additional constant 2, and only cells within the grid bounds are drawn.",
    "a79310a0.json": "1. Create an output grid that has the same number of rows and columns as the input grid and fill every cell with 0.\n2. For each cell in the input grid at coordinates (r, c), check if its value is 8 (which represents the original shape in cyan/light blue).\n3. If the cell’s value is 8, compute the target cell by adding 1 to the row index (i.e., (r + 1, c)). If (r + 1) is within the bounds of the grid, set the cell at (r + 1, c) in the output grid to 2 (the value representing red).\n4. Leave all cells that are not targets as 0.\n5. Return the output grid.",
    "a85d4709.json": "1. For each row in the input grid, scan left-to-right to locate the unique cell whose value is 5 (representing grey). Use 0 for the left column, 1 for the middle, and 2 for the right column.\\n2. If the grey pixel is found in column 0, replace the entire row in the output with 2 (red).\\n3. If the grey pixel is found in column 1, replace the entire row in the output with 4 (yellow).\\n4. If the grey pixel is found in column 2, replace the entire row in the output with 3 (green).\\n5. Maintain the same grid dimensions; each row is transformed independently based on the column position of its grey (5) pixel.",
    "a87f7484.json": "1. Check the dimensions of the input grid. It is guaranteed that one dimension is exactly 3 and the other is a multiple of 3. If the grid has 3 rows, it must be divided vertically; if it has 3 columns, divide it horizontally.\n2. Partition the grid into nonoverlapping candidate subgrids of size 3×3. When dividing vertically (grid has 3 rows), split the columns into consecutive groups of 3. When dividing horizontally (grid has 3 columns), split the rows into consecutive groups of 3.\n3. For each 3×3 candidate block, count the number of cells whose value is not 0 (0 represents the background). These nonzero cells are considered colored.\n4. Select the candidate block that contains the highest count of nonzero (colored) cells. In case of a tie, choose the block that appears first in reading order (leftmost when divided vertically or topmost when divided horizontally).\n5. Return the selected 3×3 block as the output grid.",
    "a8c38be5.json": "1. Convert the input grid so that every cell with value 0 (black) becomes 5 (grey); this establishes a uniform background of 5. 2. Identify the nine distinct 3×3 pieces in the input – each piece is a contiguous 3×3 block of cells (surrounded by rows and columns that are 0 before conversion, now 5) and may appear in any order. 3. For each extracted 3×3 piece, examine its border cells (the entire first row, last row, first column, and last column) and mark a border if any cell in that border is not 5. 4. Determine a target position for the piece in a 3×3 arrangement (which will form the final 9×9 grid, divided into nine 3×3 blocks) as follows:\n   • If the top row of the piece is marked, set its target row to 0; if the bottom row is marked, set its target row to 2; if neither is marked, set the target row to 1.\n   • Similarly, if the left column is marked, set its target column to 0; if the right column is marked, set its target column to 2; if neither is marked, set the target column to 1.\n   (Thus the unique piece that has no marked border – i.e. is completely 5 – will have target position (1,1) and become the center piece.)\n5. For each 3×3 piece, if its current orientation does not have its marked border(s) in the positions corresponding to its target (for example, a piece destined for the top row must have its top edge containing the non‐5 feature), rotate the piece by 90°, 180°, or 270° as needed until the marked border(s) align with the desired edge(s).\n6. Initialize an output grid of size 9×9 with every cell set to 5. 7. Place each rotated 3×3 piece into the output grid in the block corresponding to its target position: assign the piece with target row r and target column c to the rows (3×r) to (3×r+2) and columns (3×c) to (3×c+2) of the output grid. 8. Return the assembled 9×9 grid.",
    "a8d7556c.json": "1. Begin with the input grid and make a copy to serve as the output grid (the output has exactly the same dimensions as the input).\n2. Note that the picture is drawn using only two colors: 0 (black) and 5 (grey). The drawn diagram has the look of a table or set of boxes whose cell‐boundaries are visible as abrupt changes between 0 and 5.\n3. Interpret the picture as being subdivided into rectangular regions (boxes) by its continuous rows and columns that act as borders. In other words, imagine that some rows (and similarly some columns) form unbroken “grid lines” (these rows typically remain unchanged) and the spaces between them form the interiors of boxes.\n4. For each candidate rectangular region (an area contiguous in rows and columns) whose cells come from the set {0,5} and that has a width of at least 2 cells and a height of at least 2 cells, overwrite every cell in that region with 2 (red). (That is, if you can “form a box” of size at least 2×2 from the pattern of 0’s and 5’s, then fill the entire box with 2.)\n5. Do not change any cells that are not part of one of these qualifying boxes (for example, individual cells or lines that serve as borders remain as they were).\n6. Return the output grid, which now shows the original diagram with every identified box (a contiguous rectangular region that is larger than 1×1) filled entirely with the value 2.",
    "a9f96cdd.json": "1. Read the input grid and locate the unique cell with value 2 (red). Let its coordinates be (r, c) where r is the row index and c is the column index.\\n2. Create the output grid as an exact copy of the input grid (grid size does not change).\\n3. Replace the red cell at (r, c) with 0 (black) in the output grid.\\n4. Check the four diagonal neighbors of (r, c) and, if a neighbor lies within the grid boundaries, set its value as follows:\\n   a. If the top‐left neighbor at (r-1, c-1) exists, set it to 3 (green).\\n   b. If the top‐right neighbor at (r-1, c+1) exists, set it to 6 (pink/fuchsia).\\n   c. If the bottom‐left neighbor at (r+1, c-1) exists, set it to 8 (cyan/light blue).\\n   d. If the bottom‐right neighbor at (r+1, c+1) exists, set it to 7 (orange).\\n5. Leave all other cells unchanged and output the modified grid.",
    "aabf363d.json": "1. Let new_fill be the integer at the bottom‐left cell of the input grid (i.e. at row (n-1) and column 0, where n is the total number of rows). 2. Identify the target object by finding the contiguous region (using 4-directional connectivity: up, down, left, right) of nonzero cells that does not include the bottom‐left cell. In the examples, this object is the central pattern (for instance, cells with value 2 in Example 1, value 3 in Example 2, and value 8 in the test example). 3. Replace every cell in this identified region with new_fill (which is the value originally at the bottom‐left; e.g., 4, 6, or 2, respectively). 4. Set the bottom-left cell (row n-1, column 0) to 0. 5. Leave all other cells unchanged so that the output grid has the same size as the input.",
    "aba27056.json": "1. Keep the output grid exactly the same size as the input grid. \n2. Identify the main region in the input by finding all cells whose value is not 0 (these cells use a color in {2,3,6,7} in the examples). This region (the \"pattern\") will be preserved in the output except where a yellow overlay is applied. \n3. Over the original grid (which initially has 0’s as background), overlay a yellow pattern by changing selected 0 cells to 4. (Recall: 4 represents yellow.) \n4. The yellow overlay is drawn in a fixed, symmetric manner that connects the main region (or its internal \"hole\") to the grid edges. In every grid the following holds:\n   a. In rows that lie above and below (or partly adjacent to) the main region, fill with 4 those 0 cells that lie along one or more straight lines (horizontal or vertical) whose positions are chosen so that one continuous line connects an inner part of the main region (or the hole inside a rectangular pattern) with the corresponding edge of the grid.\n   b. In addition, from an inner corner of the main region’s hole (typically the corner nearest the center of the grid) draw a diagonal line of 4’s that extends in a straight diagonal to the grid edge. \n5. When applying the overlay, if a cell already belongs to the main region (its value is not 0) then leave it unchanged; however, if a cell is 0 and falls on one of the prescribed lines, set its value to 4. Any overlapping yellow assignments still yield 4. \n6. This produces an output in which the original nonzero pattern is maintained (even if parts of its surrounding 0’s are replaced) and a yellow (4) structure is superimposed. This structure appears in the examples as a set of connected straight‐line segments (both horizontal/vertical and one diagonal) that start at or inside the main pattern and extend to the grid border.",
    "ac0a08a4.json": "1. Determine the scale factor S by counting every cell in the input grid whose value is not 0. (For example, if the input grid has 4 nonzero cells then S = 4.)\n2. Set the dimensions of the output grid to be (number of input rows × S) by (number of input columns × S).\n3. For each cell in the input grid at row r and column c with value v (where v is an integer from 0 to 9), identify its corresponding block in the output grid. This block covers rows r×S through (r+1)×S − 1 and columns c×S through (c+1)×S − 1.\n4. Fill every cell in that block with the value v.\n5. Return the completed output grid.",
    "ae3edfdc.json": "1. Initialize an output grid with the same dimensions as the input grid, filling every cell with 0.\n2. In the input, locate the unique red center and blue center. The red center is the cell whose value is 2 and the blue center is the cell whose value is 1. Let their coordinates be (r_red, c_red) and (r_blue, c_blue) respectively.\n3. Copy these centers to the output grid at the same coordinates: set output[r_red][c_red] = 2 and output[r_blue][c_blue] = 1.\n4. For the red design (using petal value 3):\n   a. If any cell in the input on the same row as (r_red, c_red) and with a column index less than c_red contains a 3, then set the cell immediately to the left of the red center in the output (r_red, c_red - 1) to 3.\n   b. If any cell in the input on the same row and with a column index greater than c_red contains a 3, then set output[r_red][c_red + 1] to 3.\n   c. If any cell in the input on the same column as (r_red, c_red) and with a row index less than r_red contains a 3, then set output[r_red - 1][c_red] to 3.\n   d. If any cell in the input on the same column and with a row index greater than r_red contains a 3, then set output[r_red + 1][c_red] to 3.\n5. For the blue design (using petal value 7):\n   a. If any cell in the input on the same row as (r_blue, c_blue) and with a column index less than c_blue contains a 7, then set output[r_blue][c_blue - 1] to 7.\n   b. If any cell in the input on the same row and with a column index greater than c_blue contains a 7, then set output[r_blue][c_blue + 1] to 7.\n   c. If any cell in the input on the same column as (r_blue, c_blue) and with a row index less than r_blue contains a 7, then set output[r_blue - 1][c_blue] to 7.\n   d. If any cell in the input on the same column and with a row index greater than r_blue contains a 7, then set output[r_blue + 1][c_blue] to 7.\n6. All other cells remain 0. Return the output grid.\n\nNote: Here the colors have been translated to numbers as follows – red: 2, blue: 1, green (petals for red): 3, and orange (petals for blue): 7. This procedure “pulls” any 3 or 7 from anywhere in the same row or column so that exactly one petal is placed immediately adjacent (up, down, left, or right) to its corresponding center.",
    "ae4f1146.json": "1. Interpret the input grid as a 9×9 matrix in which 0 represents the background (black) and any nonzero digit (for example, 1 which is blue and 8 which is cyan/light blue) is part of a colored figure.\n2. Find all connected components of nonzero cells using 4‐neighbor (up, down, left, right) connectivity. Each connected group represents a candidate square drawn in the input.\n3. For each connected component, compute its minimal axis‐aligned bounding box. Only keep those components whose bounding box is exactly 3 rows by 3 columns (that is, a 3×3 block).\n4. In each 3×3 candidate, count the number of cells that have the value 1 (blue). This count represents the number of blue pixels in that square.\n5. Select the candidate 3×3 block with the highest count of 1’s. If two or more candidates tie for the maximum, choose the one whose top‐left cell has the smallest row index (and if still tied, the smallest column index).\n6. Output the 3×3 grid exactly as it appears in the selected bounding box. (No transformation such as mirroring is performed.)",
    "aedd82e4.json": "1. Create an output grid with the same dimensions as the input grid by copying every cell from the input.\n2. Define a connected component as a set of cells that share the same nonzero integer value and are connected via direct (up, down, left, right) neighbors.\n3. For each cell in the input grid that has a nonzero value (for example, 2 representing red), determine the connected component it belongs to by checking all directly adjacent cells with the same value.\n4. If the connected component contains exactly one cell (i.e. the cell is isolated), change that cell’s value in the output grid to 1 (blue). Otherwise, leave the cell’s value unchanged.\n5. Always leave cells with the value 0 (black) unmodified.",
    "af902bf9.json": "1. For each distinct pair of rows in the grid (call them r_top and r_bottom, with r_top < r_bottom), identify all column indices in each row where the cell value is 4 (which represents yellow). 2. Compute the intersection of the column indices for row r_top and row r_bottom. For every pair of common indices (c_left, c_right) with c_left < c_right, treat (r_top, c_left), (r_top, c_right), (r_bottom, c_left) and (r_bottom, c_right) as the four corners of a yellow border structure. 3. For every cell that lies strictly inside this rectangular border—that is, for every row r such that r_top < r < r_bottom and every column c such that c_left < c < c_right—set the cell value to 2 (which represents red). 4. Leave all other cells unchanged and maintain the same grid size. This process fills the interior of every yellow (4) frame with red (2) without altering the border pixels.",
    "b0c4d837.json": "1. Find the glass region by locating all cells whose value is 5 (the grey border). Determine the minimal axis‐aligned bounding rectangle that contains every 5. (For example, in a grid with rows indexed from 0, the topmost, bottommost, leftmost, and rightmost 5 define this box.)\n2. Define the interior of the glass as the subgrid obtained by removing the outermost row and column of that bounding box. (In other words, if the box covers rows R1 to R2 and columns C1 to C2, then the interior is rows R1+1 to R2−1 and columns C1+1 to C2−1.)\n3. In the interior, consider a cell to be part of the water region if its value is 8 (representing light blue). For each column of the interior, check whether at least one cell in that column is 8. Let N be the number of interior columns that contain one or more 8’s and let T be the total number of interior columns.\n4. Compute the horizontal water‐coverage fraction F = N/T.\n   • If F is 1 (i.e. every interior column holds water), then decide that the water spans the full width.\n   • If F is at least 0.67 but less than 1, then the water covers about two‐thirds of the interior horizontally.\n   • Otherwise (if F is less than 0.67), the water covers only the left portion of the interior.\n5. Create a new output grid of fixed size 3×3 with all cells initially 0.\n6. Map the horizontal water coverage to the top row (row 0) of the output as follows:\n   • If F = 1, set every cell in row 0—that is, output cells (0,0), (0,1) and (0,2)—to 8.\n   • If 0.67 ≤ F < 1, set the left two cells (cells (0,0) and (0,1)) to 8 and leave (0,2) as 0.\n   • If F < 0.67, set only the leftmost cell (0,0) to 8 and leave (0,1) and (0,2) as 0.\n7. Next, count the total number of interior water cells (that is, count all cells within the interior that have value 8). If this total equals 9 exactly, then also set cell (1,2) (that is, row 1, column 2) of the output grid to 8.\n8. Leave all remaining output cells (all cells not set in steps 6 or 7) as 0.\n9. Return the resulting 3×3 grid.  \n(This procedure “zooms in” on the water (8’s) inside the U‐shaped glass (5’s) and converts its horizontal extent into a standardized 3×3 output whose top row shows the water pattern while the remainder is 0, with one special case when the water count is exactly 9.)",
    "b190f7f5.json": "1. Let R be the number of rows and C be the number of columns of the input grid. Decide on a split orientation as follows: \n   • If C > R (the grid is wider than tall), split the grid vertically into two halves of equal width. Number the columns from 0 to C−1 so that the left half has columns 0 to (C/2 − 1) and the right half has columns C/2 to C−1.\n   • If R > C (the grid is taller than wide), split the grid horizontally into two parts. Number the rows from 0 to R−1 so that the top half has rows 0 to (R/2 − 1) and the bottom half has rows R/2 to R−1.\n2. Identify which half will serve as the template (T) and which as the mask (M). Do this by examining the nonzero values (ignoring 0): \n   • For a vertical split, if the left half contains at least one nonzero value that is not 8 then choose the left half as the template and the right half as the mask; otherwise choose the right half as the template and the left half as the mask.\n   • For a horizontal split, if the top half contains at least one nonzero value that is not 8 then choose the top half as the template and the bottom half as the mask; otherwise choose the bottom half as the template and the top half as the mask.\n3. (Special adjustment for horizontal splits.) When the grid is split horizontally, take the chosen mask half and remove its first row so that the final mask M has a height of (mask_rows − 1) while its width remains unchanged. (For example, if the bottom half is 4×W, the effective mask M becomes 3×W.)\n4. Let the template T have dimensions T_rows × T_cols and let the final mask M have dimensions M_rows × M_cols. The output grid will then have dimensions (T_rows × M_rows) by (T_cols × M_cols). Conceptually divide the output grid into a grid of T_rows × T_cols blocks, each of size M_rows × M_cols.\n5. For each cell in the template T at position (r, c) (using 0‐indexed coordinates) with value v (for example, v might be 2, 3, 4, 1, etc.), create a block B of size M_rows × M_cols as follows: \n   – For each cell in M at position (i, j), if M[i, j] is not 0 then set B[i, j] = v; otherwise set B[i, j] = 0. (Recall that the mask’s nonzero values—typically 8 in the examples—act only as markers; their actual number is not transferred.)\n6. Place the block B for template cell (r, c) into the output grid so that B occupies rows from (r × M_rows) to (r × M_rows + M_rows − 1) and columns from (c × M_cols) to (c × M_cols + M_cols − 1). Process every cell of T in this manner.\n7. Return the resulting output grid.\n\nThis procedure expands each cell of the chosen template by imprinting it according to the pattern given by the mask (where every nonzero in the mask causes the template’s value to appear and zeros in the mask yield 0). For vertical splits the halves are taken exactly, while for horizontal splits the mask is adjusted (by dropping its first row) so that, for example, a template of size 4×4 expands to an output grid of 12×16 as seen in the test example. All color information is represented by the integers (for instance, the marker 8 is used in the mask).",
    "b1948b0a.json": "1. Read the input grid as a two-dimensional matrix of integers. The grid is composed of only two numbers: 6 and 7.\n2. Create an output grid with the same dimensions as the input grid.\n3. Iterate over each cell in the grid using its row and column coordinates. For each cell, do the following:\n   a. If the cell value is 6 (which represents pink/fuchsia), change it to 2 (which represents red).\n   b. If the cell value is 7 (which represents orange), leave it unchanged.\n4. Return the output grid, which will have all occurrences of 6 replaced by 2 while all 7s remain the same.",
    "b230c067.json": "1. For the given input grid, keep the grid dimensions unchanged and treat every cell with a value other than 8 as background (to be copied unchanged). 2. Find all connected components (using 4‐direction connectivity: up, down, left, right) of cells that have the value 8. These components represent the separate patterns. 3. For each such component, count the number of cells (its area). In case of a tie for smallest area, use a consistent tie-break (for example, the component with the smallest row index and then smallest column index). 4. Identify the one component that has the smallest area. 5. Build the output grid by copying every cell that is not 8 from the input. For every cell that is 8 in the input, if it belongs to the smallest connected component then set its value to 2; otherwise set its value to 1. 6. Return the resulting grid.",
    "b27ca6d3.json": "1. Read the input grid of integers (each cell is 0–9) where 0 represents the background (black) and 2 represents red boxes. The grid size is unchanged in the output.\\n2. Identify connected groups of red cells (cells with value 2) using 4‐neighbor connectivity (that is, check up, down, left, right).\\n3. For each group that contains at least two cells (that is, a paired red group), compute its minimal bounding rectangle. In other words, let r_min be the smallest row index of any cell in the group, r_max the largest, c_min the smallest column index, and c_max the largest.\\n4. Expand this bounding rectangle by one cell in every direction. That is, define the border region as all cells whose row is between max(0, r_min−1) and min(max_row, r_max+1) and whose column is between max(0, c_min−1) and min(max_col, c_max+1) (where max_row and max_col are the grid’s last valid row and column indices).\\n5. For every cell in the expanded rectangle that is not one of the group’s red cells (i.e. not originally 2 in that paired group), set that cell’s value to 3 (green). (Cells that already belong to a red group remain 2.)\\n6. Leave all other cells unchanged. In particular, if a red cell is isolated (its group size is 1) do not add any border around it.\\n7. Output the modified grid with the same dimensions as the input.",
    "b2862040.json": "1. Keep the grid dimensions unchanged. \n2. For every cell in the input, identify connected components (using 4‐neighbor connectivity) of cells with value 1. These cells represent dark blue patterns that may be transformed. \n3. For each connected group S of 1's, compute its minimal bounding rectangle using the smallest and largest row and column indices that contain a cell from S. \n4. In the bounding rectangle, construct a temporary mask where cells belonging to S are marked as obstacles and all other cells are free. (Note: In the input the background is 9 and the pattern pixels are 1.) \n5. Starting from every free cell on the boundary (i.e. every cell in the first row, last row, first column, and last column of the bounding box) that is not an obstacle, perform a flood fill marking all reachable free cells. \n6. Examine the temporary mask: if there exists at least one free cell inside the bounding rectangle that was not reached by the flood fill, then S encloses an interior (i.e. S forms a closed loop). (In other words, the obstacles of S separate at least one cell from the bounding box edge.) \n7. For every connected group S that is determined to be a closed loop, change each cell in S from 1 to 8. (This corresponds to converting a dark blue closed pattern (1) to light blue (8) as specified.) \n8. Leave all other cells unchanged and output the modified grid.",
    "b527c5c6.json": "1. For every cell (r, c) in the input grid that has value 2 (red), determine if it is a tip by checking its four cardinal neighbors (up, down, left, right). Identify the unique direction in which the immediately adjacent cell is not 3 (green). Call this direction the extension direction (d_ext). (For example, if the neighbor to the left, at (r, c-1), is not 3 while all other neighbors are 3, then d_ext = left.)\n2. Compute the border thickness T for the red tip as follows: from the red cell at (r, c), move one step in the direction opposite to d_ext and count the number of consecutive cells that have value 3. Stop counting when you hit a cell that is not 3 or the edge of the grid. (For instance, if d_ext = left then move right from (r, c) and let T be the count of consecutive 3’s encountered.)\n3. Extend the tip into a red line (value 2) by filling every cell along a straight line from the red cell (r, c) in the direction d_ext until the grid edge is reached. Overwrite any cell encountered along this line with 2.\n4. Add a green border (value 3) around the extended red line. For each cell that was set to 2 in step 3, fill in, in the directions perpendicular to d_ext, all cells within a distance of T (using Manhattan offsets) as long as they lie within grid bounds. In other words, if d_ext is horizontal (left or right), then for each red cell in the red line, set the T cells immediately above and the T cells immediately below (if in bounds) to 3; if d_ext is vertical (up or down), then for each red cell in the red line, set the T cells immediately to the left and the T cells immediately to the right to 3.\n5. Process every red cell meeting the above criterion (if more than one exists, apply these steps for each tip independently; if extensions or borders overlap, later assignments may overwrite earlier ones according to these rules).\n6. Leave all other cells (those not overwritten by an extension or its borders) unchanged. The output grid must have the same dimensions as the input.",
    "b548a754.json": "1. Identify the two‐colored rectangular shape in the input grid. Find the connected region (ignoring zeros) that forms a filled rectangle with a one‐cell–thick border. Compute its bounding box by determining the minimum and maximum row indices (r_min and r_max) and column indices (c_min and c_max) that contain the shape. The cells on the border of this box all share the same value; call this the BORDER VALUE (for example, 2, 3, or 6). The cells inside (not on the edge) share another value; call this the FILL VALUE (for example, 1, 2, or 4).\n2. Locate the single extra nonzero cell (the indicator) that is not part of the rectangle. Denote its coordinates as (r_dot, c_dot) and note that its value (commonly 8) is different from both the BORDER VALUE and the FILL VALUE.\n3. Decide the stretching direction by comparing the dot’s coordinates with the rectangle’s bounding box. If the dot’s column c_dot satisfies c_min ≤ c_dot ≤ c_max, then the dot lies vertically relative to the rectangle and you will stretch vertically. If the dot’s row r_dot satisfies r_min ≤ r_dot ≤ r_max, then the dot lies horizontally relative to the rectangle and you will stretch horizontally. (Only one of these cases will occur.)\n4. If stretching vertically: \n a. If r_dot is less than r_min, set the new top boundary to new_r_min = r_dot; if r_dot is greater than r_max, set the new bottom boundary to new_r_max = r_dot. Keep c_min and c_max unchanged.\n5. If stretching horizontally: \n a. If c_dot is less than c_min, set the new left boundary to new_c_min = c_dot; if c_dot is greater than c_max, set the new right boundary to new_c_max = c_dot. Keep r_min and r_max unchanged.\n6. Redraw the rectangle in the unchanged grid. For every cell (r, c) with r between the new vertical boundaries and c between the new horizontal boundaries, assign its value as follows: if r equals the new top or bottom boundary or if c equals the new left or right boundary, set the cell to the BORDER VALUE; otherwise, set it to the FILL VALUE.\n7. Keep all other cells in the grid (typically 0) unchanged. \nThis procedure stretches the original two‐colored shape so that its extended border covers the indicator cell, while preserving the original border and fill values (using only numeric values such as 2, 1, 3, 2, 6, 4 etc.).",
    "b60334d2.json": "1. Initialize an output grid with the same dimensions as the input grid by copying every cell from the input.\n2. For each cell in the input grid with value 5 (which represents gray), let its coordinates be (r, c). Treat this cell as the center of a 3x3 block to be drawn on the output grid.\n3. For each offset (dr, dc) in {(-1,-1), (-1,0), (-1,1), (0,-1), (0,0), (0,1), (1,-1), (1,0), (1,1)}:\n   a. Compute the target cell coordinates (r + dr, c + dc). If these coordinates fall outside the grid boundaries, skip this cell.\n   b. If (dr, dc) is (0,0) (the center), set the output cell at (r, c) to 0 (black).\n   c. If exactly one of dr or dc is 0 (i.e. the cell is directly above, below, left, or right of the center), set the output cell at (r + dr, c + dc) to 1 (blue).\n   d. Otherwise (for the four diagonal cells), set the output cell at (r + dr, c + dc) to 5 (gray).\n4. Leave any cells not overwritten by a 3x3 pattern unchanged (they remain as in the copied input). Return the output grid.",
    "b6afb2da.json": "1. Copy the input grid to the output grid without changing any cell that is not part of a region with value 5.\\n2. Locate each contiguous group of cells whose value is 5 (these represent the gray regions). For each such group, determine its minimal bounding rectangle by recording the minimum row (Rmin), maximum row (Rmax), minimum column (Cmin) and maximum column (Cmax) among its cells.\\n3. For every cell (r, c) within the bounding rectangle, change its value as follows:\\n   a. If r is Rmin or Rmax and c is Cmin or Cmax (i.e. the cell is a corner of the rectangle), set the cell’s value to 1 (blue).\\n   b. Else if r is Rmin or Rmax or c is Cmin or Cmax (i.e. the cell is on the border but not a corner), set the cell’s value to 4 (yellow).\\n   c. Otherwise (the cell is strictly inside the border), set the cell’s value to 2 (red).\\n4. Leave all cells that are not part of any contiguous 5-region unchanged.\\n5. Output the resulting grid, which has the same dimensions as the input grid.",
    "b7249182.json": "1. Locate the two nonzero cells in the input grid; these are the colored cubes. Let one have value V₁ and the other V₂. They will lie either in the same row (horizontal case) or in the same column (vertical case).\n\n2. If the cubes lie in the same row (horizontal connection):\n   a. Label the cube with the smaller column index as the LEFT cube (at row R, column Cₗ with value V₁) and the other as the RIGHT cube (at row R, column Cᵣ with value V₂), where Cᵣ > Cₗ.\n   b. Compute the stem length L = floor((Cᵣ − Cₗ) / 2). This L (a positive integer) is the number of cells (counting the cube’s cell) in a horizontal “stem” that will extend from each cube toward the center.\n   c. For the LEFT cube:\n      • Draw a horizontal stem starting at (R, Cₗ) and continuing rightward for L cells; that is, fill each cell (R, C) for C from Cₗ to Cₗ + L − 1 with V₁.\n      • Let the stem’s endpoint be Eₗ = (R, Cₗ + L − 1).\n      • From Eₗ, draw a vertical connector of fixed length 5 by filling the cells in the same column as Eₗ at rows R − 2, R − 1, R, R + 1, and R + 2 with V₁ (this creates a column of 5 cells centered on row R).\n      • Then, add an extra cell to connect toward the other figure: from the top cell of the connector (at (R − 2, Eₗ.col)) fill the cell immediately to its right (i.e. (R − 2, Eₗ.col + 1)) with V₁; similarly, from the bottom cell (at (R + 2, Eₗ.col)) fill the cell immediately to its right (i.e. (R + 2, Eₗ.col + 1)) with V₁.\n   d. For the RIGHT cube:\n      • Draw a horizontal stem starting at (R, Cᵣ) and extending leftward for L cells; that is, fill each cell (R, C) for C from Cᵣ down to Cᵣ − L + 1 with V₂.\n      • Let the stem’s endpoint be Eᵣ = (R, Cᵣ − L + 1).\n      • From Eᵣ, draw a vertical connector of 5 cells (centered on row R) by filling cells at rows R − 2, R − 1, R, R + 1, and R + 2 in column Eᵣ.col with V₂.\n      • Then, add an extra cell from the top and bottom of this connector toward the center: fill the cell immediately to the left of the top cell ((R − 2, Eᵣ.col − 1)) and the cell immediately to the left of the bottom cell ((R + 2, Eᵣ.col − 1)) with V₂.\n\n3. If the cubes lie in the same column (vertical connection):\n   a. Label the cube with the smaller row index as the TOP cube (at row Rₜ, column C with value V₁) and the other as the BOTTOM cube (at row R_b, column C with value V₂), where R_b > Rₜ. Let d = R_b − Rₜ.\n   b. For the TOP cube, determine its stem length Sₜ (the number of cells in the vertical stem, counting the cube’s cell) by using the following rule:\n      • If d is odd, set Sₜ = floor(d/2) − 1; if d is even, set Sₜ = floor(d/2) − 2.\n      (For example, if the top cube is at row 2 and the bottom cube at row 11 then d = 9 and Sₜ = 4 − 1 = 3.)\n   c. Draw a vertical stem downward from the TOP cube by filling cells (Rₜ, C), (Rₜ + 1, C), …, (Rₜ + Sₜ − 1, C) with V₁. Let the stem’s endpoint be Eₜ = (Rₜ + Sₜ − 1, C).\n   d. From the row immediately below Eₜ (i.e. at row Eₜ.row + 1), draw a horizontal connector of fixed length 5 by filling the cells in that row for columns C − 2, C − 1, C, C + 1, and C + 2 with V₁.\n   e. Then, extend this connector toward the center by adding one extra cell below its leftmost and rightmost cells; that is, fill (Eₜ.row + 2, C − 2) and (Eₜ.row + 2, C + 2) with V₁.\n   f. For the BOTTOM cube, set its stem length S_b = floor(d/2) − 1 (so that, for example, if d = 9 then S_b = 4 − 1 = 3; if d is even the calculation adjusts accordingly).\n   g. Draw a vertical stem upward from the BOTTOM cube by filling cells (R_b, C), (R_b − 1, C), …, (R_b − S_b + 1, C) with V₂. Let the stem’s endpoint be E_b = (R_b − S_b + 1, C).\n   h. From the row immediately above E_b (i.e. at row E_b.row − 1), draw a horizontal connector of 5 cells by filling the cells in that row for columns C − 2, C − 1, C, C + 1, and C + 2 with V₂.\n   i. Then, extend this connector toward the center by adding one extra cell above its leftmost and rightmost cells; fill cell (E_b.row − 2, C − 2) and cell (E_b.row − 2, C + 2) with V₂.\n\n4. Leave all other cells unchanged and do not alter the overall grid size. This process creates for each cube an L‐shaped (for horizontal) or rotated “T” (for vertical) figure that extends from the original cube toward the center of the grid but stops one cell short of meeting the other figure.\n\nNote: All cell locations are given in (row, column) coordinates using the grid’s indexing. Use only the integer values (for example, 1–9) for coloring; no color names are used.",
    "b775ac94.json": "1. Keep the grid dimensions unchanged. 2. Identify every connected cluster of nonzero cells (cells whose values are not 0) using 4‐connectivity. Treat each such cluster independently. 3. For a given cluster, find the smallest rectangle (bounding box) that contains all its cells; denote its top, bottom, left, and right boundaries by min_row, max_row, min_col, and max_col. 4. Compute the center of the bounding box using integer (floor) division: center_row = floor((min_row + max_row) / 2) and center_col = floor((min_col + max_col) / 2). This center will serve as the pivot for mirroring. 5. For each cell in the cluster with value v at position (r, c), compute its mirror images about the center by using these formulas, and if the reflected coordinate lies within the grid bounds, set that cell to v in the output (overwriting 0):\na. Vertical reflection: (r, 2 * center_col − c).\nb. Horizontal reflection: (2 * center_row − r, c).\nc. Diagonal reflection (both axes): (2 * center_row − r, 2 * center_col − c).\n6. Overlap the original cells with all computed reflections so that each cluster becomes symmetrically filled around its center. (In some clusters only three of the four quadrants may be filled if one “arm” is missing, producing a three‐quarter snowflake; if all four colors are present the result is a fully symmetric snowflake.)\n7. Leave all cells that were 0 in the input as 0 in the output.",
    "b782dc8a.json": "1. Interpret the grid as a 2D array of integers. Do not change any cell whose value is not 0. In our grids the number 8 is used for the background and 0 represents empty (black) cells that may be filled. Any cell whose value is neither 0 nor 8 is a “seed” cell that shows one half of an alternating pair (for example, in some examples the seeds are 3 and 2; in others they are 1 and 4 or 4 and 3).\n2. Scan the grid and record all seed cells; these are the cells with a value not equal to 0 or 8. In every region to be patterned the seed cells will include exactly two distinct numbers. (For instance, if a region’s seed cells are 3 and 2 then the alternating pair is (3,2); if they are 1 and 4 then the pair is (1,4), etc.)\n3. Using 4‐neighbor connectivity (up, down, left, right), partition the cells that have value 0 into connected components. (Two 0 cells belong to the same component if you can travel from one to the other moving only in the four cardinal directions through cells that are 0.)\n4. For each connected component of 0’s, check whether at least one cell in the component is adjacent (i.e. shares an edge) to a seed cell. If no cell in the component touches a seed cell, leave that component unchanged (i.e. keep its 0’s intact).\n5. For every component that does touch a seed, determine its alternating pair as follows: Examine all seed cells that are 4‐neighbors of any cell in the component. Among these, choose the seed with the smallest row (and in case of a tie, the smallest column); call its value A. Let the other seed value (which will be the only other distinct number present) be B. (Thus the alternating pair is (A, B).)\n6. Now fill every cell (with row index r and column index c) in that 0–component by computing the sum (r + c) mod 2. Also compute K = (r_seed + c_seed) mod 2 for the chosen reference seed from step 5. If (r + c) mod 2 equals K, set the cell’s value to A; otherwise set it to B. (This imposes an alternating boundary pattern over the component.)\n7. Leave all nonzero cells (including background 8’s and the original seed cells) unchanged and return the modified grid.",
    "b8825c91.json": "1. Let the input be a grid of size m×n (m rows and n columns). For every cell in the grid use 0‐based coordinates so that a cell has coordinates (r, c) with 0 ≤ r < m and 0 ≤ c < n. Define the symmetric group for a cell at (r, c) to be the set of four cells: (r, c), (r, n−1−c), (m−1−r, c) and (m−1−r, n−1−c). 2. Note that in this task the color yellow is represented by the number 4. In the input grid some “yellow” regions (i.e. contiguous blocks of cells with value 4) disrupt an overall pattern. In the intended output the entire grid is both horizontally and vertically symmetric. 3. For each symmetric group (each set of four symmetric cells), check whether at least one cell in that group has a value other than 4. (When the non–4 value appears in a correctly patterned grid the entire symmetric group should share that same value.) 4. If at least one cell in the group is not 4, then set every cell in that entire symmetric group to that non–4 value. (You may assume that any non–4 values in a given symmetric group are all equal.) 5. If every cell in a symmetric group is 4, leave them unchanged. 6. Leave all cells that are not 4 (and already match their symmetric partner) as they are. 7. Output the resulting grid (which has the same dimensions as the input); it will now be both horizontally and vertically symmetric and the “yellow” (4) rectangles that broke the pattern will have been replaced by the appropriate numbers.",
    "b8cdaf2b.json": "1. Copy the input grid into the output grid without change except where specified below.\n2. Identify the bottom‐edge structure as follows. First, note that the background is represented by 0. Find all nonzero cells that are connected (via 4‑neighbors) to any cell in the bottom row; call this set the structure. Let r_cap be the smallest row index (closest to the top) that contains any cell of the structure.\n3. In the bottom row (last row of the grid), find the leftmost column L and the rightmost column R that hold a nonzero (i.e. part of the structure). Define the INTERIOR COLOR V as the value in the bottom row at column (L+R)//2. (For example, if the bottom row has nonzeros from column 0 to column 4, then V is the value at column 2.)\n4. In the rows above the structure—that is, from row 0 to row r_cap−1—only some rows will be modified to add a diagonal line in color V. In what follows the grid coordinates are (row, column) with row 0 at the top.\n5. Examine the structure’s top row (row r_cap). If that row has exactly one nonzero cell, call the structure cap a single‐cell cap; if it has more than one nonzero cell, call it a multi‑cell cap.\n6. Let n = r_cap (the count of rows above the structure). \n   • If the cap is single‐cell:\n     a. Let the pivot column be the column index of the only nonzero in row r_cap.\n     b. Define the number of modified rows m as follows: if n = 1 then m = 1; otherwise (if n > 1) choose m = n − 1.\n     c. For each integer i from 1 to m, set the two cells in row (r_cap − i) as follows (if the target column is in bounds):\n        – Replace the cell at (r_cap − i, pivot − i) with V.\n        – Replace the cell at (r_cap − i, pivot + i) with V.\n     (This draws a diagonal that starts below the structure cap and extends upward from near the center out toward both horizontal edges.)\n   • If the cap is multi‑cell:\n     a. Define m = floor(n/2) (with the convention that if n is less than 2, use m = 1).\n     b. Using the horizontal span defined by L and R (from the bottom row of the structure), select the m lowest rows of the non‐structure region; that is, for k = 0 to m − 1, let the target row be r_target = r_cap − m + k.\n     c. In each such target row, set two cells as follows:\n        – Replace the cell at (r_target, L + k) with V.\n        – Replace the cell at (r_target, R − k) with V.\n     (This creates two symmetric diagonal markers whose endpoints exactly match the horizontal span of the structure in the bottom row.)\n7. Return the modified output grid.  \n\nNotes:\n• All indexing is zero‐based; row 0 is the top and the last row is the bottom.\n• All cell values are integers (0–9); here 0 is background and V is one of 1–9 as computed from the bottom row.\n• Do not modify any cells outside those explicitly replaced by the diagonal‐drawing steps.",
    "b91ae062.json": "1. Read the input grid of size H x W, where each cell is an integer in the range 0–9. Treat 0 as the background value and all other numbers as colored values.\n2. Scan the entire grid and form the set S of distinct nonzero integers. Let k be the number of elements in S.\n3. Compute the output grid size as (H * k) rows and (W * k) columns.\n4. For each cell in the input grid located at row r and column c with value v, identify its corresponding output block. The top‐left corner of this block is at output row (r * k) and column (c * k).\n5. Replace that single input cell with a k×k block in the output by filling all cells in the block with the same number v.\n6. Repeat step 5 for every cell in the input grid so that the relative positions remain the same but each cell is replaced by a k×k square.\n7. Return the output grid.",
    "b94a9452.json": "1. Find the minimal bounding box that contains all cells with a nonzero value (treat 0 as background). Let the top‐left corner be (R_min, C_min) and the bottom‐right corner be (R_max, C_max).\n2. Extract the subgrid defined by rows R_min to R_max and columns C_min to C_max. This subgrid is guaranteed to be a square containing exactly two distinct nonzero numbers.\n3. Determine the two numbers in the subgrid. Scan its border (the first and last rows and columns) to identify the outer value; call this number c_outer. Let the other number (found in the interior) be c_inner.\n4. Construct a new grid with the same dimensions as the subgrid. For each cell in this subgrid, if the cell lies on the border (that is, its row is the first or last of the subgrid or its column is the first or last), assign it the value c_inner; otherwise, assign it the value c_outer.\n5. Output this new grid.",
    "b9b7f026.json": "1. Set the output grid to be a 1x1 grid.\n2. For the given input grid (with cell values in the range 0–9, where 0 represents the background), identify each contiguous region (object) of nonzero cells using orthogonal (4-direction) connectivity.\n3. For each object, let X be its cell value. Compute the bounding box of the object (i.e. the minimum and maximum row and column indices that contain a cell with value X).\n4. If the bounding box has a height and width of at least 3 (ensuring an interior exists), examine every cell strictly inside the bounding box (rows between r_min+1 and r_max-1 and columns between c_min+1 and c_max-1). If any such cell does not have the value X, then the object is not completely filled and is considered to have a hole.\n5. Select the object that has a hole. (If more than one object qualifies, choose any one of them.)\n6. Fill the new 1x1 output grid with the integer X (the value of the object with a hole).\n7. Return this 1x1 grid as the final output.",
    "ba26e723.json": "1. Process the input grid column‐by‐column (columns are 0-indexed) and note that the grid always has 3 rows. In every column there is a vertical pair of yellow cells represented by the value 4. Identify the type of pair in each column as follows: if the top cell (row 0) is 4 then the column is an \"upper pair\" (the two yellow cells are at row 0 and row 1); otherwise (when row 0 is not 4, typically 0) the column is a \"lower pair\" (the two yellow cells are at row 1 and row 2).\n2. Number the columns in order. For each column whose index c satisfies (c mod 3 == 0) (that is, the 1st, 4th, 7th, … column in the grid), perform the following change: \n • If the column is an upper pair (i.e. grid[0][c] equals 4), set both grid[0][c] and grid[1][c] to 6 (pink, where 6 represents pink/fuchsia).\n • If the column is a lower pair (i.e. grid[0][c] is not 4), set both grid[1][c] and grid[2][c] to 6.\n3. For all columns that do not satisfy (c mod 3 == 0), leave the cells unchanged.\n4. Return the grid with the same dimensions as the input.",
    "ba97ae07.json": "1. Copy the input grid to an output grid without change except for later modifications.\n2. Identify the vertical stroke columns. These are the column(s) in which every cell (except possibly those in one special row group) is a nonzero constant value; call that constant V. (For example, in many cases columns such as column 3–4 or a single column will have the same number (V) in every row except where an overlap occurs.)\n3. Identify the horizontal stroke row or contiguous group of rows. In each such row the majority of cells (all cells outside the vertical stroke columns) have the same nonzero value; call this value H. (For instance, a row might read H, H, …, but in the vertical stroke columns the value may conflict with H.)\n4. For each cell that lies at an intersection – that is, each cell whose row is one of the horizontal stroke rows and whose column is one of the vertical stroke columns – decide the correct value as follows:\n   a. Examine the entire horizontal stroke row in the input. If every cell in that row is already H (i.e. the row is uniform), then the horizontal stroke was drawn without the vertical stroke intruding, so the intended overlay is provided by the vertical stroke. In this case, set the cell’s value to V.\n   b. Otherwise (if the row is non‐uniform because some intersection cells do not equal H), then the horizontal stroke is intended to appear continuously. In this case, overwrite the cell with H.\n5. Leave all other cells unchanged and output the modified grid.\n\nThis algorithm uses only the numbers. (Here 0 is the background and H and V are nonzero digits such as 3,8 or 1,6, etc., determined from the grid.)",
    "bb43febb.json": "1. Scan the entire grid and identify each contiguous region of identical nonzero cells (using 4-connectedness). In this task the regions to be transformed are the ones filled with the integer 5 (representing gray). 2. For each such region, determine its bounding box by finding the minimum and maximum row and column indices where the value occurs. 3. Verify that every cell within the bounding box is equal to 5 so that the region forms a complete rectangle. 4. If the bounding box has at least 3 rows and at least 3 columns (ensuring an interior exists), replace every cell inside the rectangle that is not on the border (that is, every cell with a row index strictly between the minimum and maximum row and a column index strictly between the minimum and maximum column) with 2 (which represents red). 5. Leave all border cells (the first and last row and column of the bounding box) and all other cells in the grid unchanged. The output grid retains the same dimensions as the input.",
    "bbc9ae5d.json": "1. Read the input grid, which is a single row of integers (0–9). Let w be the number of cells (columns) in the input. Note that the input row consists of a contiguous block of nonzero numbers on the left (the colored region) followed by 0’s (representing blank cells).\n2. Compute the output grid’s height h as exactly w/2 (assume w is even). The output grid will have w columns and h rows.\n3. Determine the value k by counting the number of consecutive nonzero cells in the input row starting at column 0. Also, set the fill value v to the value in the first cell (which will be nonzero).\n4. Construct the output grid row by row. For each row i (with i = 0 for the top row up to i = h–1):\n   a. Compute the number of colored cells for that row as count = k + i.\n   b. For columns 0 to count–1, set the cell value to v.\n   c. For columns count to w–1, set the cell value to 0.\n5. Note that the first row (i = 0) will be identical to the input row. Proceed row by row until the grid is complete, forming a staircase pattern where each subsequent row has one more leading cell filled with v.",
    "bc1d5164.json": "1. Recognize that the input grid always has 5 rows and 7 columns with pixel values in the range 0–9. Here, 0 represents the black background and any nonzero digit (for example, 2, 3, 4, or 8) represents the foreground color.\n2. Create a 3×3 output grid by partitioning the input into 9 blocks as follows:\n   • For rows, define three groups:\n     - Output row 0 corresponds to input row 0.\n     - Output row 1 corresponds to input rows 1, 2, and 3.\n     - Output row 2 corresponds to input row 4.\n   • For columns, define three groups:\n     - Output column 0 corresponds to input column 0.\n     - Output column 1 corresponds to input columns 1, 2, 3, 4, and 5.\n     - Output column 2 corresponds to input column 6.\n3. For each output cell (r, c) in the 3×3 grid, scan all input cells in the block determined by the corresponding row group and column group. If any cell in that block has a nonzero value, assign the output cell that nonzero value (which represents the foreground color); if all cells are 0, leave the output cell as 0.\n4. This procedure effectively “squeezes” or compresses the foreground pattern in the input by overlaying any detected nonzero (foreground) dots onto the background, preserving their relative arrangement in a condensed 3×3 grid.\n5. Return the constructed 3×3 grid as the final output.",
    "bd4472b8.json": "1. Let the input grid have M rows and N columns. Interpret the grid as follows: row 1 contains the color pattern (a sequence of N numbers), row 2 is a reference row (unchanged), and rows 3 through M are to be replaced. 2. Copy rows 1 and 2 from the input grid directly to the output grid without changes. 3. For each row r from 3 to M, calculate the index i = (r - 3) mod N. This index i selects the color from row 1 at column (i + 1). 4. Replace every cell of row r in the output grid with the number found at row 1, column (i + 1). In other words, fill the entire row with that single number. 5. The cycle repeats: after using the last element of row 1, start again at the first element. 6. Return the output grid, which has the same dimensions as the input grid. (Note: All numbers correspond to colors by the mapping {0: black, 1: blue, 2: red, 3: green, 4: yellow, 5: grey, 6: pink/fuchsia, 7: orange, 8: cyan/light blue, 9: brown/maroon}.)",
    "bda2d7a6.json": "1. Read the input grid and determine its size n. (In all examples n is even; the provided examples use n = 6 and n = 8.)\n2. (For a 6×6 grid – three nested squares)\n   a. Define the three regions by fixed coordinates:\n      • Inner region (S_small): the center 2×2 block covering rows 2 to 3 and columns 2 to 3.\n      • Middle region (S_mid): the 4×4 block covering rows 1 to 4 and columns 1 to 4. (This region is understood by its border cells; its color is uniform.)\n      • Outer region (S_large): the border of the grid, i.e. all cells in row 0 or row 5 or in column 0 or column 5.\n   b. Sample the original colors:\n      • Let color_small be the input color taken from any cell in S_small.\n      • Let color_mid be the input color taken from any cell in S_mid.\n      • Let color_large be the input color taken from any cell in S_large.\n   c. Reassign colors to form the output grid with the same dimensions as follows:\n      • For every cell in S_small (center 2×2), set its new color to color_mid.\n      • For every cell that belongs to S_mid but is not in S_small (i.e. the middle ring), set its new color to color_large.\n      • For every cell in S_large (the outer border), set its new color to color_small.\n3. (For an 8×8 grid – four nested squares)\n   a. Define the four regions by fixed coordinates:\n      • Region A (S_small, the smallest): the center 2×2 block covering rows 3 to 4 and columns 3 to 4.\n      • Region B (S_mid, the inner 4×4 square): the block covering rows 2 to 5 and columns 2 to 5. (Note that the center 2×2 is part of this area but is treated separately by region A.)\n      • Region C (S_extra, the 6×6 ring): all cells in the 6×6 block covering rows 1 to 6 and columns 1 to 6 that are not part of the 4×4 (i.e. not in Region B).\n      • Region D (S_large, the outer border): all cells in row 0 or row 7 or column 0 or column 7.\n   b. Sample the original colors:\n      • Let color_A be the input color from any cell in Region A (S_small).\n      • Let color_B be the input color from any cell in Region B (S_mid). (Because the border of the 4×4 is uniformly the same, you may use a representative cell, e.g. at (2,2)).\n      • Let color_C be the input color from any cell in Region C (S_extra).\n   c. Reassign colors to form the output grid according to these rules:\n      • For every cell in Region A (center 2×2), set its new color to color_B.\n      • For every cell in Region B (the 4×4 ring excluding the center), set its new color to color_C.\n      • For every cell in Region C (the 6×6 ring, i.e. the difference between the 6×6 block and the 4×4 inner square), set its new color to color_A.\n      • For every cell in Region D (the outer border), set its new color to color_B.\n4. Output the grid with the same dimensions as the input in which each cell’s new value is determined by the region in which its coordinates (row, column) lie and by the above mapping of colors. (All color values are integers in the range 0–9 as given in the input.)",
    "bdad9b1f.json": "1. Read the input grid and note its dimensions (rows and columns remain unchanged in the output).\n2. Locate the unique row that contains at least one red cell (cells with value 2). Call this row R. (In our examples, for instance, row 2 in the first example, row 3 in the second, and row 4 in the test.)\n3. Locate the unique column that contains at least one blue cell (cells with value 8). Call this column C. (For example, column 4 in the first example, column 1 in the second, and column 3 in the test.)\n4. Create the output grid by processing each cell (row r, column c) of the input as follows:\n   a. If r equals R (the identified red row), then set that cell to red (value 2).\n   b. If c equals C (the identified blue column), then set that cell to blue (value 8), unless the cell is also in row R.\n   c. If both conditions apply (that is, if r = R and c = C), override the above and set that cell to yellow (value 4).\n   d. For all other cells (those not in row R and not in column C), keep the original input value.\n5. Return the resulting grid.",
    "be94b721.json": "1. For every cell in the input grid, if the cell value is not 0 (recall: 0 = black), group it with adjacent (up, down, left, right) cells that have the same number into a connected component. (Here the numbers represent colors according to: 0=black, 1=blue, 2=red, 3=green, 4=yellow, 5=grey, 6=pink/fuchsia, 7=orange, 8=cyan/light blue, 9=brown/maroon.)\n2. Count the number of cells in each connected component and select the component having the highest count (if multiple components tie, choose any one).\n3. Compute the minimal bounding rectangle for the selected component by finding the smallest and largest row indices and the smallest and largest column indices that contain any cell of that component.\n4. Extract the subgrid from the input grid that spans this bounding rectangle. Include all cell values within this rectangle exactly as they appear (this means that any 0s inside the box are kept).\n5. Return the extracted subgrid as the output grid.",
    "beb8660c.json": "1. For each row in the input grid (with height H and width W), scan the row from left to right and extract every contiguous block of cells that have a nonzero value (cells with value ≠ 0) and that are identical. Each such block is a horizontal segment; record its value (an integer between 1 and 9) and its length (the number of cells in the block).\n2. Collect all horizontal segments from all rows. (Note: if a row contains more than one separated segment, extract each one separately.)\n3. Sort the list of segments in ascending order by their length. This order guarantees that the shortest segment will be placed highest among the filled rows and the longest segment will be at the bottom.\n4. Initialize an output grid of the same dimensions (H × W) as the input, filling every cell with 0.\n5. Let N be the total number of segments extracted. In the output grid, assign these segments to consecutive rows starting from row index (H − N) up to row index (H − 1). For each segment with length L and value V, fill the corresponding output row by placing V in the rightmost L cells (that is, fill columns from W − L to W − 1 with V) and leave all other cells in that row as 0.\n6. Leave the remaining rows (from row 0 to row H − N − 1) as all 0. The resulting grid will have the segments arranged in order: the smallest (shortest) segment at the highest filled row (closest to the top of the filled portion) and the largest segment at the bottom, with each segment right‐aligned.",
    "c0f76784.json": "1. Scan the entire grid (indexed by row and column) and identify every contiguous region of cells whose value is 0 using 4‐neighbor connectivity. Only consider a region if it is completely enclosed by cells with the value 5 (that is, none of its cells touches the outer border of the grid). These regions are the holes inside the drawn shapes. 2. For each enclosed region, count the number of cells (i.e. the area of the hole). 3. Sort the enclosed regions by their cell count (area) in ascending order. Then assign a new fill value to each region based on how many holes are found: • If there are three enclosed regions, assign the smallest (fewest cells) the value 6, the next (medium area) the value 7, and the largest (most cells) the value 8. (Note: 6 stands for pink, 7 for orange, and 8 for cyan/light blue.) • If there are two regions, assign the one with fewer cells the value 7 and the one with more cells the value 8. • If there is only one region, assign it the value 8. 4. For every enclosed region, perform a flood fill by replacing every 0 in that region with its assigned fill value. 5. Leave all cells outside these enclosed regions unchanged and output the resulting grid with the same dimensions as the input.",
    "c1d99e64.json": "1. Let the input grid have R rows and C columns. 2. Identify every horizontal line: for each row r (0 ≤ r < R), if every cell in that row is 0 (black), mark row r as a full horizontal black line. 3. Identify every vertical line: for each column c (0 ≤ c < C), if every cell in that column is 0 (black), mark column c as a full vertical black line. 4. Create an output grid as a copy of the input grid. 5. For each cell at position (r, c) in the grid, if the cell’s value is 0 and (row r is marked as a full black line or column c is marked as a full black line), change that cell’s value to 2 (red). 6. Leave all other cells unchanged. 7. Return the resulting grid. This procedure recolors only those 0’s that belong to a completely black row or a completely black column.",
    "c3e719e8.json": "1. Read the 3x3 input grid of integers (each in the range 0–9). \n2. Count the occurrences of each integer in the grid and determine the dominant value (the integer that appears most frequently). For example, if 3 is the dominant value, then cells containing 3 are the dominant ones.\n3. Create a 9x9 output grid and initialize every cell to 0. \n4. Conceptually divide the 9x9 grid into nine nonoverlapping 3x3 blocks. Use 0-indexed coordinates so that for each cell in the input grid at position (r, c) (with r and c from 0 to 2), the corresponding 3x3 block in the output covers rows 3*r to 3*r+2 and columns 3*c to 3*c+2.\n5. For each cell in the input grid at position (r, c):\n   a. If the value at (r, c) equals the dominant value, then copy the entire input 3x3 grid into the corresponding 3x3 block of the output grid. \n   b. Otherwise, leave that block as 0’s.\n6. Return the 9x9 output grid.",
    "c3f564a4.json": "1. Determine the grid dimensions by letting R be the number of rows and C the number of columns in the input.\n2. Scan the entire grid for nonzero integers and let k be the maximum value found; this k defines the intended cycle of numbers [1, 2, …, k]. (For example, if k = 5 then the cycle is 1,2,3,4,5; if k = 8 then the cycle is 1,2,3,4,5,6,7,8.)\n3. Construct a complete base row (to serve as the reference for row 0) by repeating the cycle [1,2,…,k] until you have exactly C entries. In other words, set base_row[c] to the ((c mod k) + 1) for each column index c from 0 to C − 1.\n4. For every row with index r (0 ≤ r < R) and for every column with index c (0 ≤ c < C), compute the output value by taking the corresponding value from the base row and “incrementing” it by r in a cyclic fashion. That is, assign the output cell at (r, c) the value: (((base_row[c] − 1) + r) mod k) + 1. This operation adds r to the base value (with subtraction of 1 to convert into 0‐based arithmetic), wraps around modulo k (so that when the sum exceeds k the count starts again at 1), and then converts back to a 1‐to‐k value.\n5. Overwrite every cell (regardless of its original value) with the computed value. The result is a grid of the same dimensions that exhibits a diagonal pattern: each row is obtained by adding 1 (modulo k) to every cell of the row above.\n6. Return the resulting grid.",
    "c444b776.json": "1. Scan the input grid for full‐row or full‐column divider lines. A row is a divider if every cell has the same nonzero value (in these examples the divider value is 4) and a column is a divider if every cell in that column equals 4. 2. Partition the grid into sections by using the divider rows and divider columns. For example, if there is one horizontal divider row and one vertical divider column, the grid is split into four rectangular sections; if only a horizontal divider exists, split the grid into two sections. Do not include the divider rows or columns as part of a section. 3. Note that all sections (the areas between dividers and the grid edges) will have the same dimensions when the partition is symmetric. Define the relative coordinates within a section so that the top‐left cell of any section is (0,0). 4. For each cell position (r, c) within a section (using the section’s own coordinate system), examine the corresponding cell in every section. If any section has a nonzero value at that relative position (i.e. a number other than 0), record that number; if more than one nonzero value appears at the same relative coordinate, assume they are identical. If all sections have 0 at that position, record 0. This produces a union pattern of size equal to one section. 5. Replace every section in the grid with an identical copy of this union pattern, so that for every section and every relative position (r, c) the cell is set to the union value computed in step 4. 6. Keep all divider rows and divider columns unchanged (i.e. their cells remain the same as in the input). 7. Produce the output grid with the same dimensions as the input in which every section (the non‐divider areas) has been filled with the union pattern of nonzero values.",
    "c59eb873.json": "1. Compute the dimensions of the input grid: let R be the number of rows and C be the number of columns. 2. Create an output grid with dimensions 2×R (rows) by 2×C (columns). 3. For each cell in the input grid at position (r, c) containing a number v (v ∈ {0,1,2,3,4,5,6,7,8,9}), fill the corresponding 2×2 block in the output grid. Specifically, set the values at output positions (2×r, 2×c), (2×r, 2×c + 1), (2×r + 1, 2×c), and (2×r + 1, 2×c + 1) to v. 4. Return the resulting output grid.",
    "c8cbb738.json": "1. Find the background value B by scanning the entire input grid and choosing the integer that occurs most frequently. 2. For every distinct non‐B integer (each representing a group of colored pixels), collect all coordinates (r, c) where that value appears. (In all provided examples each such group has exactly 4 pixels arranged symmetrically.) 3. For each group, compute its minimal bounding box by finding min_row, max_row, min_col, and max_col over its pixels. Then let M_group = max(max_row − min_row + 1, max_col − min_col + 1). 4. Compute the center of the group’s bounding box as ( (min_row + max_row)/2, (min_col + max_col)/2 ). (Because the groups are symmetric, these centers will be integers.) 5. Set the output grid’s side length N equal to the maximum M_group over all groups. (N will be odd.) 6. Define the output grid’s center as (N//2, N//2) using 0‐indexed coordinates. 7. For each pixel in each group (with original coordinate (r, c) and group center (r_center, c_center)), calculate its offset Δr = r − r_center and Δc = c − c_center. Then place that pixel’s original integer at coordinate (N//2 + Δr, N//2 + Δc) in the new grid. 8. After processing all groups, fill every cell in the N×N grid that was not written with the background value B. 9. Return the resulting N×N grid.",
    "c8f0f002.json": "1. Read the input grid as a two‐dimensional array of integers. 2. Create an output grid of the same dimensions as the input grid. 3. For each cell at position (row, col) in the input grid, check its value: if the value is 7, then assign 5 to the corresponding output cell; otherwise, copy the original value to the output grid. 4. Return the output grid.",
    "c909285e.json": "1. Read the input as a two‐dimensional grid of integers (each between 0 and 9).\n2. Locate a square subgrid (of size n×n with n ≥ 3) that is delineated by a one‐cell thick border. In other words, find indices r and c and a size n such that:\n   a. The cells in the top row (row r, columns c to c+n−1) are all equal to some value B.\n   b. The cells in the bottom row (row r+n−1, columns c to c+n−1) are all equal to B.\n   c. The cells in the left column (rows r to r+n−1, column c) are all equal to B.\n   d. The cells in the right column (rows r to r+n−1, column c+n−1) are all equal to B.\n   (For example, in some cases B is 3, in others 2, 6, or 8 – do not refer to colors, only their numeric values.)\n3. To find this subgrid, iterate over all possible top‐left coordinates (r, c) and candidate sizes n (bounded by the input dimensions) and check that the entire border of the candidate square has the same number B.\n4. Once a valid square subgrid is identified, copy every element from that subgrid exactly (including both the uniform border and the interior pattern) without modifying any value.\n5. Set the copied n×n grid as the output grid.",
    "c9e6f938.json": "1. Let the input be a grid with R rows and C columns containing integers, where 0 represents black and 7 represents orange.\\n2. Create an output grid with R rows and 2 * C columns.\\n3. For each row (using row index i from 0 to R-1):\\n   a. Read the i-th row from the input as a list L = [L[0], L[1], ..., L[C-1]].\\n   b. Compute the horizontal mirror of this row by reversing L to get R = [L[C-1], L[C-2], ..., L[0]].\\n   c. Concatenate L with R to obtain a new row: [L[0], L[1], ..., L[C-1], L[C-1], L[C-2], ..., L[0]].\\n   d. Place this new row into the output grid at row i.\\n4. Return the output grid.",
    "c9f8e694.json": "1. For each row (r) in the input grid, read the leftmost cell (at column 0) and call its value the indicator (this value can be any integer such as 1, 2, 3, etc.).\n2. Traverse each cell in that same row (for all column indices c from 0 to the last column).\n3. If a cell’s value is 5 (which represents grey), replace that cell’s value with the indicator from column 0 of that row.\n4. Leave every cell that is not 5 unchanged.\n5. Output the resulting grid with the same dimensions as the input.",
    "caa06a1f.json": "1. Find the border color (B) by scanning the input grid’s edges. In every example the cells on one or more edges (all cells in the last few rows or all cells in the last few columns) are filled with a single number B. Determine the border thickness by counting the contiguous rows at the bottom that are entirely B and the contiguous columns on the right that are entirely B.\n2. Remove the border from the input grid. That is, define the pattern region as the subgrid from row 0 to (total_rows − number_of_border_rows − 1) and from column 0 to (total_columns − number_of_border_columns − 1). This region (located in the top‐left corner) shows the repeating pattern (the “corner pattern”).\n3. Determine the minimal repeating unit U of the pattern region. For example, examine the first row of the pattern region and find the smallest positive integer Q such that that row is exactly a repetition of its first Q numbers. Similarly, find the smallest positive integer P such that the rows of the pattern region repeat every P rows. Then take U to be the P × Q grid given by the first P rows and first Q columns of the pattern region.\n4. Construct the output grid with the same dimensions as the input grid. For each output cell with coordinates (r, c) (using 0‐indexed rows and columns), set its value to U[r mod P][(c + 1) mod Q]. (In other words, tile the minimal unit over the whole grid but shift every row one cell to the left relative to U, so that the missing border is filled with the correct continuation of the pattern.)\n5. Return the resulting grid.",
    "cbded52d.json": "1. Note that in every grid the two columns at index 2 and 5 are always 0; they serve as fixed vertical separators. Also, entire rows of 0 appear periodically and act as horizontal separators. Thus the non‐zero portion of the grid is divided into a 3 × 3 arrangement of blocks (each block is two columns wide and comes in a pair of rows), although the blocks themselves may not be internally uniform.\n2. Process the grid one nonzero row at a time (a row that is not entirely 0). In each such row, ignore the separators and view the row as three contiguous segments: a left segment (columns 0–1), a middle segment (columns 3–4) and a right segment (columns 6–7).\n • If the left and right segments are identical (that is, the two‐cell list in columns 0–1 equals the two‐cell list in columns 6–7) but the middle segment is different, then replace the entire middle segment with an exact copy of the left segment. (For example, if a row is [a, b, 0, c, d, 0, a, b] and (a,b) ≠ (c,d), change it to [a, b, 0, a, b, 0, a, b].)\n3. Next, group the nonzero rows into contiguous “block‐groups” (each group is the set of one or two consecutive nonzero rows; groups are separated by full rows of 0). Define the top (first) nonzero group as the reference group. (In the examples the nonzero groups all have two rows.)\n4. For any nonzero row that did not already undergo a horizontal fix (that is, its three segments were all identical) and that is not in the top group, apply a vertical correction using the pattern from the top group as follows:\n • If the row is the first row of its group (immediately following a 0–row), then check its left segment (columns 0–1). If that two–cell list does not equal the left segment of the very first nonzero row in the grid, overwrite the row’s left segment with that reference two–cell list.\n • If the row is the second row of its group, then check its right segment (columns 6–7). If that two–cell list does not equal the right segment of the second nonzero row in the grid, overwrite the row’s right segment with that reference two–cell list.\n5. (Do not change any separator columns or rows.)\n6. Return the modified grid. \n\nThis procedure (first enforcing that in any row where the two end segments are alike the middle must copy them, and then—in non‐top groups where all three segments were identical—correcting one end using the corresponding segment from the top group) produces the outputs observed in the training examples.",
    "cce03e0d.json": "1. Read the input as a 3x3 grid of integers. 2. Create an output grid of size 9x9 and initialize every cell with 0. 3. For every cell in the input grid with coordinates (r, c) where 0 ≤ r, c ≤ 2, check if the cell’s value is 2 (which stands for red). 4. If the cell value is 2, determine the corresponding block in the output grid with its top‐left corner at (3*r, 3*c). 5. Copy the entire 3x3 input grid into that block by setting, for every cell in the input at position (i, j) with 0 ≤ i, j ≤ 2, the output cell at (3*r + i, 3*c + j) to input[i][j]. 6. Leave all other cells in the output grid as 0. 7. Return the completed 9x9 output grid.",
    "cdecee7f.json": "1. Iterate over the input grid by columns: for each column index c from 0 to (number_of_columns - 1), and within each column, iterate over row index r from 0 to (number_of_rows - 1). For each cell, if the cell value is not 0 (i.e. not black), append that number (color) to a list in the order encountered. \n2. Let L be the list of extracted nonzero numbers; this list is built in column-major order (i.e. first inspect all cells in column 0 top-to-bottom, then column 1, etc.). \n3. Determine the smallest integer s such that s × s ≥ length(L). This s will be the side length of the square output grid. \n4. Create an s × s grid and initialize every cell to 0. \n5. Fill the grid with the numbers from L using a snake (zigzag) row pattern: \n   a. Process the rows of the output grid from r = 0 to s − 1 in order. \n   b. For each row r, take the next s numbers from L (or fewer if L is exhausted). \n   c. If r is even (i.e. 0, 2, 4, …), fill row r from leftmost column to rightmost column with the taken numbers in their original order. \n   d. If r is odd (i.e. 1, 3, 5, …), fill row r from rightmost column to leftmost column with the taken numbers (i.e. reverse their order). \n6. Any cells in the output grid that are not filled with a number from L remain as 0. \n7. Return the output grid.",
    "ce22a75a.json": "1. Read the input grid as a 2D array of integers where 0 represents black and 5 represents gray. The grid dimensions remain unchanged.\n2. Initialize an output grid of the same dimensions filled with 0 (black).\n3. For each cell in the input grid with coordinates (r, c), if its value is 5, then for every cell (i, j) in the 3x3 block centered at (r, c) (that is, for i from r-1 to r+1 and j from c-1 to c+1) that lies within the grid boundaries, set the corresponding cell in the output grid to 1 (blue).\n4. Return the output grid.",
    "ce4f8723.json": "1. Identify the structure of the input grid: the grid has 9 rows and 4 columns. Notice that row 5 (using 1-indexing) or index 4 (0-indexed) is a separator row in which every cell has the value 4. Discard this separator row.\n2. Form two 4x4 blocks from the remaining rows: the top block consists of rows 1–4 (0-indexed rows 0 to 3) and the bottom block consists of rows 6–9 (0-indexed rows 5 to 8).\n3. Create an output grid of size 4x4. For each cell in the output grid at coordinate (r, c) (with 0 ≤ r, c < 4), retrieve the corresponding top cell from the top block and the corresponding bottom cell from the bottom block.\n4. For each pair of corresponding cells, check the following: if both the top and bottom cell values are 0 (0 represents black), then set the output cell at (r, c) to 0; otherwise (if at least one cell is nonzero, representing a colored block), set the output cell at (r, c) to 3 (3 represents green).\n5. Return the resulting 4x4 grid as the final output.",
    "ce602527.json": "1. Determine the overall background value by reading the top‐left cell of the input grid (assume that every cell on the border has that same value). 2. For each cell, mark it as part of the drawing if its value is not equal to the background. (Note: a drawing may include holes or even cells whose value equals the background if they are enclosed by drawn cells.) 3. To separate drawn designs from the unbounded background, perform a flood fill from every border cell—but only spread through cells whose value equals the background. 4. Define the set of candidate design cells as all cells that are NOT reached by the border flood fill; these cells form one or more enclosed regions (even if some of them have the background number, they are enclosed by other numbers). 5. Group the candidate cells into connected regions using 4‐connectivity and by ignoring their numeric differences (that is, treat all candidate cells as equal when grouping). 6. For each connected region, compute its minimal bounding rectangle (the smallest subgrid that contains every cell of that region). 7. Discard any region whose bounding rectangle touches any edge of the original grid or whose rectangle has a height less than 3 rows or a width less than 3 columns. 8. If more than one region remains, compare the area (number of cells in the bounding rectangle) of each and select the one with the smallest area; if there is a tie, choose the one whose rectangle’s center is closest (using Euclidean distance) to the overall grid’s center. 9. Finally, output a new grid that is exactly the subgrid of the input defined by the bounding rectangle of the selected region—i.e. copy that block of numbers exactly as it appears.",
    "ce9e57f2.json": "1. Let H and W be the number of rows and columns in the input grid. Process each column C (0 ≤ C < W) separately. 2. For a given column C, if the bottom cell at (H-1, C) is 2, begin a contiguous scan upward: from row = H-1 moving upward, collect all consecutive cells that have the value 2. Let m be the number of cells in this contiguous block (i.e., the red bar anchored at the bottom). 3. Compute n = floor(m/2). This means that if m is even, exactly m/2 cells will be changed; if m is odd, then (m-1)/2 cells (the lower half) are to be changed, leaving one extra cell at the top of the block retaining the value 2. 4. Change the value of the n bottom-most cells in this block (i.e. the cells closest to the bottom of the grid) from 2 to 8. (Note: 2 represents red and 8 represents light blue.) 5. Leave all other cells unchanged. 6. Output the grid with the same dimensions as the input.",
    "cf98881b.json": "1. Divide the input grid into five vertical parts using fixed column indices (the grid always has 4 rows and 14 columns):\n   a. Left layer: columns 0–3 (a 4×4 block); this layer represents the yellow design (using value 4 when drawn, with 0 as transparent).\n   b. Left separator: column 4; all its cells are 2 and are ignored.\n   c. Middle layer: columns 5–8 (a 4×4 block); this layer represents the dark red design (using value 9 when drawn, with 0 as transparent).\n   d. Right separator: column 9; all its cells are 2 and are ignored.\n   e. Right layer: columns 10–13 (a 4×4 block); this layer represents the blue design (using value 1 when drawn, with 0 as transparent).\n2. Initialize the output grid as a 4×4 copy of the right layer (blue design). This forms the base layer.\n3. For each cell (row r, column c) in the 4×4 grid, if the corresponding cell in the middle layer is nonzero, overwrite the output cell with that value (i.e. dark red pixels, value 9, override the blue background).\n4. Then, for each cell (row r, column c), if the corresponding cell in the left layer is nonzero, overwrite the cell with that value (i.e. yellow pixels, value 4, override the underlying dark red or blue).\n5. Return the resulting 4×4 grid as the final output. (Note: Treat 0 as transparent so that a nonzero pixel in an overlay always replaces the underlying value.)",
    "d037b0a7.json": "1. Determine the number of rows (R) and columns (C) in the grid. The output grid will have the same size as the input grid.\\n2. For each column index c (from 0 to C−1), iterate over the rows from top (row 0) to bottom (row R−1).\\n3. Identify the first row r in column c where the cell value is not 0 (recall that 0 represents black). If no such cell exists, leave column c unchanged.\\n4. Let X be the value found at cell (r, c). For every row index i from r to R−1, set the cell (i, c) to X. This step fills in by propagating the nonzero value downward regardless of the original content.\\n5. Continue this process for every column and return the modified grid.",
    "d06dbe63.json": "1. Locate the unique cell in the input grid whose value is 8. Record its coordinates (row, column) as the starting point for both staircase patterns.\n2. Copy the input grid to form the output grid; leave all cells unchanged except where new markings are made.\n3. Create the upward/right staircase (using value 5) as follows:\n   a. Set the current position to the 8 cell and initialize the current direction to upward (i.e. decrement the row index).\n   b. For each segment, attempt to move up to 2 steps in the current direction. For each step, if the next cell is within the grid boundaries, change its value to 5. If you cannot make a full 2‐cell move because you hit the grid edge, add the in‐bound cell(s) and then stop this staircase.\n   c. After finishing a segment (i.e. after at most 2 moves), update the current position to the last cell that was marked with 5 and then switch direction. When the current direction is upward, change it to right (i.e. increment the column index); when it is right, change it to upward.\n   d. Repeat step 3b–3c until no step can be taken in the current segment.\n4. Create the downward/left staircase (using value 5) in a similar manner:\n   a. Reset the current position to the 8 cell and initialize the current direction to downward (i.e. increment the row index).\n   b. For each segment, attempt to move up to 2 steps in the current direction. For each step, if the next cell in that direction is within grid boundaries, set its value to 5. If only a partial segment is possible (because the grid edge is reached), add the in-bound cell(s) and then stop this staircase.\n   c. After each segment, update the current position to the last cell changed and alternate the direction. When the current direction is downward, change it to left (i.e. decrement the column index); when it is left, change it to downward.\n   d. Continue until no move can be made in a segment.\n5. Do not change any other cells; the original 8 remains unchanged and all cells not marked during the staircases remain as in the input. The final output grid shows two staircase patterns of 5 – one extending upward/right from the 8 and the other extending downward/left from the 8 – that continue until they reach the grid borders.",
    "d07ae81c.json": "1. Scan the entire input grid (of integers) and identify each cell that is a lone anomaly inside a uniform block. In each contiguous region (by orthogonal connectivity) the cells have one common background number. A cell whose value is different from that common background is defined as a seed. (For example, if a cell’s value is 1 but all its surrounding cells are 8, then that cell is a seed with value 1 and its region’s background is 8.)\n2. For every seed cell found, determine its region’s background value by checking the neighboring cells that are not the seed. (In all provided examples each seed appears as a single cell embedded in an area uniformly filled with the background.)\n3. From each seed cell, draw four diagonal rays (using the directions: northwest = (–1,–1), northeast = (–1,+1), southwest = (+1,–1) and southeast = (+1,+1)). Process each ray as follows:\n   a. Initialize the ray’s current propagation color to the seed’s value and set the expected background to the seed’s region background (both are integers between 0 and 9).\n   b. Step from the seed cell one cell at a time along the ray. For each new cell (r, c) reached (and while (r, c) remains within the grid bounds):\n      i. If the original input number at (r, c) is equal to the current expected background, then overwrite that cell in the output with the current propagation color.\n      ii. If the number at (r, c) is not equal to the current expected background (i.e. the ray has reached a boundary into another contiguous block) and if that new block contains its own seed (an anomaly cell), then switch the ray: update the current propagation color to that seed’s value and update the expected background to the background of that new region; then set cell (r, c) in the output to the new propagation color.\n      iii. Continue stepping in the same diagonal direction until you move off the grid.\n4. When two or more diagonal rays would assign a new value to the same cell, choose the value from the ray whose seed is closest in terms of the number of diagonal steps taken (i.e. the smaller step count wins).\n5. Leave all cells that are not reached by any diagonal ray unchanged (keeping their original input number).\n6. Output the resulting grid with the same dimensions as the input.\n\nNote: All numbers used are between 0 and 9. (For instance, if a human description said an anomaly is blue (1) in a block of cyan (8) or a yellow (4) anomaly in a block of red (2), use the corresponding numbers exactly.)",
    "d0f5fe59.json": "1. Examine the input grid and locate every cell whose value is not 0 (in the provided examples these cells have the value 8, which is to be used as the drawing color). 2. Group these nonzero cells into distinct shapes by using 4-connected connectivity (cells that touch horizontally or vertically belong to the same shape). 3. Count the distinct shapes; let this count be n. 4. Create an output grid of size n x n and initialize every cell to 0. 5. For each index i from 0 to n-1, set the cell at row i and column i (i.e., the main diagonal) in the output grid to the nonzero value (8). 6. Return the output grid.",
    "d10ecb37.json": "1. Read the input grid, which is a matrix of integers (each between 0 and 9).\n2. Identify that the grid has at least 2 rows and 2 columns.\n3. Extract the top-left 2x2 subgrid by taking the element at row 0, column 0; the element at row 0, column 1; the element at row 1, column 0; and the element at row 1, column 1.\n4. Construct a new output grid of size 2 rows by 2 columns where:\n   - The first row is [input(0,0), input(0,1)].\n   - The second row is [input(1,0), input(1,1)].\n5. Return this 2x2 output grid as the final result.",
    "d13f3404.json": "1. Read the input grid and let n be its number of rows (and columns). 2. Create an output grid of size (2*n) × (2*n) and fill every cell with 0. 3. For each cell in the input grid at coordinates (r, c) with a value v (where v ≠ 0), do the following: for each integer i starting at 0 while (r + i) < 2*n and (c + i) < 2*n, set the cell at (r + i, c + i) in the output grid to v. This step effectively draws a diagonal line (moving one step down and to the right) from each nonzero cell in the input. 4. Return the output grid.",
    "d22278a0.json": "1. Do not change the grid dimensions. Identify all source cells in the input that are nonzero. (In the examples these appear only at extreme positions such as corners; for each source record its row–column coordinates (r_s, c_s) and its integer value A.)\n2. For every cell in the output grid (with coordinates (r, c)), consider each source S and compute its Chebyshev distance d = max(|r − r_s|, |c − c_s|).\n3. For each source S and cell (r, c) compute a candidate value as follows: if d is even then the candidate is the source’s value A, but if d is odd then the candidate is 0.\n4. Among all sources, find the minimum distance d_min. If exactly one source attains this minimum distance then assign its candidate value to cell (r, c); however, if two or more sources tie for the minimum d then set cell (r, c) to 0.\n5. Repeat this process for every cell in the grid so that each cell’s output is determined by the nearest (in Chebyshev‐distance) input source, with the parity rule (even distance gives the source’s number; odd distance gives 0) and ties resolved by outputting 0.",
    "d23f8c26.json": "1. Read the input grid as a 2D array of integers (each integer is in the range 0–9, where 0 represents black). 2. Determine the number of columns in the grid and compute the middle column index as floor(n/2) using zero-based indexing (for example, if n = 3, the middle column is index 1). 3. Create an output grid of the same dimensions as the input grid. 4. For every cell in the input grid at row r and column c, if c equals the middle column index, copy the input value to the output grid at (r, c); otherwise, set the output grid cell at (r, c) to 0 (black). 5. Return the output grid as the final result.",
    "d2abd087.json": "1. For each cell in the input grid, if the cell’s value is 5, use 4‐directional (up, down, left, right) connectivity to identify its entire connected component (i.e. a shape made only of cells with value 5). 2. Count the number of cells in the connected component. 3. If the count is exactly 6, then change every cell in that component to 2 (red). 4. If the count is any number other than 6, then change every cell in that component to 1 (blue). 5. Leave all cells that do not have the value 5 unchanged. 6. Produce the output grid with the same dimensions as the input grid.",
    "d364b489.json": "1. Initialize an output grid with the same dimensions as the input grid and copy every cell from the input grid into the output grid. This preserves all cells that are not modified by later steps (in the examples the input cells are either 0 or 1).\n2. Iterate over every cell in the grid using its coordinates (r, c). For each cell that has the value 1 (representing a blue square):\n   a. If the cell to the left at (r, c-1) exists, set that cell in the output grid to 7 (orange).\n   b. If the cell above at (r-1, c) exists, set that cell in the output grid to 2 (red).\n   c. If the cell to the right at (r, c+1) exists, set that cell in the output grid to 6 (purple).\n   d. If the cell below at (r+1, c) exists, set that cell in the output grid to 8 (light blue).\n3. After processing all cells, return the output grid. This transformation creates, around every blue square (1), an orange (7) square immediately to its left, a red (2) square immediately above it, a purple (6) square immediately to its right, and a light blue (8) square immediately below it, while all other cells remain unchanged.",
    "d406998b.json": "1. Compute the width W of the input grid (the number of columns), indexing columns starting at 1. 2. For every cell at position (row, column):\n   a. If the cell’s value is 5 (representing gray) then:\n      i. If W is even and the column number is even, change the value from 5 to 3 (green).\n      ii. If W is odd and the column number is odd, change the value from 5 to 3 (green).\n   b. Otherwise, leave the cell unchanged. 3. Output the grid with the same dimensions as the input.",
    "d43fd935.json": "1. Copy the input grid to the output grid without change except where modifications are made.\n2. Locate the unique 2x2 block of cells whose value is 3 (this is the green square). Let its coordinates be defined by its top‐left cell (r, c) so that the block covers (r, c), (r, c+1), (r+1, c) and (r+1, c+1).\n3. For each corner of the 2x2 block, treat it as a connection point and perform two separate scans – one in the vertical direction and one in the horizontal direction – but only in the direction that goes outward from the block:\n   a. For a corner on the top edge (i.e. the two upper corners), scan upward; for a corner on the bottom edge (the two lower corners), scan downward.\n   b. For a corner on the left edge (the left corners), scan left; for a corner on the right edge (the right corners), scan right.\n4. For each scan (vertical or horizontal) from a corner:\n   a. Begin at the cell immediately adjacent to the corner in the chosen direction.\n   b. Move step by step in that same row (for horizontal scans) or column (for vertical scans), checking each cell.\n   c. Continue only if each encountered cell has value 0 (black). Stop when either you exit the grid or encounter a non‐zero cell that is not part of the green block (i.e. a cell whose value is not 0 and not 3).\n   d. If a non‐zero cell is encountered, then fill every cell that was traversed in this scan (all originally 0 cells) with the value of that encountered cell. (For example, if scanning right from a corner and the first nonzero cell encountered is 1, then replace all intervening 0’s with 1.)\n5. Do not alter any cells that are not originally 0 (other than leaving the green block cells, which remain 3) and do not fill if no colored cell is reached.\n6. Return the modified output grid.\n\nNote: All colors are represented by integers. Here 0 means black and 3 is green. Other colored cells (for example, 1, 2, 6, 7, 8, etc.) remain unchanged except where they supply their color value to fill in a drawn line.",
    "d4469b4b.json": "1. Examine the input grid and identify the unique nonzero digit present; it will be one of the following: 1, 2, or 3 (where 1 stands for blue, 2 for red, and 3 for green). 2. Create a new 3x3 output grid and fill every cell with 5 (representing light grey). 3. If the identified digit is 1 (blue), modify the output grid by setting the four corner cells to 0 (black). This means set cell (0,0), (0,2), (2,0), and (2,2) to 0, leaving the remaining cells as 5. 4. If the identified digit is 2 (red), modify the output grid by setting the leftmost and rightmost cells in the bottom two rows to 0 (black). In other words, keep the top row unchanged (all 5s) and set cells (1,0), (1,2), (2,0), and (2,2) to 0. 5. If the identified digit is 3 (green), modify the output grid by setting the top-left 2x2 block to 0 (black). That is, set cells (0,0), (0,1), (1,0), and (1,1) to 0 while keeping all other cells as 5. 6. Return the resulting 3x3 grid as the output.",
    "d4a91cb9.json": "1. Locate the two unique nonzero cells in the input grid: one cell having the value 8 (the cyan cell) and one cell having the value 2 (the red cell). Let their coordinates be (r_c, c_c) for the cell with 8 and (r_r, c_r) for the cell with 2.\n2. Determine the elbow (corner) of the L by using the row of the red cell and the column of the cyan cell. That is, set the corner coordinates to (r_r, c_c).\n3. Draw the vertical segment of the L: For every row index r between r_c and r_r (inclusive of both, regardless of which is higher), consider the cell at (r, c_c). If that cell is 0 (empty), change its value to 4 (yellow); however, if the cell already contains 8 (the cyan cell), leave it unchanged.\n4. Draw the horizontal segment of the L: For every column index c between c_c and c_r (inclusive of both), consider the cell at (r_r, c). If that cell is 0, change its value to 4 (yellow); if the cell already contains 2 (the red cell), leave it unchanged.\n5. Keep all other cells in the grid unchanged and output the resulting grid (which retains the same dimensions as the input).",
    "d4f3cd78.json": "1. Scan the entire grid and record every cell whose value is 5. Compute the minimum and maximum row indices (r_min and r_max) and column indices (c_min and c_max) among these cells; this bounding rectangle defines the intended square border (with 5 representing gray).\n2. For every cell (r, c) with r_min ≤ r ≤ r_max and c_min ≤ c ≤ c_max, if its value is not 5, set it to 8 (representing cyan/light blue). This step fills the interior of the square and corrects any missing border cell within the bounding box.\n3. Among all cells on the border of the bounding box (that is, cells where r = r_min or r = r_max or c = c_min or c = c_max), identify the unique cell that is not 5 (now 8) – call this the gap cell and denote its position as (r_gap, c_gap).\n4. Determine the extension direction based on the gap cell’s location: if r_gap equals r_min, the gap is on the top; if r_gap equals r_max, it is on the bottom; if c_gap equals c_min, it is on the left; if c_gap equals c_max, it is on the right.\n5. Extend a continuous line of 8 from the gap cell outward to the corresponding edge of the grid. Specifically, if the gap is on the top, set all cells in column c_gap from row 0 to r_gap − 1 to 8; if on the bottom, set all cells in column c_gap from row r_gap + 1 to the last row to 8; if on the left, set all cells in row r_gap from column 0 to c_gap − 1 to 8; if on the right, set all cells in row r_gap from column c_gap + 1 to the last column to 8.\n6. Leave all cells outside these modifications unchanged and output the resulting grid.",
    "d511f180.json": "1. For each cell in the input grid, identify its position by row and column coordinates.\n2. If a cell’s value is 5 (representing grey), change it to 8 (representing cyan/light blue).\n3. Otherwise, if the cell’s value is 8 (representing cyan/light blue), change it to 5 (representing grey).\n4. For any cell with a value other than 5 or 8, leave the value unchanged.\n5. Produce an output grid that has the same dimensions as the input grid, where every cell has been transformed according to the rules above.",
    "d5d6de2d.json": "1. Keep the output grid the same size as the input grid. Process the grid cell‐by‐cell to find all rectangular frames drawn in 2. For each frame, do the following:\n   a. Identify a contiguous rectangular region whose border cells are exactly 2. Let the top‐left corner of this region be (r1, c1) and the bottom–right corner be (r2, c2), where every cell in row r1 from c1 to c2 and in row r2 from c1 to c2 is 2, and every cell in column c1 (for rows r1 to r2) and column c2 (for rows r1 to r2) is 2.\n   b. If the dimensions of the rectangle are at least 3×3 (i.e. if r2 − r1 ≥ 2 and c2 − c1 ≥ 2), then the region inside the border (cells with row index between r1+1 and r2−1 and column index between c1+1 and c2−1) is considered the hole. Verify that all these interior cells are 0.\n   c. If the above conditions hold (or if the region is too small to have an interior), then replace every cell in the border (the outline of the rectangle that was 2) with 0. In addition, if an interior exists (i.e. the box is at least 3×3), fill every cell of the interior (currently 0) with 3.\n2. For any cell with value 2 that is not part of a valid rectangular frame as defined above, set it to 0.\n3. Leave all cells that are not 2 unchanged. \nThis transformation clears the drawn outlines (originally 2) by setting them to 0 and, when a valid box has an interior, fills that interior with 3. The numbers 0, 2, and 3 here correspond to black, red, and green respectively.",
    "d631b094.json": "1. Scan the input grid cell by cell and identify every cell whose value is not 0 (recall 0 represents black). 2. Verify that all nonzero cells have the same value; call this unique nonzero value N (for example, in the training examples N is 1, 2, 7, or 8). 3. Count the total number C of cells that contain N. 4. Create an output grid that has exactly 1 row and C columns. 5. Fill every cell in the output grid with the value N.",
    "d687bc17.json": "1. Let the output grid be a copy of the input grid with the same dimensions. Define the border as all cells in the first row, last row, first column, and last column; these cells remain unchanged. 2. Determine the four border colors by reading one cell from each side (for example, use the top row (row 1) for the top border color, the bottom row (row M) for the bottom border color, the left column (column 1) for the left border color, and the right column (column N) for the right border color). Note: colors are given by their numbers (for example, color 4, color 8, etc.). 3. For every interior cell (any cell at row r and column c with 2 ≤ r ≤ M-1 and 2 ≤ c ≤ N-1), do the following:  a. If the cell’s value equals one or more of the border colors, then move that cell so that it becomes adjacent to the matching border. This move is done without changing the coordinate in the direction perpendicular to that border. Specifically:   i. If the cell’s value equals the top border color, set its row to 2 (i.e. move it vertically so that it is immediately below row 1) while keeping its column unchanged.   ii. If the cell’s value equals the bottom border color, set its row to M-1 while keeping its column unchanged.   iii. If the cell’s value equals the left border color, set its column to 2 while keeping its row unchanged.   iv. If the cell’s value equals the right border color, set its column to N-1 while keeping its row unchanged. In each case, remove the original occurrence by setting that cell to 0. (If a cell’s value equals more than one border color, apply each rule independently, but note that in the provided examples each interior value matches exactly one border color.)  b. If the interior cell’s value does not equal any of the four border colors, set that cell to 0 (black). 4. After processing all interior cells, output the resulting grid. (The effect is that any interior number matching one of the border colors is relocated so that it touches its corresponding border without changing its column when moving vertically or its row when moving horizontally, and all other interior cells become 0.)",
    "d6ad076f.json": "1. Identify the two distinct nonzero regions in the input grid. For each region, compute its bounding box by determining the minimum row, maximum row, minimum column, and maximum column occupied by that region.\n2. Determine whether the regions are separated vertically or horizontally. If the vertical ranges do not overlap (i.e. one region’s maximum row is less than the other’s minimum row), then the regions are vertically separated; if the horizontal ranges do not overlap (i.e. one region’s maximum column is less than the other’s minimum column), then they are horizontally separated.\n3. If the regions are vertically separated:\n   a. Label the region with the smaller minimum row as the top region and the other as the bottom region.\n   b. Define the vertical connection area to span from (top_region.max_row + 1) to (bottom_region.min_row – 1) (inclusive).\n   c. Compute the horizontal overlap between the two regions as the interval from max(top_region.min_col, bottom_region.min_col) to min(top_region.max_col, bottom_region.max_col) (inclusive). Then trim this overlap by excluding its leftmost and rightmost columns (i.e. use from (overlap_min + 1) to (overlap_max – 1)).\n   d. The connecting rectangle is defined by the rows from step 3b and the columns from step 3c.\n4. If the regions are horizontally separated:\n   a. Label the region with the smaller minimum column as the left region and the other as the right region.\n   b. Define the horizontal connection area to span from (left_region.max_col + 1) to (right_region.min_col – 1) (inclusive).\n   c. Compute the vertical overlap between the two regions as the interval from max(left_region.min_row, right_region.min_row) to min(left_region.max_row, right_region.max_row) (inclusive). Then trim this overlap by excluding its topmost and bottommost rows (i.e. use from (overlap_min + 1) to (overlap_max – 1)).\n   d. The connecting rectangle is defined by the columns from step 4b and the rows from step 4c.\n5. Copy the input grid to the output grid without changing any cells except those in the connection region.\n6. For every cell in the computed connecting rectangle, set its value to 8 (which represents cyan/light blue according to the mapping). This new block will be one row or column smaller on each side than the overlapping portion of the smaller region.\n7. Return the modified grid (which is the same size as the input grid) as the output.",
    "d89b689b.json": "1. Locate the unique 2x2 subgrid in the input where all four cells have the same nonzero value. Let the top‐left cell of this block be at (r, c); this block is the one to replace (for example, in several cases the block has the value 8).\n2. Compute the center of this block as (r + 0.5, c + 0.5).\n3. Identify the four nonzero cells in the input that are not part of the 2x2 block. There will be exactly four such cells.\n4. For each nonzero cell at position (i, j) (outside the block), determine its quadrant relative to the block’s center: if i < r + 0.5 and j < c + 0.5 then the cell is top‐left; if i < r + 0.5 and j > c + 0.5 then top‐right; if i > r + 0.5 and j < c + 0.5 then bottom‐left; if i > r + 0.5 and j > c + 0.5 then bottom‐right.\n5. Create an output grid of the same size as the input, initializing all cells to 0.\n6. In the output grid, replace the identified 2x2 subgrid (at positions (r, c), (r, c+1), (r+1, c), and (r+1, c+1)) with the four extracted nonzero values placed by quadrant: assign the top‐left quadrant cell’s value to (r, c), the top‐right quadrant’s value to (r, c+1), the bottom‐left quadrant’s value to (r+1, c), and the bottom‐right quadrant’s value to (r+1, c+1).\n7. Leave all other cells as 0. This completes the transformation.",
    "d8c310e9.json": "1. Keep the grid dimensions unchanged (5 rows and 15 columns).\n2. For each row that is entirely 0 (the number 0), copy the row to the output without changes.\n3. For any row that contains one or more nonzero cells, first determine two indices: let f be the index (column number) of the first cell whose value is not 0 and let l be the index of the last cell whose value is not 0 in that row (all numbers are already given as digits, for example 1,2,3, etc.).\n4. Define the pattern segment as the contiguous subsequence from column f up to column l (inclusive) taken from the input row.\n5. In the output row, for all columns from 0 to l use the input’s values unchanged.\n6. For every column c where c > l, set the output cell at (row, c) to the element from the pattern segment at position ((c - l - 1) mod (l - f + 1)). (In other words, fill the remainder of the row by cyclically repeating the pattern segment.)\n7. Process each row independently.\nNOTE: All colors are already represented by numbers (for example, 0 for black, 1 for blue, 2 for red, 3 for green, etc.) so use these numeric values directly.",
    "d90796e8.json": "1. Create an output grid that is initially an exact copy of the input grid (same dimensions). 2. For each cell in the input grid that has the value 3 (which represents green), check its four direct neighbors (the cells immediately above, below, to the left, and to the right, if within bounds). If at least one neighbor has the value 2 (which represents red), then set the corresponding cell in the output grid to 8 (representing light blue/cyan). 3. For each cell in the input grid that has the value 2 (red), check its four direct neighbors (above, below, left, and right). If at least one neighbor has the value 3 (green), then set the corresponding cell in the output grid to 0 (black). 4. Leave all other cells unchanged. Note: All neighbor checks are performed on the original input grid so that the replacements do not cascade.",
    "d9f24cd1.json": "1. Begin by identifying each cell in the bottom row (the row with the highest index) that has the value 2 (red). Each of these will serve as the base of a red ray to extend upward. \n2. For each such red base, initialize a variable current_column to the column index of that base. Then, iterate from the bottom row upward (decreasing the row index) along that ray. Do not change any cells in the bottom row. \n3. For each row r (starting with the row immediately above the base) in the current ray:\n   a. If the cell in the input at (r, current_column) is not 5 (i.e. is not grey), then mark the output at (r, current_column) with 2 (red). (Do not alter any cell that already has a nonzero input value such as 5; however cells that are 0 may be overwritten with 2.)\n   b. If the cell in the input at (r, current_column) is 5 (grey), then the vertical red stroke is blocked at that row. In that case:\n      i. Leave the cell (r, current_column) unchanged (so the grey 5 remains).\n      ii. Change the direction of the ray by increasing current_column by 1 (i.e. shift one cell to the right).\n      iii. To create a smooth bend, also mark the cell immediately below r—that is, at (r+1, current_column) in the output—with 2 (red), even if that row was already filled by the continuing stroke in the old column. (This draws a horizontal connector.)\n      iv. Continue the upward extension from row r using the new current_column. \n4. Process every red base in this way independently. Then take the union of all the red strokes (value 2) with the original grid so that any cell that was originally 5 (grey) is preserved and not overwritten by red. \n5. The final output grid retains the same dimensions as the input grid and contains:\n   • Vertical red lines (value 2) starting at each red base in the bottom row that continue upward in the same column until a cell whose input value is 5 is encountered.\n   • At the first row encountered (while going upward) in which the input cell in the current column is 5, do not change that cell; instead, in the next row (one row below) add a red cell at the column immediately to the right (current_column+1) to serve as a horizontal connector, and then for all rows above use the shifted column. \n6. Thus, the red rays become straight vertical segments until they meet a grey obstacle (a cell with value 5 in the input), whereupon they bend by shifting one column to the right and continue vertically from that point. The final union of all these extensions is overlaid on the original grid without altering any cell that originally was 5.",
    "d9fac9be.json": "1. Iterate over every possible 3x3 subgrid in the input grid. A 3x3 subgrid is defined by its top‐left cell at (i, j) and includes all cells at positions (i, j) to (i+2, j+2).\n2. Within each 3x3 subgrid, define the center cell as the cell at (i+1, j+1) and the border cells as the eight cells at (i, j), (i, j+1), (i, j+2), (i+1, j), (i+1, j+2), (i+2, j), (i+2, j+1), and (i+2, j+2).\n3. Check if all eight border cells have the same integer value B and that the center cell has a value C different from B (i.e., C ≠ B). This identifies the special square with a distinct inner block.\n4. When such a 3x3 subgrid is found, produce an output grid of size 1×1 whose sole cell is set to the value C.\n5. Terminate the process, as exactly one such square is assumed to exist in the input.",
    "dae9d2b5.json": "1. Read the input as a grid of 3 rows and 6 columns containing only the integers 0, 3, and 4 (where 0 represents black, 4 represents yellow, and 3 represents green).\n2. Divide the input grid vertically into two equal halves: the left half consists of the first 3 columns (columns 0 to 2) and the right half consists of the last 3 columns (columns 3 to 5).\n3. Create a new output grid of size 3×3. For each cell in the output grid at row r and column c (with r and c from 0 to 2), identify the corresponding cells in the input: the left cell at (r, c) and the right cell at (r, c+3).\n4. Overlay the two halves as follows: if the right cell is nonzero (i.e. it is 3, the green pattern), then that output cell is considered colored; otherwise, if the right cell is zero but the left cell is nonzero (i.e. 4, the yellow pattern), then that output cell is considered colored. If both corresponding cells are 0, the output cell stays 0.\n5. Finally, regardless of whether the original colored cell came from the left (yellow, 4) or the right (green, 3), recolor every colored cell to pink by setting its value to 6. Cells that remained 0 stay unchanged.\n6. Return the resulting 3×3 grid containing only the values 6 (for colored, now pink) and 0 (for black).",
    "db3e9e38.json": "1. Copy the entire input grid to the output grid without change.\n2. Locate the anchor vertical segment by finding the first row (assume row 0) that contains a nonzero cell and let c be the column index where the value 7 appears (the value 7 represents the original color). Then, starting from that row, count how many consecutive rows have a 7 in column c; call this count n.\n3. For each row r in the vertical segment (with r from 0 to n–1, where r=0 is the top row of the segment), compute d = (n – 1) – r. This d determines how far left and right the overlay extends from column c.\n4. For each such row r, set the horizontal overlay boundaries as follows: L = max(0, c – d) and R = min((grid width – 1), c + d). These boundaries define the interval [L, R] on row r where the pattern will be drawn.\n5. For every column j in the interval [L, R] on row r, overwrite the cell with an alternating pattern defined relative to the anchor column c. Specifically, if the absolute difference |j – c| is even, set the cell’s value to 7; if it is odd, set it to 8. This ensures that the cell at column c remains 7 and the overlay alternates between 7 and 8 (with 7 representing orange and 8 representing light blue) from the center outward.\n6. Leave all cells in rows outside the vertical segment unchanged, and keep any parts of rows that lie outside the computed interval intact.\n7. Return the modified grid as the final output.",
    "db93a21d.json": "1. For each contiguous group of cells with value 9 (red) in the input grid, treat it as a separate object. Determine its bounding box by finding the minimum and maximum row and column indices that contain a 9. \n2. Let the width of the object be (right - left + 1) and define the border thickness T as the integer division of the width by 2 (e.g. a width of 2 gives T = 1, a width of 4 gives T = 2, a width of 6 gives T = 3). (Note: 9 represents red.)\n3. Compute the extended (border) bounding box by expanding the object’s bounding box by T in every direction. That is, use top = max(0, top - T), bottom = min(grid_height - 1, bottom + T), left = max(0, left - T) and right = min(grid_width - 1, right + T).\n4. In the extended bounding box, for every cell that is not part of the original red object (i.e. not one of the input cells with value 9 in that object’s region), set the cell’s value to 3 (green). Do not change the cells that were originally 9.\n5. Next, using the original red object’s horizontal span (columns from left to right as determined in step 1), fill in a vertical blue (1) column below the drawn object. For every cell in those columns and in every row starting at one row below the bottom of the extended bounding box (i.e. row = bottom + 1 of the extended box) down to the last row of the grid, if the cell is currently 0 (black) then set it to 1 (blue). Do not overwrite any cell that is not 0 (for example, if a cell already has a green border, leave it as 3).\n6. Leave all other cells unchanged; the grid size remains the same. This produces an output in which each red (9) object is surrounded by a green (3) border of thickness T and its original horizontal (red) span has a vertical blue (1) fill in all black (0) cells below the bordered object.",
    "dbc1a6ce.json": "1. Treat the grid as a two‐dimensional array where cells with value 1 are the endpoints (representing the original dark blue squares) and all other cells (typically 0) are background. The goal is to connect these 1’s with a straight-line (horizontal or vertical) segment drawn in value 8 (representing light blue).\n2. For each row (with index i):\n   a. Identify every column index j such that the cell at (i, j) is 1.\n   b. If there are two or more such indices, let min_j be the smallest and max_j the largest column index. Then, for every column index j where min_j < j < max_j, set the cell at (i, j) to 8. (This draws a horizontal line connecting the leftmost and rightmost 1’s in that row without changing the endpoints.)\n3. For each column (with index j):\n   a. Identify every row index i such that the cell at (i, j) is 1.\n   b. If there are two or more such indices, let min_i be the smallest and max_i the largest row index. Then, for every row index i where min_i < i < max_i, set the cell at (i, j) to 8. (This draws a vertical line connecting the topmost and bottommost 1’s in that column without altering the original 1’s.)\n4. Do not overwrite any cell that is originally 1; only fill cells that were not endpoints with 8. The grid’s dimensions remain unchanged, and only horizontal or vertical connectors (never diagonal) are drawn between cells with value 1.",
    "dc0a314f.json": "1. Locate the unique 5x5 square in the input that is completely filled with the integer 3 (this represents the masked or \"green\" square, since green maps to 3). Determine its top‐left coordinate; call this (r, c) using 1-indexed row and column positions. (In all examples the input grid is 16x16 and the masked square is 5x5.)\n2. Let M and N be the number of rows and columns in the input grid (M = 16, N = 16). For each cell in the masked square at offset (i, j) (where i and j range from 0 to 4), compute the mirror cell’s coordinates by performing a 180° rotation of the grid. That is, set mirror_row = M - (r + i) + 1 and mirror_col = N - (c + j) + 1.\n3. Construct a new 5x5 output grid by replacing each cell (i, j) of the masked square with the value from the input grid at the computed mirror coordinates (mirror_row, mirror_col).\n4. Return this new 5x5 grid as the final output.",
    "dc1df850.json": "1. Begin by copying the input grid to an output grid so that the size and any nonred values remain unchanged. 2. For each cell in the input grid that has the value 2 (red), iterate over all eight adjacent positions (using row offsets of -1, 0, and +1 and column offsets of -1, 0, and +1, excluding the (0,0) offset) and check if the neighbor is within the grid boundaries. 3. For each valid neighbor that is not a red cell (i.e. its value is not 2), set that cell in the output grid to 1 (blue). 4. Leave all cells that are not adjacent to a red cell unchanged. This procedure draws a blue (1) border of one cell width around every red (2) cell, correctly handling cases near the edges of the grid.",
    "dc433765.json": "1. Identify the two special cells in the grid: the cell with value 3 (representing green) and the cell with value 4 (representing yellow).\n2. Record the coordinates of the green cell as (r_g, c_g) and the yellow cell as (r_y, c_y). Coordinates use the row and column indices starting from the top‐left corner.\n3. Compute the movement for the green cell by calculating the difference in each coordinate: let Δr = r_y - r_g and Δc = c_y - c_g. Determine the step for each coordinate by taking the sign of the difference: if Δr > 0 set step_row = 1, if Δr < 0 set step_row = -1, and if Δr = 0 set step_row = 0; similarly, if Δc > 0 set step_col = 1, if Δc < 0 set step_col = -1, and if Δc = 0 set step_col = 0.\n4. Compute the new position for the green square as (r_g + step_row, c_g + step_col), which moves the green square one cell closer to the yellow square in both dimensions as applicable.\n5. In the output grid, set the original cell at (r_g, c_g) to 0, place the value 3 into the new position, and leave the cell with value 4 and all other cells unchanged. The grid dimensions remain the same.",
    "ddf7fa4f.json": "1. Do not change the grid dimensions; all cells other than those having the value 5 remain exactly as in the input. 2. Note that the top row (row 0) contains the seed colored values. In every column of row 0, a nonzero value (typically not 5) is treated as a candidate color. For example, if row 0 has the values [a, b, c, …] then any nonzero a, b, c, etc. will be used to fill a gray region. 3. Identify every connected component of cells in the grid that have the value 5. Use 4‐direction (up, down, left, right) connectivity to group these cells. 4. For each connected component found in step 3, determine its horizontal extent by finding the minimum and maximum column indices occupied by the component. 5. Look at the cells in row 0 whose column indices fall within that horizontal span. Select the nonzero candidate(s) from these cells. If there is more than one candidate, compute the horizontal center of the component (the average of its minimum and maximum column indices) and choose the candidate whose column is closest to that center. (In all provided examples the horizontal span contains exactly one nonzero candidate.) 6. Replace every cell in the connected component (originally valued 5) with the candidate’s value obtained in step 5. 7. Output the resulting grid.",
    "de1cd16c.json": "1. Determine the total number of rows in the input grid. \n2. Starting at the top (row 0), examine each row in order to see if it is uniform (that is, all cells in the row contain the same digit). \n3. If you find a row where every cell is identical, label that row as the start of the background and define the object region as all the rows above this uniform row (do not include the uniform row or any rows below it). \n4. If no row is completely uniform, split the grid horizontally into two parts by row. In this case, let the top part be the first ⌊R/2⌋ rows and the bottom part be the remaining rows; then select the part that has more rows (if the two parts are equal in number, choose the bottom part). This selected part is the object region. \n5. In the object region, count the occurrences of each digit (digits 0 through 9). \n6. Identify the digit that appears most frequently (the majority digit) in the object region. \n7. Produce a new output grid of size 1×1 whose single cell contains that majority digit.",
    "ded97339.json": "1. Scan the input grid and treat every cell with the number 8 as a seed (this represents the magenta boxes) and all other cells (with value 0) as background.\n2. For each row in the grid, collect all column indices where the cell value is 8. If a row has two or more 8’s, let min_c be the smallest column index and max_c be the largest. Then, set every cell in that row from column min_c to column max_c (inclusive) to 8 in the output. This step connects seed cells that lie in the same row by drawing a horizontal line between the leftmost and rightmost seeds.\n3. For each column in the grid, collect all row indices where the cell value is 8. If a column has two or more 8’s, let min_r be the smallest row index and max_r be the largest. Then, set every cell in that column from row min_r to row max_r (inclusive) to 8 in the output. This step connects seed cells that lie in the same column by drawing a vertical line between the topmost and bottommost seeds.\n4. Any cell that is set to 8 by either the horizontal or vertical connection should remain 8 in the output; cells not changed by these rules remain 0.\n5. The output grid must have the same dimensions as the input grid.",
    "e179c5f4.json": "1. Determine the grid dimensions. Let R be the total number of rows and C be the total number of columns. Use 1-indexed coordinates where row 1 is the top and row R is the bottom, and columns 1 through C run from left to right.\n2. Identify the starting pixel by scanning the input grid for the only nonzero cell (value 1). This pixel is always found in the bottom row (row R). Let current_column be the column index of this pixel (in the provided examples it is 1).\n3. Initialize a horizontal direction variable Δ to +1 (which means a move to the right).\n4. Create an output grid of the same dimensions and fill every cell with 8 (where 8 represents light blue).\n5. For each row from the bottom (r = R) up to the top (r = 1), do the following:\n   a. Set the cell at (r, current_column) to 1 (where 1 represents dark blue). This marks one position of the zigzag path.\n   b. If r is not 1 (i.e. if there is a row above), compute candidate_column = current_column + Δ.\n   c. If candidate_column is less than 1 or greater than C (i.e. it falls outside the grid), reverse the horizontal direction by setting Δ = -Δ and then update candidate_column = current_column + Δ.\n   d. Update current_column to candidate_column for processing the next (upper) row.\n6. The resulting grid will display a continuous zigzag diagonal of 1’s (dark blue) starting from the input’s colored pixel in the bottom row, with all other cells filled with 8 (light blue). Output this grid.",
    "e21d9049.json": "1. Identify the two strokes in the input grid. First, scan each row to find a row r_h that contains a contiguous block of nonzero cells (values other than 0); call this the horizontal stroke. Then, scan each column to find a column c_v that contains a contiguous vertical block of nonzero cells; call this the vertical stroke. (These nonzero values are taken from the input and represent colored cells using numbers such than, for example, 2 for red, 3 for green, 4 for yellow, 8 for cyan, etc.)\n2. In row r_h, locate the contiguous block of nonzero cells and record, in order from left to right, the list H of values. This list is the horizontal pattern that will be repeated across the entire row.\n3. In column c_v, locate the contiguous block of nonzero cells (reading from top to bottom) and record the list V of values. This list is the vertical pattern that will be repeated along that column.\n4. Let the intersection cell be at (r_h, c_v) in the input grid and denote its value by X (X ≠ 0). This cell belongs to both the horizontal and vertical strokes and will anchor the alignment of the two repeated patterns.\n5. Choose a horizontal offset o_h (an integer between 0 and |H|−1) so that when you extend the horizontal pattern, the value at column c_v is X. In other words, o_h is the smallest integer such that H[((c_v) + o_h) mod |H|] == X.\n6. Choose a vertical offset o_v (an integer between 0 and |V|−1) so that when extending the vertical pattern, the value at row r_h is X; that is, o_v is the smallest integer such that V[((r_h) + o_v) mod |V|] == X.\n7. Construct the output grid with the same dimensions as the input. For every cell that is not in row r_h or column c_v, copy the input value (which is 0 if it is the background).\n8. For every column index c in row r_h, set the cell’s value to H[((c) + o_h) mod |H|]. This extends the horizontal stroke across the entire row by repeating the pattern H.\n9. For every row index r in column c_v, set the cell’s value to V[((r) + o_v) mod |V|]. This extends the vertical stroke along the entire column by repeating the pattern V.\n10. At the intersection (r_h, c_v) the two assignments will yield the same value X by construction. Return the output grid.",
    "e26a3af2.json": "1. Interpret the input as a grid of numbers (each between 0 and 9) where each cell is addressed by its row R and column C. \n2. For every row, determine its dominant value (the mode, i.e. the number that occurs most frequently in that row). Also, compute the row consistency ratio = (frequency of the mode) / (total number of columns). This ratio shows how uniform the row is. \n3. For every column, determine its dominant value (the mode, i.e. the number that occurs most frequently in that column). Also, compute the column consistency ratio = (frequency of the mode) / (total number of rows). This ratio shows how uniform the column is. \n4. Compute the average consistency ratio for rows (by averaging all row ratios) and for columns (by averaging all column ratios). \n5. Decide the bar orientation based on these averages: if the average row consistency is greater than or equal to the average column consistency, conclude that the grid’s intended pattern is made of horizontal bars; otherwise, conclude it is made of vertical bars. \n6. If the bars are horizontal, then for each row R, replace every cell at (R, C) (for all columns C) with the row’s dominant value. This fills the entire row with one number. \n7. If the bars are vertical, then for each column C, replace every cell at (R, C) (for all rows R) with the column’s dominant value. This fills the entire column with one number. \n8. Return the resulting grid, keeping the same dimensions as the input. \nThis algorithm removes any scattered outlier numbers (the random squares) by filling each bar—whether a horizontal stripe or a vertical band—with its dominant number, thereby ensuring that every cell in that bar matches the intended pattern.",
    "e3497940.json": "1. Let R be the number of rows and C be the number of columns in the input grid. 2. Note that the grid always has a vertical divider column filled with 5 (gray) located exactly at column L where L = (C - 1) / 2. This divider splits the grid into a left section (columns 0 to L-1) and a right section (columns L+1 to C-1) of equal width. 3. Create an output grid with R rows and L columns (the size of one of the halves). 4. For each row r from 0 to R-1 and for each column c from 0 to L-1 in the left section, determine the corresponding column in the right section as rci = C - 1 - c. 5. Let left_value = input[r][c] and right_value = input[r][rci]. 6. If right_value is not 0, set output[r][c] = right_value; otherwise, set output[r][c] = left_value. 7. Return the output grid.",
    "e40b9e2f.json": "1. Find the minimal bounding box of all nonzero cells in the input grid. Let r_min, r_max be the minimum and maximum row indices and c_min, c_max be the minimum and maximum column indices where a cell has a nonzero value (values 1–9). \n2. Compute the center of this bounding box as (r_center, c_center) where r_center = (r_min + r_max) / 2 and c_center = (c_min + c_max) / 2. Note that r_center and c_center may be whole numbers or end in .5. This center will be used as the axis of rotation. \n3. For every cell in the input grid that has a nonzero value v, with coordinates (r, c), compute four positions by rotating (r, c) about (r_center, c_center) by 0°, 90°, 180° and 270° clockwise. Use these formulas (with dr = r - r_center and dc = c - c_center):\n a. 0° (no rotation): (r, c)               \n b. 90° clockwise: (r_new, c_new) = (r_center + dc, c_center - dr)\n c. 180° clockwise: (r_new, c_new) = (r_center - dr, c_center - dc)\n d. 270° clockwise: (r_new, c_new) = (r_center - dc, c_center + dr)\n4. For each of the four computed positions, if the position lies within the grid boundaries, set that cell in the output grid to the value v (nonzero). (When positions overlap, later placements may overwrite but the overall effect is the overlay of all four rotated copies.) \n5. Return the output grid of the same size as the input.",
    "e48d4e1a.json": "1. Read the input grid and note that the background is 0 and the special grey cells are marked with 5. These 5s are not drawn in the output but their total count determines the shift value, n.\n2. Count all cells in the input grid equal to 5; let n be this count.\n3. Identify the cross’s drawing color, L. To do this, scan the rows to find the one that is completely filled (ignoring any cells that might be 5) with the same nonzero digit (L). This row is the horizontal line; record its row index as H_orig.\n4. Identify the vertical line by scanning the columns (ignoring any grey cells with value 5). Find the column in which every cell (except in the horizontal line row) equals L; record its column index as V_orig.\n5. Compute the new positions for the cross. Set the new horizontal line row to H_new = H_orig + n and the new vertical line column to V_new = V_orig − n.\n6. Create a new grid of the same dimensions with every cell set to 0.\n7. Draw the vertical line: For every row in the output grid, set the cell at column V_new to L.\n8. Draw the horizontal line: Replace every cell in row H_new with L. (In the cell where the two lines cross the color L is used.)\n9. Output the resulting grid. (Note: All numbers are digits; here 0 represents black (background), 5 represents grey (used only to compute the shift), and L is the line color taken from the input, for example 2, 3, 4, 6, or 8.)",
    "e5062a87.json": "1. Copy the input grid to the output grid (all cell values remain the same initially).\n2. In the input grid, locate every cell with value 2 (red). Compute the smallest axis‐aligned bounding box that contains all these cells. Let the top‐left corner of this box be (R0, C0), and let its height be H and its width be W.\n3. Define the seed pattern as the set of relative offsets {(r, c) | for each cell at (r, c) within the bounding box, if the cell at (r, c) (that is, at (R0+r, C0+c) in the input) is 2, then include the offset (r, c)}.\n4. For every position (i, j) in the grid such that the entire H×W box fits inside the grid (i.e. i+H <= number of rows and j+W <= number of columns), do the following:\n a. For each offset (dr, dc) in the seed pattern, check the cell at (i+dr, j+dc) in the input grid. If every one of these cells has value 0 (black), then proceed; otherwise, do nothing for this placement.\n b. For each offset (dr, dc) in the seed pattern that passed the check, set the cell at (i+dr, j+dc) in the output grid to 2 (red).\n5. Leave all other cells in the output grid unchanged. Return the output grid as the final result.",
    "e509e548.json": "1. Interpret the input grid as having designs drawn in value 3 (all other cells are background and remain 0). 2. Identify every connected component of cells whose value is 3 using 4‐neighbor (up, down, left, right) connectivity; each such component is one design. 3. For each design, determine its external outline by finding the boundary cells (those adjacent to at least one 0). Then trace the outline in order (using only moves up, down, left, or right) and record the sequence of moves. 4. Count the number of 90° turns along this boundary trace. (A turn is any change from a horizontal move to a vertical move or vice versa.) 5. Based on the count of 90° turns, classify the design and recolor it uniformly as follows:\n   • If the design’s outline has exactly 1 turn, consider it an “L‐shaped” design and fill every cell in the component with 1 (blue).\n   • If the design’s outline has exactly 2 turns, consider it a “C‐shaped” design and fill every cell in the component with 6 (pink).\n   • If the design’s outline has exactly 3 turns, consider it a “1‐shaped” design and fill every cell in the component with 2 (red).\n6. Leave all cells that were not part of any design (i.e. not 3 in the input) unchanged. 7. Output the resulting grid (which has the same dimensions as the input) with each design’s cells replaced by its new color value.",
    "e50d258f.json": "1. Treat the background as any cell with the value 0. All cells with a nonzero value (i.e., values 1–9) are considered part of a shape. \n2. Scan every cell in the input grid by its row and column indices. For each cell that is not 0 and has not yet been visited, perform a 4‐connected flood fill (check the neighbors above, below, left, and right) to collect all connected nonzero cells; call this collection a region. \n3. For each region, determine its bounding box by finding the minimum row (r_min), maximum row (r_max), minimum column (c_min), and maximum column (c_max) among the cells in that region. \n4. Within each region, count the number of red cells. (Red is represented by the integer 2.) Inspect every cell that was reached in the flood fill and increase the count when the cell’s value equals 2. \n5. Identify the region that has the highest red-cell count. (In the event of a tie, choose one deterministically.) \n6. Extract the subgrid defined by the bounding box of the selected region – that is, copy every cell from row r_min to r_max and column c_min to c_max exactly as it appears in the input. \n7. Output this extracted subgrid as the final grid.",
    "e6721834.json": "1. Determine the orientation of the two sections in the input grid. If the grid’s dimensions have one dimension exactly twice as large as the other (for example, twice the number of rows or twice the number of columns), then split the grid evenly. In a horizontal split, let the top half be one section and the bottom half the other; in a vertical split, let the left half be one section and the right half the other.\\n2. Identify the base section as the one whose overall color (the background value that appears in almost every cell) matches the output grid background in the training examples. (For instance, in Example 1 the lower section is the base because its uniform value is 0; in Examples 2 and 3 the section with the individual squares is the base.) Let this uniform number be baseBG.\\n3. Identify the overlay section as the other section and determine its background value (the number that appears in almost every cell of that section); call it overlayBG.\\n4. Trim or extract the base section so that its dimensions (rows and columns) define the output grid. Also extract from the overlay section the corresponding subgrid of the same dimensions (aligning the top‐left corners of each section when split).\\n5. Initialize the output grid as a copy of the base section (so every cell initially equals baseBG or an individual square in that section).\\n6. For each cell with coordinates (r, c) in the output grid, look at the corresponding cell in the overlay subgrid. If the overlay cell’s value is not equal to overlayBG, then replace the output cell (r, c) with that overlay value. Otherwise, leave the output cell unchanged.\\n7. Return the output grid.  (Note: All color values are represented by integers; for example, a cell with value 1 means color 1, and so on.)",
    "e73095fd.json": "1. Let the grid be unchanged except that we will replace, with 4 (yellow), every node region in the network. In the grid, 0 represents the black background and 5 represents the grey lines that form a network whose nodes are left as gaps. \n2. For each cell in the grid that is 0 (a candidate for a node), check for nearby grey borders as follows (using grid coordinates with row r and column c):\n   a. Determine if a horizontal border is present. A cell qualifies horizontally if at least one of the following holds:\n      • If c-1 exists and grid[r][c-1] is 5, or if c+1 exists and grid[r][c+1] is 5.\n      • If an immediate neighbor is not 5, then if c-2 exists, grid[r][c-2] is 5 and the intervening cell grid[r][c-1] is 0, or if c+2 exists, grid[r][c+2] is 5 and grid[r][c+1] is 0. (This covers cases where two grey strokes run with a one‐cell gap between them.)\n   b. Determine if a vertical border is present. A cell qualifies vertically if at least one of the following holds:\n      • If r-1 exists and grid[r-1][c] is 5, or if r+1 exists and grid[r+1][c] is 5.\n      • If an immediate vertical neighbor is not 5, then if r-2 exists, grid[r-2][c] is 5 and grid[r-1][c] is 0, or if r+2 exists, grid[r+2][c] is 5 and grid[r+1][c] is 0.\n   c. If both a horizontal border and a vertical border are found for the cell (treating grid edges as valid if the only available neighbor in that direction is 5), mark the cell as a candidate node pixel.\n3. Group the candidate node pixels into connected regions using 8‐connectivity. (A node may span more than one cell.)\n4. For each connected candidate region (node), set every cell in that region in the output grid to 4 (yellow).\n5. Leave all other cells (including all cells that are originally 5, the grey lines) unchanged. \n6. Return the modified grid (which has the same dimensions as the input) as the output.",
    "e76a88a6.json": "1. Determine the template pattern:\n   a. Find the single contiguous (4‐connected) region in the grid whose cells are nonzero and are not 5. (In every example, the colored shape that is not gray is unique; here the gray value is 5.)\n   b. Compute its bounding box (minimum and maximum row and column indices of these cells). Extract the template matrix T from this bounding box, keeping the same relative arrangement of numbers (for example, in one case T = [[2,2,2],[2,4,4],[4,4,4]]; in another, T = [[6,6,6,6],[8,8,6,8],[6,8,8,8]]; in the test, T = [[4,4,4],[1,4,4],[1,4,1],[1,1,1]]).\n\n2. Replace every gray region with the template pattern:\n   a. For every contiguous (4‐connected) region of cells that have the value 5, compute its bounding box. (Each such region will be exactly rectangular and its dimensions will match those of T.)\n   b. Let the bounding box of a gray region have top‐left corner at (r, c) and the same size as T (h rows by w columns). For every position (i, j) with 0 ≤ i < h and 0 ≤ j < w, set the cell at (r + i, c + j) to T[i][j].\n\n3. Leave all other cells (those with 0 or with values other than 5 that are not part of the gray regions) unchanged.\n\n4. Return the modified grid, which has the same overall size as the input.",
    "e8593010.json": "1. Retain the grid dimensions and leave every cell that is not 0 unchanged (e.g. the background cells, which are 5).\n2. For every cell with the value 0 (representing black), use orthogonal connectivity (up, down, left, right) to group it with adjacent 0 cells into connected components.\n3. For each connected group of 0s, count the number of cells in the group.\n4. If a connected group has exactly 1 cell, change that cell’s value to 3 (green).\n5. If a connected group has exactly 2 cells, change all cells in that group to 2 (red).\n6. If a connected group has exactly 3 cells, change all cells in that group to 1 (blue).\n7. Produce the output grid; all cells originally not 0 remain unchanged.",
    "e8dc4411.json": "1. Determine the background value B by noting that almost every cell of the grid has the same number (for example, 8 in Example 1, 1 in Example 2, 4 in Example 3). 2. Define the pattern P as all cells whose value is 0 (the “black” cells) and note that these cells form a contiguous cluster. 3. Compute the minimal bounding rectangle of P; that is, let top, bottom, left, and right be the minimum and maximum row and column indices (using 1‐indexed coordinates) of any cell in P. 4. Compute the (integer) center of this bounding box as (center_row, center_col) = ((top + bottom) // 2, (left + right) // 2). 5. Find the unique cell that is not B and not 0 and that touches P (i.e. is adjacent in at least one of the 8 directions); denote its value by X (for example, X = 2 in Example 1, X = 3 in Example 2, X = 8 in Example 3) and its coordinates by (pivot_row, pivot_col). 6. Define the replication (unit) vector D = (dr, dc) by setting dr = 1 if pivot_row > center_row, dr = −1 if pivot_row < center_row, and dc = 1 if pivot_col > center_col, dc = −1 if pivot_col < center_col. (In the examples D comes out as (1,1) in Example 1, (1,−1) in Example 2, and (−1,1) in Example 3.) 7. For each cell (r,c) in P (that is, every cell whose value is 0), generate a sequence of candidate replication positions by repeatedly adding D. In other words, for each positive integer k, compute (r + k·dr, c + k·dc) provided that this position lies within the grid and does not fall back into P; if it does, then treat that candidate as eligible to be “copied.” For every such candidate position that currently has the background value B, set its value to X (thus “replicating” the pattern in the new color). 8. After all such positions are marked, process each row of the grid that lies in the replication zone (that is, outside the original bounding box of P). In any such row, if two or more cells have been set to X and if two adjacent (in that row) painted positions differ by exactly 2 in their column indices (meaning there is one background cell between them), then also fill that gap by setting the intervening cell to X. (Note that in some examples this bridging happens on some rows but not others; the rule is applied per row based on the union of replication candidates.) 9. Leave all cells that are not in P or not modified by these replications unchanged. The output grid is the same size as the input.",
    "e9614598.json": "1. Copy the input grid to create the output grid, keeping the grid dimensions unchanged.\n2. Locate the two cells with value 1 (blue). Let their coordinates be (r1, c1) and (r2, c2).\n3. Compute the midpoint coordinates as: mid_row = (r1 + r2) // 2 and mid_col = (c1 + c2) // 2. This position will be exactly between the two blue cells since they lie either in the same row or the same column.\n4. In the output grid, set the cell at (mid_row, mid_col) to 3 (green).\n5. Also set the adjacent cells in the four cardinal directions to 3: the cell above at (mid_row - 1, mid_col), the cell below at (mid_row + 1, mid_col), the cell to the left at (mid_row, mid_col - 1), and the cell to the right at (mid_row, mid_col + 1).\n6. Leave all other cells unchanged so that the two blue cells remain at value 1 and the background remains as is (typically 0 for black).\n7. Return the modified grid as the output.",
    "e98196ab.json": "1. Recognize that the input grid is 11 rows by 11 columns and that row 5 (using 0-indexing) is a solid row in which every cell is 5. This row separates the grid into two blocks: a top block (rows 0 to 4) and a bottom block (rows 6 to 10).\n2. Prepare to create an output grid with 5 rows and 11 columns by pairing the corresponding rows from the top and bottom blocks. For each index i from 0 to 4, let the top row be row i and the bottom row be row (i + 6) from the input.\n3. For each output row i and for each column j (from 0 to 10), perform the following: if the cell in the bottom block at (i + 6, j) is not 0, then set the output cell at (i, j) to that nonzero value; otherwise, set the output cell at (i, j) to the value from the top block at (i, j). This overlays the bottom block on the top block, with nonzero cells in the bottom block replacing those in the top block.\n4. Assemble all 5 processed rows to form the final 5x11 output grid.",
    "e9afcf9a.json": "1. Read the input grid, which is guaranteed to have exactly 2 rows and N columns.\\n2. Define value1 as the integer at cell (0,0) of the grid (the first row’s uniform value) and value2 as the integer at cell (1,0) (the second row’s uniform value).\\n3. Create an output grid with the same dimensions as the input grid.\\n4. For every cell at row r and column c (using 0-indexing):\\n   a. If r = 0 (first row), assign value1 if c is even and value2 if c is odd.\\n   b. If r = 1 (second row), assign value2 if c is even and value1 if c is odd.\\n5. Output the resulting grid, which now has an alternating (checkerboard-like) pattern of value1 and value2, with each row beginning with its corresponding input value.",
    "ea32f347.json": "1. Copy the input grid as the starting output grid.\n2. Find all connected groups of cells whose value is 5. To do this, use 4-directional (up, down, left, right) connectivity to group together adjacent cells with the value 5.\n3. For each connected group, count the number of cells to determine its size.\n4. Identify the three groups by size: the group with the largest count is the longest line, the one with the smallest count is the shortest line, and the remaining group is the middle-length line. (Assume there are exactly three groups.)\n5. In the output grid, change every cell in the largest group (longest line) from 5 to 1 (blue).\n6. Change every cell in the smallest group (shortest line) from 5 to 2 (red).\n7. Change every cell in the remaining (middle-length) group from 5 to 4 (yellow).\n8. Leave all other cells (those not equal to 5 in the input) unchanged.",
    "ea786f4a.json": "1. Let the input be an n×n grid with n odd. The grid is uniformly filled with a dominant number D (for example, D might be 1, 2, 3, or 6) except for the center cell at (n//2, n//2) which has the value 0. 2. Determine D by reading any non‐center cell (for instance, the top-left cell at (0, 0)). 3. For every cell in the grid with coordinates (r, c) (where r and c range from 0 to n-1), check if it lies on one of the two diagonals by testing whether r = c (the main diagonal) or r + c = n - 1 (the anti-diagonal). 4. If a cell satisfies either condition, set its value to 0; otherwise, set its value to D. 5. Return the grid with its original dimensions, now displaying an “X” pattern of 0’s on a background of D.",
    "eb281b96.json": "1. Read the input grid and let R be its number of rows (the number of columns will remain unchanged). 2. Depending on R, extract the key rows as follows:\n   • If R is exactly 3, let A be the first row, M be the second row, and C be the third row.\n   • If R is greater than 3, note that in the provided examples all the rows between the top and bottom are identical; in that case, let A be the first row, M be the second row (which represents the middle pattern), and E be the last row.\n3. Decide the output grid’s height as follows:\n   • For an input of 3 rows, set the output height to 9.\n   • For an input of more than 3 rows (for example, when R is 4 or 5), set the output height to 19.\n4. Build the output grid by constructing a vertically symmetric (bouncing) pattern that uses only the extracted rows and does not alter the columns. In other words, each output row is a copy of one of the extracted rows. The patterns are defined exactly by the examples:\n   • When R = 3, output the rows in the fixed order:\n     A, M, C, M, A, M, C, M, A\n     (This means the top row is repeated as the first and last row, with the pattern A, M, C then back M, A, etc.)\n   • When R > 3, output the rows in the fixed order:\n     A, M, M, E, M, M, A, M, M, E, M, M, A, M, M, E, M, M, A\n     (Here the output always begins and ends with A; the middle filler row M is repeated in groups of two except where the bottom row E appears; this arrangement yields a 19‐row output that is vertically symmetric—the fourth, tenth, and sixteenth rows are the copies of the bottom row E and the overall sequence mirrors about the center.)\n5. For each output row, copy the entire row exactly from the corresponding extracted row (A, M, C, or E) so that the horizontal (column) structure is preserved.\n6. Return the constructed grid as the output.",
    "eb5a1d5d.json": "1. Interpret the input as a 2D grid of integers. Repeatedly extract concentric layers from the input by doing the following until no cells remain: \n   a. Identify the current grid’s outer border (i.e., the first row, last row, first column, and last column). This border is guaranteed to be uniform and its value becomes one layer. For example, in one case the outer border is all 8s.\n   b. Record the integer of that uniform border (the outermost layer is recorded first). \n   c. Remove the outer border from the grid (delete the first and last rows and the first and last columns) to expose the next inner layer.\n2. Let the number of layers extracted be n. Compute the output grid size as (2 * n - 1). (For instance, if n = 3 the output grid will be 5×5.)\n3. Create a new output grid with the computed size. For every cell in the output grid (using 0-indexed coordinates (r, c)), determine its layer index i by computing i = min(r, c, (size - 1 - r), (size - 1 - c)). This index i (with 0 ≤ i < n) indicates that the cell belongs to layer (i + 1), counting from the outermost (layer 1) to the innermost (layer n).\n4. Set the value of each cell in the output grid to the integer from the corresponding extracted layer. That is, assign the cell at (r, c) the value recorded for layer (i + 1). \n5. The resulting output grid is a series of concentric squares where the outermost ring is filled with the integer taken from the input’s outer border, the next ring is filled with the integer from the next inner border, and so on until the center cell is filled with the innermost layer’s integer. For example, if the input layers (in order) are [8, 3, 2] then the output (5×5) grid will have an outer border of 8, the next ring of 3, and a center cell of 2.\nNote: All integers (such as 2, 3, 8, 1, etc.) are used directly, corresponding to the colors in the original descriptions.",
    "ec883f72.json": "1. Copy the input grid (of fixed size) into the output grid without change. \n2. Identify the object by finding every cell whose value is not 0. Compute the bounding box of these nonzero cells by finding the minimum and maximum row and column indices (min_row, min_col) and (max_row, max_col). \n3. Within this bounding box exactly two nonzero numbers will appear. Determine the border number by examining all cells on the perimeter of the bounding box (that is, the top row, bottom row, leftmost column, and rightmost column in the box) and choosing the value that occurs most frequently. Designate the other nonzero value as the inner number. (For example, in one case the border number is 9 and the inner number is 3; in another the border is 8 and the inner is 6.) \n4. Compute the center of the bounding box as (center_row, center_col) = ((min_row + max_row) / 2, (min_col + max_col) / 2). \n5. For each of the four corners of the bounding box – namely, at (min_row, min_col), (min_row, max_col), (max_row, min_col) and (max_row, max_col) – do the following if the cell at that corner equals the border number:\n  a. Determine the extension (diagonal) direction by computing the sign of (corner_row – center_row) and the sign of (corner_col – center_col). In other words, let dr = -1 if (corner_row – center_row) is negative and 1 if positive; similarly, let dc = -1 if (corner_col – center_col) is negative and 1 if positive. (This yields one of the four diagonal directions: (1,1), (1,–1), (–1,1) or (–1,–1).)\n  b. Starting from the cell immediately adjacent to the corner in the computed diagonal direction (i.e. at (corner_row + dr, corner_col + dc)), step repeatedly in that same (dr, dc) direction. At each step, if the new cell is within the grid boundaries, set its value to the inner number. Stop advancing when the next step would fall outside the grid.\n6. Return the modified output grid.",
    "ecdecbb3.json": "1. Copy the input grid without changing its dimensions. 2. Identify the fixed drawn line(s) by locating the continuous sequence(s) of cells with value 8 that form either an entire row (horizontal line) or an entire column (vertical line). 3. Identify each isolated dot by finding cells with value 2 that are not part of a contiguous group of 2’s. 4. For each isolated dot at position (r, c), determine the connection direction based on the orientation of the 8‐line(s): if an 8‐line is horizontal (all cells in a row are 8), the connection is vertical; if an 8‐line is vertical (all cells in a column are 8), the connection is horizontal. 5. For each dot and for each 8‐line that lies in the perpendicular direction from it, decide which connection(s) to draw. • If the dot lies on one side of the 8‐line (for example, above a horizontal line or to the right of a vertical line), plan a single connection from the dot toward that 8‐line. • If the dot lies between two parallel 8‐lines (for example, between two horizontal lines or between two vertical lines), plan two connections: one toward the nearer 8‐line in one direction and one toward the other. 6. Draw the connection line in the following way. • For a vertical connection (when the 8‐line is horizontal): if the dot is above the 8‐line, fill every cell in the same column with value 2 starting from one row below the dot up to the row immediately preceding the 8‐line; if the dot is below the 8‐line, fill every cell in the same column with value 2 starting from one row above the dot up to the row immediately following the 8‐line. • For a horizontal connection (when the 8‐line is vertical): if the dot is to the right of the 8‐line, fill every cell in the same row with value 2 starting from one column to the left of the dot up to the column immediately after the 8‐line; if the dot is to the left of the 8‐line, fill every cell in the same row with value 2 starting from one column to the right of the dot up to the column immediately before the 8‐line. 7. At the cell on the 8‐line where the connection meets (the junction cell), set its value to 2. Then overlay a 3×3 square centered on that junction cell by setting the center to 2 and all eight surrounding cells to 8. This square overrides any previous values in that 3×3 block. 8. Leave all other cells unchanged and output the final grid.",
    "ed36ccf7.json": "1. Read the input grid, which is a square grid (n x n) of digits (0–9), where 0 (black) is the background and the other digits (such as 2, 5, 6, 9) represent the drawn shape. 2. Create an output grid of the same dimensions (n x n). 3. For each cell in the output grid at row r and column c (using 0-based indexing), assign its value from the input grid at row c and column (n - 1 - r). This operation rotates the entire grid 90 degrees counterclockwise (to the left). 4. Return the output grid.",
    "ef135b50.json": "1. Find the topmost and bottommost rows in the grid that contain at least one 2. Do not change these rows. 2. For every other row r (that is, for each row with index strictly between the topmost and bottommost rows that contain a 2), scan the row from left to right and identify all contiguous segments (groups) of cells whose value is 2. (A contiguous segment is a maximal sequence of adjacent cells in the row that are all 2.) 3. If a row contains only one such segment, leave the row unchanged. If a row contains two or more segments, then for each pair of adjacent segments, let L be the column index of the rightmost 2 in the left segment and R be the column index of the leftmost 2 in the right segment; then replace every cell in that row whose column index c satisfies L < c < R with 9. 4. Leave all other cells unchanged and keep the grid size the same.",
    "f15e1fac.json": "1. Begin by copying the entire input grid unchanged to the output. In the grid only three numbers are used: 0 (background), 8 (blue) and 2 (red). 2. In every example the only blue cells in the input serve as seeds and always lie flush against one edge of the grid. (For instance, in some examples the blue seeds appear only in the top row, while in others they appear only in the left or right column.) Determine the primary propagation direction from the seed’s location as follows – if a cell with value 8 is on the top edge then you will extend a blue line downward; if on the bottom edge then extend upward; if on the left edge then extend to the right; if on the right edge then extend to the left. 3. For each blue seed, “draw” its blue line by replacing 0’s with 8’s along a straight line in the primary direction (that is, fill every cell in that column or row within the same contiguous block) without overwriting any red (2) cells. The blue line is drawn for every row (or column) of a contiguous segment of the grid—that is, from one boundary row up to (but not including) a row that contains at least one red cell. (In the examples when the seed is on the top or bottom edge the segment is a group of contiguous rows; when the seed is on the left or right edge the segment is a group of contiguous columns.) 4. When you reach the first row (or column) of the current segment that contains a red cell (a cell with value 2), do not extend the blue line into that segment. Instead, note the relative position of the red cell with respect to the blue line. Then start a new blue line in the same primary direction over the next contiguous segment by shifting the starting position away from the red cell. Specifically, if you are propagating vertically (from a top‐edge seed) and the encountered red cell lies to the left of the current blue column then shift the new blue line one column to the right; if the red cell is to the right then shift one column to the left. Similarly, if you are propagating horizontally (from a left‐ or right–edge seed) and the encountered red lies above the blue run then shift the new blue line one row down; if the red is below then shift one row up. 5. Fill the entire contiguous segment (that is, all rows between two “red rows” or from the seed edge to the first red row) with the blue line drawn in step 3. Then, use the shifted starting cell from step 4 as the seed for the next group. Continue this process – drawing a blue line in the prescribed direction for a full contiguous segment and then, upon encountering a row (or column) that contains red (2), starting a new blue line by shifting one cell away from the red cell – repeating until you have processed all segments of the grid. 6. Throughout, never change any cell that is 2 in the input; only fill cells that were 0 (background) with 8 (blue) as determined by the propagation. 7. Finally, output the resulting grid (which is the same size as the input) that now shows the original red cells and a series of parallel blue lines whose positions have been shifted by one cell at each red boundary.",
    "f1cefba8.json": "1. Find the central figure by scanning the grid for all nonzero cells. Compute its bounding box (using the smallest and largest row and column indices where a cell is nonzero); denote these as min_row, max_row, min_col, and max_col.  \n2. Within that bounding box the figure is made up of exactly two nonzero numbers. (For example, in one case the two numbers are 8 and 2, in another they are 1 and 4, and in a third they are 2 and 3.) Determine which color is meant to fill the figure uniformly. Do this by choosing the color that appears on most of the border of the bounding box (or, equivalently, the one that is dominant in the overall figure); call that C_dom. Let the other number (which appears only in a few cells inside the figure) be C_anom. (Example: if the two numbers are 8 and 2, then set C_dom = 8 and C_anom = 2; if they are 1 and 4 then C_dom = 1 and C_anom = 4; if they are 2 and 3 then C_dom = 2 and C_anom = 3.)  \n3. Correct the figure by replacing every cell inside the bounding box that equals C_anom with C_dom. (The idea is that the original figure should be uniformly C_dom.)  \n4. Record which columns inside the bounding box originally contained C_anom. For each column j from min_col to max_col, count the number of cells (within rows min_row to max_row) that originally held C_anom. Then, for each column j where the count is more than half of the cells in that column, mark j as a candidate for a vertical anomaly‐line. If there is more than one candidate, group adjacent candidate columns into clusters and, for each cluster, take the median column index. Collect these median indices into a set X_ext. (In many examples this yields two column positions; in some cases there may be only one.)  \n5. Similarly, record the rows inside the bounding box in which C_anom originally appeared. For each row i from min_row to max_row, count how many cells in that row (within the bounding box) originally equal C_anom. Mark row i as a candidate if its count is more than half the number of cells in that row. Then take the median of all candidate row indices (or, if there are none, the median of the rows that have any C_anom) and call that Y_ext. (This is the horizontal position where the “anomaly” should be relocated.)  \n6. Now “move” the anomaly out of the central figure by drawing its color into the surrounding background. Do this in two parts:\n   a. For every row r that lies outside the bounding box (that is, for r < min_row and for r > max_row), set the cell value to C_anom at every column j in the set X_ext. (This draws vertical lines in the background at the anomaly‐column positions.)\n   b. For every column c that lies outside the bounding box (that is, for c < min_col and for c > max_col), set the cell value to C_anom at row Y_ext. (This draws a horizontal line in the background at the anomaly‐row position.)  \n7. The final output is a grid of the same dimensions as the input where the central figure is uniformly filled with C_dom and the anomaly color C_anom (which originally appeared as a few misplaced cells inside the figure) has been “moved” to the grid’s exterior by extending a straight vertical line at the computed column(s) and a straight horizontal line at the computed row into the background (which is 0).",
    "f25fbde4.json": "1. Scan the input grid and identify all cells with the value 4 (which represents yellow) while the background is 0 (black). Record the smallest and largest row indices (min_row and max_row) and the smallest and largest column indices (min_col and max_col) where a 4 appears.\n2. Define the bounding box of the pattern: its height H = max_row - min_row + 1 and its width W = max_col - min_col + 1.\n3. Create an output grid of size (2 * H) rows by (2 * W) columns, and initialize every cell to 0.\n4. For each cell in the input grid that lies inside the bounding box (that is, for each cell at position (r, c) with r between min_row and max_row and c between min_col and max_col), compute its relative coordinates (i, j) where i = r - min_row and j = c - min_col. If the cell’s value is 4, then in the output grid set the 2×2 block starting at (2*i, 2*j) to have the value 4. In other words, assign 4 to the cells at positions (2*i, 2*j), (2*i, 2*j + 1), (2*i + 1, 2*j) and (2*i + 1, 2*j + 1).\n5. Leave all output cells corresponding to an input 0 unchanged as 0. The resulting output grid, which is a scaled-up version of the original 4-pattern, is the final result.",
    "f25ffba3.json": "1. Let the input grid have n rows and m columns (in all given examples n = 10 and m = 4, but the rule applies generally). 2. Compute k = n/2 (assume n is even); this k divides the grid into a top half (rows 0 to k-1) and a bottom half (rows k to n-1). 3. For each row index i from 0 to k-1, set the output row i to be exactly the input row at index (n - 1 - i). This step reflects the bottom half of the grid (rows k through n-1) in reverse order. 4. For each row index i from k to n - 1, copy the input row i unchanged into the output row i. 5. Return the output grid, which has its top half replaced by the vertically mirrored copy of the bottom half while the bottom half remains identical to the input. For example, when n = 10 and k = 5, output row 0 becomes input row 9, row 1 becomes input row 8, row 2 becomes input row 7, row 3 becomes input row 6, and row 4 becomes input row 5; rows 5 through 9 are copied directly from the input.",
    "f2829549.json": "1. Assume the input grid has 4 rows and 7 columns. The fourth column (column index 3) is always filled with 1 (blue) and serves only as a divider.\\n2. Form two 4x3 sub‐grids by ignoring column 3: extract the left sub‐grid from columns 0, 1, and 2 and the right sub‐grid from columns 4, 5, and 6. In the left sub‐grid cells, nonzero values (typically 7 for orange) indicate a colored (occupied) cell, and in the right sub‐grid nonzero values (typically 5 for grey) indicate a colored cell; a value of 0 represents black (empty).\\n3. Create a new output grid of size 4 rows by 3 columns. For each cell at row R and column C (with R from 0 to 3 and C from 0 to 2), determine the value in the left sub‐grid at (R,C) and in the right sub‐grid at (R, C) (noting that the corresponding input column for the right sub‐grid is C+4).\\n4. If either corresponding cell from the left or right sub‐grid is nonzero (i.e. occupied by 7 or 5), set the output cell to 0 (black). If both corresponding cells are 0 (black), then set the output cell to 3 (green).\\n5. Return the resulting 4x3 grid as the final output.",
    "f35d900a.json": "1. Determine the two distinct nonzero integer values in the input grid – call them v1 and v2. (For every example these appear exactly in four cells arranged in a 2×2 pattern.)\n2. For each colored cell in the input at coordinate (r, c) with value v (where v is either v1 or v2), overlay a 3×3 block on the output so that the center at (r, c) remains v and every other cell in the 3×3 (that is, all cells with row indices r−1 to r+1 and column indices c−1 to c+1, provided they lie within the grid) is set to the complementary value. In other words, if v = v1, fill the surrounding cells with v2; if v = v2, fill its surrounding cells with v1.\n3. As a result the four colored cells become four 3×3 squares (each with a one‐cell “border” of the complementary color and the original cell as the center) that are arranged in two rows and two columns. Identify the center coordinates of the top‐row squares (they share the same row, call it R_top) and the bottom‐row squares (row R_bot), and similarly identify the centers of the left‐column squares (column C_left) and the right‐column squares (column C_right).\n4. Draw horizontal connectors between the two squares in the same row. For a given row (either R_top or R_bot), note that the left square covers columns (C_left−1) to (C_left+1) and the right square covers columns (C_right−1) to (C_right+1). Fill the gap in that same row between column (C_left+1) and column (C_right−1) by writing a horizontal sequence that starts in the cell immediately after the left square and ends just before the right square. If the gap length is 2 cells, fill both with 5; if longer, fill it with an alternating pattern of 5 and 0, starting with 5 in the first connector cell adjacent to the left square.\n5. Draw vertical connectors between the two squares in the same column. For a given column (either C_left or C_right), note that the top square covers rows (R_top−1) to (R_top+1) and the bottom square covers rows (R_bot−1) to (R_bot+1). Fill the gap in that same column between row (R_top+1) and row (R_bot−1) by writing a vertical sequence that starts in the cell immediately below the top square and ends just above the bottom square. If the gap length is 2 cells, fill both with 5; if longer, fill it with an alternating sequence of 5 and 0, starting with 5 in the first cell adjacent to the top square.\n6. Do not modify any other cells; leave all cells not overwritten by a 3×3 square or a connector as 0. The output grid retains the same size as the input.",
    "f5b8619d.json": "1. Compute the dimensions of the input grid; let H be the number of rows and W the number of columns. Set the output grid size to 2*H by 2*W.\n2. For each column j (0 ≤ j < W) in the input grid, check every row; if at least one cell in column j is nonzero (i.e. not 0), mark that column as active. Otherwise, mark column j as inactive.\n3. Build a transformed grid (of size H×W) as follows: for every cell at row r and column j (0 ≤ r < H, 0 ≤ j < W), examine the input value.\n   • If column j is active and the input value is 0, then set the transformed cell to 8. (Recall: 8 represents cyan/light blue.)\n   • Otherwise, leave the cell as its original value (if nonzero in an active column or if in an inactive column, always keep 0).\n4. Construct the output grid by tiling the transformed grid in a 2×2 pattern. In other words, place a copy of the transformed grid in each quadrant (top‐left, top‐right, bottom‐left, and bottom‐right) of the output grid.\n5. The resulting output grid (of size 2*H by 2*W) is the final answer. In effect, every column that contained any colored cell in the input causes all 0’s in that column (in the transformed grid) to become 8, and then that transformed grid is repeated in all four quadrants.",
    "f76d97a5.json": "1. Determine the unique non‐grey number in the input grid by scanning all cells; since the grid contains exactly two distinct values, one of them is 5 (representing grey) and the other is the color X. 2. Create an output grid with the same dimensions as the input grid. 3. For each cell in the input, if the cell’s value is 5 then set the corresponding output cell to X; if the cell’s value is X then set the output cell to 0 (black). 4. Return the output grid as the final result.",
    "f8a8fe49.json": "1. Find the frame of 2’s. Scan the grid to locate every cell whose value is 2, and compute the smallest rectangle (bounding box) that contains all these 2’s. Denote its top‐most row as T, bottom‐most row as B, left‐most column as L, and right‐most column as R. \n2. Decide which mirror edge to use by inspecting the frame’s border. If every cell in row T (from column L to R) is 2, then the top border is complete and you will reflect the inner pattern vertically (that is, flip it so that cells inside the frame move outside above or below the frame). Otherwise, if every cell in column L (from row T to B) is 2, then the left border is complete and you will reflect the inner pattern horizontally (so that cells inside the frame move outside to the left or right). (In the given examples the first case – complete top border – applies when the 2’s form a full horizontal bar (as in Example 1) and the second case applies when the 2’s appear as two bracket‐shaped halves with a complete vertical side (as in Examples 2 and 3).)\n3. Identify the inner pattern of 5’s. In the input, select every cell with value 5 that lies strictly inside the frame (that is, with row r satisfying T < r < B and column c satisfying L < c < R). These cells form the pattern that must be flipped. \n4. For each cell (r, c) holding a 5 inside the frame, compute its mirror image as follows:\n • If reflecting vertically (using the horizontal mirror edge): compare the vertical distance to the top and bottom borders. Compute d_top = r − T and d_bottom = B − r. If d_top ≤ d_bottom, choose the top edge and set the new row r' = T − d_top; otherwise (if d_bottom < d_top) choose the bottom edge and set r' = B + d_bottom. In either case the column remains unchanged (c' = c).\n • If reflecting horizontally (using the vertical mirror edge): compare the horizontal distance to the left and right borders. Compute d_left = c − L and d_right = R − c. If d_left ≤ d_right, choose the left edge and set the new column c' = L − d_left; otherwise (if d_right < d_left) choose the right edge and set c' = R + d_right. In either case the row remains unchanged (r' = r).\n5. Erase the inner 5’s from inside the frame (set those cells to 0). \n6. Place the flipped pattern: for every computed mirror coordinate (r', c') from step 4, set that cell in the output grid to 5 (overwriting a 0 if necessary). Do not modify any cells that already contain 2 (the frame) or that are unaffected (they remain 0). \n7. The output grid is the same size as the input and now shows the 5’s relocated outside the 2’s frame by a mirror reflection across the appropriate edge.",
    "f8b3ba0a.json": "1. For each row in the input grid, scan the cells from left to right and count the number of boxes for each digit (ignoring 0). Define a box as a contiguous horizontal segment of nonzero cells having the same value. In other words, when you encounter a cell with a value in {1,…,9} that is either at the start of the row or immediately follows a cell with a different value (including 0), count that as one box for that digit.\n2. Identify all distinct nonzero digits (colors) present in the grid. (Each provided example will include exactly four such digits.)\n3. Among these four digits, determine the box count for each and then remove the digit with the highest box count from further consideration.\n4. With the remaining three digits, sort them in ascending order based on their box counts (i.e. the digit with the fewest boxes comes first, then the next, and finally the one with the most boxes among the three).\n5. Create an output grid of size 3 rows × 1 column. Assign the top cell the digit that had the highest box count among the three (i.e. the third element in the sorted order), assign the middle cell the digit with the middle count, and assign the bottom cell the digit with the lowest box count.\n6. Output this 3×1 grid where the cells (from top to bottom) are the three chosen digits in that order.",
    "f8c80d96.json": "1. Find the unique nonzero number in the input grid and call it L (this is the “line” color); note that the background value is 0 and will be changed to 5. \n2. Make an output grid of the same size and fill every cell with 5. (Here 5 plays the role of grey.) \n3. Regard the cells in the input that have the value L as a partial drawing of a spiral whose segments run in horizontal or vertical strokes with right‐angle turns and a constant spacing between turns. \n4. From the input pattern, deduce the intended full spiral path – that is, determine the orientation of each segment (whether it is drawn left‐to‐right or top‐to‐bottom) and the gap (number of cells) between turns that is consistent in the drawn parts. \n5. In the output grid, “complete” the spiral by redrawing a continuous line of width 1 using L as follows:\n   a. For every row or column where the input already has one or more cells equal to L, extend that segment in the same direction so that the entire intended stroke is drawn following the same spacing and bend as shown in the input.\n   b. At each turning point, make a 90° change in direction (as indicated by the input’s bends) while keeping the gap between successive turns constant.\n   c. Ensure that the spiral is continuous and that its drawn cells (set to L) appear in exactly those positions dictated by the extended pattern.\n6. Leave every cell that is not part of the completed spiral as 5. \n7. Return the resulting grid.",
    "f8ff0b80.json": "1. Read the input grid as a 2D array of integers. Ignore all cells with the value 0 (0 represents the background).\n2. Identify each distinct nonzero integer present in the grid; these integers represent the different colors (for example, 1, 2, 3, etc.).\n3. For each distinct nonzero integer, count the number of times it appears in the grid.\n4. Sort the distinct integers in descending order based on their counts (i.e. the integer with the highest frequency comes first, the next highest second, and the lowest third).\n5. Construct a new output grid of size 3x1 (three rows and one column). Place the integer with the highest count in the top cell (position (0,0)), the integer with the second highest count in the middle cell (position (1,0)), and the integer with the lowest count in the bottom cell (position (2,0)).\n6. Return the resulting 3x1 grid as the output.",
    "f9012d9b.json": "1. Find the bounding rectangle of all cells with value 0 in the input grid. Let Rmin be the smallest row index, Rmax the largest row index, Cmin the smallest column index, and Cmax the largest column index among cells equal to 0. The output grid will have height H = Rmax − Rmin + 1 and width W = Cmax − Cmin + 1.\n2. In the parts of the grid that are not 0, deduce the repeating color pattern by determining its horizontal period. To do this, pick any row that does not contain 0 and examine its entries. Find the smallest positive integer q such that when you take the first q cells (columns 0 to q−1) as a prototype, every cell in that row at column j has the same value as the cell in the prototype at column (j mod q). (For example, if a row is [8,6,8,6] then q = 2 with prototype [8,6].)\n3. Similarly, determine the vertical period of the pattern. From the fully colored rows (rows with no 0), find the smallest positive integer p such that if you group rows by their index mod p, the pattern in each group is consistent. In other words, there exists a prototype list of p rows (each given by its first q cells as determined in step 2) that, when repeated, recreates the colored parts of the grid.\n4. Construct a tile (a p × q grid) as follows: for each i from 0 to p − 1, choose a fully colored row whose index is congruent to i modulo p (preferably one from the upper part of the grid) and let the tile’s ith row be the first q cells of that row. This tile represents the repeating pattern that fills the grid.\n5. For every cell in the bounding rectangle found in step 1 (with global coordinates (r, c) where Rmin ≤ r ≤ Rmax and Cmin ≤ c ≤ Cmax), compute its replacement value by taking the value from the tile at row index (r mod p) and column index (c mod q). In other words, set the output cell at relative position (r − Rmin, c − Cmin) to tile[r mod p][c mod q].\n6. Output the resulting grid of size H × W. This grid (filled with numbers other than 0 according to the repeating tile) is the answer.",
    "fafffa47.json": "1. Note that the input grid has 6 rows and 3 columns and is conceptually divided into two halves: the top half (rows 0 to 2) and the bottom half (rows 3 to 5). In the top half, nonzero cells (specifically 9, which stands for brown) indicate a painted pixel, while 0 indicates a blank (background). In the bottom half, nonzero cells (specifically 1, which stands for blue) indicate a painted pixel, while 0 is blank.\n2. Create an output grid of size 3 rows by 3 columns.\n3. For each cell in the output grid at coordinates (r, c) (using zero-based indices where r = 0, 1, 2 and c = 0, 1, 2):\n   a. Let T be the value from the input top half at (r, c).\n   b. Let B be the value from the input bottom half at (r+3, c).\n   c. If either T is not 0 or B is not 0 (meaning at least one of the corresponding cells is painted), then set the output cell (r, c) to 0 (black).\n   d. Otherwise, if both T and B are 0, set the output cell (r, c) to 2 (red).\n4. Return the output grid.",
    "fcb5c309.json": "1. Identify connected regions: Iterate over every cell in the input grid and group all cells with a nonzero value (i.e. values 1–9) into connected components using 4‐neighbor (up, down, left, right) connectivity. Only nonzero cells are part of a shape; 0 is the background.\n2. Select the largest component: From all connected components found, choose the one with the greatest number of cells. This is considered the target frame-like shape.\n3. Compute the bounding box: For the selected component, determine the minimum and maximum row and column indices (min_row, max_row, min_col, max_col) of its cells. The dimensions of the output grid are then defined as height = max_row − min_row + 1 and width = max_col − min_col + 1.\n4. Determine the fill color (C): Look at the interior of the bounding box – that is, all positions with rows from min_row+1 to max_row−1 and columns from min_col+1 to max_col−1 that belong to the selected component. Identify the nonzero value found there. In all examples this interior nonzero value is uniform (for instance, it is 4 in one training example, 3 in another, 2 in a third, and 8 in the test example). Let this value be C.\n5. Create the output grid: Initialize a grid with the same dimensions as the bounding box.\n6. Draw the uniform frame: For each cell in the output grid with relative coordinates (r, c), where 0 ≤ r < height and 0 ≤ c < width, do the following:\n   a. If r is 0 or r = height−1 or c is 0 or c = width−1 (i.e. the cell is on the border of the bounding box), set that cell to C.\n   b. Otherwise (if the cell is in the interior), check the corresponding cell in the input (at row = min_row + r, column = min_col + c). If that cell (which is part of the selected component) has the value C then set the output cell to C; otherwise, set it to 0.\n7. Return the output grid. The result is a grid whose size matches the bounding box of the largest frame-like shape and whose border is uniformly colored with C. Any interior cell that originally carried the fill color remains C; all other interior cells become 0.",
    "fcc82909.json": "1. For every cell in the input grid, look for a 2×2 block (a square of four adjacent cells arranged in two rows and two columns) in which none of the four cells is 0. (These are the colored squares.) Mark the top‐left coordinate of each such block.  \n2. For each found 2×2 block, inspect its four numbers. If at least one of the numbers is 4 (the integer for yellow), mark this block as “yellow‐containing”; otherwise mark it as “non‐yellow.”  \n3. Decide on a duplicate (mirror) size for the block that will be drawn in green (green is 3). Use a convention consistent with the training examples: normally the duplicate is 2 rows tall (and 2 columns wide, exactly matching the square) but if the block is yellow‐containing then make the duplicate taller – use a height of 3 rows. (In several examples the duplicate appears larger; the idea is that the presence of 4 enlarges the green copy by one extra row.)  \n4. In the output grid (which has the same dimensions as the input), first copy all the input cells unchanged. Then, for each 2×2 block found in step 1, “overlay” a green rectangle (i.e. fill with 3) exactly under the block. That is, if the block’s bottom row is r+1 then fill the cells in the same two columns in the rows immediately below—that is, from row r+2 through row r+1+H (where H is 2 if the block is non‐yellow and 3 if it is yellow)—but do not replace any cell that was already nonzero in the input.  \n5. If two green rectangles would cover the same cell, the cell remains green (3). Leave all other cells (including original colored cells) unchanged.  \n6. The final output is the input grid with, for every detected 2×2 colored square, an added green (3) rectangle immediately below it (of size 2×2 normally, or 2×3 when the square contains 4).",
    "feca6190.json": "1. Read the input grid, which is a single row of 5 integers. Treat any nonzero integer as a colored block and let m be the count of these nonzero values.\n2. Compute the size S of the output grid as S = 5 * m. Create an S×S grid and fill every cell with 0.\n3. For each cell in the input row at column index j (where j ranges from 0 to 4) that has a nonzero value v, draw a diagonal line in the output grid as follows: For each integer offset d starting at 0, while (j + d) is less than S, set the cell at row (S − 1 − d) and column (j + d) to v. (Note: here the top row has index 0 and the bottom row has index S − 1.)\n4. Once every nonzero element in the input has been processed in this manner, output the resulting S×S grid. This produces a pattern in which each colored block from the input (using its numeric value, e.g. 1, 2, 4, 6, 7, 8, 9) appears as a diagonal stripe starting at the bottom of its column and extending upward and to the right; the length of the stripe for an element at column j is S − j.",
    "ff28f65a.json": "1. Scan the input grid to count all distinct 2×2 blocks that are entirely filled with the number 2 (which represents red). To do this, iterate over every cell (r, c) where r goes from 0 to (number_of_rows - 2) and c goes from 0 to (number_of_columns - 2). For each such cell, if grid[r][c], grid[r][c+1], grid[r+1][c], and grid[r+1][c+1] are all equal to 2, increment a counter by 1. \n2. Create a new output grid of fixed size 3×3 and initialize every cell to 0 (which represents black). \n3. Define an ordered list of positions within the 3×3 grid where numbers will be placed. Use the following order (using zero-based indexing): first (0,0), second (0,2), third (1,1), fourth (2,0), and fifth (2,2). \n4. Let n be the number obtained in step 1. For the first min(n, 5) positions in the ordered list, set the corresponding cell in the output grid to 1 (which represents blue). Leave any other cell as 0. \n5. Return the resulting 3×3 grid as the output.",
    "ff805c23.json": "1. Scan the entire input grid (a two‐dimensional array of integers) to detect a single contiguous square region in which every cell has the same value V_occluder. This region (the occluder) will be uniform and is assumed to have been painted over part of an underlying repeating design. (In all examples V_occluder is 1.)\n2. Determine the occluder’s top‐left coordinate (R, C) and its size n (the number of rows or columns; in all provided cases n = 5). The output grid will have dimensions n × n.\n3. Assume that the background (hidden) pattern is distributed over the entire input in a translationally repeated way with period n relative to the occluder’s top‐left corner. That is, for any cell that is not covered by the occluder, its relative offset (i, j) is defined by i = (r − R) mod n and j = (c − C) mod n.\n4. For each cell in the occluder (for every offset (i, j) with 0 ≤ i, j < n), collect the values from all cells in the input grid that are not inside the occluder and whose relative coordinates (r, c) satisfy (r − R) mod n = i and (c − C) mod n = j. (It is assumed that for each fixed (i, j) these cells all share the same value.)\n5. Set the cell at position (i, j) in the new n × n output grid to that common value. (For example, if one such equivalence class yields only the value 0 in positions corresponding to offset (0,0), then the output cell at (0,0) becomes 0.)\n6. Return the constructed n × n grid. \n\nThis procedure removes the occluding square (which in human terms is the blue square, i.e. of value 1) and recovers the underlying pattern from the rest of the input by using the repeated structure of the background. Note that all colors are represented by their integer codes (for example, blue is 1, green is 3, grey is 5, pink/fuchsia is 6, cyan/light blue is 8, black is 0, etc.)."
}