{
    "007bbfb7.json": "1. Initialize a 9x9 output grid with all pixel values set to 0.\n2. Analyze the 3x3 input grid. Count the number of non-zero pixels (pixels with a value from 1 to 9).\n3. For each non-zero pixel with value 'V' found at coordinates (R, C) in the input grid:\n    a. Define a 3x3 subgrid within the output grid. The top-left corner of this subgrid is located at coordinates (R*3, C*3) in the output grid.\n    b. Fill all pixels within this 3x3 subgrid with the value 'V'.\n4. The resulting 9x9 grid is the final output.",
    "00d62c1b.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Identify all areas in the input grid that are completely enclosed by pixels with value 3.\n3. For each identified enclosed area, replace the value of all pixels within that area in the output grid with the value 4.",
    "017c7c7b.json": "1. Get the input grid. Let its dimensions be R rows and C columns.\n2. Calculate the output grid's number of rows: output_rows = R + (R / 3). Ensure this result is an integer. If necessary, round to the nearest whole number. The number of columns in the output grid, output_columns, is equal to C.\n3. Create a new output grid with dimensions output_rows x output_columns, initialized with all cells set to 0.\n4. Copy the original input grid to the top R rows of the output grid, maintaining the original column positions (0 to C-1). So, for each row r from 0 to R-1 and each column c from 0 to C-1, set output_grid[r][c] = input_grid[r][c].\n5. Ignore the first two rows (row 0 and row 1) of the input grid. Copy the next three rows (row 2, row 3, and row 4) from the input grid.\n6. Paste these three rows to the bottom three rows of the output grid. Specifically, for each column c from 0 to C-1:\n    a. Set output_grid[output_rows - 3][c] = input_grid[2][c].\n    b. Set output_grid[output_rows - 2][c] = input_grid[3][c].\n    c. Set output_grid[output_rows - 1][c] = input_grid[4][c].\n7. Replace all occurrences of the value 1 in the output grid with the value 2. So, for each row r from 0 to output_rows-1 and each column c from 0 to output_columns-1, if output_grid[r][c] is equal to 1, then set output_grid[r][c] to 2.\n8. The resulting output_grid is the solution.",
    "025d127b.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Identify all distinct shapes in the input grid, excluding the background (value 0). Assume there are two shapes as suggested in one of the descriptions, but handle cases where there is one.\n3. For each shape identified:\n    a. Find the row index of the bottom-most pixel of the shape. Let this be R_bottom.\n    b. Find the row immediately above R_bottom that contains a pixel belonging to the shape. Let this row index be R_above.\n    c. Shift all rows from R_above up to (but not including) the top-most row of the grid, one row upward. For example, row 'i' becomes row 'i-1'.\n    d. Identify the center row to remove from the shape to make it narrow. It is not well defined from which row to remove. Assuming the center row of a shape can be found by (R_top + R_bottom) / 2. Let this row index be R_center.\n    e. Replace all the pixel values in the row R_center with 0 (background).",
    "045e512c.json": "1. Copy the input grid to the output grid. The output grid will therefore have the same dimensions as the input grid.\n2. Identify the \"reference shape\". The reference shape is the largest contiguous non-0 shape in the input grid. If there are multiple shapes of equal size, pick one arbitrarily. Let R be the set of coordinates occupied by the reference shape.\n3. Find all \"incomplete shapes\". An incomplete shape is a contiguous non-0 shape that is smaller than the reference shape and is not the reference shape. The incomplete shapes are located on a 0 background.\n4. For each incomplete shape:\n    a. Determine the \"target color\" of the incomplete shape. The target color is the pixel value of the incomplete shape.\n    b. \"Complete\" the incomplete shape: Add pixels of the target color to the incomplete shape until it matches the exact shape of the reference shape. The added pixels should be placed adjacent to the incomplete shape in a manner that replicates the form of the reference shape.\n    c. Determine the direction and distance from the center of the completed shape to the center of the reference shape. Store this direction and distance as a vector V.\n    d. \"Replicate\" the completed shape: Starting from the completed shape's location, add new shapes of the same form and target color, spaced according to vector V, until the edge of the grid is reached in both directions along the vector V. If a shape extends beyond the grid boundary, only draw the portion that falls within the grid.\n    e. All replicated shapes must have the exact same shape as the reference shape and must consist exclusively of the target color.\n5. The output grid now contains the original grid with the replicated shapes. The 0 background serves as the canvas to replicate the shapes upon.",
    "0520fde7.json": "1. Find the vertical line of pixels with value 5 (grey) that divides the input grid into two parts: a left grid and a right grid. This line is the central separator.\n2. Determine the dimensions (rows and columns) of the left grid and right grid, excluding the grey separator line. Assume they have the same dimensions. Let the number of rows be R and the number of columns be C.\n3. Create an output grid with dimensions R x C.\n4. Iterate through each pixel location (row i, column j) where 0 <= i < R and 0 <= j < C.\n5. At each location (i, j), obtain the pixel value from the left grid at (i, j) and the pixel value from the right grid at (i, j). Note: The coordinates in the left and right grids are relative to the top-left corner of each grid, not the overall input grid.\n6. If the pixel value at (i, j) in the left grid is 1 (blue) AND the pixel value at (i, j) in the right grid is also 1 (blue), then set the pixel value at (i, j) in the output grid to 2 (red).\n7. Otherwise, set the pixel value at (i, j) in the output grid to 0 (black).",
    "05269061.json": "1. Analyze the input grid and determine its dimensions (rows and columns). The output grid will have the same dimensions as the input grid. Initialize an output grid with the same dimensions, filled with 0 (black). \n2. Identify a pattern of pixel values along the first row of the input grid. If no pattern is readily identifiable, assume a pattern of repeating pixel values. If the input descriptions mention specific colors like red (2), blue (1), and green (3) in a diagonal pattern, proceed as follows:\n3. For each row R in the output grid:\n4. For each column C in the output grid:\n5. Calculate a diagonal index D = (R + C) modulo 3.\n6. If D is 0, set the pixel value at (R, C) to 2 (red).\n7. If D is 1, set the pixel value at (R, C) to 1 (blue).\n8. If D is 2, set the pixel value at (R, C) to 3 (green).\n9. The output grid is now complete.",
    "05f2a901.json": "1. Identify the shape consisting of pixel value 8 (light blue). Call this the 'blue shape'.\n2. Identify the shape consisting of pixel value 2 (red). Call this the 'red shape'.\n3. Retain the position of the 'blue shape' in the output grid, identical to its position in the input grid.\n4. Move the 'red shape' directly towards the 'blue shape' until they are touching. Maintain the original orientation of the 'red shape' during the move.\n5. The output grid should contain the 'blue shape' in its original location and the 'red shape' moved to be touching it.",
    "06df4c85.json": "1. Analyze the input grid to identify 2x2 square regions that are completely filled with the background color 0 (black).\n2. For each such 2x2 black square identified in step 1, examine the pixels immediately surrounding it.\n3. If two non-adjacent pixels within the surrounding area of the 2x2 black square have the same non-zero value (1-9), replace the 2x2 black square with that value.\n4. The output grid has the same dimensions as the input grid.\n5. If the conditions in step 3 are not met for a 2x2 black square, leave it as 0 (black) in the output grid.",
    "08ed6ac7.json": "1. Identify all distinct columns in the input grid. Each column represents a 'bar'. The input consists of a set of bars (columns) with varying heights, all composed of pixel value 5 (grey).\n2. For each column (bar), determine its height. The height is the number of consecutive pixels with value 5, starting from the top row of the grid.\n3. Sort the columns (bars) based on their heights in descending order. Maintain the original column indices after sorting.\n4. Assign new pixel values based on the sorted order:\n    a. The tallest bar (column) is assigned pixel value 1 (blue).\n    b. The second tallest bar (column) is assigned pixel value 2 (red).\n    c. The third tallest bar (column) is assigned pixel value 3 (green).\n    d. The shortest bar (column) is assigned pixel value 4 (yellow).\n5. Replace the pixel values of the original 'grey' bars (value 5) in the corresponding columns with their newly assigned values (1, 2, 3, or 4), up to the height of the original bar.\n6. The output grid has the same dimensions as the input grid, but the tallest bars have been re-colored based on their rank by height: blue, red, green, and yellow.",
    "09629e4f.json": "1. Find a 3x3 subgrid within the input grid that contains exactly four non-0 (black) pixel values. Let's call this the 'target subgrid'.\n2. Create an output grid with the same dimensions as the input grid, initializing all pixel values to the same value as the input grid's pixels at each location. \n3. For each 3x3 subgrid location (R, C) in the output grid, where R and C are multiples of 3, copy the 'target subgrid' pattern into the corresponding 3x3 block in the output grid.\n4. Within each 3x3 subgrid, retain the original value if it is 5 (grey), otherwise change any pixel that does not match a pixel in the target subgrid to 0 (black).",
    "0962bcdd.json": "1. Identify two plus-shaped patterns in the input grid, each composed of two distinct numerical values. Let Value1 be the value forming the arms of a plus sign, and Value2 be the value at the center of this plus sign.\n2. For each plus-shaped pattern:\n3. Extend each arm of the plus sign by one cell in each of the four cardinal directions (up, down, left, right), changing the value of these extended cells to Value1.\n4. Create a 5x5 'X' shape centered on the original center cell of the plus sign.  Set the value of all cells within this 'X' shape to Value2.\n5.  The resulting pattern will have a 5x5 area, with Value2 forming the 'X', and Value1 forming the remaining cells within the 5x5 area, excluding the 'X'.\n6. Repeat steps 3-5 for the second plus-shaped pattern.\n7. Output the modified grid.",
    "0a938d79.json": "1. Identify two distinct non-0 pixel values (referred to as color1 and color2) in the input grid.\n2. Determine the dimensions of the input grid (rows, cols).\n3. Initialize the output grid with the same dimensions as the input grid.\n4. **Case 1: Elongated Black Grid**: If the input grid has significantly more columns than rows AND contains many 0 values, then:\n   4.1. Find the first occurrence of color1 in the input grid.\n   4.2. Find the first occurrence of color2 in the input grid.\n   4.3. Iterate through each row of the output grid.\n   4.4. In each row, alternate writing short horizontal stripes of color1 and color2, starting from the column where color1 was found and then color2 found, extending to the end of the row.  If at an even column, write color1. If at an odd column, write color2.  Repeat until the end of the row is reached.\n5. **Case 2: Tall Black Grid**: If the input grid has significantly more rows than columns AND contains many 0 values, then:\n   5.1. Find the first occurrence of color1 in the input grid.\n   5.2. Find the first occurrence of color2 in the input grid.\n   5.3. Iterate through each column of the output grid.\n   5.4. In each column, alternate writing short vertical stripes of color1 and color2, starting from the row where color1 was found and then color2 found, extending to the end of the column. If at an even row, write color1. If at an odd row, write color2. Repeat until the end of the column is reached.\n6. **Case 3: Vertical Blocks Grid**: If the input grid consists of vertical blocks of different color patterns, then:\n   6.1 Copy the input grid to the output grid.\n7. The output grid should be increased by 7 blocks. This is not possible to fulfill because the previous steps dictate to copy the input grid. Therefore, this step is omitted.",
    "0b148d64.json": "1. Input: Given an input grid, identify four distinct rectangular regions located in each of the corners of the grid. Three of these regions will have the same pixel value; one will have a different pixel value. \n2. Find the rectangular region with the unique pixel value.\n3. Determine the height (H) and width (W) of this unique rectangular region.\n4. Output: Create a new output grid with dimensions H x W.\n5. Copy the pixel values from the identified unique rectangular region in the input grid to the corresponding locations in the output grid. Specifically, for each pixel at row R and column C within the unique rectangular region of the input grid, copy its pixel value to row R and column C of the output grid.",
    "0ca9ddb6.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Find all locations (R, C) in the input grid where the pixel value is 2 (red).\n3. For each location (R, C) where the pixel value is 2, set the pixel values at the following locations in the output grid to 4 (yellow): (R-1, C-1), (R-1, C+1), (R+1, C-1), and (R+1, C+1). Note that (R, C) represents row and column indices.\n4. Find all locations (R, C) in the input grid where the pixel value is 1 (blue).\n5. For each location (R, C) where the pixel value is 1, set the pixel values at the following locations in the output grid to 7 (orange): (R-1, C), (R+1, C), (R, C-1), and (R, C+1).\n6. Pixels with input values of 8 (cyan/light blue) and 6 (pink/magenta) remain unchanged in the output grid; do not modify pixels in the output based on these values.",
    "0d3d703e.json": "1. Input is a 3x3 grid. The output grid is also 3x3. Each column in the input grid consists of the same single color (number).\n2. Replace pixel values in each column based on the following rules:\n3. If a column's original pixel value is 2 (red), change it to 6 (pink).\n4. If a column's original pixel value is 3 (green), change it to 4 (yellow).\n5. If a column's original pixel value is 1 (dark blue), change it to 5 (grey).\n6. If a column's original pixel value is 8 (cyan/light blue), change it to 2 (red).\n7. If a column's original pixel value is 6 (pink), change it to 2 (red).\n8. If a column's original pixel value is 4 (yellow), change it to 3 (green).\n9. If a column's original pixel value is 5 (grey), change it to 1 (dark blue).\n10. If a column's original pixel value is 2 (red), change it to 8 (cyan/light blue).\n11. Apply these rules to all columns in the input grid to create the output grid.",
    "0dfd9992.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Identify all locations (R, C) in the output grid where the pixel value is 0 (black).\n3. For each identified location (R, C) with pixel value 0, determine the repeating pattern in the surrounding area. This might involve examining rows above and/or columns to the left of (R, C) to find a repeating sequence of pixel values.\n4. Based on the identified repeating pattern, predict the correct pixel value (1-9) to fill in at location (R, C).\n5. Replace the pixel value at (R, C) with the predicted pixel value.\n6. Repeat steps 3-5 until there are no remaining pixel values of 0 in the output grid.",
    "0e206a2e.json": "1. Input: Identify a shape composed of non-0 pixel values on a background of 0s. The input also contains three isolated single-pixel squares with non-0 values. These squares represent values 2 (red), 4 (yellow), and 1 (blue), respectively. The task is to reconstruct the shape from the input using only pixels with values 2, 4, and 1.\n2. Output Grid Size: The output grid has the same dimensions as the input grid.\n3. Rotation: Rotate the entire input grid 180 degrees clockwise.\n4. Reconstruction: Recreate the rotated shape using only pixel values 2, 4, and 1. Fill the area previously occupied by the original shape in the rotated input with a combination of pixels with values 2, 4, and 1 to approximate the original shape's appearance. The three single-pixel squares in the input provide the colors to use to complete the shape.",
    "10fcaaa3.json": "1. Determine the dimensions (height H, width W) of the input grid. All values are integers 0-9.\n2. Create an output grid with dimensions 2H (height) and 2W (width), initialized with 0.\n3. Copy the input grid into the upper-left quadrant of the output grid. That is, for each pixel value INPUT[R, C] in the input grid, set OUTPUT[R, C] = INPUT[R, C], where R ranges from 0 to H-1 and C ranges from 0 to W-1.\n4. Copy the input grid into the upper-right quadrant of the output grid. That is, for each pixel value INPUT[R, C] in the input grid, set OUTPUT[R, C+W] = INPUT[R, C], where R ranges from 0 to H-1 and C ranges from 0 to W-1.\n5. Copy the input grid into the lower-left quadrant of the output grid. That is, for each pixel value INPUT[R, C] in the input grid, set OUTPUT[R+H, C] = INPUT[R, C], where R ranges from 0 to H-1 and C ranges from 0 to W-1.\n6. Copy the input grid into the lower-right quadrant of the output grid. That is, for each pixel value INPUT[R, C] in the input grid, set OUTPUT[R+H, C+W] = INPUT[R, C], where R ranges from 0 to H-1 and C ranges from 0 to W-1.\n7. Iterate through each pixel OUTPUT[R, C] in the output grid, where R ranges from 0 to 2H-1 and C ranges from 0 to 2W-1.\n8. If OUTPUT[R, C] is not 0 (i.e., the pixel has a color value 1-9), then perform the following steps:\n9. If R > 0 and C > 0 and OUTPUT[R-1, C-1] is 0, set OUTPUT[R-1, C-1] = 8.\n10. If R > 0 and C < 2W-1 and OUTPUT[R-1, C+1] is 0, set OUTPUT[R-1, C+1] = 8.\n11. If R < 2H-1 and C > 0 and OUTPUT[R+1, C-1] is 0, set OUTPUT[R+1, C-1] = 8.\n12. If R < 2H-1 and C < 2W-1 and OUTPUT[R+1, C+1] is 0, set OUTPUT[R+1, C+1] = 8.",
    "11852cab.json": "1. Find incomplete shapes in the input grid. An incomplete shape is defined as an area of connected pixels of the same value (0-9) that has a gap, break, or missing segment in its boundary.\n2. Identify the missing pixel value(s) required to complete the shape's boundary. This is done by analyzing the immediate neighboring pixels around the incomplete section of the shape. Find the most frequent pixel value among these neighbors.\n3. Fill in the missing section(s) of the incomplete shape with the identified pixel value from step 2.\n4. The output grid has the same dimensions as the input grid.\n5. Replace the pixels in the output grid corresponding to the filled-in sections of the shape with the determined neighbor value. All other pixels in the output grid should retain their original values from the input grid.",
    "1190e5a7.json": "1. Find the horizontal and vertical lines of color 1 in the input grid. These lines divide the grid into cells.\n2. Determine the output grid dimensions by counting the number of vertical lines and adding 1 to get the width. Count the number of horizontal lines and add 1 to get the height.\n3. Identify the predominant color in the original input grid, excluding the lines of color 1. This will be the fill color.\n4. Create a new output grid with the determined width and height. \n5. Fill all cells of the output grid with the identified predominant color (represented by its corresponding number 0-9).\n",
    "137eaa0f.json": "1. Find each distinct pattern in the input grid. Each pattern contains one pixel with value 5.\n2. For each pattern found in Step 1, identify the coordinates (R, C) of the pixel with value 5.\n3. Create a 3x3 output grid filled with 0s.\n4. For each pattern identified in Step 1, copy the pattern to the output grid such that the pixel with value 5 is placed at the center of the 3x3 output grid, which is position (1, 1).\n5. The output grid now contains a 3x3 grid with the identified pattern centered around the pixel with value 5.",
    "150deff5.json": "1. Copy the input grid to the output grid. The input grid is a 9x9 grid containing 0 (black) and 5 (grey) pixel values.\n2. Find all 2x2 square regions of 5 (grey) pixels within the output grid.\n3. Replace the pixel value of each pixel within these identified 2x2 square regions with 8 (cyan/light blue).\n4. Find all remaining pixels with a value of 5 (grey) in the output grid that were not part of a 2x2 square.\n5. Replace the pixel value of these remaining 5 (grey) pixels with 2 (red). The final output grid should contain only 0 (black), 8 (cyan/light blue), and 2 (red) pixel values, with all original 5 (grey) pixels replaced by either 8 (cyan/light blue) in 2x2 blocks, or 2 (red) otherwise, resulting in potentially 1x3 red blocks as well.",
    "178fcbfb.json": "1. Initialize the output grid to be identical to the input grid. The grid consists of numerical values, where each number corresponds to a color: 0=black, 1=blue, 2=red, 3=green, 4=yellow, 5=grey, 6=pink, 7=orange, 8=cyan, 9=brown.\n2. Iterate through each cell (R, C) of the input grid.\n3. If the value at cell (R, C) is 2 (red), draw a vertical line of 2s (red) through the entire column C in the output grid. This means, for every row i from 0 to the grid height - 1, set the value of output_grid[i][C] to 2.\n4. Iterate through each cell (R, C) of the input grid again.\n5. If the value at cell (R, C) is 3 (green), draw a horizontal line of 3s (green) through the entire row R in the output grid. This means, for every column j from 0 to the grid width - 1, set the value of output_grid[R][j] to 3.\n6. Iterate through each cell (R, C) of the input grid again.\n7. If the value at cell (R, C) is 1 (blue), draw a horizontal line of 1s (blue) through the entire row R in the output grid. This means, for every column j from 0 to the grid width - 1, set the value of output_grid[R][j] to 1.\n8. Return the modified output grid.",
    "1a07d186.json": "1. Identify the predominant color number in the input grid. Let this be the 'primary color'. If there are two main color numbers, choose the one associated with lines, not single squares.\n2. Identify any color number that appears as isolated single squares. Let this be the 'single square color'. If no single square color exists, skip steps 4-6.\n3. Identify any color number that is different than the primary color and not the single square color. Let this be the 'different color'. Replace all instances of the 'different color' with 0.\n4. For each isolated single square with the 'single square color', determine if there is a horizontal or vertical line composed of the 'primary color' nearby.\n5. If a horizontal line of the 'primary color' is present, move the single square horizontally until it touches the line. The direction to move the square should match the side the single square was originally on relative to the line.\n6. If a vertical line of the 'primary color' is present, move the single square vertically until it touches the line. The direction to move the square should match the side the single square was originally on relative to the line.\n7. The output grid size remains the same as the input grid size.",
    "1b2d62fb.json": "1. Divide the input grid into two sub-grids of equal size. Assume the presence of a dividing line of value 1 (blue) separating the two grids. Discard the dividing line. Let the first sub-grid be Grid1 and the second sub-grid be Grid2. Both grids should have the same dimensions.\n2. Create an output grid. The output grid's height is 5 and width is 3.\n3. Initialize all cells in the output grid to 0 (black).\n4. Iterate through corresponding cells (R, C) in Grid1 and Grid2.\n5. If either Grid1(R, C) or Grid2(R, C) has a value of 2 (red), set the corresponding output grid cell Output(R, C) to 2 (red).\n6. After iterating through all cells, replace all occurrences of 0 (black) in the output grid with 8 (cyan / light blue).\n7. Replace all occurrences of 2 (red) in the output grid with 0 (black).",
    "1b60fb0c.json": "1. Input is a grid of numbers, primarily 0 (black) with a shape composed of 1 (blue). The overall shape appears as a 3-part pattern.\n2. The output grid has the same dimensions as the input grid.\n3. Identify the repeating 1 (blue) pattern within the input grid.\n4. Copy the identified 1 (blue) pattern.\n5. Place the copied pattern to the left of the existing 3-part pattern, effectively creating a symmetrical 4-part pattern.\n6. Change the color of the newly placed pattern from 1 (blue) to 2 (red).",
    "1bfc4729.json": "1. Find the first pixel with a non-zero value in the first row of the input 10x10 grid. Let this value be V1. This represents the color of the top region.\n2. Find the first pixel with a non-zero value in the last row of the input 10x10 grid. Let this value be V2. This represents the color of the bottom region.\n3. Create a new 10x10 output grid, initialized with all values set to 0.\n4. Fill the entire first row of the output grid with the value V1.\n5. Set the first and last pixels (column 0 and column 9) of the second row of the output grid to V1.\n6. Fill the entire third row of the output grid with the value V1.\n7. Set the first and last pixels (column 0 and column 9) of the fourth and fifth rows of the output grid to V1.\n8. Set the first and last pixels (column 0 and column 9) of the sixth and seventh rows of the output grid to V2.\n9. Fill the entire eighth row of the output grid with the value V2.\n10. Set the first and last pixels (column 0 and column 9) of the ninth row of the output grid to V2.\n11. Fill the entire tenth row of the output grid with the value V2.",
    "1c786137.json": "1. Analyze the input grid to identify a rectangle composed of pixels of a single, uniform value. Let this value be denoted as 'V'.\n2. Find the coordinates of the top-left corner (R1, C1) and the bottom-right corner (R2, C2) of the rectangle composed of value V.\n3. Calculate the height (H) and width (W) of the rectangle: H = R2 - R1 + 1, W = C2 - C1 + 1.\n4. Create an output grid with dimensions H x W.\n5. Copy the subgrid from the input grid, starting at (R1, C1) with height H and width W, to the output grid.\n6. Specifically, for each row R from R1 to R2, and each column C from C1 to C2, copy the pixel value from the input grid at (R, C) to the output grid at (R - R1, C - C1).",
    "1caeab9d.json": "1. Find the coordinates (R, C) of any pixel with value 1 (blue). This defines the target row. If multiple disconnected components of value 1 exist, choose any one of them to determine the target row.\n2. Find all connected components of pixels with value 2 (red). For each such component, calculate the vertical distance (number of rows) between the topmost row of the component and the target row (defined in step 1). If the component is above the target row, the distance is positive; if below, the distance is negative.\n3. For each connected component of value 2 (red), shift it vertically by the calculated distance so that its topmost row aligns with the target row. If the shift moves a pixel outside the grid boundaries, discard that pixel.\n4. Find all connected components of pixels with value 4 (yellow). For each such component, calculate the vertical distance (number of rows) between the topmost row of the component and the target row (defined in step 1). If the component is above the target row, the distance is positive; if below, the distance is negative.\n5. For each connected component of value 4 (yellow), shift it vertically by the calculated distance so that its topmost row aligns with the target row. If the shift moves a pixel outside the grid boundaries, discard that pixel.\n6. The output grid has the same dimensions as the input grid. All original pixels with value 1 (blue) remain in their original positions. The shifted 2 (red) and 4 (yellow) components, if any, are placed in their new positions. All other pixel values from the original input that were not part of a shifted component and were not value 1 are retained in place.",
    "1cf80156.json": "1. Find the connected region of non-zero pixel values within the input grid. Assume the rest of the grid is background with pixel value 0.\n2. Determine the bounding box of this connected region. The bounding box is defined by the top-most row (R_top), bottom-most row (R_bottom), left-most column (C_left), and right-most column (C_right) that contain non-zero pixel values.\n3. Create a new output grid. The height of the output grid is (R_bottom - R_top + 1), and the width is (C_right - C_left + 1).\n4. Copy the pixel values from the input grid's bounding box to the output grid. For each row R from R_top to R_bottom and each column C from C_left to C_right in the input grid, copy the pixel value at (R, C) to the corresponding location (R - R_top, C - C_left) in the output grid.",
    "1e0a9b12.json": "1. Initialize an output grid with the same dimensions as the input grid. Copy the input grid to the output grid.\n2. Iterate through each column C of the output grid, from left to right (C = 0 to width - 1).\n3. Within each column C, identify all pixel locations (R, C) where the pixel value is not 0 (i.e., not black). Store these non-zero pixel values and their original vertical positions (rows).\n4. In column C, count the number of non-zero pixels, N.\n5. Starting from the bottom row of the column (row index = height - 1), and moving upwards, fill the bottom N rows of column C with the non-zero pixel values extracted in Step 3. Maintain the original order of the non-zero pixel values from top to bottom within the column. If the number of non-zero pixel values (N) is less than the height of the column, the remaining top rows of column C will be filled with 0 (black).\n6. After processing all columns, the output grid contains the transformed image where all non-zero pixels have been moved to the bottom of their respective columns, with 0 filling the empty spaces above.",
    "1e32b0e9.json": "1. Define the input grid as a 17x17 grid. Define the top-left 5x5 subgrid as the 'source pattern'.\n2. Determine the 'grid color'. This is the color of the lines dividing the 9 5x5 subgrids in the input. Find the pixel value representing this color.\n3. Iterate through the nine 5x5 subgrids within the 17x17 grid. The subgrids are located at these top-left coordinates: (0,0), (0,6), (0,12), (6,0), (6,6), (6,12), (12,0), (12,6), (12,12).\n4. For each 5x5 subgrid:\n    a. Iterate through each pixel (R, C) within the current 5x5 subgrid.\n    b. If the pixel value at (R, C) in the input subgrid is different from the 'grid color', retain the original pixel value.\n    c. Otherwise, if the pixel value at (R, C) in the input subgrid is equal to the 'grid color', replace it with the corresponding pixel value from the 'source pattern' at the same relative coordinates (R modulo 5, C modulo 5). The grid color from step 2 should be used to complete the shapes in the 5x5 subgrids.\n5. The resulting modified 17x17 grid is the output grid.",
    "1f0c79e5.json": "1. Find the coordinates (R, C) of all pixels with value 2 (red) in the input grid.\n2. If no pixel with value 2 is found, find the most frequent pixel value in the input grid and proceed as if a pixel with that value was found in step 1. Let this value be 'V'.\n3. For each coordinate (R, C) found in step 1:\n    a. Extend a pattern of value 'V' towards the borders of the grid, originating from (R, C). The extension follows diagonal lines.\n    b. The pattern consists of a 3x3 block with the 'V' value centered on the diagonal.\n    c. Replace the original pixel value at (R, C) with the 'V' value.\n    d. Extend the value 'V' until the edges of the grid are reached from (R,C).\n4. If multiple pixels with value 2 (or the most frequent value 'V' from step 2) are present, perform the extension for each such pixel, potentially overwriting previous extensions.\n5. If the grid has a 2x2 object and one of the pixels has a value of 7 (orange), use the other color present in the 2x2 object to extend to the border.\n6. Fill the one pixel with the value 0 (black) in the border with the color used for extension. If there are no pixels with the value 0 (black) present, do not execute this step.\n7. The output grid has the same dimensions as the input grid.",
    "1f642eb9.json": "1. Find the largest connected region of pixel value 8 in the input grid. This region will be referred to as the \"target region\".\n2. Identify all non-8 pixels that are not connected to the target region. These are the \"source pixels\".\n3. For each source pixel with value V at coordinates (R, C), create a corresponding pixel with the same value V within the target region.\n4. Place each new pixel V inside the target region, as close as possible to the edge of the target region that is nearest to the original coordinates (R, C) of the source pixel V. If multiple locations are equidistant, choose one arbitrarily.\n5. The output grid has the same dimensions as the input grid. All pixels outside the target region remain unchanged.",
    "1f85a75f.json": "1. Identify the largest connected region of pixels with the same non-zero value in the input grid. If multiple regions have the same size, choose any one of them.\n2. Determine the bounding box of this identified region. The bounding box is defined by the minimum and maximum row and column indices that contain the region.\n3. Create an output grid. The height of the output grid is the difference between the maximum and minimum row indices (inclusive) of the bounding box. The width of the output grid is the difference between the maximum and minimum column indices (inclusive) of the bounding box.\n4. Copy the pixel values from the input grid's bounding box region to the output grid. The pixel at (minimum row index + R, minimum column index + C) in the input grid is copied to the pixel at (R, C) in the output grid, where R and C are row and column offsets within the bounding box.",
    "1f876c06.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. For each distinct non-zero number (1-9) in the input grid, find all locations (R1, C1) and (R2, C2) where the pixel value is the same.\n3. For each pair of locations (R1, C1) and (R2, C2) with the same pixel value:\n   a. If R1 equals R2, no diagonal line is needed for this row; continue to the next pair.\n   b. If C1 equals C2, no diagonal line is needed for this column; continue to the next pair.\n   c. Determine the direction of the diagonal. If R1 < R2 and C1 < C2, the direction is top-left to bottom-right. If R1 < R2 and C1 > C2, the direction is top-right to bottom-left. If R1 > R2 and C1 < C2, the direction is bottom-left to top-right. If R1 > R2 and C1 > C2, the direction is bottom-right to top-left.\n   d. Fill the diagonal line between (R1, C1) and (R2, C2) in the output grid with the same pixel value as the values at (R1, C1) and (R2, C2). The diagonal line consists of pixels whose row and column indices change incrementally (or decrementally) from (R1, C1) to (R2, C2).\n4. The resulting output grid contains the original input grid with added diagonal lines of matching pixel values connecting pairs of cells with the same non-zero pixel values.",
    "1fad071e.json": "1. Initialize a 5x1 output grid with all cells set to 0.\n2. Find all 2x2 subgrids within the input grid.\n3. Count the number of 2x2 subgrids that contain only the value 1.\n4. Iterate from left to right across the 5 cells of the output grid, starting at index 0.\n5. For each cell, if the current index is less than the count from step 3, set the cell value to 1.\n6. Otherwise, if the current index is greater than or equal to the count from step 3, the cell value remains 0.",
    "2013d3e2.json": "1. Find the bounding box of the non-0 (non-black) pixels in the input grid. The bounding box is defined as the smallest rectangular region that contains all non-0 pixels. Let the top-left corner of this bounding box be (R0, C0). Let the bottom-right corner be (R1, C1).\n2. Create a new 3x3 output grid, initialized with all 0s.\n3. Copy a 3x3 subgrid from the input grid, starting at the top-left corner of the bounding box (R0, C0). Specifically, copy the pixels from the input grid at locations (R0, C0), (R0, C0+1), (R0, C0+2), (R0+1, C0), (R0+1, C0+1), (R0+1, C0+2), (R0+2, C0), (R0+2, C0+1), and (R0+2, C0+2) into the corresponding locations (0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), and (2, 2) of the output grid. If the bounding box is smaller than 3x3 or is located close to the edge of the grid, then the values copied will be from inside the shape and the other values are 0. Use this subgrid as the final 3x3 output.",
    "2204b7a8.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Identify the two border colors. Let these be color A and color B, represented by numbers a and b respectively (where a != b and a, b are in the range 0-9).\n3. For each pixel with value 0 in the input grid:\n    a. Calculate the distance to the nearest pixel with value a.\n    b. Calculate the distance to the nearest pixel with value b.\n    c. If the distance to the nearest pixel with value a is less than the distance to the nearest pixel with value b, then replace the value of the pixel in the output grid with value a.\n    d. Otherwise, replace the value of the pixel in the output grid with value b.\n4. Output the modified grid.",
    "22168020.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Identify contiguous regions of non-zero pixel values in the input grid. These regions are the colored blocks.\n3. For each identified colored block, find the bounding box (minimum and maximum row and column indices) that encloses it.\n4. Within the bounding box of each colored block, identify the area of 0 pixels that are enclosed within the colored region. These are the \"black blocks\" to be filled.\n5. For each enclosed area of 0 pixels, determine the color value of the surrounding colored block. Fill the enclosed 0 pixels with the color value of the block. Specifically, for each enclosed 0, set its pixel value to the pixel value of the colored block that encloses it. If an enclosed 0 pixel is touching two different colored blocks, then select the color value that is most prominent in the surrounding region.",
    "22233c11.json": "1. Find all occurrences of diagonal lines composed of pixel value 3 (green) in the input grid.\n2. For each diagonal line of 3s found, determine its width (number of consecutive 3s forming the line).\n3. For each diagonal line of 3s, identify the pixels immediately adjacent to the line on both sides, moving perpendicularly from the diagonal line's direction.\n4. The distance between the edge of the 3 (green) line and the start of the added 8 (cyan/light blue) line should be equal to the width of the green line. Skip this number of pixels.\n5. Place a line of pixel value 8 (cyan/light blue) on each side of the diagonal 3 (green) line. The length of this 8 (cyan/light blue) line should be equal to the width of the original diagonal 3 (green) line.\n6. The output grid should have the same dimensions as the input grid, with the added 8 (cyan/light blue) lines in the specified locations. All other pixel values remain unchanged.",
    "2281f1f4.json": "1. Input: The input grid contains values. Identify all cells with value 5 (grey) along the top row and the rightmost column. These are the reference cells. Let the coordinates of the grey cells on the top row be (0, C), where C is the column index. Let the coordinates of the grey cells on the rightmost column be (R, W-1), where R is the row index, and W is the width of the grid. \n2. Output Grid Size: The output grid has the same dimensions (height and width) as the input grid.\n3. Transformation: For each cell (R, C) in the output grid, check the following condition: Is there a cell with value 5 at (0, C) AND a cell with value 5 at (R, W-1)? If this condition is true, then set the value of the cell (R, C) in the output grid to 2 (red). Otherwise, keep the original value from the input grid at cell (R, C) in the output grid.",
    "228f6490.json": "1. Find all regions of value 5 (grey) in the input grid. These regions represent the areas with 'holes'.\n2. For each region of value 5, identify the shape of the hole within the region.\n3. Find other regions in the input grid consisting of values other than 0 and 5. These are the candidate shapes to fill the holes.\n4. For each region of value 5 (grey), iterate through the candidate shapes (regions of other values).\n5. Determine if a candidate shape perfectly fits the hole in the current grey region. 'Perfectly fits' means the shape matches the hole's dimensions and structure exactly.\n6. If a candidate shape fits the hole, replace the pixels with value 5 within the hole with the value of the pixels comprising the shape.\n7. The output grid has the same dimensions as the input grid.\n8. If no shape perfectly fits a particular hole, leave that hole unchanged (value 5).",
    "22eb0ac0.json": "1. Copy the input grid to the output grid, maintaining the original dimensions.\n2. Iterate through each row R of the grid.\n3. For each row R, compare the value of the pixel at the first column (column 0) with the value of the pixel at the last column (column N-1, where N is the number of columns).\n4. If the pixel value at (R, 0) is equal to the pixel value at (R, N-1), then replace the value of all pixels in row R with the value of the pixel at (R, 0).\n5. If the pixel value at (R, 0) is not equal to the pixel value at (R, N-1), then do not modify row R.",
    "234bbc79.json": "1. Identify three distinct shapes within the input grid. These shapes are separated by columns of 0s (black). Shapes contain a primary color and 5s (grey). The grid is likely 11x3.\n2. Remove any column containing only 0s (black) that separates the shapes. The output grid will likely be 9x3.\n3. For each shape, replace all 5s (grey) with the value of the non-5 (non-grey) pixel within that shape. This will require identifying the 'main' color of each shape.\n4. Vertically align the shapes so they form a single connected object. The middle shape must be moved either up or down to achieve this. The position it must move towards is the position of the end of the left shape with 5s.\n5. Create the output grid by concatenating the modified shapes horizontally, in left-middle-right order. Ensure that the connected shapes are touching the shapes to one another, where the connecting pixel used to be a 5 (grey).",
    "23581191.json": "1. Find the coordinates and color of the two squares in the input grid. Let Square 1 have color value V1 at coordinates (R1, C1) and Square 2 have color value V2 at coordinates (R2, C2). The background color is 0.\n2. Create an output grid of the same dimensions as the input grid, initialized with 0s.\n3. For each row R in the output grid:\n    a. If R equals R1, for each column C in the output grid at (R, C), set the pixel value to V1.\n    b. If R equals R2, for each column C in the output grid at (R, C), set the pixel value to V2.\n4. For each column C in the output grid:\n    a. If C equals C1, for each row R in the output grid at (R, C), set the pixel value to V1.\n    b. If C equals C2, for each row R in the output grid at (R, C), set the pixel value to V2.\n5. For each pixel in the output grid at (R, C):\n    a. If the pixel value equals V1 and R equals R2, or the pixel value equals V1 and C equals C2, set pixel value to 2.\n    b. If the pixel value equals V2 and R equals R1, or the pixel value equals V2 and C equals C1, set pixel value to 2.\n    c. If the pixel value equals V1 at coordinate (R, C) and there exists coordinate (R', C') such that R==R2 and C==C1, set pixel value at (R, C) to 2.\n    d. If the pixel value equals V2 at coordinate (R, C) and there exists coordinate (R', C') such that R==R1 and C==C2, set pixel value at (R, C) to 2.\n6. Return the modified output grid.",
    "239be575.json": "1. Analyze the input grid. It contains a grid mostly filled with value 1, two squares of value 2, and a background of value 0. Determine if the placement of the value 2 squares follows a specified positional rule or pattern.\n2. If the input grid conforms to the positional rule: The output grid will be a single cell grid. The value of this single cell will be determined by extracting a value from the input grid. Specifically, extract the value from the cell located 5 rows down and 3 columns across from the top-left corner (coordinate (0,0)). The extracted value becomes the value of the output grid's single cell.\n3. If the input grid does NOT conform to the positional rule: Create an output grid of the same size as the input grid. The output grid's cells will all have the value 0, or all have the value of one of the other two colors present in the input (either all 1 or all 2).",
    "23b5c85d.json": "1. Find all distinct numbers in the input grid.\n2. For each distinct number, identify all connected regions of that number. A connected region is a set of pixels with the same number where each pixel is adjacent to at least one other pixel in the region (horizontally or vertically).\n3. Calculate the area of each connected region by counting the number of pixels it contains.\n4. Find the connected region with the smallest area among all distinct numbers.\n5. Determine the height and width of the smallest area region. These will be the height and width of the output grid.\n6. Create a new grid with the determined height and width.\n7. Fill the entire output grid with the number corresponding to the smallest area region.",
    "253bf280.json": "1. Input: Identify all pixels with value 8 (light blue). These are the target pixels.\n2. Output Grid Size: The output grid has the same dimensions as the input grid.\n3. For each row in the grid:\n 3.1. Find the leftmost and rightmost target pixels (value 8) in that row. If fewer than two target pixels exist in the row, proceed to the next row.\n 3.2. For all pixels between the leftmost and rightmost target pixels (inclusive) in that row, if the pixel value is not 8, set the pixel value to 3 (green).\n4. For each column in the grid:\n 4.1. Find the topmost and bottommost target pixels (value 8) in that column. If fewer than two target pixels exist in the column, proceed to the next column.\n 4.2. For all pixels between the topmost and bottommost target pixels (inclusive) in that column, if the pixel value is not 8, set the pixel value to 3 (green).",
    "25d487eb.json": "1. Identify the input grid. The input grid contains a pattern, possibly a structure with a base. Assume the base has a length of 5. The central cell of the base may have a different value than the other cells of the base. The output grid has the same dimensions as the input grid.\n2. Find the value of the center cell of the base. Call this value 'center_value'.\n3. Starting from the top row of the grid and moving downwards, fill the column corresponding to the center of the base with the 'center_value'.\n4. Continue filling the column until the edge of the grid is reached.",
    "25d8a9c8.json": "1. Get the input grid. The output grid will have the same dimensions as the input grid.\n2. Iterate through each row R of the input grid, from top to bottom.\n3. For each row R, find the unique pixel values present in that row.\n4. If the number of unique pixel values in row R is 1 (meaning all pixel values in that row are the same):\n   a. Set all pixel values in the corresponding row R of the output grid to 5 (grey).\n5. Otherwise (if the number of unique pixel values in row R is greater than 1):\n   a. Set all pixel values in the corresponding row R of the output grid to 0 (black).\n6. The output grid is now complete.",
    "25ff71a9.json": "1. Input: A grid of integers (0-9). Assume a 3x3 grid size if not explicitly defined in the input.\n2. Identify all cells in the input grid with the value 1 (representing blue).\n3. Create an output grid of the same dimensions as the input grid.\n4. Initialize all cells in the output grid with the value 0 (representing black).\n5. For each cell with value 1 at location (R, C) in the input grid, place the value 1 into the cell at location (R+1, C) in the output grid. If R+1 exceeds the grid height, wrap around to row 0. That is, if R+1 is equal to the grid height, place the value 1 into the cell at (0, C) in the output grid.\n6. The output grid now contains the transformed grid, where all 1 values have been shifted down by one row, wrapping around the top if necessary.",
    "264363fd.json": "1. Analyze the input grid and identify distinct regions bounded by a background color (assume background color is 0). These are considered \"boxes\".\n2. Within each \"box\", identify if there is a smaller \"shape\" present. The shape is defined as a connected component of non-background pixels. If no shape is found in a box, proceed to the next box.\n3. Determine the \"center\" pixel of the detected \"shape\" within each \"box\".\n4. Identify the color (numerical value) of the center pixel.\n5. Iterate through all pixels within the current box. If a pixel has the same color value as the center pixel identified in step 4, replace the pixel value with the entire \"shape\", centering the shape on that pixel. Overlapping shape pixels take precedence, but do not extend beyond the bounds of the box (defined by the background color, 0). If the shape extends outside the grid boundaries, clip it.\n6. Identify all pixels within a two-pixel radius (horizontally and vertically) of the center of the placed shape (excluding diagonals). These are considered the \"extension points\".\n7. For each \"extension point\", note its color value.\n8. For each \"extension point\", extend a line of pixels with the same color value as the extension point until it reaches the edge of the current \"box\" (defined by encountering the background color 0). Extend the line both horizontally and vertically from each \"extension point\". Do not extend into the background color (0).\n9. Repeat steps 2-8 for each \"box\" in the input grid.\n10. The result is the transformed grid.",
    "272f95fa.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid. \n2. Identify regions bounded by values of 8 (cyan/light blue). Assume the input grid contains two horizontal and two vertical lines of value 8 on a background of value 0 (black).\n3. Exclude the four corner regions formed by these lines from subsequent modifications.\n4. Fill the upper-middle region with value 2 (red).\n5. Fill the left-middle region with value 4 (yellow).\n6. Fill the center region with value 6 (pink).\n7. Fill the right-middle region with value 3 (green).\n8. Fill the bottom-middle region with value 1 (blue).",
    "27a28665.json": "1. Input is a 3x3 grid with each cell containing an integer value between 0 and 9.\n2. Analyze the input grid to identify specific patterns. The following patterns should be checked in order:\n3. Pattern 1: If the grid contains an inverted cross pattern (cells (0,0), (0,2), (2,0), and (2,2) have a specific non-zero value, and the rest of the grid cells are different from this value), then output a 3x3 grid where all cells have the value 2.\n4. Pattern 2: If the grid contains a 2x2 square of a specific non-zero value in the upper right corner ((0,1), (0,2), (1,1), (1,2)), and cell (2,0) also has this specific value, then output a 3x3 grid where all cells have the value 3.\n5. Pattern 3: If the grid contains a cross pattern (cells (0,1), (1,0), (1,2), (2,1) have a specific non-zero value), then output a 3x3 grid where all cells have the value 6.\n6. Pattern 4: If the grid contains an inverted cross pattern (cells (0,0), (0,2), (2,0), and (2,2) have a specific non-zero value) and cell (0,0) has a specific non-zero value, then output a 3x3 grid where all cells have the value 1.\n7. Pattern 5: If the grid contains two lines of length 2 of value 0, one coming down from the top left ((0,0), (1,0)) and one going left from the bottom right ((2,2),(2,1)), then output a 1x1 grid with value 3.\n8. Pattern 6: If the grid contains a cross of value 5, where cells (0,1), (1,0), (1,2), (2,1) all have value 5, and cell (1,1) also has value 5, then output a 1x1 grid with value 6.\n9. Pattern 7: If the grid contains a cross of value X (X != 0), where cells (0,1), (1,0), (1,2), (2,1) all have value X, and cell (1,1) has a value different than X and 0, then output a 1x1 grid with value 7.\n10. Pattern 8: If the grid contains a cross of value X (X != 0), where cells (0,1), (1,0), (1,2), (2,1) all have value X, and cell (1,1) has value 0, and cell (0,0) has value X, then output a 1x1 grid with value 1.\n11. Pattern 9: If cells (0,1), (1,0), (1,2), (2,1) have value X and cell (1,1) has value 0, and the cell (0,0) has value X, then output a 3x3 grid where all cells have the value 1.\n12. Pattern 10: If the cells (0,1), (1,0), (1,2), (2,1) form a cross of the same value, the output is a 3x3 grid where each cell has the value 6.\n13. If none of the above patterns match, output the input grid as is.",
    "28bf18c6.json": "1. Find the non-zero shape or figure present in the input grid. This shape may be composed of multiple different numbers (1-9) representing different colors.\n2. Determine the height of the input grid.\n3. Create a new output grid with a height of 3 and a width of 6.\n4. Resize the extracted shape to fit within the output grid. This implies zooming or scaling the shape.\n5. Copy the resized shape into the left half of the output grid (coordinates 0 to 2 in height, 0 to 2 in width, indexed from 0).\n6. Copy the resized shape again into the right half of the output grid (coordinates 0 to 2 in height, 3 to 5 in width, indexed from 0).",
    "28e73c20.json": "1. Assume an input grid filled entirely with the value 0.\n2. Create an output grid with the same dimensions as the input grid.\n3. Initialize the output grid with the value 0.\n4. Start at the top-left corner of the output grid, coordinate (0, 0).\n5. Traverse the outer border of the grid in a clockwise spiral, assigning the value 3 to each cell.\n6. At each corner of the spiral, stop one cell short of completing the full border.\n7. Continue this clockwise spiral pattern, assigning the value 3 to each cell, until reaching the center of the grid.\n8. The final output grid contains a spiral pattern of 3's on a background of 0's, spiraling inwards from the outer edges towards the center.",
    "29623171.json": "1. Divide the input grid into 9 equally sized boxes. Each box contains some number of pixels with values from 0 to 9. The boxes are arranged in a 3x3 grid.\n2. Within each of the 9 boxes, count the number of pixels that are NOT 0. This represents the 'colored' pixels in each box.\n3. Find the box or boxes with the maximum count of non-0 pixels.\n4. Create an output grid with the same dimensions as the input grid, also divided into 9 equally sized boxes in a 3x3 arrangement.\n5. For each box in the output grid:\n   a. If the corresponding box in the input grid had the maximum count of non-0 pixels (as determined in step 3):\n      i. Identify the color of this box by identifying the most frequent non-zero pixel value in the corresponding input box. If there are multiple most frequent non-zero pixel values, choose the smallest of those values.\n      ii. Fill the entire corresponding output box with this most frequent pixel value.\n   b. Otherwise (if the corresponding input box did NOT have the maximum count):\n      i. Fill the entire corresponding output box with the pixel value 0.",
    "29c11459.json": "1. Analyze each row of the input grid (5x11). The following steps are performed independently on each row.\n2. Identify the value of the leftmost pixel in the row.\n3. Copy this pixel value. Add four additional pixels with this same value to the right of the original pixel.\n4. Insert a pixel with value 5 (grey) to the right of the constructed block of 5 pixels.\n5. Identify the value of the rightmost pixel in the row.\n6. Copy this pixel value. Add four additional pixels with this same value to the left of the rightmost pixel.\n7. Place the two blocks (the block from the left, the grey pixel, and the block from the right) next to each other into a row to generate the output row.",
    "29ec7d0e.json": "1. Analyze the input grid. Identify areas filled with multiple colors. These areas may contain black squares (pixel value 0).\n2. Identify reference blocks within the input grid. These reference blocks contain the correct color patterns without any black squares (pixel value 0).\n3. For each black square (pixel value 0) in the multi-color areas:\n    a. Determine its coordinates (R, C) within the input grid.\n    b. Use the corresponding reference block to determine the correct color (pixel value) that should be at location (R, C).\n    c. Replace the black square (pixel value 0) at (R, C) with the correct color (pixel value) obtained from the reference block.\n4. The output grid has the same dimensions as the input grid. It is the modified input grid where all black squares (pixel value 0) in the multi-color areas have been replaced with the correct corresponding color values.",
    "2bcee788.json": "1. Identify two distinct shapes in the input grid, each composed of a single, non-0 color (number) on a 0 background.\n2. Determine the size (number of pixels) of each shape.\n3. Identify the larger shape (the one with more pixels) and the smaller shape.\n4. Create an output grid of the same dimensions as the input grid and fill it with the background color 3 (green).\n5. Copy the larger shape to the output grid, maintaining its original position and color.\n6. Determine the relative position of the smaller shape with respect to the larger shape.  The relative position will define the axis of mirroring.\n7. Create a mirrored copy of the larger shape. The mirroring should occur along the edge of the larger shape that is closest to the smaller shape in the original input.\n8. Place the mirrored copy of the larger shape on the output grid, directly adjacent to the original larger shape, along the mirroring axis determined by the position of the smaller shape. Overlap with the original larger shape is not allowed; the mirrored shape should be placed such that it is touching, but not overlapping, the original shape. Any part of the mirrored shape that would overlap the original shape should be discarded. This ensures that the mirrored shape replaces the area previously occupied by the smaller shape.",
    "2bee17df.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Identify edge pixels that are only one pixel deep around the outside of the grid.\n3. From each identified edge pixel, draw a straight line (using pixel value 3) horizontally and vertically to connect it to another edge pixel on the opposite side of the grid that is also only one pixel deep. The lines should only connect to other edge pixels that are one pixel deep. If a connection is impossible, no line is drawn.\n4. In the area separated by pixels with value 0, draw a 'T' shape. The horizontal bar of the 'T' should be made of pixels with value 3. A vertical bar of the 'T', also using pixel value 3, should extend downwards from the center of the horizontal bar.\n5. In the top right and bottom left portions of the grid, alternate pixels with values 1 and 2, starting with 1. This area should be a bordered region.\n6. Set the first row to pixel value 1. \n7. In the second row, set pixels from the 7th to the 12th column to pixel value 1.\n8. In the second row, set pixels at the 8th, 9th and 12th columns to pixel value 1.\n9. In the last row, set pixels from the 9th row down to pixel value 1 in the same column.\n10. Fill pixel value 3 in the cross and down rows.\n11. Fill pixel value 3 in the 5th row down, first column for 10 steps.\n12. Repeat filling pixel value 3 in the 4th row down the same way.",
    "2c608aff.json": "1. Find the central block(s) in the input grid. The central block(s) are defined as the contiguous non-zero region closest to the grid center. If multiple such regions exist, select the largest. If the size is the same, select the one with the smallest row, then smallest column. Let (R_center, C_center) denote the row and column indices of the top-left pixel of the central block(s). If the central block(s) occupy multiple cells, use the coordinates of the top-left corner. \n2. Iterate through all non-zero pixels outside the central block(s) in the input grid. Let (R, C) denote the row and column indices of the current non-zero pixel with value 'V'.\n3. For each pixel (R, C) with value V, check if there exists a straight, unobstructed path between (R, C) and any pixel within the central block(s). An unobstructed path means that all pixels between (R, C) and (R_center, C_center) in the same row or same column are 0.\n4. If a horizontal path exists: Check if all pixels between (R, C) and (R, C_center) are 0. If true, set all pixels between (R, C) and (R, C_center) to V.\n5. If a vertical path exists: Check if all pixels between (R, C) and (R_center, C) are 0. If true, set all pixels between (R, C) and (R_center, C) to V.\n6. The output grid has the same dimensions as the input grid. The pixels in the output grid are determined by the above steps.",
    "2dc579da.json": "1. Divide the input grid into four equal quadrants.\n2. Identify the quadrant that contains a square with a value different from the value of the majority of the squares in the input grid.\n3. Copy the identified quadrant.\n4. Create an output grid with the same dimensions as the identified quadrant.\n5. Paste the copied quadrant into the output grid.",
    "2dd70a9a.json": "1. Find all pixels with value 2 (red) and all pixels with value 3 (green) in the input grid.\n2. The output grid has the same dimensions as the input grid.\n3. For each pair of 2 (red) and 3 (green) pixels, draw a line between them using the following procedure:\n    a. Start at the 3 (green) pixel.\n    b. Extend a line of 3 (green) pixels towards the nearest 2 (red) pixel in a straight line (either horizontally or vertically first, then orthogonally to reach the 2 (red) pixel).\n    c. If the line encounters a pixel with value 8 (cyan/light blue), change the line's color to 2 (red) and continue the line towards the 2 (red) pixel until the 2 (red) pixel is reached.\n    d. If multiple 2 (red) pixels exist, connect each 3 (green) pixel to its closest 2 (red) pixel, as described above.\n    e. Update the output grid with the newly drawn lines.\n4. The remaining pixels in the output grid should retain their original values from the input grid. ",
    "2dee498d.json": "1. Find a repeating pattern of numbers (0-9) in the input grid. The pattern is repeated at least twice, usually three times, from left to right. \n2. Determine the width and height of a single instance of the repeating number pattern. This defines the output grid dimensions.\n3. Create a new output grid with the determined width and height.\n4. Copy the pixel values (0-9) from one instance of the identified number pattern in the input grid to the corresponding locations in the output grid. Specifically, for each row R and column C within the bounds of the single pattern:\n   a. Identify the pixel value at (R, C) within one instance of the repeating pattern in the input.\n   b. Assign this pixel value to the location (R, C) in the output grid.",
    "31aa019c.json": "1. Create an output grid with the same dimensions as the input grid. 2. Initialize all cells in the output grid to 0. 3. Find the unique pixel value in the input grid, meaning the pixel value that appears only once. 4. Locate the coordinates (R, C) of this unique pixel value in the input grid. 5. Copy the unique pixel value from the input grid to the corresponding coordinates (R, C) in the output grid. 6. Starting from the unique pixel at (R, C) in the output grid, surround this pixel with value 2, expanding outwards in all directions until a square of value 2 is formed around the unique pixel.",
    "321b1fc6.json": "1. Identify the multi-colored structure in the input grid. Let this be Structure A.\n2. Identify the single-colored structures in the input grid. These structures should all have the same color. Let this be Structure B and let 'X' be the color (numerical value) of Structure B.\n3. Replace all instances of the single color 'X' within Structure B with the corresponding pixel values from Structure A, effectively copying the multi-colored pattern of Structure A onto all locations where Structure B was found.\n4. Replace Structure A in its original location with black pixels (pixel value 0).",
    "32597951.json": "1. Identify all connected regions of pixel value 8, representing an incomplete rectangle.\n2. Determine the bounding box (minimum and maximum row and column indices) that encloses the region of pixel value 8.\n3. Iterate through all pixels within the bounding box.\n4. For each pixel within the bounding box, if the pixel's value is 1, change the pixel's value to 3.\n5. The output grid has the same dimensions as the input grid. All pixels outside the bounding box remain unchanged.",
    "3345333e.json": "1. Identify the dominant pixel value (V) in the input grid. This value represents the primary pattern. If there is more than one pattern determine which pattern have a square pattern connected to it.\n2. Identify a rectangular region (box) within the grid that has a different pixel value (B) than V. This box intersects or is adjacent to the primary pattern (V).\n3. Replace all pixels within the identified box (having pixel value B) with the dominant pixel value V.\n4. Find the vertical center of the original pattern.\n5. Mirror the pattern horizontally across the vertical center. For each pixel at (R, C) in the pattern, if the pixel at (R, width - 1 - C) is not the same color as the original pattern, change this pixel to the same color as the original pattern.",
    "3428a4f5.json": "1. Find the row in the input grid that contains only pixel value 4 (yellow). This row separates the top and bottom patterns. Let this row index be Y.\n2. Define the top pattern as the subgrid from row 0 to row Y-1 (exclusive of row Y). Define the bottom pattern as the subgrid from row Y+1 to the end of the input grid.\n3. Determine the height and width of the top pattern. Let the height be H and the width be W. The output grid will have dimensions H x W.\n4. Create an empty output grid of size H x W, filled with the value 0 (black) initially.\n5. Iterate through each pixel at position (R, C) in the output grid, where R ranges from 0 to H-1 and C ranges from 0 to W-1.\n6. For each pixel (R, C) in the output grid:\n    a. Get the pixel value from the top pattern at (R, C). Let this value be T.\n    b. Get the pixel value from the bottom pattern at (R, C). Let this value be B.\n    c. If T is 2 (red) and B is 2 (red), set the output grid pixel at (R, C) to 0 (black).\n    d. If T is 2 (red) and B is 0 (black), set the output grid pixel at (R, C) to 3 (green).\n    e. If T is 0 (black) and B is 2 (red), set the output grid pixel at (R, C) to 3 (green).\n    f. If T is 0 (black) and B is 0 (black), set the output grid pixel at (R, C) to 0 (black).\n    g. Otherwise if T and B are same, set the output grid pixel at (R, C) to 0 (black).\n    h. Otherwise (if T and B are different and not in the cases above), set the output grid pixel at (R, C) to a different color. A reasonable default is 5 (grey).\n7. The resulting output grid is the solution.",
    "3618c87e.json": "1. Initialize the output grid with the same dimensions as the input grid.\n2. Initialize all cells in the output grid with value 5 (grey).\n3. Find all locations (R, C) in the input grid where the pixel value is 1 (blue).\n4. For each location (R, C) found in step 3, set the pixel value at (R+2, C) in the output grid to 1 (blue). If R+2 exceeds the grid height, skip this location.\n5. Set the pixel value at (R+1, C) in the output grid to 0 (black). If R+1 exceeds the grid height, skip this location.",
    "3631a71a.json": "1. Copy the input grid to the output grid. The input grid contains a symmetrical pattern, with some areas covered by shapes of a different numerical value than the underlying pattern.\n2. Iterate through each cell (R, C) in the grid.\n3. If the value at cell (R, C) is different from the surrounding pattern, consider this cell part of a shape that needs mirroring.\n4. For each such cell (R, C), find its horizontal mirror coordinate (R, C_mirrored) where C_mirrored = grid_width - 1 - C and its vertical mirror coordinate (R_mirrored, C) where R_mirrored = grid_height - 1 - R.\n5. Replace the value at cell (R, C) with the value found at its horizontal mirror coordinate (R, C_mirrored).\n6. Replace the value at cell (R, C) with the value found at its vertical mirror coordinate (R_mirrored, C).\n7. Replace the value at cell (R, C) with the average of the values found at its horizontal mirror coordinate (R, C_mirrored) and its vertical mirror coordinate (R_mirrored, C).\n8. Handle edge cases where either the horizontal or vertical mirror coordinate falls outside the grid boundaries by reflecting the value from the existing grid cell.\n9. Ensure that only the shape areas are changed, and that the underlying symmetrical pattern remains intact.",
    "363442ee.json": "1. Find the grid's dimensions (rows, columns). The output grid will have the same dimensions.\n2. Identify a 3x3 pattern located on the left side of the input grid. This pattern will be used as a template.\n3. Locate all occurrences of the pixel value '1' (blue) in the input grid.\n4. For each location (R, C) where the pixel value is '1', perform the following steps:\n    a. Extract the 3x3 pattern from the input grid, ensuring it remains within the grid boundaries.\n    b. Superimpose the 3x3 pattern onto the output grid, centering it at location (R, C). This means the center pixel of the 3x3 pattern replaces the '1' at location (R, C).\n        i. Iterate through the 3x3 pattern. Let (r, c) be the coordinates relative to the center of the pattern (e.g., -1, 0, or 1).\n        ii. Calculate the corresponding coordinates in the output grid: (R + r, C + c).\n        iii. If (R + r, C + c) is within the bounds of the output grid, replace the pixel value at that location with the pixel value from the 3x3 pattern at (r+1, c+1) where the origin of the 3x3 pattern is (0,0).\n5. If a blue square is near the edge of the input grid such that the 3x3 pattern goes out of bounds, only copy the portion of the pattern that falls within the bounds of the output grid. Pixels in the output grid that are not covered by any 3x3 pattern remain unchanged from the input grid. \n6. The final output grid should have the same dimensions as the input grid, with the 3x3 pattern copied onto each location where a '1' was present in the input.",
    "36d67576.json": "1. Identify shapes in the input grid containing the value 4 (yellow). These are the target shapes.\n2. From the input grid, identify a single shape containing the value 4 (yellow) that also contains the value 1 (blue) and 3 (green). This is the key shape.\n3. Extract the pattern of 1 (blue) and 3 (green) values within the key shape.\n4. For each target shape identified in step 1 (other than the key shape itself), replace the existing pattern of values within the shape with the extracted pattern of 1 (blue) and 3 (green) values from the key shape.\n5. Identify L shapes containing the value 4 (yellow).\n6. Add pixels with value 1 (blue) at locations that are 2 and 4 pixels vertically to the right of vertical lines of 4 (yellow) pixels within the L shapes.\n7. Add pixels with value 3 (green) to the top of horizontal lines of 4 (yellow) pixels within the L shapes.\n8. Remove pixels with value 3 (green) from within the identified 4 (yellow) L shapes.",
    "36fdfd69.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Identify all locations (R, C) in the output grid where the pixel value is 2 (red).\n3. For each identified location (R, C) with pixel value 2, examine its neighboring pixels. Consider a neighborhood of directly adjacent pixels (up, down, left, right).\n4. If a neighboring pixel of a pixel with value 2 also has a pixel value of 2, then fill the path between these two pixels with value 4 (yellow). Only fill if the intermediate pixel values are not 0 (black). Specifically, if pixel value 2 at location (R1, C1) is next to pixel value 2 at location (R2, C2), check the intermediate locations along the row or column. If those intermediate locations are not 0, change them to 4.\n5. Treat connected regions of pixels with value 2 as shapes. Fill the direct connections between these regions with the value 4. The filling will result in connected shapes consisting of pixels with value 2 and 4.\n6. The output grid now contains the original grid, but with the connections between pixels with value 2 filled with the value 4.",
    "3906de3d.json": "1. Input: The input is a grid of numbers, with pixel values 0, 1, and 2. The grid contains a pattern of 1s (blue) across the top and 2s (red) toward the bottom, with a background of 0s (black). \n2. Output Grid Size: The output grid will have the same dimensions as the input grid.\n3. Transformation: The goal is to move all the 2s (red) upwards to fill any 0s (black) that exist above them, stopping when a 1 (blue) is encountered.\n4. Algorithm:\n   a. Iterate through each column, C, of the grid from left to right.\n   b. Within each column, C, iterate through each row, R, from bottom to top.\n   c. If the pixel value at (R, C) is 2 (red):\n      i. Move the 2 (red) upwards in the column until a 1 (blue) or the top of the grid is reached, or a non-zero number is encountered.\n      ii. Specifically, check the pixel value at (R-1, C). If it is 0 (black), swap the values at (R, C) and (R-1, C), and repeat this step, moving the 2 upwards, decrementing R each time, until either R-1 is outside the grid boundaries, the value at (R-1, C) is 1 (blue), or the value at (R-1,C) is not 0.\n",
    "39a8645d.json": "1. Identify all distinct 3x3 subgrids within the input grid. Treat each unique arrangement of numbers (0-9) within a 3x3 block as a distinct pattern. The background is 0.\n2. For each distinct 3x3 pattern, count its occurrences within the input grid.\n3. Determine the 3x3 pattern with the highest occurrence count. If multiple patterns have the same highest count, arbitrarily select one.\n4. Create a 3x3 output grid.\n5. Copy the numbers from the most frequent 3x3 pattern found in step 3 into the 3x3 output grid. This results in a zoomed-in view of the most frequent pattern.",
    "39e1d7f9.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Find all locations (R, C) in the input grid where the pixel value is 3 (green).\n3. For each location (R, C) where the pixel value is 3:\n    a. If the pixel at (R-1, C) is also 3 and no other neighboring pixels are 3, change the pixel value at (R-1, C) to 3. This effectively handles isolated green pixels in the top.\n    b. If the pixel at (R, C-1) is also 3 and no other neighboring pixels are 3, change the pixel value at (R, C-1) to 3. This handles isolated green pixels to the left.\n    c. If the pixel at (R, C+1) is also 3 and no other neighboring pixels are 3, change the pixel value at (R, C+1) to 3. This handles isolated green pixels to the right.\n4. Find all locations (R, C) in the input grid where the pixel value is 6 (pink).\n5. For each location (R, C) where the pixel value is 6:\n    a. If the pixel at (R-1, C) is also 6, do nothing.\n    b. If the pixel at (R, C-1) is also 6, do nothing.\n    c. If the pixel at (R, C+1) is also 6, do nothing.\n6. Identify a shape composed of a center color x surrounded by squares composed of color y. In this case we will be dealing with green and pink pixels.\n7. Replicate the surrounding color y shape around every instance of color x squares. Done.",
    "3aa6fb7a.json": "1. Identify incomplete squares in the input grid. These squares are each missing one corner.\n2. Determine the coordinates of the missing corner pixel for each incomplete square.\n3. For each identified missing corner, fill the corresponding pixel with the value 1 (blue).",
    "3ac3eb23.json": "1. Get the input grid dimensions (rows, columns). The output grid will have the same dimensions.\n2. Initialize the output grid with 0s (black).\n3. Examine the first row of the input grid. Identify the non-zero numerical values (representing colors) in the first row. These values determine the checkerboard patterns to be created.\n4. For each unique non-zero numerical value (color) 'C' found in the first row of the input grid, perform the following:\n    a. Find the column index 'StartCol' of the cell containing the value 'C' in the first row.\n    b. Starting from the first row (row index 0) and the column 'StartCol', create a checkerboard pattern downwards:\n        i. In the current row 'R', set the cell at (R, StartCol) to the color value 'C'.\n        ii. In the next row (R+1), set the cells at (R+1, StartCol-1) and (R+1, StartCol+1) to the color value 'C'. If StartCol - 1 or StartCol + 1 are out of bounds (less than 0 or greater than or equal to the number of columns), skip setting that specific cell. If StartCol is 0 then only set StartCol + 1; If StartCol is maximum, only set StartCol - 1.\n       iii. In the next row (R+2), set the cell at (R+2, StartCol) to the color value 'C'.\n        iv. Repeat steps i-iii for subsequent rows, incrementing R by 3 each time, until the bottom of the grid is reached. Note that the values of StartCol-1 and StartCol+1 are only set on rows that are 1 modulo 3, the center column value is set on rows 0 and 2 modulo 3. Ensure that you stop setting values when R is greater than or equal to the number of rows.\n5. If multiple colors are present in the first row of the input grid, repeat step 4 for each color, handling them independently and potentially overlapping their checkerboard patterns in the output grid.",
    "3af2c5a8.json": "1. Define the input grid. Let its dimensions be I_ROWS and I_COLS.\n2. Create an output grid of size 6x8. Let its dimensions be O_ROWS = 6 and O_COLS = 8.\n3. Copy the input grid to the top-left corner of the output grid. Specifically, for each row R from 0 to I_ROWS-1, and each column C from 0 to I_COLS-1, set output_grid[R][C] = input_grid[R][C].\n4. Mirror the input grid vertically (downwards) to fill the bottom half of the output grid. For each row R from I_ROWS to O_ROWS-1, and each column C from 0 to I_COLS-1, set output_grid[R][C] = input_grid[I_ROWS - 1 - (R - (I_ROWS - 1))][C].\n5. Mirror the left half of the output grid horizontally (rightwards) to fill the right half of the output grid. For each row R from 0 to O_ROWS-1, and for each column C from I_COLS to O_COLS-1, set output_grid[R][C] = output_grid[R][I_COLS - 1 - (C - (I_COLS - 1))].",
    "3bd67248.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Fill the bottom row (last row) of the output grid with the value 4, starting from the second column (index 1). The pixel at row (last row) and the first column (index 0) remains unchanged.\n3. Draw a diagonal line with the value 2, starting from the second column (index 1) of the bottom row (last row) and extending to the top right corner of the grid. This diagonal line overwrites existing values. In other words, set the pixel at (R, C) to 2, where R starts at the last row and decrements, and C starts at index 1 and increments, until either R reaches 0 or C reaches the last column. Make sure the diagonal starts from the second column in the last row.",
    "3bdb4ada.json": "1. Identify connected regions of the same non-zero pixel values in the input grid. These regions represent shapes.\n2. For each identified shape:\n3. Determine the bounding box of the shape (min row, min col, max row, max col).\n4. Iterate through the interior of the bounding box (excluding the border pixels):\n5. For each pixel (R, C) within the bounding box's interior:\n6. If the pixel (R, C) lies within the shape (i.e., has the same value as the shape's color) then change the pixel value to 0.",
    "3befdf3e.json": "1. Copy the input grid to the output grid. The output grid dimensions are the same as the input grid dimensions.\n2. Identify the two distinct numbers (representing colors) present in the input grid. Let's call them 'outer_number' and 'inner_number'. Assume that 'outer_number' represents the number of the outer square and 'inner_number' represents the number of the inner square.\n3. Invert the numbers in the output grid: replace all instances of 'outer_number' with 'inner_number', and replace all instances of 'inner_number' with 'outer_number'.\n4. Determine the dimensions of the inner square. Let's denote these dimensions as inner_height and inner_width.\n5. Add a border of 'outer_number' around the existing outer square. The thickness of this border depends on the size of the inner square:\n    a. If inner_height is 1 and inner_width is 1, add a border of dimensions 3x1 to the top and bottom, and 1x3 to the left and right of the outer square, using 'outer_number'.\n    b. If inner_height is 2 and inner_width is 2, add a border of dimensions 4x2 to the top and bottom, and 2x4 to the left and right of the outer square, using 'outer_number'.\n    c. If the inner square has dimensions other than 1x1 or 2x2, then add two rows/columns of 'outer_number' on each side of the outer square.",
    "3c9b0459.json": "1. Get the input grid. The grid contains integer values from 0 to 9.\n2. Determine the dimensions of the input grid: number of rows (R) and number of columns (C).\n3. Create an output grid with the same dimensions (R x C) as the input grid.\n4. Iterate through each cell of the input grid, using row index r (from 0 to R-1) and column index c (from 0 to C-1).\n5. For each cell at input grid coordinates (r, c), copy the value at that location to the output grid at coordinates (R-1-r, C-1-c). This performs a 180-degree rotation.\n6. The output grid now contains the 180-degree rotated version of the input grid.",
    "3de23699.json": "1. Find the four corner pixels in the input grid that have the same value. These pixels define the corners of a square or rectangle.\n2. Determine the bounding box formed by these four corner pixels. Let (R1, C1) be the row and column of the top-left corner pixel, and (R2, C2) be the row and column of the bottom-right corner pixel.\n3. Extract the subgrid within the bounding box, excluding the corner pixels themselves. The top-left pixel of this subgrid is at (R1+1, C1+1) and the bottom-right pixel is at (R2-1, C2-1). The extracted subgrid has dimensions (R2 - R1 - 1) rows and (C2 - C1 - 1) columns.\n4. Create an output grid with the same dimensions as the extracted subgrid.\n5. Copy the values from the extracted subgrid to the corresponding locations in the output grid.\n6. Identify the value of the corner pixels, which we'll call 'corner_value'.\n7. In the output grid, replace all pixel values with the 'corner_value'.",
    "3e980e27.json": "1. Initialize the output grid as a direct copy of the input grid. The output grid has the same dimensions as the input grid. \n2. Identify all 'isolated' green pixels (value 3). An isolated green pixel is a pixel with value 3 that has a neighborhood of only background pixels (value 0) within a radius of 1. Specifically, check the 8 neighboring pixels (up, down, left, right, and the 4 diagonals). If all 8 neighbors are 0, the green pixel is considered isolated.\n3. Identify a 'source' green pixel (value 3). A source green pixel is a pixel with value 3 that is NOT isolated and has at least one non-zero neighbor within a radius of 1. Choose the first such green pixel encountered when scanning the input grid from top-left to bottom-right.\n4. For each isolated green pixel identified in Step 2:\n    a. Copy the neighborhood pattern from the 'source' green pixel (identified in Step 3) to the isolated green pixel. The neighborhood consists of the 8 pixels surrounding the source green pixel. Preserve the pixel values (0-9) in this neighborhood pattern.\n    b. Place the copied neighborhood around the isolated green pixel, such that the relative positions of the neighboring pixel values are identical to the neighborhood around the source green pixel.\n5. Identify all 'isolated' red pixels (value 2). An isolated red pixel is a pixel with value 2 that has a neighborhood of only background pixels (value 0) within a radius of 1. Specifically, check the 8 neighboring pixels (up, down, left, right, and the 4 diagonals). If all 8 neighbors are 0, the red pixel is considered isolated.\n6. Identify a 'source' red pixel (value 2). A source red pixel is a pixel with value 2 that is NOT isolated and has at least one non-zero neighbor within a radius of 1. Choose the first such red pixel encountered when scanning the input grid from top-left to bottom-right.\n7. For each isolated red pixel identified in Step 5:\n    a. Copy the neighborhood pattern from the 'source' red pixel (identified in Step 6) to the isolated red pixel. The neighborhood consists of the 8 pixels surrounding the source red pixel. Preserve the pixel values (0-9) in this neighborhood pattern.\n    b. Horizontally mirror the copied neighborhood pattern.\n    c. Place the mirrored neighborhood around the isolated red pixel, such that the relative positions of the horizontally mirrored neighboring pixel values are correctly positioned relative to the isolated red pixel.\n8. The output grid is now complete.",
    "3eda0437.json": "1. Analyze the input grid. The input grid contains pixel values 0 (black), 1 (blue), and 5 (grey).\n2. Identify the largest square or rectangle that can be formed entirely by contiguous pixel values of 0 (black).\n3. If no such square or rectangle exists, the output grid is identical to the input grid.\n4. If a square or rectangle is identified, create an output grid that is an exact copy of the input grid.\n5. In the output grid, replace the pixel values within the bounds of the identified largest square or rectangle with the value 6 (pink).",
    "3f7978a0.json": "1. Find two columns of 5s (grey) in the input grid. These columns are the left and right boundaries of a central pattern.\n2. Ensure that a 8 (cyan/light blue) cell exists at the top of each of the two identified 5 (grey) columns.\n3. Determine the top and bottom boundaries of the central pattern. The top boundary is the row containing the 8 (cyan/light blue) cell at the top of the 5 (grey) columns. The bottom boundary is the row containing the 8 (cyan/light blue) cell at the bottom of the 5 (grey) columns.\n4. Define the central pattern as the subgrid bounded by the left and right 5 (grey) columns, and the top and bottom boundaries found in the previous steps.\n5. Determine the height and width of the central pattern.\n6. Create an output grid with the determined height and width.\n7. Copy the central pattern from the input grid to the output grid, such that the top-left cell of the central pattern in the input grid becomes the top-left cell of the output grid.\n8. All 0 (black) cells between the two 5 (grey) columns in the input are copied to the corresponding locations in the output grid. All 8 (cyan/light blue) cells between the two 5 (grey) columns in the input are copied to the corresponding locations in the output grid.",
    "40853293.json": "1. Input: The input is a grid containing squares of different integer values (0-9). The output grid has the same dimensions as the input grid.\n2. Initialize: Create an output grid with the same dimensions as the input grid. Initialize all pixel values in the output grid to 0.\n3. Iterate: For each distinct integer value 'N' (1-9) present in the input grid:\n    a. Identify: Find all locations (R, C) in the input grid where the pixel value is equal to N.\n    b. Connect Horizontally: For each row 'R', find the minimum column index C_min and the maximum column index C_max where the pixel value at (R, C) equals N. Set all pixel values in the output grid from (R, C_min) to (R, C_max) to N.\n    c. Connect Vertically: For each column 'C', find the minimum row index R_min and the maximum row index R_max where the pixel value at (R, C) equals N. Set all pixel values in the output grid from (R_min, C) to (R_max, C) to N.\n4. Resolve Overlaps: Iterate through the output grid. When vertical and horizontal lines of different integer values intersect, prioritize the vertical line. That is, if a pixel at (R, C) was set by a horizontal line to value N1 and then by a vertical line to value N2, the final pixel value at (R, C) should be N2. No operation needs to be performed if the horizontal and vertical lines are the same integer value.",
    "4093f84a.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Identify all rows and columns in the input grid that contain at least one pixel with value 5 (grey). These are considered 'grey rows' and 'grey columns'.\n3. In the output grid, for each pixel that does NOT have a value of 5:\n    a. Determine the shortest distance to the nearest 'grey row' and the shortest distance to the nearest 'grey column'.\n    b. Move the pixel's value towards the nearest 'grey row' and 'grey column' until it touches a 'grey row' or 'grey column'. This means changing the pixel value to 5 and moving it to the nearest 'grey row' or 'grey column'.\n4. Replace all pixel values that are NOT 5 in the output grid with 5.",
    "41e4d17e.json": "1. Copy the input grid to the output grid. The input grid contains light blue (8) background with darker blue (1) square borders.\n2. Identify each distinct shape formed by the darker blue (1) border.\n3. For each identified shape:\n    a. Calculate the center coordinates (R, C) of the shape. If the shape has an even width or height, the center is defined as the integer division of width/2 or height/2, respectively, added to the top-left coordinate of the shape. For example, a shape from (2,3) to (5,6) (inclusive) would have a center at (3,4).\n    b. Set the pixel value at (R, C) to pink (6).\n    c. Draw a vertical line of pink (6) pixels extending upwards and downwards from (R, C). Stop drawing the line when a darker blue (1) pixel is encountered. Do not overwrite the darker blue (1) border.\n    d. Draw a horizontal line of pink (6) pixels extending leftwards and rightwards from (R, C). Stop drawing the line when a darker blue (1) pixel is encountered. Do not overwrite the darker blue (1) border.\n4. The output grid is now complete.",
    "4258a5f9.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Find all locations (R, C) in the input grid where the pixel value is 5 (grey).\n3. For each location (R, C) found in step 2, set the pixel values of all its immediate neighbors in the output grid to 1 (blue). Immediate neighbors include the pixels directly above, below, to the left, to the right, and diagonally adjacent to (R, C).\n4. Specifically, for each grey pixel at (R, C) in the input, set the following pixels in the output to 1:\n    - (R-1, C-1) if it exists within the grid boundaries.\n    - (R-1, C) if it exists within the grid boundaries.\n    - (R-1, C+1) if it exists within the grid boundaries.\n    - (R, C-1) if it exists within the grid boundaries.\n    - (R, C+1) if it exists within the grid boundaries.\n    - (R+1, C-1) if it exists within the grid boundaries.\n    - (R+1, C) if it exists within the grid boundaries.\n    - (R+1, C+1) if it exists within the grid boundaries.\n5. The central pixel (R, C) of the 3x3 area is not changed to blue; it remains grey (5).",
    "4290ef0e.json": "1. Find all distinct shapes in the input grid. A shape is defined as a connected region of a single non-background number (0). Shapes may be outlines (hollow) or filled. Shapes can be squares, corners, or other forms. Assume shapes are spatially separated. \n2. Determine the background number. The background is the number that is most prevalent outside of the identified shapes. Assume the background is 0.\n3. Measure the bounding box size (height and width) of each shape.\n4. Sort the shapes by their bounding box size in descending order (largest to smallest).\n5. Determine the size of the output grid. The output grid's height and width should match the height and width of the largest shape's bounding box.\n6. Create a new output grid filled with the background number (0).\n7. Iterate through the sorted shapes (largest to smallest):\n    a. For the current shape, copy its number and relative spatial structure.\n    b. Calculate the center coordinates (row and column) of the output grid.\n    c. Calculate the center coordinates (row and column) of the current shape's bounding box.\n    d. Calculate the offset between the output grid's center and the shape's center.\n    e. Place the shape in the output grid, using the calculated offset to center it. If any part of the shape extends beyond the boundaries of the output grid, clip the shape so it fits within the grid.\n8. The output grid now contains the shapes nested within each other, from largest to smallest, centered in the output grid, with the original shape numbers preserved and the background as 0.",
    "42a50994.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Iterate through each pixel in the input grid, row by row, and column by column. Let the current pixel's coordinates be (R, C).\n3. For each pixel at (R, C), check its eight neighbors: (R-1, C-1), (R-1, C), (R-1, C+1), (R, C-1), (R, C+1), (R+1, C-1), (R+1, C), and (R+1, C+1). Handle edge cases by considering pixels outside the grid boundaries as having a value of 0.\n4. If the value of the pixel at (R, C) is the same as the value of any of its neighbors, then it is considered connected. If the value of the pixel at (R, C) is different from the value of all eight neighbors, it is considered a singleton.\n5. If the pixel at (R, C) is a singleton, change the value of the corresponding pixel at (R, C) in the output grid to 0.\n6. After iterating through all pixels, the output grid contains the transformed image.",
    "4347f46a.json": "1. Input: A grid of numbers representing an image with different colored shapes (rectangles or squares) on a black (0) background. The numbers 1-9 represent the colors of the shapes. \n2. Output Grid Size: The output grid has the same dimensions as the input grid.\n3. Algorithm: \n 3.1. Iterate through each pixel (R, C) of the input grid.\n 3.2. For each pixel (R, C): If the pixel value is not 0, proceed; otherwise, keep the pixel value as 0 in the output grid and proceed to the next pixel.\n 3.3. For each non-black pixel, determine the boundaries of the colored shape it belongs to. Define a shape as a connected region of pixels with the same non-zero value.\n 3.4. For each shape, identify the pixels that are not on the border of the shape. A pixel is considered an internal pixel if all its immediate neighbors (up, down, left, right) within the shape's boundaries also have the same non-zero value.\n 3.5. Replace the value of all internal pixels of each shape with 0 in the output grid. Keep the border pixels of each shape unchanged. All other pixels remain unchanged.",
    "444801d8.json": "1. Identify the input grid.\n2. Create an output grid of the same size as the input grid.\n3. Iterate through each pixel (R, C) of the input grid.\n4. Copy the pixel value from the input grid at (R, C) to the corresponding pixel (R, C) in the output grid.\n5. If the input grid contains pixel value 1 (blue) and pixel value 3 (green), and pixel value 5 (grey), superimpose them.\n6. If there are pixel values of 1 (blue) and 2 (red) in the input grid, apply a transformation. The details of this transformation are not sufficiently specified in the provided descriptions, so it must be determined by examining the input-output pairs.\n7. Output the modified grid.",
    "445eab21.json": "1. Analyze the input grid to identify distinct square patterns. A pattern is defined as a connected region of the same value.\n2. Determine the largest square pattern in the input grid based on the number of cells it occupies.\n3. Identify the value of the bottom-most pattern present in the input grid. If there is a tie, then pick any of them.\n4. Create a 2x2 output grid.\n5. Fill every cell (pixel) of the 2x2 output grid with the value determined in Step 3.",
    "447fd412.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Identify a target shape composed of connected pixels with a consistent, non-zero value in the upper portion of the input grid. Let's call this the 'reference shape'.\n3. Identify one or more regions in the lower portion of the input grid which contain pixels with value 2. These regions are candidates to be transformed.\n4. For each candidate region containing pixels with value 2, determine the shape of the reference shape.\n5. Fill the region with value 1 such that the new filled region resembles the shape of the reference shape. Ensure that pixels with value 2 remain unchanged. The filled region can be proportionally larger or smaller than the reference shape, but should maintain the same geometric structure.",
    "44d8ac46.json": "1. Copy the input grid to the output grid. This ensures the grid size remains the same and the positions of objects are initially identical.\n2. Find all connected regions of value 5 (grey) in the input grid.\n3. For each connected region of value 5:\n    a. Find all connected regions of value 0 (black) that are completely enclosed within the current 5 (grey) region.\n    b. For each enclosed 0 (black) region:\n        i. Determine the dimensions (height and width) of the minimal bounding box that contains the 0 (black) region.\n        ii. If the height and width of the bounding box are equal (meaning the 0 (black) region is a square):\n            iii. Replace all pixels within the 0 (black) square region in the output grid with the value 2 (red).\n        iv. Otherwise (if the height and width are not equal, or the black region is not a perfect square), leave the region unchanged in the output grid.\n4. If no enclosed 0 (black) regions are found inside a grey region, identify the center pixel of the grey region and change it to value 7 (orange).",
    "44f52bb0.json": "1. Input is a 3x3 grid of integers, with pixel values 0 and 6. The positions of 0 and 6 vary in each input grid.\n2. The output grid is 1x1.\n3. Count the number of pixels with value 2 in the input grid.\n4. If the count of 2 is 3 or 4, the output pixel value is 7.\n5. If the count of 2 is 2, 5, or 6, the output pixel value is 1.\n6. Assign the resulting output pixel value to the single cell in the 1x1 output grid.",
    "4522001f.json": "1. Create a 9x9 output grid initialized with 0s.\n2. Examine the 3x3 input grid.\n3. Identify the location of the 2x2 square of 3s in the input grid. Determine the corner of the 3x3 input grid where this 2x2 square is located (top-left, top-right, bottom-left, or bottom-right).\n4. Identify the location of the 2 in the innermost cell of the 2x2 square identified in step 3.\n5. Based on the corner identified in step 3, create a 4x4 square of 3s in the corresponding corner of the 9x9 output grid. Specifically:\n    - If the 2x2 square is in the top-left corner of the input, place the 4x4 square of 3s in the top-left corner of the output (coordinates (0, 0) to (3, 3)).\n    - If the 2x2 square is in the top-right corner of the input, place the 4x4 square of 3s in the top-right corner of the output (coordinates (0, 5) to (3, 8)).\n    - If the 2x2 square is in the bottom-left corner of the input, place the 4x4 square of 3s in the bottom-left corner of the output (coordinates (5, 0) to (8, 3)).\n    - If the 2x2 square is in the bottom-right corner of the input, place the 4x4 square of 3s in the bottom-right corner of the output (coordinates (5, 5) to (8, 8)).\n6. Based on the location of the 2 identified in step 4, create another 4x4 square of 3s in the output grid such that it touches the corner of the first 4x4 square. The corner where the two squares touch must be the corner where the 2 was found in the 2x2 square. \n    - If the 2 is in the top-left cell of the 2x2 square, the two 4x4 squares should touch at their top-left corners.\n    - If the 2 is in the top-right cell of the 2x2 square, the two 4x4 squares should touch at their top-right corners.\n    - If the 2 is in the bottom-left cell of the 2x2 square, the two 4x4 squares should touch at their bottom-left corners.\n    - If the 2 is in the bottom-right cell of the 2x2 square, the two 4x4 squares should touch at their bottom-right corners.",
    "4612dd53.json": "1. Copy the input grid to the output grid, maintaining the same dimensions.\n2. Identify regions in the input grid composed of contiguous pixel values of 1 (representing the blue pattern on a black background of 0).\n3. For each identified region: Examine the boundary of the region. Identify gaps in the boundary where pixel value 0 is adjacent to the region of pixel value 1.\n4. Fill in these gaps with pixel value 2 (representing red) to complete the rectangular shape(s). Ensure the fill operation creates straight lines connecting the existing pixel value 1 segments of the rectangle(s).\n5. The goal is to create complete rectangle(s) using pixel value 2 to fill in the missing sides of the rectangle(s) formed by pixel value 1.",
    "46442a0e.json": "1. Read the input grid of numbers (0-9). Let the input grid's dimensions be I rows and I columns.\n2. Create an output grid with dimensions 2*I rows and 2*I columns.\n3. Divide the output grid into four quadrants of size I x I: top-left, top-right, bottom-left, and bottom-right.\n4. Copy the input grid to the top-right quadrant of the output grid. The pixel value at (R, C) in the input grid is copied to (R, C + I) in the output grid.\n5. Rotate the input grid 90 degrees clockwise. Copy the rotated grid to the top-left quadrant of the output grid. The pixel value at (R, C) in the rotated input grid is copied to (R, C) in the output grid.\n6. Rotate the input grid 180 degrees. Copy the rotated grid to the bottom-right quadrant of the output grid. The pixel value at (R, C) in the rotated input grid is copied to (R + I, C + I) in the output grid.\n7. Rotate the input grid 90 degrees counter-clockwise. Copy the rotated grid to the bottom-left quadrant of the output grid. The pixel value at (R, C) in the rotated input grid is copied to (R + I, C) in the output grid.",
    "469497ad.json": "1. Find the unique colors in the input 5x5 grid, excluding 0 (black). Let the number of unique colors be N.\n2. Calculate the output grid size: output_size = N * 5.\n3. Create an output grid of size output_size x output_size, initialized with 0.\n4. Determine the size of the colored square: square_size = 2 * N / N. Note, this simplifies to '2' but explicitly showing the calculation to capture the general trend.\n5. Determine the thickness of the colored borders: border_thickness = N / N. Note, this simplifies to '1' but explicitly showing the calculation to capture the general trend. Also note borders are on the right and bottom of the input grid.\n6. Copy the input grid's pattern to the output grid, scaling the colored square and borders:\n   a. For each row R from 0 to 4 and each column C from 0 to 4 in the input grid:\n      i. Calculate the corresponding row Ro and column Co in the output grid: Ro = R * N / N, Co = C * N / N (This simplifies to Ro=R, Co=C, but represents the scaling factor). Note if N = 1 the color at the output grid is located at Ro=R, Co=C. If the N = 3, then the colors on the output grids are 3 times bigger with starting row and column equal to Ro = R * 3, Co = C * 3\n      ii. If the pixel value at (R, C) in the input grid is not 0 (black), copy that pixel value to a N x N block in the output grid, starting at (Ro, Co). Specifically, for each r from 0 to N-1 and each c from 0 to N-1, set output_grid[Ro + r][Co + c] = input_grid[R][C].\n7. Locate the top-left corner (row, column) of the 2x2 colored square in the input grid. Let this corner be (square_row, square_col).\n8. In the output grid, find the corresponding top-left corner of the scaled colored square: (scaled_square_row, scaled_square_col) = (square_row * N / N, square_col * N / N) which simplifies to (square_row, square_col)\n9. Draw diagonal lines of value 2 (red) from each corner of the scaled colored square to the border or edge of the output grid:\n   a. Top-left corner: Starting from (scaled_square_row, scaled_square_col), extend the diagonal upwards and to the left until reaching the grid boundary or a non-0 (non-black) cell. Set each traversed cell to 2.\n   b. Top-right corner: Starting from (scaled_square_row, scaled_square_col + square_size - 1), extend the diagonal upwards and to the right until reaching the grid boundary or a non-0 cell. Set each traversed cell to 2.\n   c. Bottom-left corner: Starting from (scaled_square_row + square_size - 1, scaled_square_col), extend the diagonal downwards and to the left until reaching the grid boundary or a non-0 cell. Set each traversed cell to 2.\n   d. Bottom-right corner: Starting from (scaled_square_row + square_size - 1, scaled_square_col + square_size - 1), extend the diagonal downwards and to the right until reaching the grid boundary or a non-0 cell. Set each traversed cell to 2.\n10. Return the output grid.",
    "46f33fce.json": "1. Read the input grid. The input grid contains single-colored squares (values 0-9) on a background (likely 0). Each distinct colored square (non-zero value) represents a single cell in the input.\n2. Determine the dimensions of the input grid (input_height, input_width).\n3. Calculate the output grid dimensions: output_height = input_height * 4; output_width = input_width * 4.\n4. Create a new output grid of size (output_height, output_width) filled with 0s.\n5. Iterate through each cell (row R, column C) of the input grid.\n6. If the value at input_grid[R][C] is not 0 (i.e., represents a colored square):\n    a. Let 'color' = input_grid[R][C].\n    b. Calculate the starting row and column for the corresponding 4x4 block in the output grid: output_row_start = R * 4; output_col_start = C * 4.\n    c. Iterate through a 4x4 block (rows i from 0 to 3, columns j from 0 to 3).\n    d. Set the value of the output_grid at location (output_row_start + i, output_col_start + j) to 'color'.\n7. The resulting output_grid now contains 4x4 blocks of color corresponding to the original colored squares in the input grid, with 0s filling the space between these blocks.",
    "47c1f68c.json": "1. Find the largest square subgrid in the top-left quadrant of the input grid that contains non-zero values. Let this subgrid be the 'pattern'.\n2. Determine the size of the 'pattern' subgrid (rows and columns).\n3. Create an output grid with the same number of rows and columns as the 'pattern' subgrid.\n4. Copy the 'pattern' subgrid to the top-left quadrant of the output grid.\n5. Horizontally mirror the 'pattern' subgrid from the top-left quadrant to the top-right quadrant of the output grid. For each pixel at (row, col) in the top-left quadrant, copy its value to (row, output_grid_width - 1 - col) in the top-right quadrant.\n6. Vertically mirror the 'pattern' subgrid from the top-left quadrant to the bottom-left quadrant of the output grid. For each pixel at (row, col) in the top-left quadrant, copy its value to (output_grid_height - 1 - row, col) in the bottom-left quadrant.\n7. Diagonally mirror the 'pattern' subgrid from the top-left quadrant to the bottom-right quadrant of the output grid. For each pixel at (row, col) in the top-left quadrant, copy its value to (output_grid_height - 1 - row, output_grid_width - 1 - col) in the bottom-right quadrant.",
    "484b58aa.json": "1. Analyze the input grid to identify a repeating pattern consisting of non-0 values. This pattern is defined as a contiguous block of pixels with varying values (1-9) that repeats throughout the grid. \n2. Identify all pixels with value 0 in the input grid.\n3. For each pixel with value 0 at location (R, C), determine the corresponding location (R', C') within the identified repeating pattern. This involves calculating the modulo of R and C with respect to the pattern's height and width, respectively. Specifically, R' = R mod pattern_height and C' = C mod pattern_width.\n4. Copy the pixel value from the repeating pattern at location (R', C') to the pixel at location (R, C) in the output grid. In other words, set output_grid[R][C] = pattern[R'][C'].\n5. Pixels in the output grid that were not originally 0 in the input grid should retain their original values.",
    "48d8fb45.json": "1. Find the area in the input grid that contains a pixel with value 5 (grey). The input grid is assumed to be 10x10, but the relevant area's dimensions are not fixed.\n2. Copy the identified area.\n3. Within the copied area, replace all pixels with value 5 (grey) with value 0 (black).\n4. Extract a 3x3 subgrid from the top-left corner of the resulting copied area after the replacement.\n5. The extracted 3x3 subgrid is the output.",
    "4938f0c2.json": "1. Identify a central square area composed of four adjacent pixels with value 3. This constitutes the \"green cube\".\n2. Inspect the area surrounding the \"green cube\". Look for repeating patterns composed of pixels with value 2 (the \"red design\"). The surrounding area has a background of 0.\n3. If four distinct \"red design\" patterns are found surrounding the \"green cube\" in the input grid, copy the entire input grid to the output grid without modification.\n4. If fewer than four \"red design\" patterns are present, create a symmetrical arrangement of the detected \"red design\" patterns around the \"green cube\". The \"red design\" patterns must extend to all four corners of the output grid.\n5. Ensure the output grid size matches the input grid size.\n6. Pixels that are not part of the 'green cube' or the 'red design' and aren't part of the background (0), should be preserved in their original locations.",
    "496994bd.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid. \n2. Identify the rows containing non-zero values (colored lines) from one end (top or bottom) of the input grid. Assume these rows form a pattern. \n3. Mirror this identified pattern to the opposite end of the output grid. The mirroring should be done row by row. The color values (1-9) in the mirrored rows should be the same as in the original pattern.",
    "49d1d64f.json": "1. Determine the dimensions of the input grid, denoted as input_rows and input_cols.\n2. Calculate the dimensions of the output grid: output_rows = input_rows * 2, output_cols = input_cols * 2.\n3. Initialize the output grid with dimensions output_rows and output_cols.\n4. Copy the input grid into the center of the output grid. The top-left corner of the input grid is placed at (input_rows / 2, input_cols / 2) in the output grid. Specifically, for each row R and column C in the input grid, copy the pixel value at (R, C) to the output grid at (R + (output_rows - input_rows) / 2, C + (output_cols - input_cols) / 2).\n5. Set the colors of the four corners of the output grid to 0 (black). Specifically, set the pixel value at (0, 0), (0, output_cols - 1), (output_rows - 1, 0), and (output_rows - 1, output_cols - 1) to 0.\n6. For each pixel in the input grid that is adjacent to an edge, extend that color to the surrounding area in the output grid. For the top row of the input grid, extend the input colors upwards by 1 row. For the bottom row of the input grid, extend the input colors downwards by 1 row. For the leftmost column of the input grid, extend the input colors leftwards by 1 column. For the rightmost column of the input grid, extend the input colors rightwards by 1 column.",
    "4be741c5.json": "1. Analyze the input grid to identify distinct, contiguous regions of uniform numerical values (0-9). These regions will be oriented either horizontally or vertically.\n2. Determine the number of distinct numerical regions found in the input grid. This number will define the dimension of the output grid.\n3. If the distinct numerical regions are arranged horizontally, the output grid will be a horizontal bar. If the distinct numerical regions are arranged vertically, the output grid will be a vertical bar.\n4. Create the output grid. If the regions are arranged horizontally and there are N distinct regions, the output grid will have dimensions 1xN. If the regions are arranged vertically and there are N distinct regions, the output grid will have dimensions Nx1.\n5. For each distinct numerical region identified in the input grid, determine its corresponding numerical value (0-9).\n6. Fill each cell of the output grid, sequentially from left to right (if horizontal) or top to bottom (if vertical), with the numerical value corresponding to the respective region in the input grid. The first cell gets the number from the first region, the second cell gets the number from the second region, and so on.",
    "4c4377d9.json": "1. Get the dimensions (rows R, columns C) of the input grid. The input grid contains pixel values. Assume pixel values are integers 0-9.\n2. Create an output grid with dimensions (2*R) rows and C columns.\n3. Copy the input grid into the bottom half of the output grid. Specifically, for each row r from 0 to R-1 and each column c from 0 to C-1, set the pixel value at output_grid[r+R][c] to the pixel value at input_grid[r][c].\n4. Create a mirrored (reflected) copy of the input grid. For each row r from 0 to R-1 and each column c from 0 to C-1, set the pixel value at output_grid[R-1-r][c] to the pixel value at input_grid[r][c].",
    "4c5c2cf0.json": "1. Identify the input grid. Assume the input grid contains a central 'X' shape composed of a single color and a smaller shape of a different color located at one of the four corners of the 'X'.\n2. Let the color of the central 'X' be 'X_color' and the color of the corner shape be 'Corner_color'. Translate the colors to numbers using the mapping (0: black, 1: blue, 2: red, 3: green, 4: yellow, 5: grey, 6: pink, 7: orange, 8: cyan, 9: brown). Represent X_color and Corner_color with their corresponding numerical values.\n3. The output grid size is the same as the input grid size.\n4. Copy the input grid to the output grid.\n5. Find the coordinates (R1, C1) of the corner where the 'Corner_color' shape is initially located.\n6. Reflect the 'Corner_color' shape across the horizontal axis of the 'X' and place it in the opposite corner. If the center of the 'X' is at (R_center, C_center), then calculate the coordinates of the new corner as (2 * R_center - R1, C1). Copy the 'Corner_color' shape to this new location on the output grid.\n7. Reflect the 'Corner_color' shape across the vertical axis of the 'X' and place it in the remaining corner. The coordinates of this corner would be (R1, 2 * C_center - C1). Copy the 'Corner_color' shape to this location on the output grid.\n8. Rotate the 'Corner_color' shape by 180 degrees. Place the rotated shape in the last remaining corner. The coordinates for this final corner would be (2 * R_center - R1, 2 * C_center - C1). Copy the rotated 'Corner_color' shape to this location on the output grid.\n9. The output grid now contains the central 'X' and the 'Corner_color' shape in all four corners, transformed as described.",
    "50846271.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Find all locations (R, C) in the output grid where the pixel value is 2 (red).\n3. For each location (R, C) found in step 2, create a cross shape centered at (R, C). The cross shape extends 2 pixels in each direction (up, down, left, right) from the center pixel.\n4. The cross shape consists of a vertical line of 5 pixels and a horizontal line of 5 pixels, intersecting at (R, C).\n5. Replace the pixel values within the bounds of the cross shape with the value 2 (red). Ensure that the cross shape does not extend beyond the boundaries of the output grid. If it does, truncate the cross shape at the grid boundaries.",
    "508bd3b6.json": "1. Identify the positions of all pixels with value 2 (red) and all pixels with value 8 (cyan/light blue) in the input grid.\n2. Determine the initial direction of movement. The problem describes a \"Pong\"-like reflection. The initial movement direction is determined by the relative positions of the pixels with value 8 (cyan/light blue).\n3. Create an output grid of the same dimensions as the input grid. Initialize all pixel values in the output grid to 0 (black).\n4. Copy the pixels with value 8 (cyan/light blue) from the input grid to the same locations in the output grid.\n5. Simulate the movement of a line starting from the pixels with value 8 (cyan/light blue) in the output grid.\n6. The line moves diagonally. If the current pixel is at the grid boundary or if the current pixel has a value of 2 (red), change the direction of the line's movement as if it bounced off of the boundary or the red pixel.\n7. As the line moves, set the value of the current pixel to 3 (green), except for the starting positions of the cyan (8) pixels.\n8. Continue the movement until the line returns to its starting position, or the entire grid is filled with 3 (green) except for the initial positions of the cyan (8) pixels.",
    "50cb2852.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. For each distinct non-zero number in the input grid, perform the following steps:\n3. Identify all connected regions of the same number (shapes) in the input grid.\n4. For each such shape:\n5. Find the interior of the shape. A pixel at location (R, C) is considered part of the interior if it is surrounded on all four sides (up, down, left, right) by pixels belonging to the same shape.\n6. Replace the number of all interior pixels of the shape in the output grid with the number 8 (light blue).",
    "5117e062.json": "1. Find the shape in the input grid that contains a pixel with value 8 (light blue). Define this shape's bounding box.\n2. Create an output grid with the same dimensions as the bounding box of the shape found in Step 1.\n3. Copy the shape from the input grid to the output grid.\n4. Within the copied shape in the output grid, find the pixel with value 8 (light blue).\n5. Determine the value of the color that surrounds the pixel with value 8 within the copied shape in the output grid. The surrounding color is the value of the non-8 pixels immediately adjacent to the pixel with value 8.\n6. Replace the pixel with value 8 in the output grid with the surrounding color's value determined in Step 5.",
    "5168d44c.json": "1. Find a repeating pattern of alternating rows of 3 (green) and 0 (black) in the input grid. This pattern defines the 'tracks'.\n2. Identify a square block of 2 (red) pixels. Determine its size. It's most likely a 3x3 block.\n3. Locate the 3x3 block of 2 (red) pixels such that it surrounds a 3 (green) pixel. This is the 'red block'.\n4. Determine the orientation of the 3 (green) 'track'.\n5. If the 'track' is horizontal (repeating rows), move the 3x3 red block two positions to the right. The new position of the 3x3 red block must surround the next 3 (green) square. The grid size remains the same.\n6. If the 'track' is vertical (repeating columns), move the 3x3 red block two positions down. The new position of the 3x3 red block must surround the next 3 (green) square. The grid size remains the same.\n7. Maintain the alternating 3 (green) and 0 (black) pattern after moving the 3x3 red block.",
    "539a4f51.json": "1. Define the input pattern as the grid of numbers (0-9) in the input grid. The input grid contains a repeating pattern. This pattern has differing values.\n2. Create a 10x10 output grid, initially filled with 0s.\n3. Iterate through the output grid, row by row and column by column.\n4. For each cell (R, C) in the output grid, determine the corresponding cell (r, c) within the input pattern using the modulo operator: r = R % input_height, c = C % input_width, where input_height and input_width are the dimensions of the input grid.\n5. Assign the value from the input pattern cell (r, c) to the output grid cell (R, C).\n6. If the value assigned from the input pattern cell (r, c) is 0, find the next non-zero value in the input pattern, scanning row by row and wrapping around to the beginning of the input pattern if necessary. Replace the 0 with this next non-zero value in the output grid cell (R,C).\n7. Continue iterating through the entire 10x10 output grid.",
    "53b68214.json": "1. Input Grid: Identify the input grid containing a pattern on a background of 0.\n2. Output Grid: Create a 10x10 output grid, initialized with all cells set to 0.\n3. Pattern Copy: Copy the input pattern to the top-left corner of the output grid, maintaining the original relative positions of all numbers within the pattern.\n4. Pattern Extension: Extend the copied pattern horizontally and vertically to fill the entire 10x10 output grid. For each cell in the output grid that is not already part of the copied input pattern, determine its value by repeating the pattern from the original input grid. The repetition should maintain the spatial relationships of the numbers in the original input pattern.",
    "543a7ed5.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Find all connected regions of pixels with value 6 in the output grid. These represent the pink squares.\n3. For each pink region found in Step 2:\n    a. Find all pixels with value 8 (light blue) that are enclosed within the pink region (value 6). These enclosed regions represent 'open spaces'.\n    b. Change the value of these enclosed pixels from 8 to 4.\n    c. Outline the entire pink region (value 6) with a border of pixels with value 3 (green). This means setting all pixels directly adjacent to the pink region to value 3, where 'adjacent' means directly above, below, left, or right, but not diagonally.",
    "54d82841.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Find all occurrences of a 3x3 shape where the center pixel of the bottom row has a value of 0.\n3. For each such 3x3 shape found at coordinates (R, C), where (R, C) represents the top-left corner of the 3x3 shape:\n    a. Set the pixel at coordinate (R + 2, C + 1) in the output grid to 4.",
    "54d9e175.json": "1. Analyze the input grid. The input grid consists of 3x3 blocks separated by lines of gray pixels (value 5). The center of each 3x3 block contains a single color, surrounded by black pixels (value 0).\n2. The output grid has the same dimensions as the input grid.\n3. Iterate through each 3x3 block in the input grid.\n4. Within each 3x3 block, identify the color (integer value 0-9) of the center pixel. This pixel is located at relative coordinate (1, 1) within the 3x3 block.\n5. Replace the entire 3x3 block in the output grid according to the following color mapping:\n    * If the center pixel value is 3 (green), replace the entire 3x3 block with the value 8 (cyan/light blue).\n    * If the center pixel value is 1 (blue), replace the entire 3x3 block with the value 6 (pink/purple).\n    * If the center pixel value is 4 (yellow), replace the entire 3x3 block with the value 2 (red).\n    * If the center pixel value is 2 (red), replace the entire 3x3 block with the value 7 (orange).\n    * If the center pixel value is 0 (black), maintain black color of the block in the output.\n6. If none of the conditions in step 5 are met, do not change the value of the 3x3 block. Copy the input block to the output block.",
    "5521c0d9.json": "1. Analyze the input grid. The input grid contains shapes of values 1, 2, and 4 on a background of value 0.\n2. For each distinct shape (contiguous non-zero region): \n   a. Identify the bounding box of the shape. The bounding box is defined by the minimum and maximum row and column indices containing the shape's value.\n   b. Calculate the height of the bounding box: height = (maximum row index - minimum row index + 1).\n   c. Move the entire shape downward by height rows. This means for each pixel with a value of 1, 2, or 4 in the shape, copy its value to a new location height rows below its original location. Set the original location to 0.\n   d. If the new row index (original row index + height) exceeds the grid's height, wrap around. The new row index will be (original row index + height) modulo grid height. This ensures the shape appears at the bottom of the grid when moved down.\n3. After processing all shapes, the output grid will contain the transformed shapes at the bottom.",
    "5582e5ca.json": "1. Analyze the input grid, which is a 3x3 grid of integer values (0-9). Each integer represents a color.\n2. Count the occurrences of each distinct integer (0-9) within the input grid.\n3. Find the integer that appears most frequently in the input grid. If there is a tie, select the smallest integer among the tied integers.\n4. Create a new 3x3 output grid.\n5. Fill every cell in the output grid with the most frequent integer found in step 3.",
    "5614dbcf.json": "1. Divide the input grid into 3x3 blocks, assuming the original large squares are approximately 3x3 in size. If the input grid dimensions are not multiples of 3, handle edge cases by processing the remaining rows and columns separately, still aiming to identify dominant colors within them.\n2. For each 3x3 block, count the occurrences of each number (0-9).\n3. Identify the number with the highest occurrence count within the 3x3 block. This is the dominant number for that block. If there's a tie, choose the smallest number among the tied numbers.\n4. Create a new 3x3 output grid.\n5. Assign the dominant number identified in step 3 to the corresponding cell in the new 3x3 output grid.",
    "56dc2b01.json": "1. Identify the red line (pixel value 2) in the input grid. Determine its orientation (horizontal or vertical). A line is defined as a series of adjacent pixels with value 2.\n2. Identify the green pattern (pixel value 3) in the input grid.\n3. Move the green pattern (pixel value 3) such that it is adjacent to the red line (pixel value 2). The relative position of the green pattern to the red line (left/right or above/below) should be preserved from the input.\n4. Add a light blue line (pixel value 8) parallel to the red line (pixel value 2) on the opposite side of the green pattern (pixel value 3). The light blue line (pixel value 8) should be adjacent to the green pattern (pixel value 3).\n5. The output grid size is the same as the input grid size. All areas not part of the red line, green pattern, or light blue line should be 0.",
    "56ff96f3.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Find all pairs of cells with the same non-zero value. A pair consists of two cells having the same value between 1 and 9 inclusive.\n3. For each pair of cells with value 'V' at coordinates (R1, C1) and (R2, C2):\n4. Define a rectangular region with corners at (R1, C1) and (R2, C2). Assume R1 <= R2 and C1 <= C2. If not, swap the coordinates accordingly.\n5. For each cell (R, C) within this rectangular region (R1 <= R <= R2 and C1 <= C <= C2):\n6. If the cell (R, C) in the output grid has a value of 0, replace its value with V.",
    "57aa92db.json": "1. Copy the input grid to the output grid. The output grid will be the same size as the input grid.\n2. Identify distinct shapes within the input grid. A shape is defined as a connected region of pixels with the same value, where connectivity is defined as being adjacent either horizontally or vertically.\n3. Among the identified shapes, search for incomplete \"T\" or \"U\" shapes. An incomplete shape is a shape that appears to be a fragment of a larger \"T\" or \"U\" shape.\n4. Simultaneously, search for a complete shape, ideally a square or rectangular shape. This shape serves as a template.\n5. If an incomplete \"T\" or \"U\" shape is found, complete the shape by extending it to form a full \"T\" or \"U\" shape, mirroring its existing orientation.\n6. The pixel value used to complete the incomplete shape should be different from the pixel value immediately surrounding the incomplete shape. Use the other pixel value present in the input grid.\n7. If multiple incomplete \"T\" or \"U\" shapes are found, complete each of them independently using the same process described above.",
    "5ad4f10b.json": "1. Create a 3x3 output grid. 2. Set the center pixel of the output grid (coordinates (1,1)) to the value 4 (yellow). 3. Set all other pixels in the output grid to the value 0 (black).",
    "5bd6f4ac.json": "1. Define the input grid. The input grid contains numerical values (0-9). Its dimensions are variable.\n2. Define the output grid. The output grid has dimensions 3x3.\n3. Extract a subgrid from the top-right portion of the input grid. The subgrid's dimensions are one third of the input's height by one third of the input's width.\n4. Copy the values from the extracted subgrid to the output grid, such that the extracted subgrid occupies the output grid. The top-left of the extracted grid maps to the top-left of the output grid. Fill the 3x3 output grid row by row, using values from the extracted subgrid. If the extracted subgrid contains fewer than 9 pixels, the values will loop.",
    "5c0a986e.json": "1. Find a 2x2 box of pixel value 1 (blue) in the input grid. Define the top-left coordinate of this box as (blue_row, blue_col). If multiple such boxes exist, choose the first one encountered scanning from top-left to bottom-right. 2. Starting from the (blue_row, blue_col) coordinate, extend a diagonal line of pixel value 1 (blue) towards the top-left corner of the grid. For each step, set the pixel at (blue_row - i, blue_col - i) to 1 (blue), where i is the step number, as long as (blue_row - i) and (blue_col - i) are within the grid boundaries (0 <= row < grid height, 0 <= col < grid width). 3. Find a 2x2 box of pixel value 2 (red) in the input grid. Define the bottom-right coordinate of this box as (red_row, red_col). If multiple such boxes exist, choose the first one encountered scanning from top-left to bottom-right. 4. Starting from the (red_row, red_col) coordinate, extend a diagonal line of pixel value 2 (red) towards the bottom-right corner of the grid. For each step, set the pixel at (red_row + i, red_col + i) to 2 (red), where i is the step number, as long as (red_row + i) and (red_col + i) are within the grid boundaries (0 <= row < grid height, 0 <= col < grid width). 5. The output grid has the same dimensions as the input grid. The pixels not modified in steps 2 and 4 retain their original values from the input grid.",
    "5c2c9af4.json": "1. Find three non-overlapping squares (or dots) in the input grid. These squares should ideally be of the same color.\n2. Determine the center square (or dot). Let its coordinates be (R_center, C_center).\n3. Measure the side length, L, of the center square.\n4. Create an output grid with the same dimensions as the input grid.\n5. Copy the pixel values from the input grid to the output grid.\n6. Initialize the square side length increment, increment = L.\n7. Initialize current square color: color = the color of the three initial squares (dots).\n8. Starting from the center coordinates (R_center, C_center), draw concentric squares outwards. The initial square has side length L.\n9. For each concentric square:\n    a. Define the top-left corner of the square at (R_center - (L + increment)/2, C_center - (L + increment)/2).\n    b. Iterate through the pixels within the bounds of the square:\n        i. For each pixel (R, C) within the square's bounds, set output_grid[R][C] = color.\n10. Increase increment by L.\n11. Check if the next square would extend beyond the bounds of the output grid. Stop if it does. The check is:  if (R_center - (L + increment)/2 < 0) or (R_center + (L + increment)/2 >= grid_height) or (C_center - (L + increment)/2 < 0) or (C_center + (L + increment)/2 >= grid_width), then stop the process.\n12. Repeat steps 9-11 until the next square would extend beyond the grid boundaries.\n13. The output grid now contains the concentric squares pattern.",
    "5daaa586.json": "1. Find the four lines in the input grid that form a square or rectangle. These lines will have a color value other than 0.\n2. Determine the coordinates of the bounding box formed by these four lines. Let (R1, C1) be the top-left coordinate and (R2, C2) be the bottom-right coordinate of the bounding box. The bounding box includes the lines.\n3. Create an output grid with dimensions (R2 - R1 + 1) x (C2 - C1 + 1).\n4. Copy the subgrid from the input grid defined by the bounding box (R1:R2, C1:C2) to the output grid.\n5. Identify all non-zero pixel values within the inner region of the output grid (excluding the boundary lines). These are the colored squares inside the box. Let (Ri, Ci) be the coordinates of such a pixel with value V.\n6. For each colored square at (Ri, Ci) with value V:\n    a. Find the boundary line with the same value V.\n    b. If the rectangle's width (C2-C1+1) is greater than its height (R2-R1+1), draw a horizontal line from (Ri, C2) to (Ri, Ci), setting all pixel values along the line to V. Fill in from right to left until reaching (Ri, Ci).\n    c. If the rectangle's height (R2-R1+1) is greater than its width (C2-C1+1), draw a vertical line from (R2, Ci) to (Ri, Ci), setting all pixel values along the line to V. Fill in from bottom to top until reaching (Ri, Ci).\n    d. If the rectangle's height (R2-R1+1) is equal to its width (C2-C1+1), draw a vertical line from (R1, Ci) to (Ri, Ci), setting all pixel values along the line to V. Fill in from top to bottom until reaching (Ri, Ci).",
    "60b61512.json": "1. Input: A grid of integers from 0 to 9, representing abstract shapes. The grid size is variable.\n2. Output: A grid of the same size as the input grid.\n3. Process: Identify incomplete square shapes formed by non-zero integer values in the input grid.\n4. Fill: For each incomplete square shape identified in Step 3, replace all zero values within the boundaries of the square with the integer 7 (representing orange). This completes the squares.\n5. Preserve: Maintain all non-zero integer values from the input grid in their original positions in the output grid.",
    "6150a2bd.json": "1. Read the input grid. The input grid contains a shape of various numbers on a background of 0.\n2. Create an output grid with the same dimensions as the input grid.\n3. For each pixel at row R and column C in the input grid, copy the pixel value to the pixel at row (height - 1 - R) and column (width - 1 - C) in the output grid, where height is the height of the grid and width is the width of the grid. R and C start from 0.\n4. The output grid is now the horizontally and vertically flipped version of the input grid.",
    "623ea044.json": "1. Find the coordinates (R_center, C_center) of the single non-zero pixel in the input grid. This pixel represents the center square and its value represents the target color. Let this pixel value be 'color'.\n2. Create an output grid with the same dimensions as the input grid, initialized with all pixel values set to 0.\n3. Set the pixel at (R_center, C_center) in the output grid to 'color'.\n4. Starting from the center pixel (R_center, C_center), extend lines outwards in four diagonal directions.\n5. For each diagonal direction:\n    a. Increment R and C (or decrement R and/or C, depending on the direction) until the edge of the grid is reached.\n    b. Set the pixel value at the current (R, C) in the output grid to 'color'.\n    c. Repeat steps 5a and 5b until the edge of the grid is reached in that direction.\n6. The output grid now contains an 'X' shape formed by lines of the same color as the center square, extending to the edges of the grid.",
    "62c24649.json": "1. Initialize a 6x6 output grid. All cells are initially 0.\n2. Copy the 3x3 input grid to the top-left corner of the output grid, such that the top-left cell of the input grid maps to output grid cell (0, 0).\n3. Reflect the 3x3 grid in the top-left corner of the output grid horizontally and place it in the top-right 3x3 corner of the output grid. Specifically, for each cell (R, C) in the top-left 3x3 grid (R from 0 to 2, C from 0 to 2), copy the value at (R, C) to (R, 5-C) in the output grid.\n4. Reflect the entire top 6x3 section (formed by the original and mirrored grids) vertically and place it in the bottom 6x3 section of the output grid. Specifically, for each cell (R, C) where R ranges from 0 to 2 and C ranges from 0 to 5, copy the value at (R, C) to (5-R, C) in the output grid.",
    "63613498.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Identify a shape enclosed by a border of pixel value 5 (grey) within the input grid. Assume there is only one such shape with a 5 (grey) border.\n3. Define the 'target shape' as the shape identified in step 2, excluding the 5 (grey) border itself. The 'target shape' is characterized by its pixel values and relative spatial arrangement.\n4. Search the input grid for shapes outside of the 5 (grey) border that have the exact same pixel values and spatial arrangement as the 'target shape' defined in step 3. Shapes must match in both content (pixel values) and orientation.\n5. For each shape found in step 4 that exactly matches the 'target shape', replace the pixel values of that shape in the output grid with the value 5 (grey).\n6. Do not modify the 'target shape' enclosed in the 5 (grey) border in the output grid. Do not modify any shapes that do not precisely match the 'target shape'.",
    "6430c8c4.json": "1. Input: Assume a single input grid, taller than it is wide, containing a horizontal band of 4 (yellow) separating two regions: an upper region and a lower region.\n2. Extract: Find the topmost 4x4 subgrid from the input grid.\n3. Extract: Find a second 4x4 subgrid from the input grid, located directly below the 4 (yellow) line.\n4. Create: Initialize a 4x4 output grid filled with 3 (green).\n5. Overlay: For each cell (R, C) in the output grid (where R and C range from 0 to 3 inclusive):\n    a. If the pixel value at (R, C) in the topmost 4x4 subgrid is NOT 0 (black), change the pixel value at (R, C) in the output grid to 0 (black).\n    b. If the pixel value at (R, C) in the bottommost 4x4 subgrid is NOT 0 (black), change the pixel value at (R, C) in the output grid to 0 (black).",
    "6455b5f5.json": "1. Identify all connected regions of 0s (black) in the input grid. Treat regions connected horizontally or vertically as a single region. Each region represents a 'black shape'.\n2. Calculate the area (number of 0s) of each 'black shape'.\n3. Find the 'largest black shape', which is the black shape with the maximum area.\n4. Replace all 0s within the 'largest black shape' with 1 (dark blue).\n5. Find the 'smallest black shape(s)', which is/are the black shape(s) with the minimum area.\n6. Replace all 0s within the 'smallest black shape(s)' with 8 (cyan / light blue).\n7. The output grid size is the same as the input grid size.",
    "662c240a.json": "1. Divide the input grid, which is 3 units wide and 9 units high, into three 3x3 subgrids stacked vertically.\n2. Initialize a candidate output grid as a 3x3 grid.\n3. **First Attempt:** Copy the pixel values from the top 3x3 subgrid of the input to the candidate output grid.\n4. Check if the first attempt leads to the correct output (this step requires external validation and is not explicitly defined in the provided descriptions). If it is correct, then stop and output the candidate grid.\n5. **Second Attempt:** If the first attempt fails, copy the pixel values from the middle 3x3 subgrid of the input to the candidate output grid.\n6. Check if the second attempt leads to the correct output (this step requires external validation and is not explicitly defined in the provided descriptions). If it is correct, then stop and output the candidate grid.\n7. **Third Attempt:** If the second attempt fails, copy the pixel values from the bottom 3x3 subgrid of the input to the candidate output grid.\n8. The output grid is the candidate output grid.",
    "67385a82.json": "1. Copy the dimensions of the input grid to determine the dimensions of the output grid.\n2. Copy the input grid to the output grid initially.\n3. Identify connected regions of value 3 (originally green) in the output grid.\n4. For each connected region of value 3, determine its size (number of cells).\n5. If a connected region of value 3 has more than 2 cells, change the value of all cells in that region to 8 (light blue).\n6. Change the cell at the top-left corner (0,0), from 3 to 8 if it has value 3.\n7. Find any 2x2 grids containing only the value 3 in the bottom grid and change the value of the 2x2 grid to 8.",
    "673ef223.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Identify all pixels with value 8 (cyan/light blue) that are connected to a pixel with value 2 (red) through a continuous horizontal or vertical path of pixels with value 8 (cyan/light blue). These are 'connectable' 8-pixels.\n3. Change the value of all 'connectable' 8-pixels to 4 (yellow).\n4. For each 2 (red) region in the top half of the output grid, find all 4 (yellow) pixels. For each such 4 (yellow) pixel, extend a path of 8 (cyan/light blue) pixels horizontally or vertically from the 4 (yellow) pixel until it reaches a 2 (red) pixel.\n5. For each 2 (red) region in the bottom half of the output grid, find all 4 (yellow) pixels. Extend a path of 8 (cyan/light blue) pixels horizontally or vertically from where each corresponding 4 (yellow) pixel *would* have been (if it existed) to the edge of the grid, if such a 4 (yellow) pixel existed in the top half of the grid according to step 4. If no corresponding 4 (yellow) pixel exists in the top half, skip the extension for that coordinate.",
    "6773b310.json": "1. Divide the input grid into 3x3 subgrids.\n2. For each 3x3 subgrid:\n3. Count the number of pixels with value 6 (representing pink).\n4. If the count of pixels with value 6 is equal to 2:\n5. Set the corresponding pixel in the output grid to 1 (representing blue).\n6. Otherwise, for each 3x3 subgrid:\n7. Set the corresponding pixel in the output grid to 0 (representing black).\n8. The output grid will be 3x3.",
    "67a3c6ac.json": "1. Input: Given an input grid of integers representing a color pattern, where each integer ranges from 0 to 9.\n2. Output Grid Size: The output grid has the same dimensions as the input grid.\n3. Transformation: Create a mirror image of the input grid from left to right.\n4. Step-by-step mirroring process:\n   4.1. Iterate through each row R of the input grid, from the top row to the bottom row.\n   4.2. Iterate through each column C of the input row R, from the leftmost column to the rightmost column.\n   4.3. For each pixel at (R, C) in the input grid, copy its integer value V to the pixel at (R, width - 1 - C) in the output grid, where 'width' is the number of columns in the input grid. The coordinates (R,C) are zero-indexed.",
    "67a423a3.json": "1. Identify two intersecting lines of different colors in the input grid. These lines will be composed of pixels with distinct numerical values (1-9, excluding 0, which represents black/background). Let the numerical value of the first line be 'A' and the numerical value of the second line be 'B'.\n2. Find the intersection point (R, C) where the two lines meet. This point will initially have either the value 'A' or 'B'.\n3. Create a 3x3 square centered at the intersection point (R, C). The square will span rows R-1 to R+1 and columns C-1 to C+1.\n4. Assign the value '4' (representing yellow) to all pixels within the 3x3 square, EXCEPT for the central pixel at (R, C).\n5. The central pixel (R, C) retains its original value (either 'A' or 'B'). All pixels outside of the 3x3 square remain unchanged.",
    "67e8384a.json": "1. Take the 3x3 input grid. \n2. Create a 6x6 output grid.\n3. Copy the 3x3 input grid to the top-left corner (coordinates (0,0) to (2,2)) of the 6x6 output grid.\n4. Copy the 3x3 input grid to the top-right corner (coordinates (0,3) to (2,5)) of the 6x6 output grid.\n5. Create a mirrored (flipped vertically) copy of the 3x3 input grid.\n6. Copy the mirrored 3x3 input grid to the bottom-left corner (coordinates (3,0) to (5,2)) of the 6x6 output grid.\n7. Copy the mirrored 3x3 input grid to the bottom-right corner (coordinates (3,3) to (5,5)) of the 6x6 output grid.",
    "681b3aeb.json": "1. Initialize a 3x3 output grid filled with 0s.\n2. Find the two distinct non-0 shapes in the input grid. These shapes will have pixel values other than 0.\n3. Determine the bounding box for each shape. The bounding box is the smallest rectangle that contains all pixels of that shape.\n4. Copy the first shape to the output grid, starting at position (0, 0). The pixel values in the shape will replace the 0s in the output grid.\n5. Copy the second shape to the output grid.  The placement of the second shape must be such that when combined with the first shape, the result forms a filled or nearly filled 3x3 grid. Overlapping pixel values from the two shapes are permitted. Experiment to find a correct placement via shifting the location of the second grid. The coordinates of the top left corner of the bounding box of the second grid can be shifted between (-2, -2) and (2, 2).\n6. If multiple valid placements exist, any one is acceptable.\n7. The resulting output grid should contain a combination of the pixel values from the two input shapes, arranged to fill the 3x3 grid as completely as possible.",
    "6855a6e4.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Identify two vertical lines composed of pixel value 2 (red). These lines form the brackets. They should be approximately parallel.\n3. Identify two distinct shapes composed of pixel value 5 (grey). These shapes are located outside the brackets.\n4. For each grey shape:\n    a. Move the grey shape to the interior of the two red brackets.\n    b. Position the grey shape such that there is a column of pixel value 0 (black) between the red bracket and the edge of the grey shape closest to that bracket.\n    c. Flip the grey shape vertically.\n5. Ensure that the red brackets remain unchanged from the input grid in the output grid. The relative vertical positions of the shapes and brackets do not change, only the horizontal.",
    "68b16354.json": "1. Read the input grid. The grid contains integer values from 0 to 9. These values represent different colors. The specific mapping is: 0: black, 1: blue, 2: red, 3: green, 4: yellow, 5: grey, 6: pink, 7: orange, 8: cyan, 9: brown. However, the algorithm operates directly on the numerical values, not the colors. \n2. Determine the height and width of the input grid.\n3. Create an output grid with the same height and width as the input grid.\n4. Iterate through each row R of the input grid, from the top row (R=0) to the bottom row (R=height-1).\n5. For each row R, copy the entire row to row (height - 1 - R) in the output grid. Specifically: for each column C from 0 to width - 1, set the pixel value at output_grid[height - 1 - R][C] equal to the pixel value at input_grid[R][C].\n6. The output grid is now the vertically flipped version of the input grid.",
    "694f12f3.json": "1. Identify all distinct objects of value 4 in the input grid. An object is defined as a contiguous group of pixels with value 4, where contiguity is defined by 4-way connectivity (up, down, left, right). Ignore any object that touches the border of the grid.\n2. For each identified object, perform a flood fill. The fill value depends on the size of the object. Determine the size of each object by counting the number of pixels with value 4 that constitute the object.\n3. Determine the object with the largest size and fill it with value 2.\n4. Determine the object with the smallest size and fill it with value 1. If there is only one object, fill it with 2.\n5. All the pixels with value 4 that are not internal to the objects with value 2 or 1, should remain as value 4.",
    "6a1e5592.json": "1. Copy the input grid to the output grid. The output grid dimensions are the same as the input grid dimensions.\n2. Identify all distinct regions of connected pixels with value 5 (gray) in the input grid. Each such region represents a gray shape.\n3. For each gray shape identified in step 2:\n    a. Find the optimal vertical shift for the gray shape to fit into the connected region of pixels with value 2 (red) at the top of the output grid. Optimality is defined by maximizing the overlap between the shifted gray shape and the red region, while minimizing overlap with other regions, or minimizing empty space within the red region.\n    b. Shift the gray shape vertically by the determined optimal shift value within the output grid.\n    c. Change the pixel value of all pixels belonging to the shifted gray shape from 5 (gray) to 1 (dark blue) in the output grid.\n4. Replace all pixels with value 5 (gray) in the output grid with the value 0 (black).",
    "6aa20dc0.json": "1. Identify a 3x3 reference grid within the input grid. This grid contains exactly three distinct non-background pixel values. Let the background pixel value be B. \n2. Locate other clusters of connected pixels within the input grid that contain exactly two of the three non-background pixel values found in the reference 3x3 grid.\n3. For each such cluster:\n   a. Determine the missing pixel value from the reference 3x3 grid that is not present in the cluster.\n   b. Fill in the missing pixel value to complete the pattern from the reference 3x3 grid. Specifically, for each pixel in the cluster's bounding box, if the pixel has the background value B, determine its corresponding value in the 3x3 reference grid. Set the pixel's value to that corresponding value.\n4. The output grid has the same dimensions as the input grid. The 3x3 grid is not altered. Any clusters that only have one pixel value are not considered. Any 2x2 or larger blocks use the same value to fill in based on the 3x3 grid, scaled up accordingly. The rotation or reflection may need to be applied to align the pattern.",
    "6b9890af.json": "1. Find the largest square of value 2 in the input grid. Define the size of this square as N. The output grid will have dimensions N x N.\n2. Identify the other distinct non-2 object in the input grid. Let's call this object 'target'.\n3. Create an N x N output grid.\n4. Fill the entire output grid with the pattern of 'target'.",
    "6c434453.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Identify all connected regions of pixels with value 1 in the input grid. If a region forms a square shape, replace all pixels with value 1 in that square region in the *output* grid with value 2.\n3. Identify closed regions of pixels with value 2 in the input grid, and set corner pixels in the *output* grid to 0.\n4. All other pixel values in the output grid should remain the same as in the copied input grid.",
    "6cdd2623.json": "1. Find the unique pixel value (1-9) that appears exactly four times in the input grid. Let this value be 'X'. If no such value exists, the task is invalid.\n2. Locate the coordinates (R, C) of the four pixels with value 'X'. Label them P1, P2, P3, and P4.\n3. Create an output grid of the same dimensions as the input grid, initialized with pixel value 0.\n4. Determine the two pairs of pixels to connect. The pairs should connect pixels across the grid, not along edges. If P1 and P2 are on the top/bottom edges, and P3 and P4 are on the left/right edges (or vice-versa), connect P1 to P2 and P3 to P4. If all four are on the top/bottom edges, connect the two most distant pixels, and similarly for the left/right edges.\n5. Draw a line of value 'X' between the first pair of pixels (e.g., P1 and P2). For all rows between the row of P1 and the row of P2, set the pixel at the column of P1 (or P2, since they are aligned) to 'X'.\n6. Draw a line of value 'X' between the second pair of pixels (e.g., P3 and P4). For all columns between the column of P3 and the column of P4, set the pixel at the row of P3 (or P4, since they are aligned) to 'X'.\n7. The output grid is now complete. Return this grid.",
    "6cf79266.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Find all 3x3 regions in the input grid where every pixel has a value of 0 (black).\n3. For each such 3x3 region found, replace the corresponding 3x3 region in the output grid with a 3x3 region where every pixel has a value of 1 (blue).",
    "6d0160f0.json": "1. Divide the input grid into nine 3x3 subgrids. Assume the input grid dimensions are a multiple of 3.\n2. Find the 3x3 subgrid that contains at least one pixel with the value 4 (yellow).\n3. Designate the 3x3 subgrid found in step 2 as the \"source subgrid\".\n4. Determine the position of the source subgrid within the 3x3 arrangement of subgrids (top-left, top-middle, top-right, middle-left, middle, middle-right, bottom-left, bottom-middle, bottom-right).\n5. Create an output grid identical in size to the input grid, filled initially with 0 (black) in all subgrids except for one.\n6. Based on the position determined in step 4, identify the corresponding 3x3 subgrid in the output grid.\n7. Copy the pixel values from the source subgrid (identified in step 3) to the corresponding 3x3 subgrid in the output grid (identified in step 6).\n8. In the output grid, change any pixel value 5 (grey) within the copied subgrid to 0 (black).\n9. Retain any border, specifically keeping the pixel values of 5 (grey) if they exist in the original grid and were not part of the copied subgrid.",
    "6d0aefbc.json": "1. Input is a 3x3 grid of numbers (0-9).\n2. Create a new output grid with dimensions 3x6.\n3. Copy the original 3x3 grid into the left half (columns 0, 1, and 2) of the output 3x6 grid. For each row R (0-2) and column C (0-2) of the input grid, set the pixel value at (R, C) in the output grid to the corresponding pixel value in the input grid.\n4. Reflect the original 3x3 grid horizontally to fill the right half (columns 3, 4, and 5) of the output 3x6 grid. Specifically, for each row R (0-2) and column C (0-2) of the input grid, set the pixel value at (R, 3+C) in the output grid to the pixel value at (R, 2-C) from the input grid.",
    "6d58a25d.json": "1. Identify the 'arrowhead' shape. This is a contiguous non-zero region in the input grid. Treat 0 as background.\n2. For each column C in the input grid, find the first row R_arrowhead directly below the 'arrowhead' shape such that grid[R_arrowhead, C] is not 0 (not part of the background).\n3. If a non-zero value (representing a color) exists in the input grid at grid[R_arrowhead, C], then proceed; otherwise, move to the next column.\n4. If grid[R_arrowhead, C] contains a value N (1-9), create a vertical line downwards from row R_arrowhead in column C, setting grid[R, C] = N for all rows R from R_arrowhead to the bottom of the grid.\n5. Retain all other pixel values in the grid. Output the modified grid.",
    "6d75e8bb.json": "1. Find the largest connected region of pixels with a value of 8 in the input grid. Let this region be called 'region 8'.\n2. Determine the bounding box of 'region 8'. The bounding box is defined by the minimum and maximum row and column indices of the pixels in 'region 8'.\n3. Create an output grid with the same dimensions as the input grid.\n4. Copy all pixel values from the input grid to the output grid.\n5. Fill the area within the bounding box in the output grid with the value 2. This means, for every row R between the minimum and maximum row indices of the bounding box, and every column C between the minimum and maximum column indices of the bounding box, set output_grid[R][C] = 2.",
    "6e02f1e3.json": "1. Input is a 3x3 grid. The grid contains pixel values between 0 and 9. Determine the number of distinct pixel values (colors) in the input grid.\n2. Create a new 3x3 grid filled with the value 0.\n3. Based on the number of distinct pixel values, modify the new grid as follows:\n4. If the number of distinct pixel values is 1:\n   a. Set the pixel value at (0, 0) to 5.\n   b. Set the pixel value at (0, 1) to 5.\n   c. Set the pixel value at (0, 2) to 5.\n5. If the number of distinct pixel values is 2:\n   a. Set the pixel value at (0, 0) to 5.\n   b. Set the pixel value at (1, 1) to 5.\n   c. Set the pixel value at (2, 2) to 5.\n6. If the number of distinct pixel values is 3:\n   a. Set the pixel value at (0, 2) to 5.\n   b. Set the pixel value at (1, 1) to 5.\n   c. Set the pixel value at (2, 0) to 5.\n7. The modified 3x3 grid is the output.",
    "6e19193c.json": "1. Copy the input grid to the output grid.\n2. Identify all L-shaped regions consisting of three connected pixels of the same non-zero value. A region is L-shaped if it consists of three pixels where removing one pixel leaves a straight line. The grid may contain multiple such L-shaped regions.\n3. For each L-shaped region, determine the pixel that, if changed to 0, would complete a 2x2 square containing the L-shape. This pixel is considered the \"center\" of the L-shape.\n4. Leave the \"center\" pixel with value 0.\n5. Starting from the pixel diagonally adjacent to the \"center\" pixel (relative to the L-shape's open corner; move diagonally away from the \"inside\" of the L), extend a diagonal line. The diagonal direction should not be the same direction as the L-shape's point.\n6. For each pixel along this diagonal line, set its value to the original non-zero value of the L-shaped region, until the edge of the grid is reached.\n7. Repeat steps 3-6 for each identified L-shaped region.",
    "6e82a1ae.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Find connected groups of pixels with value 5 (grey) in the input grid.\n3. For each connected group found in step 2:\n    a. If the group contains 2 pixels, change the pixel values of the corresponding pixels in the output grid to 3 (green).\n    b. If the group contains 3 pixels, change the pixel values of the corresponding pixels in the output grid to 2 (red).\n    c. If the group contains 4 pixels, change the pixel values of the corresponding pixels in the output grid to 1 (blue).",
    "6ecd11f4.json": "1. Find the small grid (source grid) and the large grid (mask grid) in the input. The small grid contains multiple values (0-9). The large grid primarily contains one value, with a pattern of value 0 (black). The small grid's dimensions are smaller than the large grid's dimensions.\n2. Determine the dimensions (rows and columns) of the small grid. The output grid will have the same dimensions as the small grid.\n3. Create an output grid with the dimensions determined in step 2, and initialize it with the values from the small grid.\n4. Iterate through each cell (R, C) of the small grid and the corresponding cell (R, C) of the large grid.\n5. In each iteration, check the value of the cell (R, C) in the large grid.\n6. If the value of the cell (R, C) in the large grid is 0, then replace the value of the corresponding cell (R, C) in the output grid with 0.\n7. If the value of the cell (R, C) in the large grid is not 0, keep the value of the cell (R, C) in the output grid as it is.\n8. After iterating through all cells, the output grid contains the transformed pattern.",
    "6f8cd79b.json": "1. Get the input grid. Let its dimensions be R rows and C columns.\n2. Create a new output grid with the same dimensions (R rows and C columns).\n3. Initialize all pixel values in the output grid to 0.\n4. Iterate through each pixel (r, c) in the output grid, where r ranges from 0 to R-1, and c ranges from 0 to C-1.\n5. Check if the current pixel (r, c) is located on the border of the grid. A pixel is on the border if any of the following conditions are true:\n    a. r is 0 (top row).\n    b. r is R-1 (bottom row).\n    c. c is 0 (leftmost column).\n    d. c is C-1 (rightmost column).\n6. If the pixel (r, c) is on the border (as determined in step 5), set the pixel value at (r, c) in the output grid to 8.\n7. After iterating through all pixels, the output grid now contains a border of value 8, with the interior remaining as 0.\n8. Output the generated output grid.",
    "6fa7a44f.json": "1. Take the input grid, which is a 3x3 grid.\n2. Create an output grid with dimensions 3x6.\n3. Copy the entire 3x3 input grid to the top-left portion of the output grid, specifically to the coordinates (R, C) where R ranges from 0 to 2 and C ranges from 0 to 2.\n4. Mirror the 3x3 input grid vertically to create a reflected image. \n5. Place this mirrored 3x3 grid in the bottom portion of the output grid, specifically at coordinates (R, C) where R ranges from 3 to 5 and C ranges from 0 to 2. For example, the value at input grid coordinate (0,0) should be placed at output grid coordinate (5,0). The value at input grid coordinate (2,1) should be placed at output grid coordinate (3,1).",
    "72322fa7.json": "1. Create an output grid with the same dimensions as the input grid. 2. Copy the input grid to the output grid. 3. Identify all unique, connected shapes composed of non-zero pixel values in the input grid; consider these shapes as exemplars. 4. For each pixel in the input grid, if the pixel has a non-zero value and is not part of any identified exemplar shape (i.e., it's a singleton): 5. Find all exemplar shapes with the same pixel value as the singleton. 6. For each matching exemplar shape, determine the relative coordinates of all pixels constituting that shape with respect to a reference point (e.g., top-left pixel of the shape). 7. Apply the pattern of the first matching exemplar shape found in step 5 to the singleton. That is, for each relative coordinate in the exemplar's pattern, set the corresponding pixel value in the output grid, relative to the singleton's location, to the exemplar's pixel value at that relative coordinate.",
    "72ca375d.json": "1. Find all distinct figures on the input grid. A figure is a connected component of non-zero pixel values, surrounded by pixels with value 0.\n2. Select one of the figures.\n3. Determine the bounding box of the selected figure. The bounding box is the smallest rectangular region that contains all non-zero pixels of the selected figure.\n4. Create an output grid. The dimensions of the output grid should be the same as the dimensions of the bounding box of the selected figure.\n5. Copy the pixel values from the input grid, within the bounding box of the selected figure, to the corresponding locations in the output grid.\n6. All other locations in the output grid will be filled with the pixel value 0.",
    "73251a56.json": "1. The output grid has the same dimensions as the input grid.\n2. Identify all pixel locations in the input grid where the pixel value is 0 (black).\n3. Determine the pattern of non-zero pixel values radiating from the top-left corner (0, 0) of the input grid.\n4. For each pixel location identified in step 2, replace the pixel value 0 with a value that continues the pattern identified in step 3.",
    "7447852a.json": "1. Input: Assume an input grid containing 2 (red) patterns on a 0 (black) background.\n2. Output Grid Size: The output grid has the same dimensions as the input grid.\n3. Locate: Identify all cells with value 0 (black).\n4. Iterate: Process the 0 (black) cells from left to right, row by row, starting from the bottom row and proceeding upwards.\n5. Fill: For each 0 (black) cell, check its index in the sequence of 0 (black) cells. If the index modulo 3 is equal to 0, replace the 0 (black) cell with 4 (yellow). Otherwise, leave the 0 (black) cell unchanged.\n6. Output: The modified grid with some 0 (black) cells replaced by 4 (yellow) according to the described pattern.",
    "7468f01a.json": "1. Identify the bounding box of the largest non-zero object in the input grid. This defines the active region.\n2. Create an output grid with the same dimensions as the input grid.\n3. Copy the content within the bounding box from the input grid to the corresponding region in the output grid.\n4. Identify all distinct non-zero objects within the bounding box of the copied region in the output grid.\n5. For each identified non-zero object:\n    a. Define the bounding box of the current non-zero object.\n    b. Rotate the pixels within this object's bounding box 180 degrees.\n    c. Replace the original object in the output grid with the rotated object.",
    "746b3537.json": "1. Analyze the input grid (4x4). Identify three columns of paired numbers. The numbers can range from 0 to 9. Descriptions suggest a pattern within these number pairs.\n2. Create an output grid of size 1x1.\n3. Determine the predominant number from the input grid's patterned number pairs. If the number pairs indicate a single, repeating number, use that number. If the number pairs vary, identify the most frequent number across all pairs.\n4. Assign the most frequent number (0-9) found in step 3 to the single cell of the 1x1 output grid.\n5. Output the 1x1 grid.",
    "74dd1130.json": "1. Analyze the input grid. The grid contains two or three distinct numbers on a background of 5. Some grids have very specific arrangements of values.\n2. The output grid has the same dimensions as the input grid.\n3. Perform a transformation that involves a mirroring operation, in some cases combined with a rotation.\n4. Specific Transformations (apply only when input conditions are met):\n5. If the input contains a pattern of values, especially with value 2 at specific locations (e.g., locations 1, 2, and 9 when numbered top-down, left-to-right from 1), perform the following:\n    a. Move the value 2 from location 2 to location 4. (Numbering is assumed to be top-down, left-to-right starting from 1).\n    b. Change the value at location 2 to 5.\n6. If the above condition is not met, then:\n    a. Rotate the input grid 90 degrees clockwise.\n    b. Mirror the rotated grid horizontally.",
    "75b8110e.json": "1. Create a 4x4 output grid initialized with all values set to 0.\n2. Define the input grid as an 8x8 grid.\n3. Copy the top-left quadrant (rows 0-3, columns 0-3) from the input grid to the output grid (rows 0-3, columns 0-3). This quadrant contains the initial pattern with value 4.\n4. Superimpose the bottom-right quadrant (rows 4-7, columns 4-7) from the input grid onto the output grid. For each pixel (R, C) in the output grid, if the corresponding pixel in the bottom-right quadrant of the input grid has a value other than 0, replace the output grid's pixel value at (R, C) with the value from the input grid (bottom-right quadrant). This quadrant contains the pattern with value 9.\n5. Superimpose the bottom-left quadrant (rows 4-7, columns 0-3) from the input grid onto the output grid. For each pixel (R, C) in the output grid, if the corresponding pixel in the bottom-left quadrant of the input grid has a value other than 0, replace the output grid's pixel value at (R, C) with the value from the input grid (bottom-left quadrant). This quadrant contains the pattern with value 6.\n6. Superimpose the top-right quadrant (rows 0-3, columns 4-7) from the input grid onto the output grid. For each pixel (R, C) in the output grid, if the corresponding pixel in the top-right quadrant of the input grid has a value other than 0, replace the output grid's pixel value at (R, C) with the value from the input grid (top-right quadrant). This quadrant contains the pattern with value 5.",
    "760b3cac.json": "1. Find the yellow shape (value 4) and the blue shape (value 1) in the input grid. The background is value 0.\n2. Identify the location of the tallest point (highest column index if multiple tallest points) of the yellow shape (value 4).\n3. Determine if the tallest point of the yellow shape (value 4) is on the left or right side of the shape. Compare the column index of the tallest point to the horizontal center of the bounding box of the yellow shape.\n4. If the tallest point of the yellow shape (value 4) is on the left, mirror the blue shape (value 1) horizontally.\n5. If the tallest point of the yellow shape (value 4) is on the right, mirror the blue shape (value 1) horizontally.\n6. Place the mirrored blue shape (value 1) to the right of the original blue shape (value 1) in the output grid.\n7. The output grid size is the same as the input grid size.\n8. The rest of the output grid should contain background value 0.",
    "776ffc46.json": "1. Identify shapes in the input grid that are completely enclosed by a border of value 5 (grey). A shape is defined as a connected region of non-zero pixel values. The border must completely surround the shape with value 5.\n2. For each shape identified in Step 1, determine its dimensions (height and width).\n3. Find other shapes in the input grid that have the same dimensions as the shape identified in Step 1.\n4. For each shape found in Step 3 that has the same dimensions, replace the pixel values of that shape with the pixel value of the shape enclosed by the grey border (value 5) identified in Step 1.",
    "77fdfe62.json": "1. Find the inner region of value 8 (cyan/light blue) in the input grid. This region is surrounded by a border of value 1 (dark blue). The corners outside of the region of value 8 (cyan/light blue) contain colored squares. \n2. Define the output grid size to be the same size as the inner region of value 8 (cyan/light blue).\n3. Copy the inner region of value 8 (cyan/light blue) from the input to the output grid.\n4. For each pixel with value 8 (cyan/light blue) in the output grid, determine the nearest corner square color in the original input grid. Replace the pixel value 8 (cyan/light blue) with the numerical value of the nearest corner color. The color-to-number mapping is: 0: black, 1: blue, 2: red, 3: green, 4: yellow, 5: grey, 6: pink, 7: orange, 8: cyan, 9: brown.",
    "780d0b14.json": "1. Find all unique pixel values (0-9) in the input grid, excluding the value 0 (representing the black background).\n2. Determine the number of unique, non-zero pixel values found in step 1. This number will be the dimension of the output grid (NxN).\n3. Create an empty output grid of size NxN.\n4. Copy the arrangement of the non-zero pixel values from the input grid to the output grid. The arrangement should mirror the original input grid. For example, if the pixel value 1 appears in the top-left corner of the pattern in the input, place it in the top-left position in the output grid.\n5. Each unique pixel value from the input (excluding 0) is placed in the output grid, maintaining its relative position as observed in the input grid's pattern. The relative spatial arrangement of the non-zero values in the input should be replicated in the output.\n6. If a color (pixel value) is present multiple times in the input, its position in the output grid should reflect its overall arrangement from the input.",
    "7837ac64.json": "1. Find the corners of squares in the input grid.\n2. The output grid is 3x3.\n3. For each cell (R, C) in the output grid (where R and C range from 0 to 2):\n4. Determine the corresponding square in the input grid based on (R,C).\n5. Extract the pixel values at the four corners of this corresponding square in the input grid.\n6. If the pixel values of all four corners are the same, set the pixel value of cell (R, C) in the output grid to that corner value.\n7. Otherwise, set the pixel value of cell (R, C) in the output grid to 0.",
    "794b24be.json": "1. Find the input grid dimensions (rows, columns). The output grid will have the same dimensions.\n2. Count the number of pixels with value 1 in the input grid.\n3. Create an output grid with the same dimensions as the input, initialized with all pixel values set to 0.\n4. Starting from the top-left corner of the output grid (row 0, column 0), fill pixels with the value 2 according to the following order, until the count from step 2 is reached: (0, 0), (0, 1), (0, 2), (1, 1). Only fill a location if the count from step 2 has not been exhausted. If the count is exhausted, the output grid remains with value 0 for the remaining locations.\n5. The output grid is now complete.",
    "7b6016b9.json": "1. Copy the input grid to the output grid, maintaining the same dimensions.\n2. Identify the largest connected region of value 0 (representing the background). Starting from any pixel with value 0 on the border of the grid, perform a flood fill, changing all connected 0s to 3 (green).\n3. Identify all regions surrounded by value 4 (yellow). For each such region, change the value of all cells within that region to 2 (red).",
    "7b7f7511.json": "1. Determine the dimensions (rows and columns) of the input grid. Let the number of rows be R and the number of columns be C.\n2. Determine the larger dimension between R and C. This dimension will be halved.\n3. If R >= C, the output grid will have dimensions R/2 rows and C columns. If R is odd, use floor(R/2). Copy the top half rows [0 to R/2-1] from the input grid to the output grid.\n4. If C > R, the output grid will have dimensions R rows and C/2 columns. If C is odd, use floor(C/2). Copy the left half columns [0 to C/2-1] from the input grid to the output grid.\n5. For each pixel in the output grid at row r and column c, the value will be the same value as the corresponding pixel in the input grid from which it was copied.",
    "7c008303.json": "1. Find the input grid, which contains a cross of value 8 (cyan/light blue) dividing it into four sections. Let's call these sections quadrants. The light blue cross is not considered part of any quadrant.\n2. Identify a 2x2 section (section A) containing multiple colors. The location of this section can vary, but its upper-left corner's coordinates define its position.\n3. Identify a 6x6 section (section B) containing only values 3 (green) and 0 (black). The location of this section can vary, but its upper-left corner's coordinates define its position.\n4. Create a 6x6 output grid, filled initially with 0 (black).\n5. Copy the contents of the 6x6 section B from the input grid to the 6x6 output grid.\n6. Divide the 6x6 output grid into four 3x3 quadrants: top-left, top-right, bottom-left, and bottom-right.\n7. Find the value of the top-left cell in the 2x2 section A. Replace all pixels with value 3 (green) in the top-left 3x3 quadrant of the output grid with this value.\n8. Find the value of the top-right cell in the 2x2 section A. Replace all pixels with value 3 (green) in the top-right 3x3 quadrant of the output grid with this value.\n9. Find the value of the bottom-left cell in the 2x2 section A. Replace all pixels with value 3 (green) in the bottom-left 3x3 quadrant of the output grid with this value.\n10. Find the value of the bottom-right cell in the 2x2 section A. Replace all pixels with value 3 (green) in the bottom-right 3x3 quadrant of the output grid with this value.\n11. The output grid now contains the transformed result.",
    "7ddcd7ec.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Find all locations (R, C) in the input grid where a non-zero pixel value is located at a corner of a larger square or rectangular block of pixels.\n3. For each such location (R, C) with a non-zero pixel value V, extend a diagonal line of pixels with value V from (R, C) towards the edge of the grid.\n4. The diagonal extension must follow these rules: If the corner is top-left, extend diagonally towards the top-left corner of the grid (decreasing R and C). If the corner is top-right, extend diagonally towards the top-right corner of the grid (decreasing R and increasing C). If the corner is bottom-left, extend diagonally towards the bottom-left corner of the grid (increasing R and decreasing C). If the corner is bottom-right, extend diagonally towards the bottom-right corner of the grid (increasing R and C).\n5. The extension stops when it reaches the grid boundary or encounters a pixel with a value different from V. During the extension, overwrite any existing pixel values along the diagonal with V.",
    "7df24a62.json": "1. Copy the input grid to the output grid. The input grid can be either 23x23 or 22x22. Determine the dimensions from the input. If the background color of the input is 1 (blue), change the background color of the output grid to 0 (black). \n2. If there are instances of 4 (yellow) boxes surrounded by 1 (blue) boxes, identify all such patterns in the input grid.\n3. Find all instances of 4 (yellow) boxes in the input grid. These 4 (yellow) boxes should have the same configuration as the pattern identified in Step 2.\n4. For each instance of the 4 (yellow) pattern found in Step 3, surround it with 1 (blue) boxes in the output grid, exactly as the 4 (yellow)/1 (blue) pattern identified in Step 2. Note that \"surrounding\" means adding 1 (blue) boxes to all sides of the 4 (yellow) boxes.",
    "7e0986d6.json": "1. Identify the dominant non-0 value in the input grid. This value represents the primary colored shape. Let this value be called 'dominant_color'.\n2. Create a new grid with the same dimensions as the input grid, filled with the value 0 (black background).\n3. Copy the area of the input grid containing the dominant colored shape (pixels with value 'dominant_color') to the corresponding location in the new grid.\n4. Identify all pixels in the input grid with value 1 (blue).\n5. For each blue pixel (value 1) at coordinate (R, C) in the input grid, perform the following:\n6. Examine the surrounding pixels of (R, C) in the input grid. Consider the immediate neighbors: (R-1, C), (R+1, C), (R, C-1), and (R, C+1). If any of these coordinates are out of bounds, ignore them.\n7. Determine the most frequent non-1 value among the valid neighboring pixels.\n8. In the output grid, replace the value at (R, C) with this most frequent neighboring value determined in step 7.",
    "7f4411dc.json": "1. Analyze the input grid. The input grid contains shapes composed of pixels with values 1-9, and isolated single pixels with values 1-9. 0 represents the background.\n2. Identify all single pixels. A single pixel is defined as a pixel that is not adjacent (horizontally or vertically) to any other pixel of the same value.\n3. Remove all identified single pixels. Change the value of each identified single pixel to 0.\n4. Output the modified grid.",
    "7fe24cdd.json": "1. Define the input grid as a 3x3 matrix. Let this be INPUT.\n2. Create an empty 6x6 output grid. Let this be OUTPUT.\n3. Copy the INPUT grid to the top-left 3x3 section of the OUTPUT grid. Specifically, for each row R and column C from 0 to 2: OUTPUT[R][C] = INPUT[R][C].\n4. Rotate the INPUT grid 90 degrees clockwise. Let this rotated grid be ROTATED_1. Specifically, for each row R and column C from 0 to 2: ROTATED_1[C][2-R] = INPUT[R][C].\n5. Copy the ROTATED_1 grid to the top-right 3x3 section of the OUTPUT grid. Specifically, for each row R and column C from 0 to 2: OUTPUT[R][C+3] = ROTATED_1[R][C].\n6. Rotate the ROTATED_1 grid 90 degrees clockwise. Let this rotated grid be ROTATED_2. Specifically, for each row R and column C from 0 to 2: ROTATED_2[C][2-R] = ROTATED_1[R][C].\n7. Copy the ROTATED_2 grid to the bottom-right 3x3 section of the OUTPUT grid. Specifically, for each row R and column C from 0 to 2: OUTPUT[R+3][C+3] = ROTATED_2[R][C].\n8. Rotate the ROTATED_2 grid 90 degrees clockwise. Let this rotated grid be ROTATED_3. Specifically, for each row R and column C from 0 to 2: ROTATED_3[C][2-R] = ROTATED_2[R][C].\n9. Copy the ROTATED_3 grid to the bottom-left 3x3 section of the OUTPUT grid. Specifically, for each row R and column C from 0 to 2: OUTPUT[R+3][C] = ROTATED_3[R][C].\n10. The OUTPUT grid now contains the final result.",
    "80af3007.json": "1. Find the 9x9 pattern on the 0 (black) background in the input grid. This pattern consists of nine 3x3 squares arranged in a 3x3 grid.\n2. The output grid will be 9x9, matching the size of the identified pattern.\n3. Copy the original 9x9 pattern to the output grid.\n4. For each 3x3 square within the output grid that has the value 5 (grey):\n    a. Replace that 3x3 square with a smaller version of the original 9x9 pattern.  This means map the values in the 9x9 pattern to the 3x3 square. Treat the 9x9 grid as a template and tile it inside the 3x3 square replacing the square's initial value of 5.",
    "810b9b61.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Identify all connected regions of pixels with value 1 (representing original blue shapes) in the input grid.\n3. For each connected region of 1s identified in step 2:\n    a. Check if the region is a closed shape. A closed shape is defined as a shape where every pixel with value 1 in the region is adjacent only to other pixels with value 1 or pixels with value other than 1 that create an enclosed area. \n    b. If the region is a closed shape, replace the value of all pixels in that region in the output grid with the value 3 (representing green).\n    c. If the region is not a closed shape (i.e., it is an open shape or line), retain the value of 1 in the output grid for that region.",
    "82819916.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Iterate through each row (R) of the output grid.\n3. For each row (R), check if there is a complete, non-black (not 0) colored line present in the input grid. If a fully filled line exists in the input, copy that row's pattern in the input grid to the corresponding row (R) in the output grid.\n4. If a row (R) in the input grid has exactly three non-zero values, denote the value of the first and second filled-in cells in the row as A, and the value of the third filled-in cell as I. Replace all remaining zero values in row (R) of the output grid according to the following pattern: A A I I I A I A. If the row length exceeds this pattern, repeat the pattern as needed.\n5. Any remaining zero values in the output grid should remain zero.",
    "83302e8f.json": "1. Initialize the output grid to be identical in size to the input grid. Copy all pixel values from the input grid to the corresponding locations in the output grid.\n2. Identify all squares of value 0 (black) in the input grid.\n3. For each identified black square, examine its borders (the pixels immediately surrounding it). \n4. If all borders of the black square are solid, change the value of that square in the output grid from 0 (black) to 3 (green).\n5. If any border of the black square is broken (or not solid), change the value of that square in the output grid from 0 (black) to 4 (yellow).\n6. All pixels that are not modified based on the above steps should retain their original values from the input grid in the output grid.",
    "834ec97d.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Find the coordinates (R, C) of the single non-0 pixel in the input grid. Let 'value' be the value of this pixel.\n3. In the output grid, set the pixel at (R+1, C) to 'value'.\n4. Starting at row R, and going up to row 0 (inclusive), set the pixel at (row, C) to 4.\n5. Starting at column C+2, and going to the right edge of the grid, and for every other column (C+2, C+4, C+6,...), set all the pixels in that column to 4.\n6. Starting at column C-2, and going to the left edge of the grid, and for every other column (C-2, C-4, C-6,...), set all the pixels in that column to 4.",
    "8403a5d5.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Iterate through the columns of the output grid, starting from the leftmost column (column 0).\n3. For each column, check if the column index is even (0, 2, 4, ...). If the column index is even, copy the corresponding column from the input grid to the output grid. In other words, retain the original pixel values from the input grid for that column.\n4. If the column index is odd (1, 3, 5, ...), set all pixel values in that column of the output grid to 0.\n5. After processing all columns as described above, iterate through the output grid's columns again, starting from the second column (index 1).\n6. For each odd-indexed column (1, 3, 5,...), identify the topmost pixel. Change this pixel's value to 5.\n7. For the next odd-indexed column, identify the bottommost pixel. Change this pixel's value to 5.\n8. Repeat steps 6 and 7, alternating between setting the topmost and bottommost pixels to 5 for each successive odd-indexed column.",
    "846bdb03.json": "1. Find the bounding box of the input grid. Let the height and width of this bounding box be H and W, respectively.\n2. Identify two vertical \"pillar\" structures within the input grid. These structures are characterized by having a block of 4 (yellow) at both their top and bottom.\n3. Determine the coordinates of the top-left and bottom-left 4 (yellow) blocks of both pillar structures. These define the vertical boundaries.\n4. Create an output grid with height H and width W, where H is the height of the pillar structures and W is the width between the outer edges of the two 4 (yellow) blocks plus the width of the two 4 (yellow) blocks.\n5. Place a 4 (yellow) block in each of the four corners of the output grid.\n6. Fill the space between the 4 (yellow) blocks with 0 (black).\n7. Extract the color patterns located between the two pillar structures in the input grid. These patterns should connect the two pillar structures between the 4 (yellow) blocks.\n8. Copy these color patterns into the corresponding space in the output grid between the 4 (yellow) blocks. If the color arrangement between the pillar structures needs to be flipped to match, perform a horizontal flip before copying.\n9. If necessary, consider the possibility of mirroring or rotating color arrangements to ensure the colors within the connecting patterns match the adjacent colors in the vertical \"pillar\" structures.",
    "855e0971.json": "1. Find all pixels with value 0 in the input grid.\n2. For each pixel with value 0 at coordinate (R, C), determine the boundaries of the connected region of non-0 values that contains this pixel.\n3. Determine the width and height of this connected region.\n4. If the width of the region is greater than or equal to the height, extend the pixel with value 0 horizontally to fill the entire width of the region, starting from the original pixel location (R, C). This means setting all pixels in row R, from the leftmost to the rightmost column of the region, to 0.\n5. If the height of the region is greater than the width, extend the pixel with value 0 vertically to fill the entire height of the region, starting from the original pixel location (R, C). This means setting all pixels in column C, from the topmost to the bottommost row of the region, to 0.\n6. The output grid has the same dimensions as the input grid. The output grid should contain the modified grid after applying steps 4 and 5 to each pixel with value 0.",
    "85c4e7cd.json": "1. Determine the grid size (N x N) of the input grid. Assume N is odd. \n2. Initialize an output grid of the same size (N x N) as the input grid.\n3. Iterate through the layers of the input grid, starting from the outermost layer and moving inwards. The layer number L ranges from 0 to (N-1)/2.\n4. For each layer L:\n   a. Identify the value V_outer of the pixels at layer L in the input grid. This value represents the 'outermost color' for this layer.\n   b. Identify the value V_inner of the pixels at layer (N-1)/2 in the input grid. This value represents the 'innermost color'.\n   c. Calculate the corresponding mirrored layer L_mirrored = (N-1)/2 - L. Note: This mirrored layer index starts from the center and goes outwards. For example, if (N-1)/2 is 4 and L is 0, then the mirrored layer will have index 4.\n   d. Assign the pixel value V_outer to the pixels at layer L_mirrored in the output grid.\n   e. The new value for each pixel is determined as follows: For layer L, assign the value found at layer (N-1)/2 to layer L of the output. For layer (N-1)/2, assign the value found at layer L to layer (N-1)/2 of the output. For other layers, assign the original value from the input grid.\n5. Output the modified grid.",
    "868de0fa.json": "1. Identify the input grid, which contains a grid of numbers. Assume the grid contains a background of 0 and squares with borders of 1.\n2. Create an output grid with the same dimensions as the input grid.\n3. Identify squares bordered by the value 1.\n4. Fill the area inside each 1-bordered square with the value 2, only if the dimensions of the filled square are even.\n5. For the remaining 1-bordered squares (dimensions 1x1, 3x3, 5x5, etc.), fill the area inside each 1-bordered square with the value resulting from the combination of 2 and 4. Since the combination logic is undefined, use value 7 as a default to represent a mixture of the red and yellow squares instead. This implies if a square is 1x1, 3x3, 5x5, etc., fill it with the value 7.\n6. The rest of the grid, (i.e., where the input was 0), should remain as 0 in the output grid.",
    "8731374e.json": "1. Find the smallest subgrid within the larger input grid that contains values other than the background value. Define this subgrid as the 'target subgrid'.\n2. Determine the dimensions (rows and columns) of the target subgrid. Let R be the number of rows and C be the number of columns.\n3. Initialize an output grid with dimensions equal to the dimensions of the target subgrid.\n4. Iterate through each cell in the target subgrid. If a cell at row r and column c within the target subgrid has a value other than the background value, perform the following:\n5. Fill the entire row r of the output grid with the value found at cell (r, c) of the target subgrid.\n6. Fill the entire column c of the output grid with the value found at cell (r, c) of the target subgrid.\n7. The resulting output grid represents the transformed input.",
    "88a10436.json": "1. Copy the input grid to the output grid.\n2. Identify the 3x3 shape within the input grid. This shape contains pixel values from 0-9.\n3. Identify the single pixel with value 5 (grey) in the input grid. Let its row and column coordinates be (R, C).\n4. Define a 3x3 subgrid in the output grid, with its center at (R, C). The coordinates of the top-left corner of this subgrid are (R-1, C-1), and the bottom-right corner are (R+1, C+1).\n5. Copy the 3x3 shape identified in step 2 to the 3x3 subgrid defined in step 4, overwriting the existing pixel values in the output grid within that region.",
    "88a62173.json": "1. Analyze the input grid to identify distinct rectangular sub-grids in each corner of the input. Assume these sub-grids contain numerical patterns.\n2. Determine the dimensions (rows and columns) of one of these corner sub-grids. This determines the output grid's dimensions.\n3. Copy the pixel values from one of the corner sub-grids from the input grid to create the output grid. The choice of which corner sub-grid to use is arbitrary but must be consistent across all input-output pairs for a given task. For example, always copy the top-left sub-grid.\n4. The output grid will then have dimensions equal to the dimensions of the chosen corner sub-grid, and its pixel values will match the pixel values of that sub-grid from the input.",
    "890034e9.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Identify the shape in the input grid. The shape is defined as a contiguous region that is not the background color. Assume the background color is the most frequent color in the grid, excluding 0 (black).\n3. Within the identified shape, count the number of pixels with value 0 (black). This is the 'black count'.\n4. Search the input grid for another region containing pixels with value 0 (black), where the number of black pixels is equal to the 'black count' calculated in step 3. These black pixels need not form a shape. This region may also contain additional black squares around it.\n5. Determine the center coordinates (R, C) of this second region of black pixels. If the black pixels form a rectangular block, the center is the center of the rectangle. If the black pixels are scattered, estimate the center as the average row and column indices of the black pixels.\n6. Copy the identified shape from the input grid. Let the top-left corner of the bounding box of the shape be (shape_R, shape_C).\n7. Paste the copied shape onto the output grid, such that the center of the second black region (R, C) in the output grid becomes the center of the pasted shape. Calculate the paste location as follows: The top-left corner of the shape (shape_R, shape_C) in the copied shape should be placed at (R - (original shape width / 2), C - (original shape height / 2)) of output. Handle boundary conditions: if the calculated paste location goes beyond the bounds of the output grid, shift the shape until it fits within the grid, truncating the shape if necessary.\n8. Ensure that the output contains two identical shapes.",
    "8a004b2b.json": "1. Find the four corner squares with pixel value 4 (yellow). These define the corners of a rectangular region.\n2. Define the output grid to be the rectangular region bounded by the four corner squares found in step 1. The output grid size is determined by the dimensions of this rectangle.\n3. Identify the region outside the 4 (yellow) corner squares in the input grid. Call this the 'external pattern'.\n4. Copy the 'external pattern' from the input grid into the output grid, replacing any existing content within the output grid (the area defined by the 4 (yellow) corner squares). The top-left corner of the 'external pattern' should align with the top-left corner of the output grid.",
    "8be77c9e.json": "1. Get the input grid, which is a 3x3 grid containing values 0 and 1.\n2. Create an output grid with a height of 6 and a width of 3. Initialize all cells to 0.\n3. Copy the input grid to the top half of the output grid. For each row R and column C in the input grid (0 <= R <= 2, 0 <= C <= 2), set the pixel value at output grid location (R, C) to the value at input grid location (R, C).\n4. Reflect the input grid vertically and copy it to the bottom half of the output grid. For each row R and column C in the input grid (0 <= R <= 2, 0 <= C <= 2), set the pixel value at output grid location (5-R, C) to the value at input grid location (R, C).",
    "8d5021e8.json": "1. Analyze the input grid. The input grid is expected to be 2x3, containing four pixels with value 0 (representing black) and two pixels with other values.\n2. Create an output grid with dimensions 5x9.\n3. Copy the original 2x3 input grid to the top-left corner of the output grid (starting at coordinates (0, 0)).\n4. Create a reversed copy of the input grid. The \"reversed\" input grid is obtained by mirroring the original input grid horizontally. For each row, the values of the first and third columns are swapped.\n5. Place the reversed input grid immediately to the right of the original input grid in the output grid (starting at coordinates (0, 3)).\n6. Repeat steps 4 and 5 two more times, placing the reversed input grid to the right of the previous reversed input grid in the output grid (starting at coordinates (0, 6) for the second repetition and beyond the output grid for the third repetition, so only part of the mirrored input appears in the output).\n7. Fill the two rows below the pattern with mirrored and reversed input grids analogously. The second row will start at (2,0) and continue as above.",
    "8d510a79.json": "1. Input is a grid of integers (0-9). The output grid has the same dimensions as the input grid. \n2. Identify all locations (R, C) in the input grid that contain the value 2 (red) or 1 (blue).\n3. Count the number of cells with value 2 (red) and the number of cells with value 1 (blue).\n4. If the count of cells with value 2 (red) is even, then for each cell (R, C) with value 2 in the input grid, fill all cells from (R+1, C) down to the bottom of the grid with the value 2. Do not change the value of the original cell (R, C).\n5. If the count of cells with value 2 (red) is odd, then for each cell (R, C) with value 2 in the input grid, fill all cells from (R-1, C) up to the top of the grid with the value 2. Do not change the value of the original cell (R, C).\n6. If the count of cells with value 1 (blue) is even, then for each cell (R, C) with value 1 in the input grid, fill all cells from (R+1, C) down to the bottom of the grid with the value 1. Do not change the value of the original cell (R, C).\n7. If the count of cells with value 1 (blue) is odd, then for each cell (R, C) with value 1 in the input grid, fill all cells from (R-1, C) up to the top of the grid with the value 1. Do not change the value of the original cell (R, C).\n8. All other cell values remain unchanged.",
    "8e1813be.json": "1. Find the largest square within the input grid that is not composed of pixel value 0. This is the 'colored square'.\n2. Determine the size (N x N) of the 'colored square'. The output grid will also be of size N x N.\n3. Identify lines (rows or columns) within the input grid that contain pixel values other than 0. These are 'colored lines'.\n4. Determine the orientation of the 'colored lines'. Are they primarily horizontal (rows) or vertical (columns)?\n5. If the 'colored lines' are horizontal:\n    a. Iterate through the rows of the input grid.\n    b. For each row identified as a 'colored line' (containing non-zero pixel values), record the pixel value (0-9) present in that row.\n    c. Repeat these recorded pixel values in the same order to fill the rows of the N x N output grid, creating horizontal stripes.\n6. If the 'colored lines' are vertical:\n    a. Iterate through the columns of the input grid.\n    b. For each column identified as a 'colored line' (containing non-zero pixel values), record the pixel value (0-9) present in that column.\n    c. Repeat these recorded pixel values in the same order to fill the columns of the N x N output grid, creating vertical stripes.\n7. Output the generated N x N grid.",
    "8e5a5113.json": "1. Input: Assume the input grid contains three squares arranged horizontally. The left square contains a pattern of numbers (0-9). The middle and right squares contain only the number 0.\n2. Output Grid Size: The output grid has the same dimensions as the input grid.\n3. Copy: Copy the content of the left square in the input grid to the left square in the output grid. No change.\n4. Rotate Middle Square: Create a rotated version of the left square. Rotate the original pattern clockwise by 90 degrees. Place the result into the middle square of the output grid. If the original grid has a '2' (red) in the top-left corner, after rotation, '2' (red) should now be in the top-right corner.\n5. Rotate Right Square: Create another rotated version of the original left square. Rotate the original pattern clockwise by 180 degrees relative to its original orientation. Place the result into the right square of the output grid. If the original grid has a '2' (red) in the top-left corner, after rotation, '2' (red) should now be in the bottom-right corner.",
    "8eb1be9a.json": "1. Input: Observe a grid of numbers. Identify a central pattern within this grid.\n2. Output Grid Size: The output grid will have the same dimensions (height and width) as the input grid.\n3. Transformation: Create the output grid by replicating the identified central pattern to fill the entire grid. Specifically:\n    a. Determine the boundaries of the central pattern in the input grid.\n    b. Copy this central pattern.\n    c. Paste the copied pattern repeatedly across the entire output grid, both horizontally and vertically, until the output grid is completely filled.",
    "8efcae92.json": "1. Identify all distinct shapes in the input grid. These shapes consist of connected regions of non-zero pixel values on a background of 0s.\n2. Determine the shape to replicate. Several descriptions suggest different methods:\n    * Method 1: The shape with the most pixels of value 2 (red).\n    * Method 2: The bottom-most shape.\n    * Method 3: One of the shapes formed by pixels of value 1 (blue).\n    Choose **one** of these methods and apply it consistently across all input/output pairs.\n3. Let the chosen shape's dimensions be R rows and C columns. Create an output grid of size R x C.\n4. Copy the pixel values from the chosen shape in the input grid to the corresponding locations in the output grid. Specifically, for each row r from 0 to R-1 and each column c from 0 to C-1, set output[r][c] = input[row_start + r][col_start + c], where (row_start, col_start) is the top-left coordinate of the chosen shape in the input grid.\n5. Return the output grid.",
    "8f2ea7aa.json": "1. Initialize the output grid to be identical to the input grid. The input and output grids have the same dimensions.\n2. Iterate through each cell (R, C) of the input grid, where R is the row index and C is the column index.\n3. If the pixel value at (R, C) in the input grid is not 0 (black), then proceed; otherwise, skip to the next cell.\n4. Treat the input grid as a representation of a 3x3 grid of blocks, where each block has a size equal to input_width/3 x input_height/3 (assuming input_width and input_height are divisible by 3).\n5. Calculate the starting row and column indices of the corresponding block in the output grid: block_start_row = (R // (input_height // 3)) * (input_height // 3), block_start_col = (C // (input_width // 3)) * (input_width // 3).\n6. For each cell (R_in, C_in) in the input grid that has the same non-zero value as cell (R, C), calculate the corresponding block start row: block_start_row_in = (R_in // (input_height // 3)) * (input_height // 3), block_start_col_in = (C_in // (input_width // 3)) * (input_width // 3).\n7. Iterate through all cells of the input grid, and if the pixel value is same as input pixel value at (R,C), replicate the entire input grid shape in the output grid, starting at the calculated block_start_row_in and block_start_col_in.\n8. To 'replicate the shape', iterate through each cell (input_R, input_C) in the original input grid. For each such cell, calculate corresponding output cell (output_R, output_C) within the target block as follows: output_R = block_start_row_in + input_R % (input_height // 3) and output_C = block_start_col_in + input_C % (input_width // 3).\n9. Set the pixel value at (output_R, output_C) in the output grid to the pixel value at (input_R, input_C) from the input grid.\n10. After processing all colored pixels, return the modified output grid.",
    "90c28cc7.json": "1. Find the bounding box of non-0 pixels (colored regions) in the input grid. Let this bounding box define the active region.\n2. Analyze the active region to identify the minimal repeating rectangular pattern. This pattern consists of cells with values 1-9.\n3. Determine the dimensions (rows and columns) of this minimal repeating pattern.\n4. Create an output grid with the dimensions determined in step 3.\n5. For each cell (R, C) in the output grid, copy the corresponding pixel value from the minimal repeating pattern found in the input's active region. If the pattern's height is H and width is W, then output[R, C] = input[R_in, C_in] where R_in = R % H + min_row, and C_in = C % W + min_col. Here min_row and min_col are the row and column indices of the top-left corner of the bounding box.\n6. Ensure all values in the output grid are integers between 1 and 9.",
    "90f3ed37.json": "1. Input: Observe an input grid containing a pattern in the top row. A similar, incomplete pattern exists in one or more rows below the top row, starting at certain cell locations within these rows.\n2. Output Grid Size: The output grid maintains the same dimensions as the input grid.\n3. Transformation: For each row containing an incomplete pattern:\n    3.1. Copy the pattern from the top row.\n    3.2. Align the copied pattern with the starting cell locations observed in the incomplete pattern row.\n    3.3. Fill the remaining cells in the incomplete pattern row with the corresponding pixel values from the copied pattern, using pixel value 1 (dark blue).",
    "913fb3ed.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Iterate through each cell (R, C) in the input grid.\n3. If the value of the cell (R, C) in the input grid is 3 (green), then change the value of all adjacent cells (up, down, left, right, and diagonals) in the output grid to 6 (pink). Handle edge cases by checking boundaries.\n4. If the value of the cell (R, C) in the input grid is 8 (cyan / light blue), then change the value of all adjacent cells (up, down, left, right, and diagonals) in the output grid to 4 (yellow). Handle edge cases by checking boundaries.\n5. If the value of the cell (R, C) in the input grid is 2 (red), then change the value of all adjacent cells (up, down, left, right, and diagonals) in the output grid to 1 (blue). Handle edge cases by checking boundaries.",
    "91413438.json": "1. Analyze the input grid, which is a 3x3 grid. The background color is 0 (black). The foreground is some colored pattern. Count the number of non-0 (non-black) pixels in the 3x3 input grid. This count is referred to as 'N'.\n2. Determine the size of the output grid based on 'N':\n    - If N = 3, output grid size is 18x18.\n    - If N = 4, output grid size is 15x15.\n    - If N = 5, output grid size is 12x12.\n    - If N = 6, output grid size is 9x9.\n    - It is implied that input will contain an N between 3 and 6. A plausible extrapolation of the above pattern is:\n    - If N = 1, output grid size is 24x24.\n    - If N = 2, output grid size is 21x21.\n    - If N = 7, output grid size is 6x6.\n    - If N = 8, output grid size is 3x3.\n    - If N = 9, output grid size is 0x0 (empty grid).\n3. Create an empty output grid of the determined size (WxH).\n4. Copy the 3x3 input pattern horizontally into the output grid, repeating it 'N' times. Start at the top-left corner (0, 0) of the output grid.  Each copy of the 3x3 input grid should be placed immediately to the right of the previous copy. If 'N' copies of the input grid exceed the width 'W' of the output grid, then stop copying after having copied only the 'N' times. Do not wrap around to the next line. Do not scale the original pattern.",
    "91714a58.json": "1. Analyze the input grid to identify a solid block of the same pixel value, where the block's height is at least 2 pixels. If multiple such blocks exist, prioritize the largest one.\n2. Create an output grid with the same dimensions as the input grid, initialized with all pixel values set to 0.\n3. Copy the identified solid block from the input grid to the corresponding location in the output grid. This means: for each pixel (R, C) within the identified solid block in the input, copy the pixel value at (R, C) from the input grid to (R, C) in the output grid.\n4. All other pixels in the output grid remain 0.",
    "9172f3a0.json": "1. Create a 9x9 output grid initialized with zeros. \n2. Iterate through each cell (r, c) of the 3x3 input grid, where r and c range from 0 to 2.\n3. For each input cell (r, c), extract its numerical value. Let this value be V.\n4. In the 9x9 output grid, define a 3x3 block corresponding to the input cell (r, c). The top-left corner of this block is located at output grid coordinates (r*3, c*3).\n5. Fill the entire 3x3 block in the output grid, starting at (r*3, c*3) and extending to (r*3 + 2, c*3 + 2), with the value V. That is, for row R ranging from r*3 to r*3 + 2, and column C ranging from c*3 to c*3 + 2, set output_grid[R][C] = V.",
    "928ad970.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Find the four positions of pixels with value 5 (grey). Let these positions be (R1, C1), (R2, C2), (R3, C3), and (R4, C4).\n3. Determine the boundaries of the largest rectangle that can be enclosed by the four grey pixels. The sides of this new rectangle must touch the inside of each of the four grey pixels.\n4. Find the color (numerical value) of the original smaller rectangle within the four grey pixels. To do this, locate any pixel inside the smaller rectangle. Read its numerical value (0-9). Let this value be 'COLOR'.\n5. Draw a new rectangle on the output grid, using 'COLOR' as the pixel value, with the boundaries determined in Step 3. This rectangle will replace the corresponding pixels in the copied grid with the value 'COLOR'.",
    "93b581b8.json": "1. Copy the input grid to the output grid. The input grid contains a 2x2 square with four distinct numbers in its corners.\n2. Identify the 2x2 square within the grid. Let (R, C) be the top-left coordinates of this 2x2 square.\n3. Create four 2x2 blocks. \n4. The first 2x2 block's number should be the same as the number in the input's 2x2 square at (R+1, C+1). Place this block such that its top-left corner touches the top-left corner (R, C) of the identified 2x2 square.\n5. The second 2x2 block's number should be the same as the number in the input's 2x2 square at (R+1, C). Place this block such that its top-left corner touches the top-right corner (R, C+1) of the identified 2x2 square.\n6. The third 2x2 block's number should be the same as the number in the input's 2x2 square at (R, C+1). Place this block such that its top-left corner touches the bottom-left corner (R+1, C) of the identified 2x2 square.\n7. The fourth 2x2 block's number should be the same as the number in the input's 2x2 square at (R, C). Place this block such that its top-left corner touches the bottom-right corner (R+1, C+1) of the identified 2x2 square.\n8. If any part of the added 2x2 blocks falls outside the bounds of the output grid, those parts should be ignored (not added to the grid).",
    "941d9a10.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid. 2. Identify the regions separated by pixels with value 5 (grey). 3. Perform a flood fill operation in the top-left region using the color value 1 (blue). Start the flood fill from the top-leftmost pixel of the region. 4. Perform a flood fill operation in the central region using the color value 2 (red). Start the flood fill from a central pixel of the region. 5. Perform a flood fill operation in the bottom-right region using the color value 3 (green). Start the flood fill from the bottom-rightmost pixel of the region.",
    "94f9d214.json": "1. Input is a 4x8 grid. The top 4x4 subgrid contains a pattern of 3's (green). The bottom 4x4 subgrid contains a pattern of 1's (blue). \n2. Create a 4x4 output grid.\n3. Copy the bottom 4x4 subgrid (1's / blue pattern) from the input to the output grid.\n4. Copy the top 4x4 subgrid (3's / green pattern) from the input to the output grid, overlaying it on the existing output grid.\n5. In the output grid, replace all 0's (black) with 2's (red).\n6. In the output grid, replace all 3's (green) and 1's (blue) with 0's (black).",
    "952a094c.json": "1. Find the bounding rectangle of non-zero pixels within the input grid. Let this rectangle's top-left corner be (R1, C1) and its bottom-right corner be (R2, C2). Assume the input grid has a black (0) background.\n2. Copy the input grid to the output grid.\n3. Identify the four inner corner pixels within the bounding rectangle. These are located at (R1+1, C1+1), (R1+1, C2-1), (R2-1, C1+1), and (R2-1, C2-1).\n4. Store the pixel values at these four inner corner locations. Let these values be V1, V2, V3, and V4, corresponding to the locations (R1+1, C1+1), (R1+1, C2-1), (R2-1, C1+1), and (R2-1, C2-1), respectively.\n5. Set the pixel values at the inner corner locations (R1+1, C1+1), (R1+1, C2-1), (R2-1, C1+1), and (R2-1, C2-1) in the output grid to 0.\n6. Replace the pixel at the outer corner location (R2, C2) in the output grid with V1 (the original value at (R1+1, C1+1)).\n7. Replace the pixel at the outer corner location (R2, C1) in the output grid with V2 (the original value at (R1+1, C2-1)).\n8. Replace the pixel at the outer corner location (R1, C2) in the output grid with V3 (the original value at (R2-1, C1+1)).\n9. Replace the pixel at the outer corner location (R1, C1) in the output grid with V4 (the original value at (R2-1, C2-1)).",
    "9565186b.json": "1. Analyze the input grid to count the occurrences of each unique number (0-9). 2. Identify the number with the highest count. If there are multiple numbers with the same highest count, arbitrarily select one. 3. Iterate through each cell (R, C) of the input grid. 4. If the number at cell (R, C) is not the number identified in step 2, replace it with 5 (grey). 5. The resulting grid is the output grid.",
    "95990924.json": "1. Input: Identify all squares containing the value 5 (grey). These are the 'center squares'.\n2. Output Grid Size: The output grid has the same dimensions as the input grid.\n3. Transformation: For each 'center square' at row R and column C:\n    a. Set the pixel at (R-1, C-1) to 1 (blue). If (R-1, C-1) is outside the grid bounds, skip this step for this center square.\n    b. Set the pixel at (R-1, C+1) to 2 (red). If (R-1, C+1) is outside the grid bounds, skip this step for this center square.\n    c. Set the pixel at (R+1, C-1) to 3 (green). If (R+1, C-1) is outside the grid bounds, skip this step for this center square.\n    d. Set the pixel at (R+1, C+1) to 4 (yellow). If (R+1, C+1) is outside the grid bounds, skip this step for this center square.\n4. All other pixels in the output grid retain their original values from the input grid.",
    "963e52fc.json": "1. Get the input grid dimensions (rows, columns). Let these be 'input_rows' and 'input_cols'.\n2. Create an output grid with dimensions 'input_rows' and 'input_cols * 2'.\n3. Iterate through each row 'R' from 0 to 'input_rows - 1'.\n4. Iterate through each column 'C' from 0 to 'input_cols - 1'.\n5. Copy the pixel value from the input grid at (R, C) to the output grid at (R, C).\n6. Copy the pixel value from the input grid at (R, C) to the output grid at (R, C + input_cols).\n7. The output grid now contains the repeating pattern from the input grid.",
    "97999447.json": "1. Copy the input grid to the output grid.\n2. Iterate through each row (R) and each column (C) of the input grid.\n3. If the pixel value at (R, C) is not 0 (black), store the original color value V from the input grid at (R, C).\n4. Initialize a flag variable named 'alternate' to 0.\n5. Starting from the column C+1 in row R, and continuing to the right edge of the grid in row R, perform the following steps:\n6. If 'alternate' is 0, set the pixel value in the output grid at (R, column) to 5 (grey).\n7. If 'alternate' is 1, set the pixel value in the output grid at (R, column) to V (the original color).\n8. Toggle the value of 'alternate'. If 'alternate' is currently 0, change it to 1. If 'alternate' is currently 1, change it to 0.\n9. Continue steps 6-8 until the right edge of the grid in row R is reached.\n10. Repeat steps 3-9 for each row R and column C of the input grid.",
    "97a05b5b.json": "1. Identify the 'large grid' containing a pattern with missing sections. The large grid will contain a color other than 0 where the missing sections are. Determine the dimensions of this large grid. The output grid will have these same dimensions.\n2. Identify the 'small grids', each representing a piece that fits into one of the missing sections of the 'large grid'. These 'small grids' will also likely have a color other than 0 in them.\n3. For each 'small grid', find the location where it fits into the 'large grid'. This is done by overlaying the 'small grid' onto the 'large grid' in such a way that it fills a missing section.\n4. For each missing section, copy the corresponding 'small grid' into the 'large grid', replacing the black (0) pixels in the 'large grid' with the pixel values from the corresponding 'small grid'.\n5. The resulting 'large grid', now with the missing sections filled, is the output grid.",
    "98cf29f8.json": "1. Identify the background color in the input grid, which is 0 (black). Confirm that the input grid contains exactly two other colors besides the background color 0. These colors represent two distinct shapes and a dividing line.\n2. Identify a single horizontal or vertical line in the input grid. This line will consist of a single color and span the entire width or height of the grid. Let the value of the color composing this line be denoted as 'line_color'.\n3. Create an output grid that is an exact copy of the input grid.\n4. In the output grid, remove the single horizontal or vertical line identified in step 2 by setting all pixel values of the line to the background color 0.\n5. Identify the shape in the input grid that has the same color as 'line_color'.\n6. Move the identified shape towards the other shape by shifting all pixels of 'line_color' that comprised the shape in the direction where the line was removed. The movement should continue until the two shapes are adjacent to each other. Pixels of the same color ('line_color') in the original shape position should become 0 (black) after the shift.",
    "995c5fa3.json": "1. Divide the input grid into three distinct sections. Assume the input grid has a height that is approximately three times its width. Each section's height should be roughly equal to the input grid's width. Process each section separately to determine the color for each row in the 3x3 output grid.\n2. Create a 3x3 output grid.\n3. Process the first section of the input grid to determine the value for the top row of the output grid. Examine the content of this section. Specifically:\n    a. If the first section contains a 2x2 block of 0s (black) in the center, set the first row of the output grid to 8 (cyan).\n    b. If the first section contains no 0s (black), set the first row of the output grid to 2 (red).\n    c. If the first section contains a 2x2 block of 0s (black) centered at the bottom, set the first row of the output grid to 4 (yellow).\n    d. If the first section contains two 1x2 lines of 0s (black) on the left and right sides, set the first row of the output grid to 3 (green).\n    e. If none of the above conditions are met, the color of the first row is determined by other descriptions, otherwise, set the first row of the output grid to 2 (red).\n4. Process the second section of the input grid in the same manner as step 3 to determine the value of the second row of the output grid.\n    a. If the second section contains a 2x2 block of 0s (black) in the center, set the second row of the output grid to 8 (cyan).\n    b. If the second section contains no 0s (black), set the second row of the output grid to 2 (red).\n    c. If the second section contains a 2x2 block of 0s (black) centered at the bottom, set the second row of the output grid to 4 (yellow).\n    d. If the second section contains two 1x2 lines of 0s (black) on the left and right sides, set the second row of the output grid to 3 (green).\n    e. If none of the above conditions are met, set the second row of the output grid to 1 (blue).\n5. Process the third section of the input grid in the same manner as steps 3 and 4 to determine the value of the third row of the output grid.\n    a. If the third section contains a 2x2 block of 0s (black) in the center, set the third row of the output grid to 8 (cyan).\n    b. If the third section contains no 0s (black), set the third row of the output grid to 2 (red).\n    c. If the third section contains a 2x2 block of 0s (black) centered at the bottom, set the third row of the output grid to 4 (yellow).\n    d. If the third section contains two 1x2 lines of 0s (black) on the left and right sides, set the third row of the output grid to 3 (green).\n    e. If none of the above conditions are met, set the third row of the output grid to 4 (yellow).\n6. Ensure each row in the output grid has the same numerical value for all cells within that row. For example, if the first row is determined to be 2 (red), then all cells in the first row should have the value 2. If the second row is set to 1 (blue), then every cell in the second row will have a value of 1, and the third row has value 4 (yellow), then every cell in the third row has a value of 4.\n7. The output grid is a 3x3 grid with each row containing a single distinct numerical value (0-9) based on the processed input sections.",
    "99b1bc43.json": "1. Input: The input grid contains a 4x4 square (Square A) of pixels with values 1 (blue) and 0 (black), followed by a horizontal line of pixels with value 4 (yellow), followed by another 4x4 square (Square B) of pixels with values 2 (red) and 0 (black). Square A is located above the yellow line, and Square B is located below the yellow line.\n2. Output Grid Size: The output grid is a 4x4 square.\n3. Algorithm: Create a new 4x4 output grid.\n4. Iterate through each pixel location (R, C) within the 4x4 squares, where R is the row number (0-3) and C is the column number (0-3).\n5. For each pixel location (R, C): Compare the pixel value at (R, C) in Square A to the pixel value at (R, C) in Square B.\n6. If the pixel value at (R, C) in Square A is equal to the pixel value at (R, C) in Square B, set the pixel value at (R, C) in the output grid to 0 (black).\n7. If the pixel value at (R, C) in Square A is not equal to the pixel value at (R, C) in Square B, set the pixel value at (R, C) in the output grid to 3 (green).\n8. The resulting 4x4 grid is the output.",
    "99fa7670.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Find all non-zero pixel locations in the input grid. These locations represent the starting points for extending lines.\n3. Iterate through the non-zero pixel locations, processing them from bottom to top (largest row index to smallest row index).\n4. For each non-zero pixel location (R, C) with value V (where V is between 1 and 9):\n    a. Extend a horizontal line to the right from (R, C) until the right edge of the grid is reached. Set the value of all pixels in this line to V.\n    b. Extend a vertical line downwards from the rightmost pixel of the horizontal line (at row R) until the bottom edge of the grid is reached, or until another non-zero pixel with a different value is encountered. The extension downwards should stop *before* overwriting a pixel with a value different than 0. Set the value of all pixels in this vertical line to V.\n5. The output grid now contains the transformed image.",
    "9aec4887.json": "1. Find the two input grids: the primary grid (referred to as the 'colored object' or 'colored pattern') and the secondary grid (referred to as the 'light blue object' or 'light blue pattern').\n2. Determine the dimensions (rows and columns) of the primary grid. The output grid will have the same dimensions.\n3. Copy the primary grid to the output grid. This will serve as the base.\n4. Overlay the secondary grid onto the center of the primary grid in the output. The 'light blue object' or 'light blue pattern' (translated to the number 8) is placed inside the 'colored object'.\n5. Identify all pixels with value 8 (originally 'light blue') in the output grid that are adjacent to pixels of a different value (representing the outline of the original primary grid).\n6. For each identified pixel with value 8 that is adjacent to the outline of the primary grid, replace its value with the value of the adjacent non-8 pixel.\n7. Output the resulting grid.",
    "9af7a82c.json": "1. Analyze the input grid to determine the frequency of each distinct number (0-9). Ignore any background color if present. If a background color is present, find the most frequently occurring number and consider this the background.\n2. Identify the distinct numbers present in the input grid, excluding the background number (if any). Count the occurrences of each of these distinct numbers.\n3. Sort the distinct numbers in descending order based on their frequency (number of occurrences). Let 'N' be the number of distinct numbers.\n4. Determine the output grid dimensions: The width of the output grid is equal to N (the number of distinct numbers). The height of the output grid is equal to the maximum frequency among all distinct numbers in the input grid.\n5. Create a new output grid with dimensions calculated in step 4, initialized with the background number 0 (black).\n6. Iterate through each column of the output grid, from left to right (column index from 0 to N-1):\n   a. For the current column 'C', retrieve the corresponding number from the sorted list of distinct numbers (obtained in step 3). Let this number be 'Value'.\n   b. Determine the frequency 'F' of 'Value' in the input grid.\n   c. Fill the first 'F' rows of column 'C' with the number 'Value', starting from the top row (row index 0).\n   d. Leave the remaining rows in column 'C' (from row index 'F' to the bottom) as the background number 0 (black).",
    "9d9215db.json": "1. Find all non-zero pixel values in the input grid. These represent colored boxes.\n2. Identify the arrangement of these non-zero pixels.\n3. Create an output grid of the same dimensions as the input grid, initialized with all pixel values set to 0.\n4. Copy the arrangement of non-zero pixels to each of the four corners of the output grid. Ensure the copied arrangements are mirrored reflections of the original arrangement, relative to the center of the original arrangement.\n5. Identify two adjacent non-zero pixel values, value A and value B, in the original arrangement.\n6. Using value A, create a border around the entire output grid. The border should start from the location of value A in the corner arrangement and extend outwards. Place value A pixels separated by one 0 pixel until reaching another corner.\n7. Using value B, place value B pixels at the corners where the border created with value A ends.\n8. When placing the border with value A, if a location already contains a non-zero pixel value from the corner arrangements, skip that location, leaving the existing non-zero pixel untouched.",
    "9dfd6313.json": "1. Input: Read the input grid of integers (0-9). The grid represents a pattern of colored blocks, where each number corresponds to a color. The grid size remains constant throughout the transformation.\n2. Rotate: Rotate the input grid 90 degrees to the right (clockwise).\n3. Flip: Flip the rotated grid horizontally. The left edge of the rotated grid becomes the right edge of the final output.\n4. Output: Write the resulting transformed grid as the output. The output grid has the same dimensions as the input grid.",
    "9ecd008a.json": "1. Find the regions of connected pixels with value 0 in the input grid. These are the \"black spots\".\n2. Determine the pattern that needs to be filled into each \"black spot\". This will likely involve analyzing the pixels surrounding the \"black spots\" to infer a repeating or evolving pattern.\n3. For each \"black spot\", copy the inferred pattern into the \"black spot\". Ensure the pattern is correctly aligned and that any pattern evolution is properly applied as it is copied.\n4. The output grid should be the same size as the input grid, with the \"black spots\" now filled with the inferred and copied pattern.",
    "9edfc990.json": "1. Copy the input grid to the output grid. The output grid will be of the same size as the input grid.\n2. Identify connected regions of 0s (black pixels) in the input grid.\n3. For each connected region of 0s:\n    a. Check if the region is surrounded by non-zero pixels. A region is considered surrounded if every 0 in the region has at least one non-zero neighbor (up, down, left, or right).\n    b. If the region is surrounded by non-zero pixels, change all the 0s in that region in the output grid to 1s (blue).\n4. The output grid now contains the modified grid with specific black regions changed to blue.",
    "9f236235.json": "1. Identify the central region of the input grid. The method for identifying the central region is not explicitly defined; further clarification would be needed to determine the precise algorithm. It could be based on a fixed size, a specific pattern, or another criterion. Assume the central region's coordinates are (R_start, C_start) to (R_end, C_end). If the central region cannot be automatically identified then the process cannot continue.\n2. Copy the pixel values from the central region defined in Step 1. These copied values will form the basis of the output grid.\n3. Determine the desired size of the output grid. The size may be specified in the prompt or derived from the input grid's characteristics. Let the output grid dimensions be Rows_out x Cols_out.\n4. Create an empty output grid of size Rows_out x Cols_out, initialized with a default value (e.g., 0).\n5. Replicate or transform the copied central pattern to fill the output grid. The exact replication or transformation method isn't specified clearly. Possibilities include: \n     a. Tiling: Repeatedly paste the central region's pattern to fill the output grid. \n     b. Mirroring: Replicate the pattern while mirroring it horizontally and/or vertically. This is alluded to in Description 1. If mirroring, mirror the central pattern horizontally. If the central region is asymmetric, this mirrored version must be distinct from the original.\n6. Remove all pixels with value 2 (red) from the input grid, if present. This instruction is taken from Description 2.\n7. Output the transformed grid.",
    "a1570a43.json": "1. Identify four pixels with the value 3 that form a square within the input grid. These pixels define the corners of a frame.\n2. Identify all pixels with the value 2 within the input grid that form a connected shape. This is the shape to be repositioned.\n3. Calculate the center of the frame: Determine the coordinates of two opposite corner pixels with value 3, (R1, C1) and (R2, C2). The center of the frame is ((R1 + R2) / 2, (C1 + C2) / 2).\n4. Calculate the bounding box of the shape with value 2: Find the minimum and maximum row and column indices (min_R, max_R, min_C, max_C) of all pixels with value 2.\n5. Calculate the center of the shape: The center of the shape is ((min_R + max_R) / 2, (min_C + max_C) / 2).\n6. Calculate the offset: The offset is the difference between the frame's center and the shape's center. offset_R = frame_center_R - shape_center_R; offset_C = frame_center_C - shape_center_C.\n7. Create a new grid of the same size as the input grid, filled with 0s.\n8. Copy the shape with value 2 to the new grid, applying the calculated offset. For each pixel with value 2 at (R, C) in the original grid, place a pixel with value 2 at (R + offset_R, C + offset_C) in the new grid. Ensure that the copied shape remains entirely within the bounds defined by the four corner pixels with value 3. Do not copy if the new coordinates are out of bounds.\n9. Copy the four corner pixels with value 3 from the original input grid to the new grid at their original positions.\n10. The new grid is the output.",
    "a2fd1cf0.json": "1. Find the coordinates (R1, C1) of the first square with pixel value 2 (red). Assume there is only one such square.\n2. Find the coordinates (R2, C2) of the second square with pixel value 3 (green). Assume there is only one such square.\n3. Create a path of pixel value 8 (cyan/light blue) connecting the two squares using right angles.\n4. The path starts at (R1, C1) and extends horizontally to the column C2. Change the pixel values along the row R1 from column min(C1, C2) to max(C1, C2) to 8 (cyan/light blue).\n5. The path then extends vertically from the new coordinate (R1, C2) to (R2, C2). Change the pixel values along the column C2 from row min(R1, R2) to max(R1, R2) to 8 (cyan/light blue).\n6. The output grid has the same dimensions as the input grid, with the path of 8 (cyan/light blue) connecting the squares of 2 (red) and 3 (green).",
    "a3325580.json": "1. Define the input grid. Each cell in the grid contains a number from 0 to 9. 0 represents black.\n2. Identify distinct connected regions of non-0 numbers within the input grid. Call these regions 'shapes'.\n3. For each 'shape', count the number of cells it occupies (its area).\n4. Find the maximum area among all 'shapes'.\n5. Identify all 'shapes' that have an area equal to the maximum area found in step 4.\n6. Create the output grid. The number of columns in the output grid is equal to the number of 'shapes' identified in step 5. The number of rows in the output grid is equal to the maximum area (found in step 4).\n7. For each 'shape' identified in step 5, create a vertical column in the output grid. The value of all cells in this column is equal to the number associated with the cells of the corresponding shape in the input grid.\n8. The order of the vertical columns in the output grid should correspond to the left-to-right order of the identified shapes in the input grid. If two shapes are in the same column, use top to bottom order. If the maximum number of cells are 5 or more, output grid has a height matching input grid, and is 1 cell wide.",
    "a3df8b1e.json": "1. Find the single pixel with value 1 in the input grid. Let its coordinates be (R, C). This is the starting point. Assume that the bottom of the image has a higher R value than the top.\n2. Initialize current coordinates to (R, C).\n3. Iterate until the current row R is 0:\n    a. Move diagonally up and to the right: Set the pixel at (R-1, C+1) to 1. If C+1 is beyond the right boundary of the grid, stop this rightward movement.\n    b. Move diagonally up and to the left: Set the pixel at (R-1, C-1) to 1. If C-1 is less than 0 (beyond the left boundary of the grid), stop this leftward movement.\n    c. Decrement R (R = R - 1).\n4. The output grid has the same dimensions as the input grid. All pixels not set to 1 in the above steps should be kept as their original values.",
    "a416b8f3.json": "1. Get the input grid dimensions: input_height, input_width.\n2. Create an output grid with dimensions: output_height = input_height, output_width = 2 * input_width.\n3. Iterate through each row R from 0 to input_height - 1.\n4. Iterate through each column C from 0 to input_width - 1.\n5. Copy the pixel value from the input grid at (R, C) to the output grid at (R, C).\n6. Copy the pixel value from the input grid at (R, C) to the output grid at (R, C + input_width).",
    "a48eeaf7.json": "1. Identify all pixels with value 2 (red) in the input grid. These pixels form a target square.\n2. Identify all pixels with value 5 (grey) in the input grid. These pixels are to be moved.\n3. For each pixel with value 5 (grey), move it along its row or column towards the nearest pixel with value 2 (red), prioritizing the shortest path.\n4. If a pixel with value 5 (grey) encounters a pixel with value 2 (red) during its movement, stop the movement and place the pixel with value 5 (grey) adjacent to the pixel with value 2 (red).\n5. If multiple pixels with value 5 (grey) are on the same row or column, move them independently towards the nearest pixel with value 2 (red).\n6. Copy all the pixels with value 2 from the input grid to the output grid at their original positions.\n7. Copy all other pixel values to the output grid, after applying the movement rules for pixels with value 5.\n8. Ensure the output grid has the same dimensions as the input grid.",
    "a5313dff.json": "1. Find shapes in the input grid that have an interior filled with any number and a border consisting of any other number. Note the shape's outline and interior region.\n2. Create an output grid of the same size as the input grid.\n3. For each identified shape, fill the interior of the shape in the output grid with the number 1 (blue).\n4. If the border of the shape extends beyond the bounds of the output grid, maintain the original number 0 (black) for those border pixels in the output grid.",
    "a5f85a15.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Iterate through each diagonal line of the grid, starting from the top-left corner. A diagonal line consists of cells where the sum of the row and column indices is constant.\n3. Within each diagonal line, starting from the second cell, change the value of every other cell to 4. That is, if a cell (R, C) on a diagonal line is the nth cell on that diagonal line, and n is greater than or equal to 2, then change the cell's value to 4 if (n-1) is even.",
    "a61ba2ce.json": "1. The input grid contains four distinct 3-pixel patterns, each composed of a different color. These patterns are situated within a larger grid of 0s (black). The output grid will be 4x4. 2. Extract the four distinct 3-pixel patterns from the input. Let the first pattern correspond to the top-left corner, the second to the top-right, the third to the bottom-left, and the fourth to the bottom-right. 3. Create a 4x4 output grid. 4. Copy the first 3-pixel pattern to the top-left corner of the output grid, specifically to locations (0,0), (0,1), and (1,0). 5. Copy the second 3-pixel pattern to the top-right corner of the output grid, specifically to locations (0,3), (0,2), and (1,3). 6. Copy the third 3-pixel pattern to the bottom-left corner of the output grid, specifically to locations (3,0), (3,1), and (2,0). 7. Copy the fourth 3-pixel pattern to the bottom-right corner of the output grid, specifically to locations (3,3), (3,2), and (2,3). 8. Fill the central 2x2 square of the output grid with 0s (black). This corresponds to locations (1,1), (1,2), (2,1), and (2,2).",
    "a61f2674.json": "1. Copy the input grid to the output grid. The output grid dimensions are the same as the input grid dimensions.\n2. Identify all contiguous vertical lines or blocks composed of pixel value 5 (grey). A vertical line/block is defined as a set of vertically adjacent pixels with value 5.\n3. For each identified vertical line/block, determine its height (number of vertically adjacent pixels with value 5).\n4. Find the shortest vertical line/block. If there are multiple shortest lines/blocks, choose any one.\n5. Change the pixel value of all pixels in the shortest vertical line/block from 5 (grey) to 2 (red).\n6. Find the tallest vertical line/block. If there are multiple tallest lines/blocks, choose any one.\n7. Change the pixel value of all pixels in the tallest vertical line/block from 5 (grey) to 1 (blue).\n8. Change the pixel value of all remaining pixels with value 5 (grey) in the output grid to 0 (black).",
    "a64e4611.json": "1. Initialize the output grid to be the same size as the input grid. Copy all values from the input grid to the output grid.\n2. Identify all areas of connected 0s (black pixels) in the output grid.\n3. For each identified area of connected 0s:\n    a. Check if the area is completely surrounded by 0s (black pixels).\n    b. If the area is completely surrounded by 0s, fill the entire area with the value 3 (green).",
    "a65b410d.json": "1. Find the horizontal line of value 2 (red) in the input grid. Let its row index be R and the number of consecutive pixels with value 2 be N. Assume the line starts at column C. If there are multiple lines with value 2, choose the top-most one.\n2. Copy the line of value 2 (red) from the input to the output at the same position.\n3. Iterate upwards from the row above the red line (R-1). In each iteration, increase the number of pixels by 1. Fill N+1 pixels with value 3 (green) horizontally, starting from column C. Repeat this process moving upwards until the top row of the grid is reached.\n4. Iterate downwards from the row below the red line (R+1). In each iteration, decrease the number of pixels by 1. Fill N-1 pixels with value 1 (blue) horizontally, starting from column C. Repeat this process moving downwards until the number of pixels to fill becomes 1.\n5. Fill the remaining row with only one pixel of value 1 (blue) starting from column C.\n6. All the remaining empty cells that are not modified should remain 0 (black).",
    "a68b268e.json": "1. Input is a larger grid containing four 4x4 grids separated by a border of value 1 (blue). The goal is to produce a single 4x4 output grid.\n2. Initialize the output grid as a 4x4 grid.\n3. Extract the top-left 4x4 grid from the input and copy it to the output grid. This defines the initial state of the output grid.\n4. Extract the top-right 4x4 grid from the input.\n5. Iterate through each cell (R, C) of the top-right 4x4 grid, where R and C range from 0 to 3.\n6. If the pixel value at (R, C) in the top-right 4x4 grid is not 0 (black), and if the pixel value at (R, C) in the output grid is 0 (black), then replace the pixel value at (R, C) in the output grid with the pixel value from the top-right 4x4 grid.\n7. Extract the bottom-left 4x4 grid from the input.\n8. Iterate through each cell (R, C) of the bottom-left 4x4 grid, where R and C range from 0 to 3.\n9. If the pixel value at (R, C) in the bottom-left 4x4 grid is not 0 (black), and if the pixel value at (R, C) in the output grid is 0 (black), then replace the pixel value at (R, C) in the output grid with the pixel value from the bottom-left 4x4 grid.\n10. Extract the bottom-right 4x4 grid from the input.\n11. Iterate through each cell (R, C) of the bottom-right 4x4 grid, where R and C range from 0 to 3.\n12. If the pixel value at (R, C) in the bottom-right 4x4 grid is not 0 (black), and if the pixel value at (R, C) in the output grid is 0 (black), then replace the pixel value at (R, C) in the output grid with the pixel value from the bottom-right 4x4 grid.\n13. The output grid now contains the combined pattern.",
    "a699fb00.json": "1. Analyze the input grid, row by row. Do not analyze columns.\n2. For each row, find occurrences of the pattern: pixel value 1, followed by pixel value 0, followed by pixel value 1.\n3. If the pattern is found, replace the pixel value 0 between the two pixel values of 1 with pixel value 2.\n4. Retain all other pixel values in the grid without modification. Specifically, leave existing pixel value 1 as 1, and existing pixel value 0 that is not part of the described pattern as 0.\n5. Output the modified grid, maintaining the original grid dimensions.",
    "a740d043.json": "1. Identify the input grid. The input grid contains a pattern. The pattern is surrounded by a border of pixel value 1 (blue). The goal is to extract this pattern.\n2. Determine the size of the pattern. This will be the size of the output grid.\n3. Create an output grid with the dimensions determined in step 2.\n4. Copy the pattern from the input grid to the output grid. The pattern consists of the non-1 (blue) values within the input grid.\n5. If any areas of the output grid are not part of the original pattern (e.g., due to variations in pattern placement), fill those areas with pixel value 0 (black).",
    "a78176bb.json": "1. Copy the input grid to the output grid.\n2. Identify the diagonal line consisting of a single non-zero digit (referred to as the 'diagonal value'). This line extends diagonally across the grid.\n3. Identify any regions of value 5 (grey) that extend from one or both sides of the diagonal line.\n4. For each region of value 5 (grey) extending from the diagonal line:\n   a. Locate the pixel with value 0 (black) that is adjacent to the region of value 5 (grey) and closest to the diagonal line.\n   b. Starting from this pixel with value 0 (black), create a new diagonal line parallel to the original diagonal line, using the 'diagonal value'. The new line should extend until it reaches the boundaries of the grid or another object.\n5. Replace all pixels with value 5 (grey) with value 0 (black).",
    "a79310a0.json": "1. Find all pixels with values other than 0 in the input grid. These pixels form a shape.\n2. Create a new grid with the same dimensions as the input grid, filled entirely with 0.\n3. For each pixel in the shape found in step 1, let its original coordinates be (R, C).\n4. In the new grid, set the pixel at coordinates (R+1, C) to 2. If R+1 exceeds the grid height, the shape is truncated.",
    "a85d4709.json": "1. Get the input grid. The grid size remains the same for the output.\n2. Iterate through each row R of the input grid, where R ranges from 0 to the number of rows minus 1.\n3. Within each row R, examine the values of the first three columns (columns 0, 1, and 2) to determine the dominant color.\n4. IF a pixel value 5 (grey) is found in column 0 of row R, set all pixel values in row R of the output grid to 2 (red).\n5. ELSE IF a pixel value 5 (grey) is found in column 1 of row R, set all pixel values in row R of the output grid to 4 (yellow).\n6. ELSE IF a pixel value 5 (grey) is found in column 2 of row R, set all pixel values in row R of the output grid to 3 (green).\n7. ELSE if, on row R, there are two pixel values 0 (black) together on the left (columns 0 and 1), set all pixel values in row R of the output grid to 3 (green).\n8. ELSE if, on row R, there are two pixel values 0 (black) separated by a pixel value 5 (grey) in the middle (column 1), set all pixel values in row R of the output grid to 4 (yellow).\n9. ELSE if, on row R, there are two pixel values 0 (black) together on the right (columns 1 and 2), set all pixel values in row R of the output grid to 2 (red).\n10. ELSE set all pixel values in row R of the output grid to 3 (green).\n11. Output the modified grid.",
    "a87f7484.json": "1. Analyze the input grid to identify the frequency of each unique number (0-9). The frequency is the count of how many times each number appears in the grid.\n2. Determine the number that occurs most frequently in the input grid. If there are ties, select the smallest of the tied numbers.\n3. Create a 3x3 output grid.\n4. Fill the entire 3x3 output grid with the most frequent number identified in step 2.",
    "a8c38be5.json": "1. Divide the input grid into 3x3 subgrids.\n2. Create a 9x9 output grid, initialized with all cells set to 5 (grey).\n3. Identify and locate all 3x3 subgrids within the input.\n4. Place the 3x3 subgrid that is entirely filled with 5 (grey) in the center of the output grid, spanning rows/columns 3-5 and 3-5.\n5. For each remaining 3x3 subgrid in the input:\n    a. If a 3x3 subgrid has a color other than 5 (grey) along its top edge, place that subgrid in the top-middle of the output grid (rows/columns 0-2, 3-5).\n    b. If a 3x3 subgrid has a color other than 5 (grey) along its bottom edge, place that subgrid in the bottom-middle of the output grid (rows/columns 6-8, 3-5).\n    c. If a 3x3 subgrid has a color other than 5 (grey) along its left edge, place that subgrid in the middle-left of the output grid (rows/columns 3-5, 0-2).\n    d. If a 3x3 subgrid has a color other than 5 (grey) along its right edge, place that subgrid in the middle-right of the output grid (rows/columns 3-5, 6-8).\n    e. Place the remaining four 3x3 grids at the corners. Match the corner colors of the input grids to the neighboring sides. For instance, a grid with a color other than 5 at the top left corner should be placed at the top left corner of the output grid, if there is a match in the neighboring middle grids.\n6. If color adjacency conflicts cannot be resolved, prioritize placing the grids in the following order: top-left, top-right, bottom-left, bottom-right.\n7. The resulting 9x9 grid is the output.",
    "a8d7556c.json": "1. The output grid has the same dimensions as the input grid. 2. Find all square subgrids within the input grid where all cells have a value of 0 and the subgrid's side length is greater than 1. 3. In the output grid, replace the values of the cells corresponding to the locations of these identified square subgrids with the value 2.",
    "a9f96cdd.json": "1. Find the coordinates (R, C) of all pixels with value 2 in the input grid. These are the 'red pixels'.\n2. Create an output grid with the same dimensions as the input grid.\n3. Initialize all pixel values in the output grid to 0 (black).\n4. For each red pixel found at coordinates (R, C) in the input grid, perform the following steps:\n    a. Set the pixel value at (R-1, C-1) in the output grid to 3 (green). If R-1 or C-1 is out of bounds, skip this step.\n    b. Set the pixel value at (R-1, C+1) in the output grid to 6 (pink). If R-1 or C+1 is out of bounds, skip this step.\n    c. Set the pixel value at (R+1, C-1) in the output grid to 8 (cyan/light blue). If R+1 or C-1 is out of bounds, skip this step.\n    d. Set the pixel value at (R+1, C+1) in the output grid to 7 (orange). If R+1 or C+1 is out of bounds, skip this step.\n    e. Set the pixel value at (R, C) in the output grid to 0 (black). This replaces the original red pixel with black.\n5. Return the output grid.",
    "aabf363d.json": "1. Find the value of the pixel in the bottom-left corner of the input grid. Let this value be 'X'. The bottom-left corner is defined as the pixel at row index equal to the maximum row index, and column index 0. \n2. Replace all pixel values in the input grid with the value 'X'.\n3. Set the pixel value at the bottom-left corner to 0. The bottom-left corner is defined as the pixel at row index equal to the maximum row index, and column index 0.",
    "aba27056.json": "1. Initialize the output grid with the same dimensions and pixel values as the input grid.\n2. Identify the rectangular region within the grid that has a \"hole\" or interior of pixels with value other than 0 (black).\n3. Fill the interior (the \"hole\") of the identified rectangle with the value 4 (yellow).\n4. For each inner corner of the filled rectangle (the \"hole\"), extend a straight line of value 4 (yellow) to the nearest edge of the grid, either horizontally or vertically. Choose either horizontal or vertical lines consistently for all corners.\n5. From each inner corner of the filled rectangle, extend a diagonal line of value 4 (yellow) towards the closest grid edge. The diagonal line should start from the corner and continue until it reaches the edge of the grid or intersects another pixel with value 4.\n6. The output grid is now complete.",
    "ac0a08a4.json": "1. Find the dimensions (rows, columns) of the input grid. Let these be R and C respectively. The input grid consists of numbers (0-9). Assume a 3x3 input grid is typical.\n2. Identify all unique non-zero numbers in the input grid. Let N be the number of unique non-zero numbers.\n3. Calculate the dimensions of the output grid. The output grid's dimensions are R*N rows and C*N columns.\n4. Create a new output grid filled entirely with the number 0.\n5. Iterate through each cell (r, c) of the input grid, where r ranges from 0 to R-1, and c ranges from 0 to C-1.\n6. If the value at input grid cell (r, c) is not 0, perform the following steps:\n    a. Determine the index (i) of the number at (r, c) within the list of unique non-zero numbers identified in step 2. This index will range from 0 to N-1.\n    b. Calculate the starting row (start_row) and starting column (start_col) for placing a block of the value from (r, c) in the output grid: start_row = r * N and start_col = c * N.\n    c. Iterate through a square block of size N x N in the output grid, starting at (start_row, start_col). For each cell (row, col) within this block (where row ranges from start_row to start_row + N - 1, and col ranges from start_col to start_col + N - 1), set the value of the output grid cell (row, col) to the value found in the input grid at (r, c).\n7. The resulting output grid is the transformed grid.",
    "ae3edfdc.json": "1. Find the coordinates (R_red, C_red) of the pixel with value 2 (red) in the input grid. If multiple pixels with value 2 exist, consider only the first encountered. \n2. Find the coordinates (R_blue, C_blue) of the pixel with value 1 (blue) in the input grid. If multiple pixels with value 1 exist, consider only the first encountered. \n3. Create an output grid with the same dimensions as the input grid, initialized with a default value (e.g., 0). \n4. Copy the pixel value 2 (red) from (R_red, C_red) in the input grid to (R_red, C_red) in the output grid.\n5. Copy the pixel value 1 (blue) from (R_blue, C_blue) in the input grid to (R_blue, C_blue) in the output grid.\n6. Iterate through all pixels in the input grid. For each pixel at coordinates (R, C):\n    a. If the pixel value is 3 (green):\n        i. Calculate the vertical distance: vertical_dist = R - R_red.\n        ii. Calculate the horizontal distance: horizontal_dist = C - C_red.\n        iii. If vertical_dist is negative, place value 3 (green) at (R_red - 1, C_red) in the output grid, if that location is within bounds. If vertical_dist is positive, place value 3 (green) at (R_red + 1, C_red) in the output grid, if that location is within bounds. If vertical_dist is zero, examine horizontal_dist.\n        iv. If horizontal_dist is negative, place value 3 (green) at (R_red, C_red - 1) in the output grid, if that location is within bounds. If horizontal_dist is positive, place value 3 (green) at (R_red, C_red + 1) in the output grid, if that location is within bounds. Do not place if horizontal_dist is zero.\n    b. If the pixel value is 7 (orange):\n        i. Calculate the vertical distance: vertical_dist = R - R_blue.\n        ii. Calculate the horizontal distance: horizontal_dist = C - C_blue.\n        iii. If vertical_dist is negative, place value 7 (orange) at (R_blue - 1, C_blue) in the output grid, if that location is within bounds. If vertical_dist is positive, place value 7 (orange) at (R_blue + 1, C_blue) in the output grid, if that location is within bounds. If vertical_dist is zero, examine horizontal_dist.\n        iv. If horizontal_dist is negative, place value 7 (orange) at (R_blue, C_blue - 1) in the output grid, if that location is within bounds. If horizontal_dist is positive, place value 7 (orange) at (R_blue, C_blue + 1) in the output grid, if that location is within bounds. Do not place if horizontal_dist is zero.\n7. Return the output grid.",
    "ae4f1146.json": "1. Divide the input grid into four equal-sized square subgrids. Assume each subgrid is 3x3.\n2. For each subgrid, count the number of pixels with value 1 (blue).\n3. Identify the subgrid with the maximum count of pixels with value 1.\n4. Copy the pixel values from the identified subgrid to the output grid. The output grid size is 3x3.",
    "aedd82e4.json": "1. Copy the input grid to the output grid, preserving all pixel values.\n2. Identify all connected components (shapes) in the input grid.\n3. For each connected component, determine the number of pixels it contains.\n4. If a connected component consists of only one pixel, replace the pixel value in the corresponding location of the output grid with the value 1 (blue).",
    "af902bf9.json": "1. Find a square structure of 4 pixels with value 4. These pixels form a square.\n2. Determine the center coordinates of the 4x4 square. Let (R, C) be the row and column index of the center.\n3. Place a pixel with value 2 at the calculated center location (R, C). Note that the center location (R, C) is not directly adjacent to any of the pixels with value 4 forming the square. The output grid size is the same as the input grid size.",
    "b0c4d837.json": "1. Input is a grid containing a shape of value 5 with a region of value 1 inside it. The general shape may resemble a U or a container filled with value 1.\n2. Output is a 3x3 grid.\n3. Analyze the input grid to identify the region of value 1 within the value 5 shape.\n4. Based on the configuration of the region with value 1, perform the following actions to generate the 3x3 output grid:\n5. Determine the shape of the region with value 1. Note that the values provided below related to the region of value 1.\n6. If the region with value 1 has dimensions 3x5 or 1x2, fill the entire first row of the 3x3 output grid with value 8.\n7. If the region with value 1 has dimensions 2x3 or 4x3, set the two leftmost cells in the first row of the 3x3 output grid to value 8.\n8. If the region with value 1 has dimensions 3x3, fill the entire first row of the 3x3 output grid with value 8, and also set the cell at (1, 2) (row 1, column 2 - indexing from 0) to value 8.\n9. If the region with value 1 has dimensions 2x2, set the leftmost cell in the first row of the 3x3 output grid (0, 0) to value 8.\n10. If steps 6-9 do not apply determine the number of rows of value 0 (black) above the region of value 1. Add one pixel of value 8 (cyan) to the output grid starting in the upper left corner and proceeding to the right of the first row, then continuing to the next row.",
    "b190f7f5.json": "1. Find the grid in the input that contains a pattern. This pattern is composed of pixels that are equal to 8 (cyan/light blue). Let the dimensions of this pattern grid be X by Y.\n2. Calculate the dimensions of the output grid as (X * X) by (Y * Y).\n3. Create a new blank grid with dimensions (X * X) by (Y * Y), initialized with a default value of 0.\n4. Find the other grid in the input. This grid will contain various pixel values besides 8. Iterate through each distinct pixel value (excluding 8) found in this other grid.\n5. For each pixel value (other than 8) found in step 4, iterate through the entire (X * X) by (Y * Y) output grid. Treat the output grid as being divided into X*Y blocks of size X by Y.\n6. When the index of the current pixel corresponds to an X by Y block in the output grid, replace the entire block with the 8-pattern, but instead of using the value 8, use the pixel value from step 5.\n7. Output the transformed grid.",
    "b1948b0a.json": "1. Identify the pixel value that is not equal to 7 (orange). Let this value be 'X'.\n2. Create an output grid with the same dimensions as the input grid.\n3. In the output grid, replace all occurrences of pixel value 'X' with the pixel value 2 (red).\n4. The remaining pixels (pixels with value 7) in the output grid stay unchanged.",
    "b230c067.json": "1. Find all distinct shapes consisting of connected pixels with value 8 (cyan) in the input grid. Assume there are exactly three such shapes.\n2. Copy the input grid to create the output grid. The output grid will have the same dimensions as the input grid.\n3. Identify the two leftmost shapes in the output grid. Define leftmost based on the minimum column index of the shape's bounding box.\n4. Change the pixel values of the two leftmost shapes in the output grid to 8 (cyan).\n5. Change the pixel values of the remaining shape (the one that is not among the two leftmost) in the output grid to 2 (red).",
    "b27ca6d3.json": "1. Find all pairs of adjacent pixels with value 2 in the input grid. Define a 'pair' as two or more 2's that are horizontally or vertically adjacent.\n2. For each 'pair' found in step 1, surround the entire connected region of 2's with pixels of value 3. This means: For each pixel with value 2 that is part of a 'pair', change all adjacent pixels (including diagonals) with value 0 to value 3. Also change adjacent pixels of value 0 around the entire rectangular bounding box defined by the 2's, to 3.\n3. The size of the output grid is the same as the input grid. Any pixel not changed in step 2 remains unchanged from the original input grid.",
    "b2862040.json": "1. The input grid contains a background of value 2. It also contains closed patterns of value 1 (dark blue). It might also contain closed patterns of value 8 (light blue) and line-only patterns of value 1 (dark blue). \n2. The output grid has the same dimensions as the input grid.\n3. Find all closed patterns of value 1 (dark blue) in the input grid.\n4. Replace the value of all cells belonging to the identified closed patterns of value 1 with the value 8 (light blue).\n5. The resulting grid is the output grid.",
    "b527c5c6.json": "1. Find all distinct connected regions of pixel value 3 (green) in the input grid. Assume there are two such regions.\n2. For each region identified in step 1, find a pixel with value 2 (red) located adjacent to the region's boundary.\n3. For each region and its corresponding red pixel, determine the \"thickness\" of the green region. This is the number of consecutive pixels with value 3 (green) encountered when moving away from the red pixel, perpendicular to the grid's edge, until another color or the opposite edge is reached.\n4. From each red pixel, extend a line of pixel value 2 (red) to the edge of the grid, in the direction away from the green region. This creates a red line.\n5. On each side of the red line created in step 4, draw a border consisting of consecutive pixels with value 3 (green). The width of this green border on each side should be equal to the 'thickness' calculated in step 3 for the corresponding green region.",
    "b548a754.json": "1. Find the single pixel with value 8 (cyan/light blue). Let its coordinates be (R_target, C_target). This pixel will be covered in the output.\n2. Find the shape consisting of two distinct regions: an outer region with pixel value X, and an inner region with pixel value Y. X and Y are distinct values between 0 and 9.\n3. Determine the bounding box of the shape found in step 2. Let the top-left corner of the bounding box be (R_start, C_start) and the bottom-right corner be (R_end, C_end).\n4. Copy the shape's pattern, including the outer value X and inner value Y, such that the copied shape expands from its original location towards the target pixel (R_target, C_target).\n5. The expansion should occur by extending the boundaries of the shape while maintaining the original color pattern (outer value X and inner value Y).\n6. The expansion continues until the expanded shape completely covers the target pixel (R_target, C_target). Specifically, the expanded shape must include the pixel (R_target, C_target) within its outer boundary (value X).\n7. In the output grid, all pixels within the expanded shape retain their original values (X for the outer region, Y for the inner region).\n8. All pixels outside the expanded shape retain their original values from the input grid.\n9. The pixel at (R_target, C_target) in the output grid will have the value X (the outer color of the expanded shape).",
    "b60334d2.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Find all pixels with value 5 (grey) in the input grid. Store the coordinates of these pixels as (R, C).\n3. For each (R, C) found in step 2, perform the following operations:\n    a. Replace the pixel at (R, C) in the output grid with the value 0 (black).\n    b. Set the pixel at (R-1, C) in the output grid to 1 (blue). If R-1 is outside the grid boundaries, skip this step.\n    c. Set the pixel at (R+1, C) in the output grid to 1 (blue). If R+1 is outside the grid boundaries, skip this step.\n    d. Set the pixel at (R, C-1) in the output grid to 1 (blue). If C-1 is outside the grid boundaries, skip this step.\n    e. Set the pixel at (R, C+1) in the output grid to 1 (blue). If C+1 is outside the grid boundaries, skip this step.\n    f. Set the pixel at (R-1, C-1) in the output grid to 5 (grey). If either R-1 or C-1 is outside the grid boundaries, skip this step.\n    g. Set the pixel at (R-1, C+1) in the output grid to 5 (grey). If either R-1 or C+1 is outside the grid boundaries, skip this step.\n    h. Set the pixel at (R+1, C-1) in the output grid to 5 (grey). If either R+1 or C-1 is outside the grid boundaries, skip this step.\n    i. Set the pixel at (R+1, C+1) in the output grid to 5 (grey). If either R+1 or C+1 is outside the grid boundaries, skip this step.",
    "b6afb2da.json": "1. Copy the input grid to the output grid.\n2. Find all squares containing the value 5 (grey).\n3. For each square found:\n    a. Identify the coordinates of the four corner pixels of the square. Change the value of these corner pixels to 1 (blue).\n    b. Identify the remaining pixels on the edges of the square (excluding the corners). Change the value of these edge pixels to 4 (yellow).\n    c. Identify the pixels inside the square (excluding the edges). Change the value of these interior pixels to 2 (red).",
    "b7249182.json": "1. Find the coordinates (R1, C1) and (R2, C2) of the two non-zero pixel values in the input grid. Let V1 be the pixel value at (R1, C1) and V2 be the pixel value at (R2, C2). Assume the background is 0.\n2. Create horizontal lines of length 5 extending from (R1, C1) and (R2, C2). The line starting at (R1, C1) will have pixel value V1, and the line starting at (R2, C2) will have pixel value V2. Determine the direction of the line based on the relative positions of (R1, C1) and (R2, C2). If R1 == R2, then create horizontal lines. If C1 == C2, create vertical lines. The lines should grow inward toward each other. Each line has a length of 5 and is filled with the appropriate color, V1 or V2.\n3. At the end of each of the two lines of length 5 created above, create a perpendicular line of length 5, with pixel value equal to the color of the original line at its start. For the line starting at (R1, C1), if the first line was horizontal, create a vertical line of length 5. If the first line was vertical, create a horizontal line of length 5. Similarly, for the line starting at (R2, C2), if the first line was horizontal, create a vertical line of length 5. If the first line was vertical, create a horizontal line of length 5.\n4. On both ends of each perpendicular line of length 5 add a pixel with the same color of the perpendicular line, effectively making it length 7. This connects the two figures together, forming a closed shape.",
    "b775ac94.json": "1. Identify the input grid. The output grid has the same dimensions as the input grid.\n2. For each distinct group of connected non-zero pixels (a 'cluster') in the input:\n3. Identify the most frequent pixel value (number) within the cluster. If there's a tie, select the smallest number.\n4. Treat the group of connected pixels with this most frequent value as the 'anchor shape'.\n5. For each remaining pixel value (number) in the cluster, perform the following steps:\n6. Extract the shape formed by the connected pixels of that specific value.\n7. Mirror this shape relative to the anchor shape's bounding box. Specifically, create mirrored copies horizontally and vertically, using the center of the anchor shape's bounding box as the center of symmetry. The anchor shape itself remains unchanged.\n8. Place the mirrored shapes on the output grid such that they are symmetrical to the initial shape with respect to the center of the anchor shape's bounding box.\n9. If any mirrored pixel falls outside the grid boundaries, discard that pixel.\n10. The background color (pixels with value 0) remain unchanged.",
    "b782dc8a.json": "1. Identify the input grid. The grid contains a pattern, primarily composed of values 1 and 4, with a smaller shape composed of two other values present within the pattern.\n2. Create an output grid with the same dimensions as the input grid.\n3. Identify all locations in the input grid where the value is 0 (black).\n4. For each location (R, C) identified in step 3, determine the value of the nearest non-zero pixel.\n5. Set the corresponding pixel at (R, C) in the output grid to the value determined in step 4.\n6. Output the resulting grid.",
    "b8825c91.json": "1. Identify all rectangles composed entirely of pixel value 4 in the input grid. 2. Replace all pixels with value 4 that form the identified rectangles with value 0. 3. For each remaining pixel with value 4, replace it with a value (0-9) that completes a pattern that exhibits both horizontal and vertical symmetry. The replacement value must be chosen to match the existing pattern surrounding the pixel location.",
    "b8cdaf2b.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Identify a structure located at the bottom of the grid. This structure is composed of two different numerical values (representing colors).\n3. Determine the numerical value that represents the interior of the structure. This is the value that is enclosed by the outer layer of the structure.\n4. Find the top row (smallest row index) of the identified structure.\n5. Starting from the leftmost pixel of the top row of the structure, draw a diagonal line upwards and to the left. Replace each pixel along this diagonal with the numerical value identified in step 3.\n6. Starting from the rightmost pixel of the top row of the structure, draw a diagonal line upwards and to the right. Replace each pixel along this diagonal with the numerical value identified in step 3.",
    "b91ae062.json": "1. Read the input grid. Assume the input grid is a square grid, commonly 3x3. Most of the grid will likely contain 0 (black). \n2. Find all unique non-zero pixel values in the input grid. These represent the different 'colors' or values present. Count the number of these unique non-zero values. Let this count be N.\n3. Determine the output grid size. If N = 1, the output grid size is 6x6. If N = 2, the output grid size is 6x6. If N = 3, the output grid size is 9x9. If N = 4, the output grid size is 12x12. In general, output size = N * 3, clamping N at a maximum of 4 (12x12 output).\n4. Create an empty output grid of the determined size (N*3 x N*3). \n5. Calculate the block size: block size = 3 if output size is 9x9, block size = 4 if output size is 12x12, and block size = 2 if output size is 6x6. Block size is equal to output grid size / 3.\n6. Iterate through each cell (row R, column C) of the input grid.\n7. For each cell (R, C) in the input grid, get the pixel value V at (R, C).\n8. In the output grid, create a block of size (block size x block size) where the top-left corner of the block is at (R * block_size, C * block_size). Fill this entire block with the value V.\n9. The completed output grid is the result.",
    "b94a9452.json": "1. Find the minimum row and column indices (R1, C1) and the maximum row and column indices (R2, C2) that define the outer square, where the background color is 0. The grid dimensions should correspond to the outer square.\n2. Create an output grid of the same dimensions as the outer square defined by (R1, C1) and (R2, C2).\n3. Identify the color (V1) of the outer square.\n4. Identify the inner square by finding the minimum row and column indices (IR1, IC1) and the maximum row and column indices (IR2, IC2) within the outer square, where the inner square has a uniform color (V2) different from V1. Assume that this inner square is centered.\n5. Replace all pixel values equal to V1 in the output grid with V2.\n6. Replace all pixel values within the inner square defined by (IR1, IC1) and (IR2, IC2) in the output grid with V1.",
    "b9b7f026.json": "1. Analyze the input grid to identify distinct objects (squares or rectangles). An object is defined as a contiguous region of a single color (numerical value).\n2. Determine if any object has a \"hole\". An object has a \"hole\" if it contains a region of a different color (numerical value) completely surrounded by the object's color (numerical value).\n3. If an object with a hole is found, copy the numerical value (0-9) of that object to the single output grid cell (1x1).\n4. If multiple objects with holes are found, copy the numerical value of the first such object encountered during the analysis to the output grid.\n5. If no object with a hole is found, the output grid cell should be assigned a value of 0.",
    "ba26e723.json": "1. Assume the input grid consists of repeating vertical patterns of pixel value 4 (yellow) in pairs. The input grid height is not specified, but the pattern is expected to repeat. The input grid width is not modified.\n2. Create an output grid with the same dimensions as the input grid. Initialize the output grid with the same values as the input grid.\n3. Starting from the top of the first column (column index 0), replace the first two pixels with pixel value 6 (pink). That is, set output_grid[0][0] = 6 and output_grid[1][0] = 6.\n4. Skip the next four pixels (two pairs of pixel value 4 (yellow)).\n5. Replace the next two pixels with pixel value 6 (pink). \n6. Repeat steps 4 and 5 until the end of the column is reached. If there are fewer than 4 pixels remaining, skip to step 7. If there are fewer than 2 pixels, skip the replacement.\n7. Proceed to the next column (column index 1) and repeat steps 3-6 until all columns have been processed.",
    "ba97ae07.json": "1. Copy the input grid to the output grid, preserving the original dimensions.\n2. Identify the locations where two lines of different values intersect. An intersection is defined as a pixel (R, C) where two or more lines with different values meet or touch. \n3. For each intersection pixel (R, C): Determine the values of the two intersecting lines. Assume these values are Value1 and Value2, where Value1 != Value2.\n4. At the intersection pixel (R, C) in the output grid, replace the original pixel value with the value of the other intersecting line. If the original value at (R, C) was Value1, change it to Value2. Conversely, if it was Value2, change it to Value1.",
    "bb43febb.json": "1. Find all connected regions of pixels with value 5 (grey) in the input grid. Assume there are two such regions, each forming a rectangle.\n2. For each identified rectangular region:\n3. Determine the dimensions (height and width) of the rectangle.\n4. Calculate the coordinates of the inner rectangle to be filled. The inner rectangle's top-left corner will be one row/column inside the outer rectangle's top-left corner. The inner rectangle's bottom-right corner will be one row/column inside the outer rectangle's bottom-right corner.\n5. Fill the inner rectangular region with the value 2 (red). Pixels located between (row_start + 1, col_start + 1) and (row_end - 1, col_end - 1) should have their values changed to 2.\n6. The output grid has the same dimensions as the input grid. All pixels outside of the modified inner rectangles remain unchanged.",
    "bbc9ae5d.json": "1. Find the input grid. This grid will always be a single row. Let the width of the input grid be W. This value, W, represents the width of the output grid. The height of the output grid, H, is equal to W / 2 (integer division, discarding any remainder). Initialize the output grid with dimensions W x H, filled with 0s (black). \n2. Copy the input row to the first row (top row) of the output grid. This means for each column C from 0 to W-1, set the pixel value at (0, C) in the output grid to the corresponding pixel value in the input row.\n3. For each subsequent row R in the output grid (from R=1 to H-1):\n   a. Let N be the number of non-0 (non-black) pixels from the original input row. Increase N by the row number R (N = N + R).\n   b. For each column C from 0 to N-1:\n     i. Copy the color value from the input row at the column index C to the output grid at row R and column C. In other words, output[R][C] = input[0][C % W], using modulo to loop back to the beginning of input row if N > W. \n   c. For each column C from N to W-1:\n     i. Set the pixel value at (R, C) in the output grid to 0 (black).",
    "bc1d5164.json": "1. Initialize a 3x3 output grid. All cells are initially set to 0.\n2. Examine the input grid to identify a color other than 0. Let this color be denoted as 'X'.\n3. For each cell (r, c) in the 3x3 output grid, determine its value based on a corresponding region in the input grid.\n4. The region in the input grid corresponding to output cell (r, c) spans rows from (r * input_height / 3) to ((r + 1) * input_height / 3) (exclusive), and columns from (c * input_width / 3) to ((c + 1) * input_width / 3) (exclusive). Integer division should be used.\n5. For each cell (r, c) in the output grid, examine the corresponding region in the input grid. If any pixel in the corresponding region has value X, set the output cell (r, c) to X. Otherwise, the output cell (r, c) remains 0.\n6. The final 3x3 grid contains either 0 or X.",
    "bd4472b8.json": "1. Get the input grid. The first row contains a sequence of numbers (0-9), representing colors. Let 'color_sequence' be the array of these numbers from the first row, where color_sequence[i] is the color at row 0, column i. The second row contains only the number 5 (grey). The rows below the second row contain only the number 0 (black). \n2. Create an output grid with the same dimensions as the input grid.\n3. Copy the first two rows of the input grid to the output grid exactly. This means copying the 'color_sequence' to the first row and the row of 5s to the second row of the output grid.\n4. Determine the length of 'color_sequence'. Let this length be 'sequence_length'.\n5. Iterate through the rows of the output grid, starting from the third row (row index 2) until the last row.\n6. Inside the row iteration, for each row 'R', calculate the index 'color_index' using the formula: color_index = (R - 2) modulo sequence_length.\n7. Set all the values in row 'R' of the output grid to the number at color_sequence[color_index].\n8. Return the output grid.",
    "bda2d7a6.json": "1. Determine the size of the input grid. Assume it contains concentric squares with sizes 2x2, 4x4, 6x6, (and potentially 8x8). Let N be the size of the largest square.\n2. Extract the center 2x2 square. Define its pixel value as 'value_2'.\n3. Extract the 4x4 square. Define its pixel value as 'value_4'.\n4. Extract the 6x6 square. Define its pixel value as 'value_6'.\n5. If an 8x8 square exists, extract it. Define its pixel value as 'value_8'.\n6. Replace the pixel values of the center 2x2 square with 'value_4'.\n7. Replace the pixel values of the 4x4 square with 'value_6'.\n8. Replace the pixel values of the 6x6 square with 'value_2'.\n9. If an 8x8 square exists, replace the pixel values of the 8x8 square with 'value_4'.\n10. Output the modified grid.",
    "bdad9b1f.json": "1. Find horizontal lines of pixels with value 2 (red) in the input grid. Identify the starting and ending column indices of each horizontal line. Assume these represent horizontal \"squares\".\n2. Find vertical lines of pixels with value 1 (blue) in the input grid. Identify the starting and ending row indices of each vertical line. Assume these represent vertical \"squares\".\n3. Extend each horizontal line of value 2 (red) to the left and right until it reaches the edge of the output grid.\n4. Extend each vertical line of value 1 (blue) upwards and downwards until it reaches the edge of the output grid.\n5. For each pixel where a horizontal line of value 2 (red) intersects a vertical line of value 1 (blue), set the pixel value to 4 (yellow).",
    "be94b721.json": "1. Identify all distinct shapes composed of non-zero pixel values within the input grid, considering 0 (black) as background.\n2. For each shape, determine its bounding box: the smallest rectangle that contains all pixels of that shape, including any 0 (black) pixels within the shape.\n3. Calculate the number of non-zero pixels (pixel values 1-9) within each shape's bounding box.\n4. Identify the shape with the highest count of non-zero pixels within its bounding box. If there's a tie, choose any one of the tied shapes.\n5. Define the output grid dimensions to be the same as the bounding box of the identified shape.\n6. Copy the pixel values from the input grid corresponding to the bounding box of the identified shape to the output grid. The copied region will include the shape and any surrounding 0 (black) pixels within the bounding box. Ensure the copied region is placed such that the top-left corner of the bounding box in the input corresponds to the top-left corner (0, 0) of the output grid.",
    "beb8660c.json": "1. Find all horizontal line segments of non-0 pixel values in the input grid. A horizontal line segment is defined as a contiguous sequence of pixels with the same non-0 value on the same row, separated by 0 values or the grid boundaries.\n2. Measure the length of each identified line segment. The length is the number of pixels in the segment.\n3. Sort the line segments in descending order based on their lengths.\n4. Create an output grid of the same dimensions as the input grid, filled with 0.\n5. Iterate through the sorted line segments, starting with the longest. For each line segment:\n6. Let the current line segment's value be 'V', its length be 'L', and its original row be 'R'.\n7. Determine the row 'OutputRow' in the output grid where the line segment will be placed. The longest line segment will be placed on the bottom row of the output grid, the second longest on the second to last row, and so on. If there are more line segments than rows, the remaining segments are placed from the top row down.\n8. Calculate the starting column 'OutputColumn' for placing the line segment. Align the line segments to the right side of the grid. 'OutputColumn' = GridWidth - L, where GridWidth is the width of the grid.\n9. Copy the pixel value 'V' into the output grid, starting at (OutputRow, OutputColumn) and extending for L pixels horizontally: OutputGrid[OutputRow][OutputColumn + i] = V, for i from 0 to L-1.\n10. After processing all line segments, the output grid is complete.",
    "c0f76784.json": "1. Identify all distinct squares in the input grid based on contiguous regions of value 5 (grey). Assume squares are aligned to the grid axes.\n2. Determine the size (side length) of each identified square.\n3. Sort the squares by their size in ascending order (smallest to largest).\n4. Fill the interior of each square based on its sorted order:\n    a. For the smallest square, fill its interior (excluding the border) with the value 6 (pink).\n    b. For the second smallest square (middle square), fill its interior with the value 4 (yellow).\n    c. For the largest square, fill its interior with the value 8 (cyan / light blue).\n5. Maintain the original grid size and all pixel values outside of the identified and filled squares. Specifically, any 'holes' or regions with value 0 (black) or other values within the identified squares' borders, should be replaced by the appropriate fill color as per step 4.\n6. Output the modified grid.",
    "c1d99e64.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid. \n2. Identify horizontal lines: Find rows where all pixel values are 0.\n3. Identify vertical lines: Find columns where all pixel values are 0.\n4. Change pixel values: In the output grid, change the pixel value of all cells belonging to identified horizontal or vertical lines to 2. Specifically, for each row identified in step 2, change every pixel value in that row to 2. For each column identified in step 3, change every pixel value in that column to 2.",
    "c3e719e8.json": "1. Define the input grid as a 3x3 grid. Define the output grid as a 9x9 grid. \n2. Count the occurrences of each number (0-9) in the input 3x3 grid. \n3. Find the most frequent number in the input grid. Call this the 'dominant number'.\n4. Iterate through each cell (r, c) of the input 3x3 grid, where r and c range from 0 to 2.\n5. For each cell (r, c) in the input grid:\n    a. If the value of the cell (r, c) equals the 'dominant number':\n        i. Copy the entire 3x3 input grid to the corresponding 3x3 block in the output grid, starting at row (r*3) and column (c*3). Specifically, for i from 0 to 2 and j from 0 to 2, set the output grid cell (r*3 + i, c*3 + j) to the value of the input grid cell (i, j).\n    b. Otherwise (if the value of the cell (r, c) is not equal to the 'dominant number'):\n        i. Set all cells within the corresponding 3x3 block in the output grid, starting at row (r*3) and column (c*3), to 0. Specifically, for i from 0 to 2 and j from 0 to 2, set the output grid cell (r*3 + i, c*3 + j) to 0.",
    "c3f564a4.json": "1. Input: The input is a grid containing diagonal lines of various numbers, interspersed with 0 values (representing black). \n2. Output Size: The output grid will have the same dimensions as the input grid.\n3. Transformation: Iterate through each cell (R, C) of the input grid.\n4. If the value at cell (R, C) is 0, find the nearest non-zero value along the diagonals.\n5. To find the nearest non-zero value, check cells along the four diagonals passing through (R, C):\n    a. Diagonal 1: (R+i, C+i) for i = 1, 2, 3, ... until a non-zero value is found or the grid boundary is reached.\n    b. Diagonal 2: (R-i, C-i) for i = 1, 2, 3, ... until a non-zero value is found or the grid boundary is reached.\n    c. Diagonal 3: (R+i, C-i) for i = 1, 2, 3, ... until a non-zero value is found or the grid boundary is reached.\n    d. Diagonal 4: (R-i, C+i) for i = 1, 2, 3, ... until a non-zero value is found or the grid boundary is reached.\n6. From the non-zero values found along the four diagonals, select the closest non-zero value (smallest i). If multiple non-zero values are equally close, choose any of them.\n7. Replace the 0 value at cell (R, C) in the output grid with the nearest non-zero value found in step 6.\n8. If the value at cell (R, C) is not 0, copy the original value from the input grid to the same cell (R, C) in the output grid.\n9. The output grid now contains the transformed grid with 0s filled in with the diagonal pattern.",
    "c444b776.json": "1. Input: A grid of numbers with a background of 0 (black). The grid appears to be divided into sections, likely four sections. The number of sections may vary.\n2. Output Grid Size: The output grid will have the same dimensions (height and width) as the input grid.\n3. Algorithm: Copy the pixel values from one section of the input grid to all other sections. Specifically:\n 4. Select a section of the input grid as the 'source section'.\n 5. Iterate through each pixel in the input grid.\n 6. For each pixel, get its value. \n 7. Replace the value of every pixel in the output grid with the pixel value from the 'source section' at the corresponding location.",
    "c59eb873.json": "1. Determine the dimensions (rows and columns) of the input grid. Let the number of rows be R and the number of columns be C.\n2. Create an output grid with dimensions 2R rows and 2C columns.\n3. Iterate through each cell (r, c) in the input grid, where r ranges from 0 to R-1 and c ranges from 0 to C-1.\n4. Get the integer value V at cell (r, c) in the input grid.\n5. In the output grid, create a 2x2 block of cells, all with the value V. Specifically:\n    a. Set the value of the cell at (2r, 2c) to V.\n    b. Set the value of the cell at (2r, 2c + 1) to V.\n    c. Set the value of the cell at (2r + 1, 2c) to V.\n    d. Set the value of the cell at (2r + 1, 2c + 1) to V.\n6. Return the output grid.",
    "c8cbb738.json": "1. Find the background color (a single, prevalent pixel value) in the input grid. This will be an integer from 0-9. Call this value 'BG'.\n2. Identify distinct groups of connected, non-BG pixels in the input grid. A group consists of 4 pixels as outline patterns.\n3. Determine the bounding box for each group. The bounding box is defined by the minimum and maximum row and column indices occupied by the group's pixels.\n4. Find the largest bounding box among all groups. Determine its width (max_column - min_column + 1) and height (max_row - min_row + 1).\n5. Create an output grid with dimensions equal to the width and height of the largest bounding box.\n6. Fill the entire output grid with the background color, 'BG'.\n7. Iterate through each identified group from Step 2.\n8. For each group, determine the offset (delta_row, delta_column) by subtracting the minimum row and column indices of the largest bounding box (from Step 4) from the minimum row and column indices of the current group's bounding box.\n9. For each pixel with value 'V' in the group, where V is not equal to BG, copy that pixel value to the output grid at the location (row + delta_row, column + delta_column). This means output[row + delta_row][column + delta_column] = V.",
    "c8f0f002.json": "1. Input grid and output grid have the same dimensions. 2. Examine each pixel in the input grid. 3. If a pixel value is 4 (yellow), then replace that pixel value with 5 (grey) in the corresponding location in the output grid. 4. If a pixel value is not 4 (yellow), then copy the original pixel value from the input grid to the corresponding location in the output grid.",
    "c909285e.json": "1. Find a square subgrid within the input grid that is enclosed by a border of a single, consistent pixel value. This border must be at least one pixel wide. Let the subgrid's top-left coordinate be (R1, C1) and its bottom-right coordinate be (R2, C2). Let the border color have the value B. If multiple such subgrids exist, select the one with the smallest area.\n2. Determine the size of the subgrid including the border. Calculate the width as (C2 - C1 + 1) and the height as (R2 - R1 + 1).\n3. Create an output grid with the same width and height calculated in Step 2.\n4. Copy the pixel values from the corresponding region of the input grid, including the border, to the output grid. Specifically, for each row R from R1 to R2 (inclusive) and each column C from C1 to C2 (inclusive), set the pixel value at (R - R1, C - C1) in the output grid to the pixel value at (R, C) in the input grid.",
    "c9e6f938.json": "1. Get the input grid. Let its dimensions be R rows and C columns.\n2. Create an output grid with dimensions R rows and 2*C columns.\n3. Iterate through each row (R) and each column (C) of the input grid.\n4. In the output grid, copy the pixel value from the input grid at (R, C) to the output grid at (R, C).\n5. In the output grid, copy the pixel value from the input grid at (R, C) to the output grid at (R, 2*C - 1 - C). This creates a mirrored image along the vertical axis.",
    "c9f8e694.json": "1. Input: The input grid contains a pattern of colored squares (values 0-9) and grey blocks (value 5). A line of colored squares (values 0-9) exists on one side of the grid.\n2. Output Grid Size: The output grid has the same dimensions as the input grid.\n3. Transformation: For each grey block (value 5) in the input grid:\n   a. Find the row (R) of the grey block.\n   b. In the same row (R), identify the colored square (value 0-9) from the colored line on the side of the grid.\n   c. Replace the value of the grey block (value 5) in the output grid with the value (0-9) of the colored square found in step b.",
    "caa06a1f.json": "1. Identify a square subgrid in the input, located in one of the corners. This subgrid exhibits a checkerboard pattern consisting of two distinct numbers. Let's call these numbers A and B. \n2. Determine the size of this checkerboard subgrid (N x N). \n3. Identify a border of a single, solid color around two sides of the checkerboard subgrid. Let this border color be C. This border may or may not be present. If present, note the thickness of the border (in number of rows/columns).\n4. Create an output grid of the same size as the input grid.\n5. Fill the entire output grid with a checkerboard pattern using the same two numbers (A and B) and the same arrangement as the identified subgrid. Ensure the pattern seamlessly extends from where the subgrid was located in the input.\n6. The value of A is placed at location (0,0) and the subsequent values are determined based on the checkerboard pattern.\n7. If a border color C was identified, it is not used in generating the output.",
    "cbded52d.json": "1. Copy the input grid to the output grid. The output grid size is the same as the input grid size. \n2. For each row in the grid: if the pixel value at the center column of the row is X, change the pixel values at the first and last column of the row to X.\n3. For each column in the grid: if the pixel value at the center row of the column is Y, change the pixel values at the first and last row of the column to Y.",
    "cce03e0d.json": "1. Input is a 3x3 grid of numbers. The output is a 9x9 grid. \n2. Divide the 9x9 output grid into nine 3x3 blocks.\n3. Find all locations in the input 3x3 grid where the value is 2 (red).\n4. For each location (R, C) in the input grid where the value is 2, copy the entire 3x3 input grid into the corresponding block in the 9x9 output grid.  The top-left corner of the corresponding block in the output grid is at coordinates (R*3, C*3), where R and C range from 0 to 2.\n5. All other blocks in the output grid should remain as they were initialized (presumably initialized with zeros, but the algorithm does not specify this). If the initial values of other blocks are unspecified assume they are 0.",
    "cdecee7f.json": "1. Find all non-zero pixel locations in the input grid. Store these locations and their corresponding pixel values (1-9) in a list, ordered from left to right and top to bottom. This list represents the sequence of colored squares.\n2. Create an empty 3x3 output grid filled with zeros (black).\n3. Iterate through the list of non-zero pixel values and their locations obtained in step 1.\n4. Place each non-zero pixel value sequentially into the output grid, following a boustrophedonic (snake-like) pattern:\n   a. Start at the top-left corner (0, 0) of the output grid.\n   b. Fill the first row from left to right.\n   c. When the end of a row is reached, move to the next row and reverse the filling direction.\n   d. Continue this pattern until all non-zero pixel values from the input have been placed in the output grid.\n5. If the list of non-zero pixels is exhausted before the entire output grid is filled, the remaining cells in the output grid remain as 0 (black).",
    "ce22a75a.json": "1. Maintain the same grid size for the output as the input grid.\n2. Find each pixel with value 5 (grey) in the input grid.\n3. For each pixel found with value 5 at coordinates (R, C), change the pixel at (R, C) to value 1 (blue).\n4. Additionally, change the values of the surrounding 8 pixels to 1 (blue). This includes the pixels at:\n   - (R-1, C-1)\n   - (R-1, C)\n   - (R-1, C+1)\n   - (R, C-1)\n   - (R, C+1)\n   - (R+1, C-1)\n   - (R+1, C)\n   - (R+1, C+1)\n5. If any of the coordinates calculated in step 4 fall outside the bounds of the grid, ignore those coordinates and do not attempt to change those pixel values.",
    "ce4f8723.json": "1. Divide the input grid (4x8) into two 4x4 grids: a top grid and a bottom grid.\n2. Create a 4x4 output grid.\n3. Iterate through each cell at the same (R, C) coordinate in both the top and bottom 4x4 grids.\n4. For each (R, C): If the value in BOTH the top grid and the bottom grid at (R, C) is 0, then set the output grid's cell at (R, C) to 0.\n5. Otherwise, if either the top or the bottom grid at (R, C) is not 0, set the output grid's cell at (R, C) to 3.",
    "ce602527.json": "1. Find distinct shapes in the input grid. The shapes are defined as connected regions of non-background pixels. Assume the background color is the most frequent pixel value in the input grid.\n2. Determine the size (height and width) of one of the detected shapes.\n3. Create an output grid with the determined size.\n4. Copy the pixel values from the selected shape in the input grid to the corresponding locations in the output grid. If the background color is 0, all other numbers (1-9) represent the designs.",
    "ce9e57f2.json": "1. Find the columns containing contiguous vertical sections of value 2 (red) starting from the bottom row of the input grid. Assume there are four such columns.\n2. For each column identified in step 1, determine the height of the contiguous vertical section of value 2.\n3. For each column, calculate a midpoint: if the height is even, the midpoint is height / 2. If the height is odd, the midpoint is (height - 1) / 2.\n4. For each column, iterate from the bottom row up to the row indicated by the midpoint. Replace the value 2 (red) in these rows with the value 8 (cyan).\n5. The remaining values of 2 (red) in the column above the midpoint remain unchanged.",
    "cf98881b.json": "1. Analyze the input grid. Assume the input grid contains three distinct sections from left to right. The leftmost section contains pixels with the value 4 (yellow). The other sections contain pixels with other values; they represent patterns to be overlaid. Assume the output grid dimensions are the same as the leftmost section of the input grid. If not, resize the output grid according to the leftmost section dimensions. The input grid consists of 56 squares and three colors miss means the missing colors should be considered as black pixel with value 0. Also, the leftmost section's yellow pixels should be considered as a base which output size depends on it. \n2. Initialize an output grid with dimensions equal to the leftmost section. Fill the output grid with the pixel values from the leftmost section (value 4). \n3. Identify the rightmost section of the input grid, corresponding to the \"blue design\" which will be referred to as layer 1 (using pixel value 1). Overlay the pixel values from layer 1 onto the output grid. If a pixel in layer 1 has a non-zero value (1), replace the corresponding pixel value in the output grid with the value from layer 1. Otherwise, keep the output grid's original value in that position. \n4. Identify the middle section of the input grid, corresponding to the \"dark red design\" which will be referred to as layer 2 (using pixel value 2). Overlay the pixel values from layer 2 onto the output grid. If a pixel in layer 2 has a non-zero value (2), replace the corresponding pixel value in the output grid with the value from layer 2. Otherwise, keep the output grid's current value in that position. \n5. The output grid will show the overlay of the three layers, with the rightmost section (layer 1, value 1) as the base, followed by the middle section (layer 2, value 2) overlaid on top, and finally the leftmost section, the yellow pixels with the value 4. Prioritize the later layers during overlay. Thus the yellow will be on top of red which will be on top of blue.",
    "d037b0a7.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid. 2. Iterate through each cell (R, C) of the input grid, where R represents the row index and C represents the column index. 3. If the pixel value at (R, C) is not 0 (black), then: 4. Iterate downwards from row R+1 to the bottom row of the grid (inclusive), along the same column C. 5. For each cell (Row, C) in this downward iteration, set the pixel value at (Row, C) in the output grid to the pixel value at (R, C). This fills the cells below the non-black color with that same color until the bottom border.",
    "d06dbe63.json": "1. Find the coordinates (R, C) of the single non-zero pixel in the input grid. Assume the input grid contains exactly one non-zero pixel. Let the value of this pixel be 'X'.\n2. Create an output grid of the same dimensions as the input grid, initialized with all pixels set to 0.\n3. Set the pixel at (R, C) in the output grid to the value 'X'.\n4. Generate a staircase pattern of value 5 (grey) starting from the pixel at (R, C) and extending towards the top-right corner of the output grid as follows:\n   a. Initialize current coordinates to (R, C).\n   b. Repeat until the current coordinates reach the boundary of the grid or exceed grid dimensions.\n   c. Set the pixels at (current R - 1, current C) and (current R - 2, current C) to 5, only if the coordinates are within the grid boundaries.\n   d. Set the pixels at (current R, current C + 1) and (current R, current C + 2) to 5, only if the coordinates are within the grid boundaries.\n   e. Update current coordinates: current R = current R - 2; current C = current C + 2.\n5. Generate a staircase pattern of value 5 (grey) starting from the pixel at (R, C) and extending towards the bottom-left corner of the output grid as follows:\n   a. Initialize current coordinates to (R, C).\n   b. Repeat until the current coordinates reach the boundary of the grid or exceed grid dimensions.\n   c. Set the pixels at (current R + 1, current C) and (current R + 2, current C) to 5, only if the coordinates are within the grid boundaries.\n   d. Set the pixels at (current R, current C - 1) and (current R, current C - 2) to 5, only if the coordinates are within the grid boundaries.\n   e. Update current coordinates: current R = current R + 2; current C = current C - 2.\n6. Return the output grid.",
    "d07ae81c.json": "1. Find all single-pixel locations (R, C) in the input grid that are not surrounded by the same value in all 8 neighboring cells. These are the 'source pixels'.\n2. For each source pixel with value V at (R, C), extend diagonal lines in all four diagonal directions (top-left, top-right, bottom-left, bottom-right) starting from (R, C).\n3. Extend each diagonal line as follows: If the adjacent cell along the diagonal has the same value as V, continue the diagonal line with value V.\n4. If the adjacent cell along the diagonal has a different value V2, change the value of the line to V2 and continue the diagonal line with the new value V2.\n5. Terminate a diagonal line when:\n    a. The diagonal line reaches the edge of the grid.\n6. The output grid size is the same as the input grid size.\n7. All other pixel values in the output grid, other than those modified by the diagonal lines, should remain the same as in the input grid.",
    "d0f5fe59.json": "1. Determine the number of distinct shapes present in the input grid. Let this number be N.\n2. Create a new output grid of size N x N.\n3. Identify the color of the shapes in the input grid. Represent this color as its corresponding numerical value (0-9). Let this value be C.\n4. Iterate through the output grid, where R represents the row index and C represents the column index (both starting from 0).\n5. Inside the iteration, check if R is equal to C. \n6. If R equals C, set the pixel value at (R, C) in the output grid to C. \n7. If R is not equal to C, set the pixel value at (R, C) in the output grid to 0.",
    "d10ecb37.json": "1. Define the input grid. The input grid contains a pattern of numbers (0-9). The size of the input grid is variable.\n2. Create a 2x2 output grid.\n3. Copy the pixel value from the top-left corner of the input grid (coordinate (0,0)) to the pixel at coordinate (0,0) of the output grid.\n4. Copy the pixel value from the input grid at coordinate (0,1) to the pixel at coordinate (0,1) of the output grid.\n5. Copy the pixel value from the input grid at coordinate (1,0) to the pixel at coordinate (1,0) of the output grid.\n6. Copy the pixel value from the input grid at coordinate (1,1) to the pixel at coordinate (1,1) of the output grid.",
    "d13f3404.json": "1. Find the input grid dimensions (rows, columns). Let these be R and C respectively.\n2. Create an output grid with dimensions 4R x 4C, initialized with all cells set to 0.\n3. Identify up to three non-zero pixels in the input grid. Store their coordinates and values. If there are less than three, treat the missing ones as if they did not exist.\n4. For each identified non-zero pixel with value V at coordinate (r, c) in the input grid, perform the following:\n    a. Iterate from column c to 4C - 1 in the output grid along row r, setting each cell's value to V.\n    b. Iterate from row r to 4R - 1 in the output grid along column c, setting each cell's value to V.\n    c. For each cell (row, col) in the output grid, where row >= r and col >= c, set the cell's value to V. Thus, create a line down and right from each original coordinate to the output edge.",
    "d22278a0.json": "1. Identify the colors of the corner squares. Designate the color of the top-left corner as 'color1' and the color of the bottom-left corner as 'color2'. If the top-left corner color is 2 (red) and bottom-left corner is 4 (yellow), proceed with those numbers. Otherwise, extract 'color1' and 'color2' from the grid. \n2. Create an output grid of the same dimensions as the input grid.\n3. Starting from the top-left corner (0, 0), draw vertical lines of 'color1' (red, which is 2). The lines should extend downwards. Leave one column of background color (likely black = 0) between each line.\n4. If the grid is large enough, after a certain number of lines, shorten the lines and extend them horizontally to the left border, creating an 'L' shape.\n5. Mirror the process from step 3, starting from the bottom-right corner of the output grid with 'color2' (yellow, which is 4). The lines extend upwards. Leave one column of background color (likely black = 0) between each line.\n6. Similarly, if the grid is large enough, after a certain number of lines, shorten these lines and extend them horizontally to the right border, creating a mirrored 'L' shape.\n7. Ensure that a single row of background color (likely black = 0) separates the lines emanating from opposite corners in the central region of the grid.",
    "d23f8c26.json": "1. Get the input grid. Let the number of rows be R and the number of columns be C.\n2. Create an output grid with the same dimensions R x C, and initialize all cells to 0.\n3. Calculate the middle column index: M = C // 2 (integer division).\n4. Iterate through each row i from 0 to R-1.\n5. Copy the pixel value from the input grid at (i, M) to the output grid at (i, M).",
    "d2abd087.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Identify all connected regions of pixels with value 5 (grey) in the input grid. Define a connected region as a set of pixels with value 5 (grey) that are 4-directionally adjacent (up, down, left, right).\n3. For each identified connected region of pixels with value 5 (grey):\n    a. Count the number of pixels in the region.\n    b. If the count is exactly 6, then change the value of all pixels in that region in the output grid to 2 (red).\n    c. If the count is not equal to 6, then change the value of all pixels in that region in the output grid to 1 (blue).",
    "d364b489.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Find all locations (R, C) in the input grid where the pixel value is 1 (blue).\n3. For each location (R, C) found in step 2:\n    a. Set the pixel value at (R, C - 1) in the output grid to 7 (orange). If C-1 is out of bounds, do nothing.\n    b. Set the pixel value at (R - 1, C) in the output grid to 2 (red). If R-1 is out of bounds, do nothing.\n    c. Set the pixel value at (R, C + 1) in the output grid to 6 (pink). If C+1 is out of bounds, do nothing.\n    d. Set the pixel value at (R + 1, C) in the output grid to 8 (cyan). If R+1 is out of bounds, do nothing.",
    "d406998b.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Iterate through the columns of the output grid, starting from the second column (column index 1). Columns are indexed from 0.\n3. For each column, check if the column index is odd.\n4. If the column index is odd, iterate through the cells in that column.\n5. For each cell in the odd-indexed column, check if the value of the cell is 5 (grey).\n6. If the cell value is 5, change the cell value to 3 (green).",
    "d43fd935.json": "1. Copy the input grid to the output grid.\n2. Find a 2x2 square of pixel value 3 in the input grid. If no such square exists, stop.\n3. For each corner of the 2x2 square of pixel value 3, perform the following steps:\n    a. Examine the pixels directly above the corner, stopping when a non-0 pixel is encountered or the top of the grid is reached.\n    b. If a non-0 pixel is found at (R, C), change all 0 pixels between the corner of the 2x2 square of pixel value 3 and (R, C) to the value of the pixel at (R, C).\n    c. Examine the pixels directly to the right of the corner, stopping when a non-0 pixel is encountered or the right edge of the grid is reached.\n    d. If a non-0 pixel is found at (R, C), change all 0 pixels between the corner of the 2x2 square of pixel value 3 and (R, C) to the value of the pixel at (R, C).\n    e. Examine the pixels directly below the corner, stopping when a non-0 pixel is encountered or the bottom of the grid is reached.\n    f. If a non-0 pixel is found at (R, C), change all 0 pixels between the corner of the 2x2 square of pixel value 3 and (R, C) to the value of the pixel at (R, C).\n    g. Examine the pixels directly to the left of the corner, stopping when a non-0 pixel is encountered or the left edge of the grid is reached.\n    h. If a non-0 pixel is found at (R, C), change all 0 pixels between the corner of the 2x2 square of pixel value 3 and (R, C) to the value of the pixel at (R, C).",
    "d4469b4b.json": "1. Analyze the input grid to determine the dominant color among 1 (blue), 2 (red), and 3 (green). If no dominant color is present, the result is undefined.\n2. Create a 3x3 output grid initialized with the value 5 (grey).\n3. IF the dominant color in the input is 1 (blue):\n    a. Set the output grid's corner values to 0 (black): (0,0), (0,2), (2,0), (2,2).\n4. IF the dominant color in the input is 2 (red):\n    a. Set the output grid's values at the following coordinates to 0 (black): (2,0), (2,2), (1,0), (1,2).\n5. IF the dominant color in the input is 3 (green):\n    a. Set the values in the upper-left 2x2 square of the output grid to 0 (black): (0,0), (0,1), (1,0), (1,1).\n6. The resulting 3x3 grid is the final output.",
    "d4a91cb9.json": "1. Copy the input grid to the output grid. The input grid contains at least one pixel of value 1 (blue) and at least one pixel of value 2 (red). All other pixels are assumed to be value 0 (black).\n2. Find the coordinates (R1, C1) of any pixel with value 1 (blue) in the input grid. R1 is the row index, and C1 is the column index.\n3. Find the coordinates (R2, C2) of any pixel with value 2 (red) in the input grid. R2 is the row index, and C2 is the column index.\n4. Draw a vertical line of value 4 (yellow) through the column C1, starting from row 0 and ending at the last row of the grid.\n5. Draw a horizontal line of value 4 (yellow) through the row R2, starting from column 0 and ending at the last column of the grid.",
    "d4f3cd78.json": "1. Identify the grid dimensions (rows, columns). The output grid will have the same dimensions as the input grid.\n2. Replace all pixels with value 5 (grey) in the input grid with the value 8 (cyan / light blue). This creates the base grid for the output.\n3. Find the pixel with value 0 (black). Let its coordinates be (R, C).\n4. Change the pixel at (R, C) to value 8 (cyan / light blue).\n5. Extend a line of value 8 (cyan / light blue) from the pixel at (R, C) to the edge of the grid. The line should extend in one of the four cardinal directions (up, down, left, or right). The direction should be determined by the location of the original value 0 (black) pixel relative to the grid edges. If the pixel is closest to the top edge, extend upwards; if closest to the bottom edge, extend downwards; if closest to the left edge, extend leftwards; if closest to the right edge, extend rightwards. If equidistant, choose any direction. The line should overwrite any existing pixel values encountered along the way.",
    "d511f180.json": "1. Get the input grid. The grid contains integer values from 0 to 9.\n2. Create an output grid with the same dimensions as the input grid.\n3. Iterate through each pixel in the input grid, row by row, column by column.\n4. At each pixel (R, C) in the input grid, get its value.\n5. If the pixel value at (R, C) is 5 (grey), then set the pixel value at (R, C) in the output grid to 8 (cyan / light blue).\n6. If the pixel value at (R, C) is 8 (cyan / light blue), then set the pixel value at (R, C) in the output grid to 5 (grey).\n7. If the pixel value at (R, C) is not 5 or 8, then set the pixel value at (R, C) in the output grid to the same value as the input grid at (R, C).\n8. After iterating through all pixels, the output grid contains the transformed image.",
    "d5d6de2d.json": "1. Identify regions of connected pixels with value 2. Call these \"red regions\".\n2. Identify regions of connected pixels with value 0. Call these \"black regions\".\n3. Iterate through each black region.\n4. Within each black region, replace all pixel values of 0 with the value 3.\n5. The output grid has the same dimensions as the input grid.",
    "d631b094.json": "1. Find the non-zero pixel value in the input grid. Let this value be denoted as 'X'.\n2. Count the number of pixels with value 'X' in the input grid. Let this count be denoted as 'N'.\n3. Create an output grid with a height of 1 and a width of 'N'.\n4. Fill all pixels in the output grid with the value 'X'.",
    "d687bc17.json": "1. Copy the input grid to the output grid. The output grid will be the same size as the input grid.\n2. Examine the top edge of the grid. For each unique number (1-9) found on the top edge:\n    a. Find all pixels within the interior of the grid (excluding the border) that have the same number as the number on the top edge.\n    b. For each such pixel at location (R, C), move it vertically upwards in the same column (C) until it touches the top edge or another non-zero pixel. If a move is performed, set the original location (R, C) to 0.\n3. Examine the right edge of the grid. For each unique number (1-9) found on the right edge:\n    a. Find all pixels within the interior of the grid (excluding the border) that have the same number as the number on the right edge.\n    b. For each such pixel at location (R, C), move it horizontally rightwards in the same row (R) until it touches the right edge or another non-zero pixel. If a move is performed, set the original location (R, C) to 0.\n4. Examine the bottom edge of the grid. For each unique number (1-9) found on the bottom edge:\n    a. Find all pixels within the interior of the grid (excluding the border) that have the same number as the number on the bottom edge.\n    b. For each such pixel at location (R, C), move it vertically downwards in the same column (C) until it touches the bottom edge or another non-zero pixel. If a move is performed, set the original location (R, C) to 0.\n5. Examine the left edge of the grid. For each unique number (1-9) found on the left edge:\n    a. Find all pixels within the interior of the grid (excluding the border) that have the same number as the number on the left edge.\n    b. For each such pixel at location (R, C), move it horizontally leftwards in the same row (R) until it touches the left edge or another non-zero pixel. If a move is performed, set the original location (R, C) to 0.\n6. After performing steps 2-5, set any remaining non-border pixels (pixels not connected to any border color) to 0.",
    "d6ad076f.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Find the two distinct regions in the input grid that are not background (0). Assume these regions represent two rectangles.\n3. Determine the bounding box for each of the two rectangular regions. Let Region A have corners (R1A, C1A) and (R2A, C2A), and Region B have corners (R1B, C1B) and (R2B, C2B), where R1 < R2 and C1 < C2.\n4. Determine the minimum width and height between the two rectangles. min_width = min(C2A - C1A + 1, C2B - C1B + 1), min_height = min(R2A - R1A + 1, R2B - R1B + 1).\n5. Connect the two rectangular regions with a straight line of value 8. The line's thickness is implicitly defined by removing 1 row/column from each side of the smaller rectangle's dimensions. The dimensions of the connecting line should be min_width - 2 and min_height - 2. The connecting line will be a horizontal or vertical line.\n6. If the rectangles are horizontally aligned (R1A approximately equals R1B), create a horizontal line of value 8 between the rectangles. The row index of the line will be close to both rectangles. The column start and end points of the line should extend from C2A to C1B (if C2A < C1B) or from C2B to C1A (if C2B < C1A). The thickness of the horizontal line (number of rows) will be min_height - 2. Ensure that the newly created block of value 8 does not overlap either of the initial rectangular blocks.\n7. If the rectangles are vertically aligned (C1A approximately equals C1B), create a vertical line of value 8 between the rectangles. The column index of the line will be close to both rectangles. The row start and end points of the line should extend from R2A to R1B (if R2A < R1B) or from R2B to R1A (if R2B < R1A). The thickness of the vertical line (number of columns) will be min_width - 2. Ensure that the newly created block of value 8 does not overlap either of the initial rectangular blocks.",
    "d89b689b.json": "1. Find all 2x2 subgrids within the input grid where all four cells have the same value. Let 'V' be this value.\n2. For each such 2x2 subgrid found at the top-left corner (R, C):\n3. Identify four distinct values, 'A', 'B', 'C', and 'D', present in the input grid, such that none of them is equal to 'V'. If fewer than four such distinct values exist, choose arbitrary distinct values different than 'V', ensuring that 'A', 'B', 'C', 'D' are distinct.\n4. Replace the 2x2 subgrid at (R, C) with the following values: grid[R][C] = A, grid[R][C+1] = B, grid[R+1][C] = C, grid[R+1][C+1] = D. Ensure these four replacements use the chosen 'A','B','C', and 'D' values.",
    "d8c310e9.json": "1. Analyze the input grid. Determine its dimensions (rows and columns). Let R and C represent row and column indices, respectively, starting from 0. \n2. Create an output grid with the same dimensions as the input grid.\n3. Iterate through each pixel location (R, C) in the input grid.\n4. Copy the value of the pixel at (R, C) from the input grid to the corresponding pixel at (R, C) in the output grid.\n5. The output grid is now a direct copy of the input grid.",
    "d90796e8.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Iterate through each pixel location (R, C) in the grid.\n3. Check if the pixel at (R, C) has a value of 2 (red).\n4. If the pixel at (R, C) is 2 (red), check its four immediate neighbors (up, down, left, right) for a value of 3 (green). Do not consider diagonal neighbors.\n5. If a neighboring pixel at (R+1, C), (R-1, C), (R, C+1), or (R, C-1) has a value of 3 (green), then:\n    a. Change the value of the pixel at (R, C) to 0 (black).\n    b. Change the value of the adjacent neighboring pixel that was 3 (green) to 8 (cyan/light blue).\n6. Continue iterating through all pixels in the grid.",
    "d9f24cd1.json": "1. Copy the input grid to the output grid. The output grid will have the same dimensions as the input grid.\n2. Find all pixels with value 2 (red) in the input grid. Note their coordinates as (R, C), where R is the row index and C is the column index.\n3. For each red pixel found at (R, C):\n    a. Starting from (R, C), extend a vertical line upwards by changing the pixel values in the output grid to 2 (red) for all rows R' from R down to 0, i.e., (R', C) for R' = R-1, R-2, ..., 0.\n    b. During the vertical line extension, check if a pixel with value 5 (grey) is encountered at any location (R', C) where R' < R. \n    c. If a grey pixel (value 5) is encountered at (R', C), stop the vertical line extension at row R'+1. Then, resume the vertical line extension from coordinate (R', C+1) upwards by changing the pixel values in the output grid to 2 (red) for all rows R'' from R'-1 down to 0, i.e., (R'', C+1) for R'' = R'-2, R'-3, ..., 0. The horizontal displacement is always to the right (C+1).\n    d. If the column C+1 goes beyond the grid boundary, then stop the vertical line extension. Do not extend further.",
    "d9fac9be.json": "1. Find a 3x3 square within the input grid. If multiple exist, find the one with a distinct center value. 2. Identify the value at the center of the 3x3 square. Let this value be 'center_value'. 3. Create a new 3x3 grid. 4. Set the value of every cell in the new grid to 'center_value'. 5. Output the new 3x3 grid.",
    "dae9d2b5.json": "1. Define the input grid as a 6x3 matrix of integer values (0-9). If the input grid is not 6x3, resize it to 6x3, cropping or padding with 0 as needed.\n2. Create a 3x3 output grid, initialized with all values set to 0.\n3. Copy the left two columns (columns 0 and 1) of the input grid to the output grid. Specifically, for each row R from 0 to 2:\n    a. Copy the value at input grid location (R, 0) to output grid location (R, 0).\n    b. Copy the value at input grid location (R, 1) to output grid location (R, 1).\n4. Copy the next two columns (columns 2 and 3) of the input grid to the output grid. Specifically, for each row R from 0 to 2:\n    a. Copy the value at input grid location (R, 2) to output grid location (R, 2).\n    b. Copy the value at input grid location (R, 3) to output grid location (R, 1).\n5. Define a function REPLACE(grid, original_value, new_value) that iterates through all cells (R, C) of the given grid and replaces all instances of 'original_value' with 'new_value'.\n6. Call REPLACE(output_grid, 3, 6). This will change all values of 3 (originally green) in the output grid to 6 (pink).\n7. Call REPLACE(output_grid, 4, 6). This will change all values of 4 (originally yellow) in the output grid to 6 (pink).",
    "db3e9e38.json": "1. Identify the input line of pixels. The length of this line is variable (either 4 or 5). The pixel values in this line can vary.\n2. Copy the input line to the first row of the output grid.\n3. Create subsequent rows by alternating the original pixel values with the value 8 (cyan/light blue), reducing the length of the line by one pixel each time.\n4. For each subsequent row (starting from the second row), reduce the length of the line by one. If the original pixel's index is even, use the original pixel value from the input line. If the original pixel's index is odd, use the value 8.\n5. The number of rows in the output grid should correspond to the length of the original input line.\n6. Example: If the input line is of length 4, there will be 4 rows in the output.\n7. Example: If the input line is of length 5, there will be 5 rows in the output.\n8. The output grid size is equal to the size of the input grid.\n9. Let R be the row number and C be the column number, both starting from 0.\n10. Row 0 is the original input line.\n11. For each row R > 0, and for each column C, if C is even, the pixel value at (R, C) is the same as the original input pixel value at index C in the original input line, otherwise, the pixel value at (R,C) is 8. Ensure that each row (R>0) has one fewer pixel than the previous row. Starting from column 0.\n12. If the input line's pixel length is 4, copy the first four pixels for row 0. For row 1 copy the first 3 pixels (alternating 8 with the corresponding pixel from row 0). For row 2 copy the first 2 pixels. For row 3 copy the first pixel.\n13. If the input line's pixel length is 5, copy the first five pixels for row 0. For row 1 copy the first 4 pixels (alternating 8 with the corresponding pixel from row 0). For row 2 copy the first 3 pixels. For row 3 copy the first 2 pixels. For row 4 copy the first pixel.",
    "db93a21d.json": "1. Find all connected regions of pixel value 2 (red) in the input grid. Call each region a \"red shape\".\n2. For each red shape:\n    a. Determine the width of the red shape. Define the width as the maximum horizontal span of the red shape's pixels.\n    b. Calculate the border size: border size = width of the red shape / 2. Use integer division (round down).\n    c. Add a border of pixel value 3 (green) around the red shape. The border's thickness is equal to the border size calculated in step 2b.\n    d. Find the bounding box of the red shape and its green border.\n    e. For each column within the bounding box's horizontal span:\n        i. Identify the bottommost pixel of the red shape within that column.\n        ii. Starting from the pixel directly below the bottommost red pixel, extend a vertical line of pixel value 1 (blue) downwards to the bottom of the grid within that column, but only where the current pixel value is 0 (black). If the pixel is not 0 (black), stop drawing the blue line in that column. Do not overwrite any pixel of value 3 (green).",
    "dbc1a6ce.json": "1. Create an output grid of the same dimensions as the input grid. Initialize all pixel values in the output grid to 0.\n2. Find all pixels with value 1 in the input grid. Store the coordinates (R, C) of these pixels.\n3. For each pixel with value 1 at coordinate (R1, C1), iterate through all other pixels with value 1 at coordinate (R2, C2).\n4. If R1 is equal to R2 (same row): Fill all pixels in the output grid from (R1, min(C1, C2)) to (R1, max(C1, C2)) with the value 8.\n5. If C1 is equal to C2 (same column): Fill all pixels in the output grid from (min(R1, R2), C1) to (max(R1, R2), C1) with the value 8.\n6. The output grid now contains lines with value 8 connecting pixels with value 1 that were in the same row or column in the input grid.",
    "dc0a314f.json": "1. Find the square region of color 3 (green) within the input grid. This region represents the \"green square\".\n2. Determine the dimensions (height and width) of the green square.\n3. Create an output grid with the same dimensions as the green square.\n4. Remove the green square from the input grid, revealing the underlying pattern.\n5. Copy the pattern from the original input grid (with the green square removed) into the output grid, such that the content of the green square in the original grid is replaced by the corresponding content now visible after its removal.\n6. The output grid now contains the inferred pattern that was originally hidden beneath the green square.",
    "dc1df850.json": "1. Copy the input grid to the output grid, preserving the original dimensions.\n2. Find all locations (R, C) in the input grid where the pixel value is 2 (red).\n3. For each location (R, C) found in step 2:\n    a. Set the pixel value at (R-1, C-1) in the output grid to 1 (blue), if (R-1, C-1) is within the bounds of the grid.\n    b. Set the pixel value at (R-1, C) in the output grid to 1 (blue), if (R-1, C) is within the bounds of the grid.\n    c. Set the pixel value at (R-1, C+1) in the output grid to 1 (blue), if (R-1, C+1) is within the bounds of the grid.\n    d. Set the pixel value at (R, C-1) in the output grid to 1 (blue), if (R, C-1) is within the bounds of the grid.\n    e. Set the pixel value at (R, C+1) in the output grid to 1 (blue), if (R, C+1) is within the bounds of the grid.\n    f. Set the pixel value at (R+1, C-1) in the output grid to 1 (blue), if (R+1, C-1) is within the bounds of the grid.\n    g. Set the pixel value at (R+1, C) in the output grid to 1 (blue), if (R+1, C) is within the bounds of the grid.\n    h. Set the pixel value at (R+1, C+1) in the output grid to 1 (blue), if (R+1, C+1) is within the bounds of the grid.",
    "dc433765.json": "1. Find the coordinates (R1, C1) of the pixel with value 4 (yellow). If multiple pixels with value 4 exist, choose any one.\n2. Find the coordinates (R2, C2) of the pixel with value 3 (green). If multiple pixels with value 3 exist, choose any one.\n3. Create a new grid with the same dimensions as the input grid, filled with the value 0 (black).\n4. Place a pixel with value 4 (yellow) at coordinates (R1, C1) in the new grid.\n5. Calculate the distance between (R1, C1) and (R2, C2) in both row and column directions: row_diff = R1 - R2 and col_diff = C1 - C2.\n6. Move the green pixel (value 3) one step closer to the yellow pixel (value 4):\n   - If abs(row_diff) > 0, then set R3 = R2 + sign(row_diff), where sign(x) is 1 if x > 0, -1 if x < 0, and 0 if x = 0.\n   - Otherwise, set R3 = R2.\n   - If abs(col_diff) > 0, then set C3 = C2 + sign(col_diff), where sign(x) is 1 if x > 0, -1 if x < 0, and 0 if x = 0.\n   - Otherwise, set C3 = C2.\n7. Place a pixel with value 3 (green) at coordinates (R3, C3) in the new grid.\n8. The new grid is the output.",
    "ddf7fa4f.json": "1. Assume the input grid has a rectangular shape. Let R be the number of rows and C be the number of columns.\n2. Create an output grid with the same dimensions (R rows and C columns) as the input grid.\n3. Iterate through each column, from column index 0 to C-1.\n4. For each column, examine the pixel value in the first row (row index 0) of the input grid. Let this value be V.\n5. Iterate through the remaining rows in the current column (from row index 1 to R-1).\n6. If the pixel value at row index R' and column index C' in the input grid is 5 (grey), then set the corresponding pixel value at row index R' and column index C' in the output grid to V.\n7. If the pixel value at row index R' and column index C' in the input grid is not 5, then copy the pixel value from the input grid to the output grid at row index R' and column index C'.\n8. After iterating through all columns and rows, the output grid is complete.",
    "de1cd16c.json": "1. Analyze the input grid. The input contains multiple grids. These grids may contain areas filled with single-digit numbers (0-9). Some grids may contain squares of a specific number surrounded by squares of other numbers.\n2. For each distinct number (0-9) found in the input grids, count the total number of occurrences across ALL input grids.\n3. Identify the number with the highest count from step 2. If there is a tie, pick any of the tied numbers.\n4. The output grid is a 1x1 grid.\n5. Set the single pixel value of the output grid to the number identified in step 3.",
    "ded97339.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Identify all pixels with value 6 (magenta) in the input grid. Let these be the 'magenta pixels'.\n3. For each magenta pixel at location (R, C), examine its immediate neighbors (up, down, left, and right).\n4. If a neighboring pixel is also a magenta pixel (value 6), change the value of the pixel between them to 6. A pixel is 'between' two magenta pixels if they are horizontally or vertically adjacent. If the horizontal coordinate is the same between the two pixels, the fill is vertical. If the vertical coordinate is the same between the two pixels, the fill is horizontal.\n5. Specifically:\n    a. If the neighbor above (R-1, C) is 6, change the pixel at (R-1, C) to 6.\n    b. If the neighbor below (R+1, C) is 6, change the pixel at (R+1, C) to 6.\n    c. If the neighbor to the left (R, C-1) is 6, change the pixel at (R, C-1) to 6.\n    d. If the neighbor to the right (R, C+1) is 6, change the pixel at (R, C+1) to 6.",
    "e179c5f4.json": "1. Copy the input grid to the output grid, preserving the grid dimensions.\n2. Find the pixel with value 1 (dark blue). Let its coordinates be (R, C).\n3. Initialize the grid with value 8 (light blue).\n4. Set the pixel at (R, C) to 1 (dark blue).\n5. While the process is not complete:\n    a. Increment R by 1 and C by 1. If R is greater than or equal to the number of rows or C is greater than or equal to the number of columns, then go to step (b).\n    b. Set the pixel at (R, C) to 1 (dark blue).\n    c. If C equals the number of columns, then:\n        i. Increment R by 1 and set C to the number of columns - 2.\n        ii. If R is greater than or equal to the number of rows, the process is complete.\n        iii. Set the pixel at (R, C) to 1 (dark blue).\n    d. If C is -1, then:\n        i. Increment R by 1 and set C to 1.\n        ii. If R is greater or equal to the number of rows, the process is complete.\n        iii. Set the pixel at (R, C) to 1 (dark blue).\n    e. Increment R by 1 and Decrement C by 1\n    f. If R is greater than or equal to the number of rows, the process is complete. \n    g. Set the pixel at (R, C) to 1 (dark blue).",
    "e21d9049.json": "1. Identify the input grid dimensions (rows, columns). Assume background color is 0.\n2. Copy the input grid to the output grid, preserving the original size.\n3. Find all non-0 pixels in the input grid that form horizontal lines. A horizontal line is defined as a contiguous sequence of pixels with the same non-0 value in a single row.\n4. For each horizontal line found in step 3, extend the line horizontally in both directions (left and right) until it reaches the edge of the output grid. Maintain the original value of the pixels in the horizontal line during the extension.\n5. Find all non-0 pixels in the input grid that form vertical lines. A vertical line is defined as a contiguous sequence of pixels with the same non-0 value in a single column.\n6. For each vertical line found in step 5, extend the line vertically in both directions (up and down) until it reaches the edge of the output grid. Maintain the original value of the pixels in the vertical line during the extension.\n7. The output grid is now complete.",
    "e26a3af2.json": "1. Analyze the input grid to identify rows or columns primarily composed of a single, consistent pixel value (0-9), but also containing scattered pixels with differing values. These are the 'bars'.\n2. For each 'bar' (row or column):\n3. Determine the predominant pixel value within that row or column. This will be the 'bar's value'.\n4. Iterate through each pixel in the 'bar'.\n5. If a pixel's value does not match the 'bar's value', replace the pixel's value with the 'bar's value'.\n6. The output grid should have the same dimensions as the input grid.",
    "e3497940.json": "1. Find the column of pixels with value 5. This column divides the input grid into a left side and a right side.\n2. Determine the width of the left side of the grid. This will be the width of the output grid.\n3. Determine the height of the input grid. This will be the height of the output grid.\n4. Create an output grid with the determined width and height, initialized with 0s.\n5. Iterate through each row R from 0 to the height of the output grid minus 1.\n6. Iterate through each column C from 0 to the width of the output grid minus 1.\n7. Let L be the pixel value at (R, C) on the left side of the input grid.\n8. Let offset be the number of columns from the 5-valued column to the right edge of the input grid. Calculate the corresponding column on the right side: right_C = width of right side - 1 - C, or input_width - 5_column_index - 1 - C. Let R be the row index from the input grid. Let R be the row index from the input grid.\n9. Let R be the row index from the input grid.Let Right_C be the column on the right side, calculated as input width - 5 column index - 1 - C. Let R be the row index from the input grid. Let R be the row index from the input grid.\n10. Let R be the row index from the input grid.Let R be the row index from the input grid.Let right_C be the column on the right side, calculated as input width - 5 column index - 1 - C. Let R be the row index from the input grid. Let R be the row index from the input grid.\n11. Let R be the row index from the input grid.Let R be the row index from the input grid.Let right_C be the column on the right side, calculated as input width - 5 column index - 1 - C. Let R be the row index from the input grid.Let R be the row index from the input grid.Calculate the coordinate of the pixel on the right side of the input grid as (R, right_C).\n12. Let R be the row index from the input grid.Let R be the row index from the input grid.Let right_C be the column on the right side, calculated as input width - 5 column index - 1 - C. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.\n13. Let R be the row index from the input grid.Let R be the row index from the input grid.Let right_C be the column on the right side, calculated as input width - 5 column index - 1 - C. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Find the pixel value at (R, right_C) on the right side of the input grid; call this value R.\n14. Let R be the row index from the input grid.Let R be the row index from the input grid.Let right_C be the column on the right side, calculated as input width - 5 column index - 1 - C. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.\n15. Let R be the row index from the input grid.Let R be the row index from the input grid.Let right_C be the column on the right side, calculated as input width - 5 column index - 1 - C. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.\n16. Let R be the row index from the input grid.Let R be the row index from the input grid.Let right_C be the column on the right side, calculated as input width - 5 column index - 1 - C. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.\n17. Let R be the row index from the input grid.Let R be the row index from the input grid.Let right_C be the column on the right side, calculated as input width - 5 column index - 1 - C. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.If L equals R, set the pixel value at (R, C) in the output grid to L. Otherwise, if either L or R is not 0, set the pixel value at (R, C) in the output grid to the value which is not 0. If both L and R are 0, the output remains 0.\n18. Let R be the row index from the input grid.Let R be the row index from the input grid.Let right_C be the column on the right side, calculated as input width - 5 column index - 1 - C. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.\n19. Let R be the row index from the input grid.Let R be the row index from the input grid.Let right_C be the column on the right side, calculated as input width - 5 column index - 1 - C. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid. Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.Let R be the row index from the input grid.End the loops.\n20. Return the output grid.",
    "e40b9e2f.json": "1. Find the bounding box of the non-0 (black) region in the input grid. This region represents the 'large shape'.\n2. Identify a single, isolated non-0 pixel that lies on a corner of the bounding box found in step 1. Let the color of this isolated pixel be 'corner_color'.\n3. Create an output grid of the same dimensions as the input grid, initialized with all values set to 0.\n4. Copy the original input grid to the output grid.\n5. Rotate the 'large shape' 90 degrees clockwise around the center of the bounding box. Replace the corresponding pixels in the output grid with the values from the rotated shape. If a pixel already has a non-0 value, overwrite it with the new rotated value.\n6. Repeat step 5 two more times, rotating the 'large shape' 90 degrees clockwise each time (180 and 270 degrees from the original), and overwriting existing values in the output grid.\n7. The final output grid will contain the original shape, plus the shapes rotated 90, 180, and 270 degrees, effectively creating a symmetrical pattern. The corner single block will also be rotated around the center.",
    "e48d4e1a.json": "1. Copy the input grid to the output grid.\n2. Find the number of connected pixels with value 5 (grey) in the input grid. This is the shift value.\n3. Set all pixels with value 5 (grey) in the output grid to 0 (black).\n4. Identify all horizontal lines composed of non-zero pixel values in the output grid.\n5. For each horizontal line identified in step 4, shift it downward by the shift value calculated in step 2. If shifting a line causes it to go beyond the bounds of the grid, the portion of the line that goes out of bounds should be truncated.\n6. The resulting grid is the final output.",
    "e5062a87.json": "1. Identify a distinct pattern of pixels with value 2 (red) in the input grid.\n2. Find all locations in the input grid where a pixel with value 0 (black) exists.\n3. For each location where a pixel with value 0 (black) is found, check if it is part of the same pattern as the identified pixel with value 2 (red).\n4. If a pixel with value 0 (black) is part of the same pattern as the pixel with value 2 (red), change its value to 2 (red).\n5. In a specific row, located 6 rows down from the top, identify four consecutive pixels with value 0 (black).\n6. Change the values of these four pixels to the same values as the four colored blocks that precede them in the same row. White blocks are value 0.",
    "e509e548.json": "1. Identify connected regions of value 3 (green) in the input grid. Treat each connected region as a distinct object.\n2. For each identified region of value 3 (green):\n    a. Analyze the shape of the region.\n    b. Count the number of 90-degree edges in the region's boundary. \n    c. If the region has one 90-degree edge, change all pixel values in that region to 1 (blue).\n    d. If the region has two 90-degree edges, change all pixel values in that region to 6 (pink).\n    e. If the region has three 90-degree edges, change all pixel values in that region to 2 (red).\n3. Output the modified grid.",
    "e50d258f.json": "1. Identify all distinct rectangular shapes in the input grid. Each shape should contain at least one pixel with value 2 (red).\n2. For each identified rectangular shape, count the number of pixels with value 2 (red).\n3. Find the rectangular shape with the maximum count of pixels with value 2.\n4. Determine the dimensions (rows and columns) of this rectangular shape.\n5. Create a new output grid with the determined dimensions.\n6. Copy the pixel values from the identified rectangular shape with the most pixels with value 2 (red) to the corresponding locations in the new output grid. All pixels from the selected input rectangle will be copied to the output. Other areas should not be considered or modified.",
    "e6721834.json": "1. Input is a grid containing two sections, each with a different background number. One section (Section A) contains individual square regions of various numbers. The other section (Section B) contains the same individual square regions, each surrounded by a border of other numbers. The grid dimensions of Section A and Section B are identical.\n2. The output grid size is the same size as Section A.\n3. Initialize the output grid with the numbers from Section A.\n4. For each individual square region in Section A at location (R, C) with number N:\n    a. Locate the corresponding square region with the same number N at location (R, C) in Section B.\n    b. Identify the numbers in the immediate surrounding border (up, down, left, and right) of the square region at (R, C) in Section B.\n    c. Copy these surrounding border numbers from Section B to the corresponding locations in the output grid around the square region at (R, C).",
    "e73095fd.json": "1. Input grid: Identify pixels with value 5 and value 0. Value 5 represents lines or squares. Value 0 represents the background.\n2. Output grid size: The output grid has the same dimensions as the input grid.\n3. Transformation: Replace all pixels with value 5 in the input grid with the value 4 in the output grid. Keep pixels with value 0 as value 0.",
    "e76a88a6.json": "1. Find all connected regions of pixels with value 5 (grey) in the input grid.\n2. Identify the first connected region of pixels with value 5 (grey). This will serve as the source pattern.\n3. Extract the pattern from this first region. Determine the minimum row (min_row) and minimum column (min_col) of the bounding box containing the source region's pattern. For each pixel with value 5 (grey) in this region, calculate its relative coordinates as (row - min_row, col - min_col), where row and col are the row and column indices of the pixel.\n4. For each remaining connected region of pixels with value 5 (grey):\n    a. Determine the minimum row (min_row) and minimum column (min_col) of the bounding box containing the target region.\n    b. For each relative coordinate (r_row, r_col) obtained in step 3:\n        i. Calculate the absolute coordinates (target_row, target_col) in the target region as (min_row + r_row, min_col + r_col).\n        ii. Find the original pixel value at the corresponding relative coordinate (r_row, r_col) in the source region defined in Step 3. Copy this original value to the (target_row, target_col) location in the output grid.\n5. For all other pixels (pixels not modified in step 4), copy the corresponding pixel value from the input grid to the output grid.",
    "e8593010.json": "1. Input: A 10x10 grid containing only values 0 (black) and 5 (grey).\n2. Output: A 10x10 grid of the same size as the input grid.\n3. Process the grid as follows:\n4. For each pixel in the input grid, if the pixel value is 5 (grey), copy the value 5 to the corresponding pixel in the output grid.\n5. Identify all connected components of value 0 (black) in the input grid.\n6. For each connected component:\n   a. If the connected component consists of a single pixel (size 1), change the corresponding pixel value in the output grid to 3 (green).\n   b. If the connected component consists of two connected pixels (size 2), change the values of the corresponding pixels in the output grid to 2 (red).\n   c. If the connected component consists of three connected pixels (size 3), change the values of the corresponding pixels in the output grid to 1 (blue).",
    "e8dc4411.json": "1. Find the coordinates (R0, C0) of all cells with value 0 (black). This defines the \"black pattern\".\n2. Find the coordinates (R1, C1) of the single cell that is NOT value 0 (black). Let V be the value of this cell.\n3. Initialize an empty grid of the same dimensions as the input grid, called the output grid.\n4. Copy all values from the input grid to the corresponding cells in the output grid.\n5. Starting from the cell (R1, C1), iteratively copy the \"black pattern\" diagonally. The direction of the diagonal must be consistent. \n6. The copying process is as follows: For each cell with coordinates (R, C) in the \"black pattern\" relative to (R0, C0), set the corresponding cell (R1 + (R - R0), C1 + (C - C0)) in the output grid to the value V, only if the destination cell lies within the bounds of the grid.\n7. After applying the black pattern once, calculate the new coordinates (R2, C2) to place the pattern again diagonally. The relative position of the new location should maintain the same diagonal direction as the previous placement of the pattern.\n8. Repeat step 6 and 7 until no more complete \"black patterns\" can be placed diagonally within the bounds of the output grid. When a pattern extends beyond the grid boundaries, only copy the portion that fits inside the grid.\n9. The final output grid contains the transformed image.",
    "e9614598.json": "1. Copy the input grid dimensions to the output grid. The grid is 10x10.\n2. Find the locations of the two pixels with value 1 in the input grid.\n3. Copy the pixel values, including the value 1 pixels, from the input grid to the output grid.\n4. Calculate the midpoint (R_mid, C_mid) between the row and column coordinates of the two pixels with value 1.  R_mid = (R1 + R2) / 2, C_mid = (C1 + C2) / 2, where (R1, C1) and (R2, C2) are the coordinates of the two pixels with value 1.\n5. Set the pixel value at (R_mid, C_mid) in the output grid to 3.\n6. Set the pixel value at (R_mid - 1, C_mid) in the output grid to 3, if R_mid - 1 is within the grid bounds.\n7. Set the pixel value at (R_mid + 1, C_mid) in the output grid to 3, if R_mid + 1 is within the grid bounds.\n8. Set the pixel value at (R_mid, C_mid - 1) in the output grid to 3, if C_mid - 1 is within the grid bounds.\n9. Set the pixel value at (R_mid, C_mid + 1) in the output grid to 3, if C_mid + 1 is within the grid bounds.",
    "e98196ab.json": "1. Input is an 11x11 grid of integer values (0-9). Assume row and column indices start at 0.\n2. Identify row index R where all values in that row are 5 (grey). This row divides the grid into two sections: above and below.\n3. Extract the 5 rows immediately above row R (rows R-5 to R-1). If R<5, start from row 0 instead of R-5. These become the top part of the output.\n4. Extract the 5 rows immediately below row R (rows R+1 to R+5). If R+5>10, stop at row 10. These become the bottom part of the output.\n5. The output grid is 11x5.\n6. Construct the output grid by taking rows from steps 3 and 4 in the original input grid. The order is not changed, the upper 5 rows will be the top portion of the output and the lower 5 rows will be the bottom portion of the output.",
    "e9afcf9a.json": "1. Determine the input grid's dimensions (rows, columns). The output grid will have the same dimensions as the input grid. \n2. Identify the value of the pixel at the top-left corner (0,0) of the input grid. Call this value 'first_color'.\n3. Identify a second color that is different than the first color. Call this value 'second_color'.\n4. Iterate through each row of the output grid, starting from row 0.\n5. Within each row, iterate through each column, starting from column 0.\n6. If the row number is even:\n    a. If the column number is even, set the pixel value at (row, column) in the output grid to 'first_color'.\n    b. If the column number is odd, set the pixel value at (row, column) in the output grid to 'second_color'.\n7. If the row number is odd:\n    a. If the column number is even, set the pixel value at (row, column) in the output grid to 'second_color'.\n    b. If the column number is odd, set the pixel value at (row, column) in the output grid to 'first_color'.",
    "ea32f347.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Identify all distinct continuous lines composed of pixel value 5 (grey) on a background of pixel value 0 (black).\n3. Measure the length of each identified grey line (pixel value 5), defined as the number of connected pixels with value 5.\n4. Sort the identified grey lines by length in descending order.\n5. Identify the longest line (line with the greatest length).\n6. Change the pixel value of all pixels forming the longest line from 5 to 1 (blue).\n7. Identify the middle line (line with the median length).\n8. Change the pixel value of all pixels forming the middle length line from 5 to 4 (yellow).\n9. Identify the shortest line (line with the smallest length).\n10. Change the pixel value of all pixels forming the shortest line from 5 to 2 (red).",
    "ea786f4a.json": "1. Identify the input grid. The input grid contains a square area of one dominant integer value (0-9), with a square block of a different integer value (0-9) located at the center of the grid. \n2. Determine the dimensions of the input grid. The output grid will have the same dimensions.\n3. Identify the center block's integer value. This value will be used to draw diagonal lines.\n4. Locate the four corners of the center block. Let these coordinates be (R1, C1), (R1, C2), (R2, C1), and (R2, C2), where R1 < R2 and C1 < C2.\n5. Starting from each of the four corner coordinates (R1, C1), (R1, C2), (R2, C1), and (R2, C2), draw diagonal lines extending towards the corners of the grid, setting the pixel value along each diagonal line to the integer value of the center block.\n6. Specifically:\n    a. From (R1, C1), draw a diagonal line towards the top-left corner of the grid. Set the pixel value at each coordinate (R1 - i, C1 - i) to the center block's integer value, where i increments from 0 until R1 - i or C1 - i reaches 0.\n    b. From (R1, C2), draw a diagonal line towards the top-right corner of the grid. Set the pixel value at each coordinate (R1 - i, C2 + i) to the center block's integer value, where i increments from 0 until R1 - i reaches 0 or C2 + i reaches the grid's maximum column index.\n    c. From (R2, C1), draw a diagonal line towards the bottom-left corner of the grid. Set the pixel value at each coordinate (R2 + i, C1 - i) to the center block's integer value, where i increments from 0 until R2 + i reaches the grid's maximum row index or C1 - i reaches 0.\n    d. From (R2, C2), draw a diagonal line towards the bottom-right corner of the grid. Set the pixel value at each coordinate (R2 + i, C2 + i) to the center block's integer value, where i increments from 0 until R2 + i or C2 + i reaches the grid's maximum index.\n7. Output the modified grid.",
    "eb281b96.json": "1. Determine the input grid's width (W) and height (H). Assume the input grid contains a repeating pattern. \n2. Create an output grid with a width of W and a height of (H * 3) + 1.\n3. Copy the original input grid pattern to the top H rows of the output grid, starting at row 0.\n4. Create a vertically mirrored pattern of the original input grid. To create the mirrored pattern, for each row R from 0 to H-1 in the original input grid, copy the values to row (H * 2) - R in the output grid. This mirrored pattern will be placed below the original pattern in the output grid.\n5. Create a flipped pattern of the original input grid in the output grid. To create the flipped pattern, for each row R from 0 to H-1 in the original input grid, copy the values to row H + R in the output grid.\n6. Fill the last row of the output grid (at row index H * 3) with a pattern derived as follows: For each column C from 0 to W-1, copy the pixel value from row H-1 of the original input grid at column C to the same column C of the last row of the output grid.",
    "eb5a1d5d.json": "1. Determine the number of distinct pixel values (colors) in the input grid. Let this number be N. Assume N is between 2 and 4, inclusive.\n2. Calculate the size of the output grid, S, as S = 2 * N - 1. The output grid will be S x S.\n3. Identify the pixel values corresponding to each distinct \"layer\" in the input, from the innermost to the outermost. This ordering determines the assignment order of pixel values in the output grid. Assume that the smallest contiguous region is the innermost layer, the next smallest contiguous region is the next layer, and so on. Store these pixel values in a list called VALUE_LIST, ordered from innermost to outermost layer.\n4. Create an empty S x S output grid, initialized with a default value (e.g., 0).\n5. Iterate through the VALUE_LIST, along with a corresponding size variable, CURRENT_SIZE, starting from 1 and incrementing by 2 in each iteration. The iteration index i ranges from 0 to N-1.\n6. In each iteration i, set the central CURRENT_SIZE x CURRENT_SIZE block of the output grid to the pixel value VALUE_LIST[i].\n7.  Specifically, for each iteration i:\n    a. Calculate the starting row index, START_ROW = (S - CURRENT_SIZE) / 2.\n    b. Calculate the starting column index, START_COL = (S - CURRENT_SIZE) / 2.\n    c. Iterate through rows R from START_ROW to START_ROW + CURRENT_SIZE - 1.\n    d. Iterate through columns C from START_COL to START_COL + CURRENT_SIZE - 1.\n    e. Set the pixel value at (R, C) in the output grid to VALUE_LIST[i].\n8. After iterating through all pixel values in VALUE_LIST, the output grid is complete. Return the output grid.",
    "ec883f72.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Find the outer square (border) and the inner square within the input grid. These squares are composed of different numbers (0-9).\n3. Determine the number representing the color of the inner square (0-9).\n4. For each corner of the outer square (border), extend a diagonal line outwards to the edge of the grid.\n5. The number value of each pixel along these diagonal lines should be the same as the number representing the inner square's color.\n6. Specifically, for each corner of the outer square at coordinates (R, C):\n    a. Extend the diagonal line towards the top-left corner: While R > 0 and C > 0, set the pixel value at (R, C) in the output grid to the inner square's number, then decrement R and C.\n    b. Extend the diagonal line towards the top-right corner: While R > 0 and C < grid_width - 1, set the pixel value at (R, C) in the output grid to the inner square's number, then decrement R and increment C.\n    c. Extend the diagonal line towards the bottom-left corner: While R < grid_height - 1 and C > 0, set the pixel value at (R, C) in the output grid to the inner square's number, then increment R and decrement C.\n    d. Extend the diagonal line towards the bottom-right corner: While R < grid_height - 1 and C < grid_width - 1, set the pixel value at (R, C) in the output grid to the inner square's number, then increment R and increment C.",
    "ecdecbb3.json": "1. Copy the input grid to the output grid. The output grid will be the same size as the input grid.\n2. Identify all pixels with value 'x' that form continuous horizontal or vertical lines. Define these as 'lines of x'.\n3. Identify all pixels with value 'y' that are not connected to the lines of x. Define these as 'isolated pixels of y'.\n4. For each isolated pixel of y at coordinates (R, C), find the closest line of x. Determine the orientation (horizontal or vertical) of this closest line of x.\n5. Draw a line of value y, perpendicular to the closest line of x, starting from the isolated pixel of y at (R, C) and extending until it intersects the closest line of x.\n6. At the point of intersection between the line of y and the line of x, change the value of the intersecting pixel to y.\n7. For each pixel that has the value y, surround this pixel with a square of pixels that all have the value x. The pixel with value y should be at the center of the square. If the square extends beyond the boundaries of the grid, truncate the square at the boundary.",
    "ed36ccf7.json": "1. Assume the input is a square grid of integers, with values ranging from 0-9. The output grid will have the same dimensions as the input grid. 2. Rotate the entire input grid counter-clockwise by 90 degrees to produce the output grid. Specifically, the pixel at input grid coordinates (R, C) will be copied to output grid coordinates (C, N-1-R), where N is the size of the input grid's side, R is the row index, and C is the column index, both starting from 0.",
    "ef135b50.json": "1. Find all connected regions of pixel value 2 (red) in the input grid. These will be referred to as \"red regions\".\n2. Iterate through each row of the input grid.\n3. Within each row, identify pairs of red regions that are separated by one or more pixels with value 0 (black).\n4. For each such pair of red regions in a row, fill the intervening pixels between them with pixel value 2 (red).",
    "f15e1fac.json": "1. Copy the input grid to the output grid. \n2. Find all locations (R, C) in the input grid where the pixel value is 1 (blue). These are the starting points.\n3. Find all locations (R', C') in the input grid where the pixel value is 2 (red). These are the target indicators.\n4. For each starting point (R, C) with value 1:\n    a. Determine a drawing direction (horizontal or vertical) based on the relative position of 2 (red) values in the grid. If 1 (blue) is on the top, the direction is down. If 1 (blue) is on the left, the direction is right.\n    b. Draw a line of value 1 (blue) starting from (R, C) in the determined direction.\n    c. The line should extend until it encounters a pixel with value 2 (red).\n    d. After reaching the 2 (red) pixel at (R', C'), shift the starting position of the 1 (blue) line by one cell away from the 2 (red) pixel. For example, if the 2 (red) pixel is below, start the next line one cell above the 2 (red) pixel. If the 2 (red) pixel is to the right, start the next line one cell to the left of the 2 (red) pixel.\n    e. Continue drawing the line of value 1 (blue) in the same direction as before until the edge of the grid or another 2 (red) pixel is encountered.\n    f. Repeat steps d and e until the end of the grid is reached in that direction.\n5. All other pixel values remain unchanged from the original grid.",
    "f1cefba8.json": "1. Copy the input grid to the output grid. \n2. Identify the inner rectangle/square within the grid. Let the color of this inner shape be 'inner_color'.\n3. Identify the border surrounding the inner shape. Let the color of this border be 'border_color'.\n4. Find any protrusions of 'inner_color' into the 'border_color'. Protrusions are defined as single or multiple connected pixels of 'inner_color' located directly adjacent to the inner shape within the border region.\n5. For each protrusion found:\n    a. Determine if the protrusion is located on the left or right border of the inner shape. If so, consider the row (R) containing the protrusion.\n    b. Determine if the protrusion is located on the top or bottom border of the inner shape. If so, consider the column (C) containing the protrusion.\n    c. If the protrusion is on the left or right border, iterate through each cell in row R. If the cell value is not 0, change the cell value to 'border_color'. If the cell value is 0, change the cell value to 'inner_color'.\n    d. If the protrusion is on the top or bottom border, iterate through each cell in column C. If the cell value is not 0, change the cell value to 'border_color'. If the cell value is 0, change the cell value to 'inner_color'.",
    "f25fbde4.json": "1. Find the bounding box of all pixels with value 4 in the input grid. These pixels form the 'shape'.\n2. Determine the dimensions (height and width) of the 'shape' found in step 1.\n3. Calculate the output grid dimensions: output height = 2 * shape height, output width = 2 * shape width.\n4. Create a new output grid with dimensions calculated in step 3, filled with the value 0.\n5. Iterate through each pixel with value 4 within the bounding box of the 'shape' in the input grid. Let (R, C) be the row and column coordinates of the current pixel with value 4, relative to the top-left corner of the shape's bounding box. \n6. In the output grid, set the pixel at (2*R, 2*C) to 4.\n7. In the output grid, set the pixel at (2*R + 1, 2*C) to 4.\n8. In the output grid, set the pixel at (2*R, 2*C + 1) to 4.\n9. In the output grid, set the pixel at (2*R + 1, 2*C + 1) to 4.\n10. The output grid now contains the 'shape', doubled in size, with the rest of the grid having a value of 0.",
    "f25ffba3.json": "1. Get the input grid. The grid contains integer values representing colors (0-9).\n2. Create an output grid with the same dimensions as the input grid.\n3. Iterate through each row R of the input grid, from top to bottom (R = 0 to height - 1).\n4. For each row R, copy the entire row from the input grid to row (height - 1 - R) of the output grid. This reflects the grid vertically.\n5. The output grid now contains the vertically reflected version of the input grid.",
    "f2829549.json": "1. Extract the first 3x4 grid from the input. Let's call this Grid A.\n2. Extract the last 3x4 grid from the input. Let's call this Grid B.\n3. Create a new 3x4 grid called Output Grid, initialized with all values set to 0.\n4. Iterate through each cell (R, C) in Grid A and Grid B, where R is the row index (0-3) and C is the column index (0-2).\n5. If the value at cell (R, C) in Grid A is not 0 OR the value at cell (R, C) in Grid B is not 0, then set the value at cell (R, C) in the Output Grid to 0.\n6. If the value at cell (R, C) in Grid A is 0 AND the value at cell (R, C) in Grid B is 0, then set the value at cell (R, C) in the Output Grid to 3.\n7. The Output Grid now contains the transformed grid with values 0 and 3.",
    "f35d900a.json": "1. Copy the input grid to the output grid. The output grid has the same dimensions as the input grid.\n2. Identify two distinct non-zero pixel values in the input grid. Name the first value 'A' and the second value 'B'. If there are multiple such pairs, select one.\n3. For each pixel with value A in the input grid:\n    a. Create a 3x3 square centered on that pixel location in the output grid. If the pixel is located at (R, C), the square will span rows R-1 to R+1 and columns C-1 to C+1. Pixels outside of the grid bounds should be ignored.\n    b. Set all pixels within this 3x3 square to value B.\n4. For each pixel with value B in the input grid:\n    a. Create a 3x3 square centered on that pixel location in the output grid. If the pixel is located at (R, C), the square will span rows R-1 to R+1 and columns C-1 to C+1. Pixels outside of the grid bounds should be ignored.\n    b. Set all pixels within this 3x3 square to value A.\n5. Identify all the 3x3 squares created in steps 3 and 4.\n6. Connect the 3x3 squares. Fill the space between squares with alternating pixel values 5 (grey) and 0 (black), starting with 5 (grey) adjacent to the squares.",
    "f5b8619d.json": "1. Determine the dimensions (rows, columns) of the input grid. Let the input grid height be 'H' and width be 'W'.\n2. Create an output grid with dimensions 2H x 2W. Initialize all cells in the output grid to 0.\n3. Iterate through each cell (R, C) of the input grid, where R ranges from 0 to H-1 and C ranges from 0 to W-1.\n4. For each cell (R, C) in the input grid, copy its value to four corresponding cells in the output grid: (2R, 2C), (2R, 2C+1), (2R+1, 2C), and (2R+1, 2C+1).\n5. Iterate through each column C of the input grid.\n6. If all cells in column C of the input grid are 0, set all cells in columns 2C and 2C+1 of the output grid to 0.\n7. Otherwise, for each column C of the input grid that contains at least one non-zero value:\n    a. In output columns 2C and 2C+1, examine corresponding column C in the input grid from top (R=0) to bottom (R=H-1):\n        i. If the cell value in the input grid at (R, C) is not 0, set all cells in output rows 2R and 2R+1 of columns 2C and 2C+1 to the value of the input cell (R, C).\n        ii. If the cell value in the input grid at (R, C) is 0, set all cells in output rows 2R and 2R+1 of columns 2C and 2C+1 to 1.",
    "f76d97a5.json": "1. Obtain the input grid. The output grid will have the same dimensions as the input grid.\n2. Iterate through each pixel in the input grid, row by row, and column by column. Let (R, C) denote the row and column indices of the current pixel.\n3. If the pixel value at (R, C) in the input grid is 5 (grey), then set the pixel value at (R, C) in the output grid to the value of the colored box found in the input grid (replace grey with color).\n4. If the pixel value at (R, C) in the input grid is not 5 (grey), then set the pixel value at (R, C) in the output grid to 0 (black) (replace color with black).\n5. Return the output grid.",
    "f8a8fe49.json": "1. Identify two distinct patterns in the input grid: an outer \"bracket\" pattern (value 7) and an inner pattern (value 5). Assume that the grid size of the output is the same as the input.\n2. Determine the location of the inner pattern (value 5) relative to the bracket pattern (value 7).\n3. IF the inner pattern (value 5) is located inside the bracket pattern (value 7), THEN move the inner pattern (value 5) to the outside of the bracket pattern (value 7) at the same vertical level, with a single empty column (value 0) separating the bracket pattern (value 7) and the inner pattern (value 5).\n4. ELSE IF the inner pattern (value 5) is located outside the bracket pattern (value 7), THEN move the inner pattern (value 5) to the inside of the bracket pattern (value 7), ensuring even horizontal spacing (value 0) between the inner pattern (value 5) and the sides of the bracket pattern (value 7).\n5. The remaining grid locations should retain their original values.",
    "f8b3ba0a.json": "1. Analyze the input grid and identify all distinct pixel values (numbers 0-9). Assume there are four distinct pixel values.\n2. Count the number of occurrences of each distinct pixel value in the input grid.\n3. Determine the pixel value with the fewest occurrences. \n4. Create a 3x1 output grid.\n5. Assign the pixel value determined in step 3 to the pixel at coordinate (2, 0) in the output grid (bottom row).\n6. Find the pixel value with the second-fewest occurrences in the input grid.\n7. Assign this pixel value to the pixel at coordinate (1, 0) in the output grid (middle row).\n8. Find the pixel value with the third-fewest occurrences in the input grid.\n9. Assign this pixel value to the pixel at coordinate (0, 0) in the output grid (top row).",
    "f8c80d96.json": "1. Change all pixel values of 0 to 5.\n2. Identify lines of a single color (not 0) that bend at a right angle. These lines originate from the edges of the grid and maintain consistent spacing between them.\n3. Determine the color value of these lines.\n4. Extend these lines, maintaining their color value, right-angle bends, and consistent spacing, until they reach the boundaries of the grid or intersect with another line.\n5. Ensure that the extended lines do not overwrite existing non-5 pixel values.\n6. The output grid size is identical to the input grid size.",
    "f8ff0b80.json": "1. Analyze the input grid and identify the three distinct pixel values (integers from 0-9). Let these values be V1, V2, and V3.\n2. Count the number of occurrences of each distinct pixel value (V1, V2, and V3) in the input grid. Let these counts be C1, C2, and C3, respectively.\n3. Create a list of tuples, where each tuple contains a pixel value and its corresponding count: [(V1, C1), (V2, C2), (V3, C3)].\n4. Sort this list of tuples in descending order based on the counts (C1, C2, C3). This will arrange the pixel values from most frequent to least frequent.\n5. Create a 3x1 output grid (3 rows, 1 column).\n6. Populate the output grid, assigning pixel values based on the sorted list: The pixel value from the first tuple (most frequent) goes into the first row (0,0) of the output grid. The pixel value from the second tuple goes into the second row (1,0) of the output grid. The pixel value from the third tuple (least frequent) goes into the third row (2,0) of the output grid.",
    "f9012d9b.json": "1. Find the region(s) in the input grid containing the value 0 (representing black squares). These regions define the output size and location.\n2. Analyze the immediate surrounding area of each 0-valued region in the input grid to identify a repeating color pattern. The pattern will likely consist of two alternating values (numbers between 1-9).\n3. Determine the value that should logically occupy each position within the 0-valued region based on the identified repeating pattern. \n4. Create an output grid for each 0-valued region, with the same dimensions as that region.\n5. Fill the output grid with the determined values from step 3, thus completing the inferred pattern within the output grid.",
    "fafffa47.json": "1. Create a 3x3 output grid initialized with the value 0.\n2. Identify the input grid's region containing value 9 (brown). Copy this 9-pattern to the top of the 3x3 output grid.\n3. Identify the input grid's region containing value 1 (blue). Copy this 1-pattern to the bottom of the 3x3 output grid.\n4. For each pixel in the 3x3 output grid: If the pixel value is currently 0, replace it with the value 7 (orange).\n5. For each pixel in the 3x3 output grid: If the pixel value is currently 1 or 9, replace it with the value 0.",
    "fcb5c309.json": "1. Find all distinct shapes in the input grid where the background color is 0 (black). A shape is defined as a connected region of non-zero pixels. \n2. Determine the size (height and width) of the smallest bounding box that encompasses each shape. \n3. Identify the largest shape based on the area of its bounding box (height * width). If multiple shapes have the same largest area, choose one arbitrarily.\n4. Create an output grid with dimensions equal to the bounding box of the largest shape found in step 3. \n5. Copy the pixels contained within the bounding box of the largest shape from the input grid to the output grid.  The position of the top-left corner of the bounding box in the input grid corresponds to the top-left corner (0, 0) of the output grid.\n6. Identify the most frequent non-zero pixel value within the interior of the largest shape's bounding box in the *input* grid.  Do not consider the bounding box edges.\n7. Replace all non-zero pixel values within the copied shape in the *output* grid with the most frequent non-zero pixel value found in Step 6.",
    "fcc82909.json": "1. Input: The input is a grid containing 2x2 blocks of varying numbers on a 0 (black) background. The blocks themselves consist of numbers 0-9.\n2. Output Grid Size: The output grid has the same dimensions as the input grid.\n3. Transformation: For each 2x2 block in the input grid:\n    a. Copy the original 2x2 block to the output grid at the same location.\n    b. Below each 2x2 block, add a block of 3 (green) numbers.\n    c. Determine the dimensions of the green block based on the numbers present in the original 2x2 block:\n        i. If the original 2x2 block contains the number 4 (yellow) AND the number 8 (cyan), create a 2x3 block of 3 (green) numbers directly below the original 2x2 block.\n        ii. Else if the original 2x2 block contains the number 4 (yellow) but not the number 8 (cyan), create a 2x4 block of 3 (green) numbers directly below the original 2x2 block.\n        iii. Else create a 2x2 block of 3 (green) numbers directly below the original 2x2 block.\n4. The newly created 3 (green) blocks will replace the original 0 (black) background.",
    "feca6190.json": "1. Find the input grid, which is a 5x1 grid containing values 0-9.\n2. Count the number of non-zero values in the input grid. This number will be referred to as N.\n3. Determine the output grid size: both width and height are equal to N * 5.\n4. Create an empty output grid of size (N * 5) x (N * 5), filled with 0s.\n5. Iterate from R = 0 to N - 1, representing the row offset.\n6. Iterate from C = 0 to 4, representing the column of the input grid.\n7. If the value at input grid (0, C) is not 0, then copy the input grid pattern. Row offset is equal to R.\n8. For each non-zero pixel value at input grid (0, C), set the corresponding pixel in the output grid:\n   - Output grid row: (N * 5) - 5 - R +0, the row index is (N*5) - (5+R) always\n   - Output grid column: (C + R)*5, the column index is (C+R)*5 always\n   - Output grid value: the value from the input grid at (0, C).\n   - Assign outputGrid[(N * 5) - 5 - R][(C + R)*5] = inputValue(0, C)",
    "ff28f65a.json": "1. Find all 2x2 subgrids within the input grid where every cell has a value of 2 (red). \n2. Count the number of such 2x2 red subgrids. Let this count be 'N'.\n3. Create a new 5x5 grid filled with 0s (black).\n4. Starting from the top-left corner (0, 0) of the output grid, fill N cells with the value 1 (blue), alternating positions. \n5. Fill the cells in the following order: (0, 0), (0, 2), (0, 4), (2, 0), (2, 2), (2, 4), (4, 0), (4, 2), (4, 4), (1, 1), (1, 3), (3, 1), (3, 3). If N exceeds the available positions, stop after filling the last available position.\n6. Any remaining cells in the 5x5 grid retain their initial value of 0 (black).",
    "ff805c23.json": "1. Find the square block of color 1 in the input grid. Let its dimensions be N x N.\n2. Create an output grid of size N x N.\n3. Determine the top-left coordinates (R, C) of the color 1 square within the input grid.\n4. Extract the N x N region from the input grid that is located at the same coordinates (R, C) where the color 1 square is positioned. Note: Exclude the color 1 square itself; extract the underlying pattern.\n5. Copy the extracted N x N region to the output grid."
}