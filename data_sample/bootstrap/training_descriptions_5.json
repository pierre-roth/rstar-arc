{
    "794b24be.json": "1. Let G be the input grid of size 3×3. Use zero-based indices: rows 0–2 from top, columns 0–2 from left.\n2. Compute N = number of cells in G with value 1.\n3. Create an output grid O of size 3×3, and set all cells to 0.\n4. For each integer k from 1 to N:\n   a. If k ≤ 3: set O[0, k−1] = 2.\n   b. Else if k = 4: set O[1, 1] = 2.\n5. Return O as the transformed grid.",
    "22eb0ac0.json": "1. Let H = number of rows in the input grid and W = number of columns in the input grid.  \n2. For each row index r from 0 to H-1 do:  \n   a. Let v_left = grid[r][0] and v_right = grid[r][W-1].  \n   b. If v_left != 0 and v_left == v_right then:  \n      i. For each column index c from 0 to W-1 set grid[r][c] = v_left.  \n3. Return the modified grid as the output.",
    "7b6016b9.json": "1. Let H = number of rows and W = number of columns in the input grid.\n2. Determine boundary_value = the unique non-zero integer present in the input grid.\n3. Initialize output_grid as an exact copy of the input grid.\n4. Create a boolean matrix visited of size H×W, initialized to false.\n5. Define a recursive procedure flood_fill_outside(r, c):\n   a. Mark visited[r][c] = true.\n   b. Set output_grid[r][c] = 3.\n   c. For each 4-neighbor (r+dr, c+dc) with (dr,dc) in {(-1,0),(1,0),(0,-1),(0,1)}:\n      i. If (r+dr, c+dc) is within grid bounds, input_grid[r+dr][c+dc] == 0, and visited[r+dr][c+dc] == false, then call flood_fill_outside(r+dr, c+dc).\n6. For each cell on the grid border (r=0, r=H-1 for c=0..W-1; c=0, c=W-1 for r=0..H-1), if input_grid[r][c] == 0 and visited[r][c] == false, call flood_fill_outside(r, c).\n7. Iterate over all cells (r, c): if input_grid[r][c] == 0 and visited[r][c] == false, set output_grid[r][c] = 2.\n8. Leave all cells with value boundary_value unchanged in output_grid.\n9. Return output_grid.",
    "7b7f7511.json": "1. Compute H = number of rows and W = number of columns in the input grid. 2. If W > H then:\n  a. Set halfW = W / 2.\n  b. Create an output grid of size H × halfW.\n  c. For each row r in 0..H-1 and each column c in 0..halfW-1, set output[r][c] = input[r][c].\n3. Otherwise (H > W):\n  a. Set halfH = H / 2.\n  b. Create an output grid of size halfH × W.\n  c. For each row r in 0..halfH-1 and each column c in 0..W-1, set output[r][c] = input[r][c].\n4. Return the output grid.",
    "834ec97d.json": "1. Let input be a 2D grid of integers; let H be its height and W its width.\n2. Locate the single nonzero pixel in the input. Let its row be r and its column be c, and let its value be V.\n3. Initialize the output grid as a copy of the input grid.\n4. Define background value B=0 and stripe value S=4.\n5. Remove the original pixel: set output[r][c]=B.\n6. Move the pixel down by one row: set output[r+1][c]=V.\n7. Compute parity P = c mod 2.\n8. For each row y from 0 to r inclusive:\n   a. For each column x from 0 to W-1:\n      i. If x mod 2 == P then set output[y][x] = S; else set output[y][x] = B.\n9. Leave all other cells unchanged.",
    "1cf80156.json": "1. Let G be the input 2D integer grid with row indices 0..M-1 and column indices 0..N-1.\n2. Identify the set P of all coordinates (r,c) such that G[r][c] != 0 (non-zero pixels).\n3. Compute r_min = min_r over P, r_max = max_r over P, c_min = min_c over P, c_max = max_c over P.\n4. Compute H = r_max - r_min + 1 and W = c_max - c_min + 1.\n5. Initialize an output grid O with H rows and W columns.\n6. For each i in 0..H-1 and j in 0..W-1, set O[i][j] = G[r_min + i][c_min + j].\n7. Return O.",
    "8403a5d5.json": "1. Use zero-based indexing for rows (0…H-1) and columns (0…W-1).\n2. Let H = number of rows, W = number of columns of the input grid.\n3. Scan the input grid to find the unique nonzero cell at (r0, c0). Let C = input[r0][c0].\n4. Initialize the output grid as a copy of the input grid (all other cells are zero).\n5. For each column c from c0 to W-1 inclusive:\n   a. If (c - c0) mod 2 = 0, then for each row r from 0 to H-1 set output[r][c] = C.\n   b. Else (i.e. (c - c0) mod 2 = 1), compute k = (c - c0 - 1) // 2. If k mod 2 = 0 set output[0][c] = 5; otherwise set output[H-1][c] = 5. Leave all other cells in column c at 0.\n6. Return the output grid.",
    "7fe24cdd.json": "1. Read the input grid of size 3×3. 2. Initialize an empty output grid of size 6×6. 3. For each input cell at row r and column c (0 ≤ r,c ≤ 2):\n   a. Let v = input[r][c].\n   b. Set output[r][c] = v.       (top-left quadrant, 0° rotation)\n   c. Set output[c][5 - r] = v.   (top-right quadrant, 90° clockwise)\n   d. Set output[5 - r][5 - c] = v. (bottom-right quadrant, 180° rotation)\n   e. Set output[5 - c][r] = v.   (bottom-left quadrant, 270° clockwise)\n4. Return the output grid.",
    "2281f1f4.json": "1. Determine H = number of rows and W = number of columns of the input grid.\n2. Compute last_col = W - 1.\n3. Build list vertical_cols: for each column index c in 0..W-1, if grid[0][c] == 5 then append c to vertical_cols.\n4. Build list horizontal_rows: for each row index r in 0..H-1, if grid[r][last_col] == 5 then append r to horizontal_rows.\n5. For each r in horizontal_rows: for each c in vertical_cols: if grid[r][c] == 0 then set grid[r][c] = 2.\n6. Return the modified grid with the same dimensions as input.",
    "85c4e7cd.json": "1. Let N be the number of rows (and columns) of the input grid; row and column indices run from 0 to N-1.\n2. Compute L = (N + 1) // 2 (the number of concentric layers).\n3. Initialize an array original_colors of length L.\n4. For each layer index i from 0 to L-1:\n   a. Read original_colors[i] = grid[i][i].\n5. For each layer index i from 0 to L-1:\n   a. Let new_color = original_colors[L - 1 - i].\n   b. For each column c from i to N - 1 - i:\n      i. Set grid[i][c] = new_color.\n      ii. Set grid[N - 1 - i][c] = new_color.\n   c. For each row r from i to N - 1 - i:\n      i. Set grid[r][i] = new_color.\n      ii. Set grid[r][N - 1 - i] = new_color.\n6. Return the modified grid.",
    "1f642eb9.json": "1. Let grid be the input 10×10 matrix of integers and keep its dimensions unchanged.\n2. Find all coordinates (r,c) where grid[r][c] == 8. Compute:\n   • row_min = minimum r\n   • row_max = maximum r\n   • col_min = minimum c\n   • col_max = maximum c\n3. For each coordinate (r,c) in the grid where grid[r][c] != 0 and grid[r][c] != 8, do:\n   a. Let v = grid[r][c].\n   b. If col_min ≤ c ≤ col_max and r < row_min, then set grid[row_min][c] = v.\n   c. Else if col_min ≤ c ≤ col_max and r > row_max, then set grid[row_max][c] = v.\n   d. Else if row_min ≤ r ≤ row_max and c < col_min, then set grid[r][col_min] = v.\n   e. Else if row_min ≤ r ≤ row_max and c > col_max, then set grid[r][col_max] = v.\n4. Leave all other cells unchanged and return the modified grid.",
    "1e0a9b12.json": "1. Let R be the number of rows and C be the number of columns in the input grid.\n2. Initialize an output grid of size R by C with all values set to 0.\n3. For each column index c from 0 to C-1:\n   a. Initialize an empty list L.\n   b. For each row index r from 0 to R-1:\n      i. Let v = input[r][c]; if v != 0 then append v to L.\n   c. Let k be the length of L.\n   d. For j from 0 to k-1:\n      i. Set output[R-k+j][c] = L[j].\n4. Return the output grid.",
    "1bfc4729.json": "1. Initialize a 10x10 output grid filled with 0.\n2. Identify the two non-zero marker pixels:\n   - For each cell (i,j) in the input grid if input[i][j] != 0 then:\n     - If i < 5 assign color1 = input[i][j].\n     - Else assign color2 = input[i][j].\n3. For each row i from 0 to 4 inclusive:\n   - If i == 0 or i == 2 then for each column j from 0 to 9 set output[i][j] = color1.\n   - Otherwise set output[i][0] = color1 and output[i][9] = color1.\n4. For each row i from 5 to 9 inclusive:\n   - Let r = i - 5.\n   - If r == 2 or r == 4 then for each column j from 0 to 9 set output[i][j] = color2.\n   - Otherwise set output[i][0] = color2 and output[i][9] = color2.\n5. Return the output grid.",
    "1f876c06.json": "1. Interpret input as a 2D array G of size H rows by W columns with 0-based indices (rows 0 to H-1, columns 0 to W-1).\n2. Create O as a deep copy of G.\n3. For each integer v > 0 present in G, gather all coordinates (r, c) such that G[r][c] == v into a list P_v.\n4. For each v where P_v has length 2: let P_v = [(r1, c1), (r2, c2)]. Compute dr = 1 if r2 > r1 else -1; compute dc = 1 if c2 > c1 else -1; compute steps = abs(r2 - r1) (assert abs(c2 - c1) == steps).\n5. For k from 0 to steps inclusive: set O[r1 + k * dr][c1 + k * dc] = v.\n6. Return O as the output grid.",
    "7ddcd7ec.json": "1. Let H be the number of rows and W be the number of columns of the input grid.\n2. Identify the unique non-zero integer C present in the grid.\n3. Collect the set P of all coordinates (i,j) where grid[i][j] == C.\n4. Partition P into 4-connected components, where two coordinates are adjacent if they differ by exactly 1 in row or exactly 1 in column.\n5. Let S be the component with size >1 (the filled square). Let E be the set of coordinates in P that are not in S (the extension pixels).\n6. For each extension pixel p in E:\n   a. Let (ip,jp) be the coordinates of p.\n   b. Find the unique corner coordinate q = (iq,jq) in S such that |ip - iq| == 1 and |jp - jq| == 1.\n   c. Compute the direction (dr,dc) = (ip - iq, jp - jq).\n   d. Initialize (i,j) = (ip,jp).\n   e. Loop:\n      i. Compute (i_next,j_next) = (i + dr, j + dc).\n      ii. If i_next < 0 or i_next >= H or j_next < 0 or j_next >= W, break the loop.\n      iii. Set grid[i_next][j_next] = C.\n      iv. Set (i,j) = (i_next,j_next).\n7. Output the modified grid.",
    "1fad071e.json": "1. Read the input grid as a 2D array input_grid with H rows and W columns.\n2. Initialize integer count = 0.\n3. For each row index r from 0 to H-2 and each column index c from 0 to W-2:\n   - If input_grid[r][c] == 1 AND input_grid[r][c+1] == 1 AND input_grid[r+1][c] == 1 AND input_grid[r+1][c+1] == 1, then increment count by 1.\n4. Create an output_grid of size 1 row and 5 columns, and set every cell to 0.\n5. For each integer i from 0 to count-1, set output_grid[0][i] = 1.\n6. Return output_grid.",
    "22168020.json": "1. Copy the input grid to an output grid of identical size.\n2. For each row r in the output grid:\n   a. Determine the set of distinct non-zero values present in that row.\n   b. For each value v in this set:\n      i. Let min_c be the smallest column index where output[r][min_c] == v.\n      ii. Let max_c be the largest column index where output[r][max_c] == v.\n      iii. For each column c from min_c to max_c inclusive, assign output[r][c] = v.\n3. Return the output grid.",
    "23581191.json": "1. Let H = number of rows and W = number of columns in the input grid.\n2. Scan the input grid to locate all cells (r,c) where input[r][c] != 0. There will be exactly two such cells. Label the first as (r1,c1) with value v1 = input[r1][c1], and the second as (r2,c2) with value v2 = input[r2][c2].\n3. Initialize an output grid of size H×W filled with 0.\n4. For each row index r from 0 to H–1:\n   a. Set output[r][c1] = v1.\n   b. Set output[r][c2] = v2.\n5. For each column index c from 0 to W–1:\n   a. Set output[r1][c] = v1.\n   b. Set output[r2][c] = v2.\n6. Set output[r1][c2] = 2.\n7. Set output[r2][c1] = 2.\n8. Return the output grid.",
    "25d8a9c8.json": "1. Let H be the number of rows and W the number of columns in the input grid.\n2. Initialize an output grid of size H×W.\n3. For each row index r from 0 to H-1:\n   3.1 Set uniform = true.\n   3.2 For each column index c from 1 to W-1:\n       If input[r][c] ≠ input[r][0], set uniform = false and break the loop.\n   3.3 If uniform is true, set fill_value = 5; otherwise set fill_value = 0.\n   3.4 For each column index c from 0 to W-1, set output[r][c] = fill_value.\n4. Return the output grid.",
    "810b9b61.json": "1. Let H be the number of rows and W be the number of columns of the input grid G.\n2. Initialize an output grid O of size H×W as a copy of G.\n3. Initialize a boolean array visited[H][W] to false.\n4. For each cell (r,c) with r in [0..H-1], c in [0..W-1]:\n   a. If G[r][c]≠1 or visited[r][c] is true, continue to next cell.\n   b. Perform a 4-connected flood fill from (r,c) to collect all cells in this component C; mark each visited.\n   c. Compute r_min = min{r_i | (r_i,c_i)∈C}, r_max = max{r_i | (r_i,c_i)∈C},\n      c_min = min{c_i | (r_i,c_i)∈C}, c_max = max{c_i | (r_i,c_i)∈C}.\n   d. Let height = r_max – r_min + 1, width = c_max – c_min + 1.\n   e. If height < 3 or width < 3, continue to next component.\n   f. Let expected_outline = 2*height + 2*width – 4.\n   g. If |C| ≠ expected_outline, continue.\n   h. If every (r_i,c_i)∈C satisfies (r_i==r_min or r_i==r_max or c_i==c_min or c_i==c_max), then:\n      for each (r_i,c_i)∈C set O[r_i][c_i] = 3.\n5. Return O.",
    "2204b7a8.json": "1. Let H = number of rows, W = number of columns.\n2. Detect stripe orientation:\n   If for every r in 0..H-1 grid[r][0] > 0 and grid[r][0] == grid[0][0], and for every r grid[r][W-1] > 0 and grid[r][W-1] == grid[0][W-1], and grid[0][0] != grid[0][W-1], then:\n     orientation = vertical\n     left_color = grid[0][0], right_color = grid[0][W-1]\n     left_column = 0, right_column = W-1\n   Otherwise:\n     orientation = horizontal\n     top_color = grid[0][0], bottom_color = grid[H-1][0]\n     top_row = 0, bottom_row = H-1\n3. Identify object_color as the unique value v > 0 such that v != stripe colors (left_color/right_color or top_color/bottom_color).\n4. Initialize output grid as a copy of input.\n5. For each cell (r,c) with 0 ≤ r < H and 0 ≤ c < W:\n   If input[r][c] == object_color then:\n     If orientation == vertical:\n       Let d_left = c - left_column, d_right = right_column - c.\n       If d_left ≤ d_right then set output[r][c] = left_color else set output[r][c] = right_color.\n     Else (orientation == horizontal):\n       Let d_top = r - top_row, d_bottom = bottom_row - r.\n       If d_top ≤ d_bottom then set output[r][c] = top_color else set output[r][c] = bottom_color.\n6. Return the output grid.",
    "1caeab9d.json": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Initialize an empty map shape_pixels.\n3. For each cell (r,c) in the input grid:\n   a. If grid[r][c] ≠ 0, append coordinate (r,c) to shape_pixels[ v ] where v = grid[r][c].\n4. Set reference_value = 1.\n5. Compute ref_top = minimum r among all (r,c) in shape_pixels[ reference_value ].\n6. For each shape value v in shape_pixels:\n   a. Compute top_v = minimum r among all (r,c) in shape_pixels[v].\n   b. Compute offset_v = ref_top − top_v.\n7. Create an output grid of size H×W and fill all cells with 0.\n8. For each shape value v in shape_pixels and for each (r,c) in shape_pixels[v]:\n   a. Compute new_r = r + offset_v.\n   b. Set output[new_r][c] = v.\n9. Return the output grid.",
    "1f85a75f.json": "1. Let H be the number of rows and W be the number of columns in the input grid. 2. Compute background_value as the pixel value that appears most frequently in the grid. 3. Initialize visited as an empty set; best_cells as an empty list; best_size as 0. 4. For each cell (r,c) with 0 ≤ r < H and 0 ≤ c < W: if input[r][c] ≠ background_value and (r,c) not in visited, then:\n   a. Set value = input[r][c]; initialize queue = [(r,c)]; current_cells = []\n   b. While queue is not empty: pop (rr,cc); if (rr,cc) not in visited and input[rr][cc] == value, then add (rr,cc) to visited and current_cells, and enqueue each 4-adjacent neighbor (rr-1,cc), (rr+1,cc), (rr,cc-1), (rr,cc+1) that lies within [0..H-1]×[0..W-1].\n   c. If len(current_cells) > best_size, set best_cells = current_cells and best_size = len(current_cells).\n5. Compute min_row = min(r for (r,c) in best_cells), max_row = max(r for (r,c) in best_cells), min_col = min(c for (r,c) in best_cells), max_col = max(c for (r,c) in best_cells). 6. Create output grid of size (max_row - min_row + 1) rows and (max_col - min_col + 1) columns. 7. For each i from 0 to max_row - min_row and each j from 0 to max_col - min_col, set output[i][j] = input[min_row + i][min_col + j]. 8. Return the output grid.",
    "8be77c9e.json": "1. Let H = number of rows in the input grid and W = number of columns.\n2. Create an output grid of size (2*H) rows and W columns.\n3. For each row r from 0 to H-1 and each column c from 0 to W-1:\n   a. Let v = input[r][c].\n   b. Set output[r][c] = v.\n   c. Set output[(2*H - 1) - r][c] = v.\n4. Return the output grid.",
    "25ff71a9.json": "1. Determine H = number of rows and W = number of columns of the input grid.\n2. Initialize an output grid of dimensions H by W with every cell set to 0.\n3. For each row index r from 0 to H-2 and each column index c from 0 to W-1:\n   If input[r][c] != 0 then set output[r+1][c] = input[r][c].\n4. Return the output grid.",
    "855e0971.json": "1. Let output be a copy of the input grid.\n2. Identify each distinct non‐zero value v present in the input.\n3. For each such v:\n   a. Compute min_row = minimum row index r where input[r][c] == v.\n   b. Compute max_row = maximum row index r where input[r][c] == v.\n   c. Compute min_col = minimum column index c where input[r][c] == v.\n   d. Compute max_col = maximum column index c where input[r][c] == v.\n   e. Let height = max_row - min_row + 1 and width = max_col - min_col + 1.\n   f. If height < width then set orientation_v = “vertical” else set orientation_v = “horizontal”.\n4. For each zero pixel at (r, c) in the input:\n   a. Find the unique v whose bounding box [min_row..max_row]×[min_col..max_col] contains (r, c).\n   b. If orientation_v == “vertical” then for r0 from min_row to max_row set output[r0][c] = 0.\n   c. If orientation_v == “horizontal” then for c0 from min_col to max_col set output[r][c0] = 0.\n5. Return output.",
    "88a62173.json": "1. Let R be number of rows and C be number of columns of the input grid. 2. Compute midRow = floor(R/2) and midCol = floor(C/2). 3. Extract four subgrids each of size midRow by midCol: TL from rows 0..midRow-1 and cols 0..midCol-1; TR from rows 0..midRow-1 and cols midCol+1..C-1; BL from rows midRow+1..R-1 and cols 0..midCol-1; BR from rows midRow+1..R-1 and cols midCol+1..C-1. 4. Compare the four subgrids by elementwise equality and identify the one whose pattern occurs exactly once. 5. Return that unique subgrid as the output grid.",
    "253bf280.json": "1. Let A be the input grid of size H×W. Create an output grid O by copying A. 2. For each row index r from 0 to H−1:  a. Let C = sorted list of all column indices c where A[r][c] == 8.  b. If |C| ≥ 2 then let c_min = C[0], c_max = C[last].  c. For each c in the range c_min+1 to c_max−1: if O[r][c] == 0 then set O[r][c] = 3. 3. For each column index c from 0 to W−1:  a. Let R = sorted list of all row indices r where A[r][c] == 8.  b. If |R| ≥ 2 then let r_min = R[0], r_max = R[last].  c. For each r in the range r_min+1 to r_max−1: if O[r][c] == 0 then set O[r][c] = 3. 4. Return O as the transformed grid.",
    "82819916.json": "1. Compute H = number of rows and W = number of columns.\n2. Find the row index r_full such that for all c in 0..W-1, grid[r_full][c] != 0.\n3. Set A_full = grid[r_full][0]. Scan c from 1..W-1 to find the first c1 where grid[r_full][c1] != A_full; set I_full = grid[r_full][c1].\n4. For each row i from 0..H-1:\n   If the count of non-zero cells in row i is > 0 and < W then:\n     a. Scan c from 0..W-1 to find the first grid[i][c] != 0; set A_line = grid[i][c].\n     b. Continue scanning c from 0..W-1 to find the first grid[i][c] != 0 and != A_line; set I_line = grid[i][c].\n     c. For each column c from 0..W-1:\n        If grid[r_full][c] == A_full then set grid[i][c] = A_line else set grid[i][c] = I_line.\n5. Return the modified grid.",
    "7c008303.json": "1. Locate the divider row and column:\n   1.1. Find R in [0..8] such that for all j in [0..8], grid[R][j]==8.\n   1.2. Find C in [0..8] such that for all i in [0..8], grid[i][C]==8.\n2. Compute quadrant dimensions:\n   2.1. hTop = R; hBot = 8 - R\n   2.2. wLeft = C; wRight = 8 - C\n3. Identify the 2x2 color region A:\n   3.1. If hTop==2 and wLeft==2 then set rA=0, cA=0\n   3.2. Else if hTop==2 and wRight==2 then set rA=0, cA=C+1\n   3.3. Else if hBot==2 and wLeft==2 then set rA=R+1, cA=0\n   3.4. Else if hBot==2 and wRight==2 then set rA=R+1, cA=C+1\n   3.5. Read four colors:\n        colorA00 = grid[rA][cA]\n        colorA01 = grid[rA][cA+1]\n        colorA10 = grid[rA+1][cA]\n        colorA11 = grid[rA+1][cA+1]\n4. Identify the 6x6 pattern region B:\n   4.1. If hTop==6 and wLeft==6 then set rB=0,   cB=0\n   4.2. Else if hTop==6 and wRight==6 then set rB=0,   cB=C+1\n   4.3. Else if hBot==6 and wLeft==6 then set rB=R+1, cB=0\n   4.4. Else if hBot==6 and wRight==6 then set rB=R+1, cB=C+1\n5. Initialize outputGrid as a 6×6 array of zeros.\n6. For each i in 0..5 and j in 0..5:\n   6.1. If grid[rB+i][cB+j] != 0 then:\n        a. If i<3 and j<3 set col=colorA00\n        b. Else if i<3 and j>=3 set col=colorA01\n        c. Else if i>=3 and j<3 set col=colorA10\n        d. Else set col=colorA11\n        e. Set outputGrid[i][j] = col\n   6.2. Else leave outputGrid[i][j] = 0\n7. Return outputGrid (6×6).",
    "1e32b0e9.json": "1. Let N = number of rows in input (equal to number of columns).\n2. Let blank_color = input[0][0].\n3. Determine block_size: scan row 0 from column c=1 to N-1; let block_size be the first c for which input[0][c] != blank_color.\n4. Let grid_color = input[0][block_size].\n5. Let block_pitch = block_size + 1.\n6. Let num_blocks = (N + 1) / block_pitch (will be 3).\n7. Identify shape_color: in the top-left block region rows [0..block_size-1] and cols [0..block_size-1], find the unique value v != blank_color and != grid_color; set shape_color = v.\n8. Build shape_mask: all relative coordinates (r,c) with 0 ≤ r < block_size, 0 ≤ c < block_size such that input[r][c] == shape_color.\n9. Initialize output = a copy of input.\n10. For each block_row in 0..num_blocks-1 and block_col in 0..num_blocks-1:\n    a. Let origin_r = block_row * block_pitch, origin_c = block_col * block_pitch.\n    b. For each (dr,dc) in shape_mask:\n       i. Let r = origin_r + dr, c = origin_c + dc.\n       ii. If input[r][c] == shape_color, set output[r][c] = shape_color.\n       iii. Else if input[r][c] == blank_color, set output[r][c] = grid_color.\n11. Return output.",
    "1c786137.json": "1. Use 0-based indexing: grid[r][c] refers to row r, column c.\n2. Identify border color B:\n  a. For each distinct pixel value v in the input grid, collect all coordinates (r,c) where grid[r][c] == v into set S_v.\n  b. Compute r_min = min(r), r_max = max(r), c_min = min(c), c_max = max(c) over all (r,c) in S_v.\n  c. If every cell on the rectangle perimeter defined by rows r_min and r_max for all c in [c_min..c_max], and columns c_min and c_max for all r in [r_min..r_max], has value v, and no cell with r_min < r < r_max and c_min < c < c_max has value v, then set B = v and stop.\n3. Let r1 = r_min, r2 = r_max, c1 = c_min, c2 = c_max.\n4. Compute H_out = r2 - r1 - 1 and W_out = c2 - c1 - 1.\n5. Initialize an output grid of size H_out rows by W_out columns.\n6. For each i in 0..H_out-1 and each j in 0..W_out-1, set output[i][j] = input[r1 + 1 + i][c1 + 1 + j].\n7. Return the output grid.",
    "28bf18c6.json": "1. Scan the input grid to find all coordinates (r,c) where input[r][c] != 0. 2. Let r_min = minimum r, r_max = maximum r, c_min = minimum c, c_max = maximum c over those coordinates. 3. Compute H = r_max - r_min + 1 and W = c_max - c_min + 1. 4. Create an output grid of size H rows and 2*W columns, initialized with 0. 5. For each dr from 0 to H-1 and each dc from 0 to W-1:\n   a. Let v = input[r_min + dr][c_min + dc].\n   b. Set output[dr][dc] = v.\n   c. Set output[dr][dc + W] = v.\n6. Return the output grid.",
    "868de0fa.json": "1. Let H and W be the number of rows and columns of the input grid.  Index rows by r=0..H-1 and columns by c=0..W-1.  2. Initialize an empty list of square-border components.  3. For each cell (r,c) with value 1 not yet visited:  \n   a. Perform a 4-connected flood-fill to collect all cells of this component.  Mark them visited.  \n   b. Compute r_min = minimum r, r_max = maximum r, c_min = minimum c, c_max = maximum c over the component.  \n   c. Compute height = r_max − r_min + 1 and width = c_max − c_min + 1.  If height ≠ width, skip this component.  Otherwise let s = height (the side length).  \n   d. Verify that for every cell (r',c') in the bounding box [r_min..r_max]×[c_min..c_max]:  if r'=r_min or r'=r_max or c'=c_min or c'=c_max then grid[r'][c'] must equal 1, else grid[r'][c'] must equal 0.  If this fails, skip.  \n   e. Otherwise append (r_min,r_max,c_min,c_max,s) to the list of square borders.  \n4. For each recorded square border (r_min,r_max,c_min,c_max,s):  \n   a. If s<3, continue.  \n   b. If s mod 2 == 0 set fill = 2 else set fill = 7.  \n   c. For r from r_min+1 to r_max-1 and c from c_min+1 to c_max-1 set grid[r][c] = fill.  \n5. Return the modified grid as the output.",
    "2013d3e2.json": "1. Identify all coordinates (r, c) in the input grid where input[r][c] != 0.\n2. Compute r_min = minimum r and r_max = maximum r among these coordinates; compute c_min = minimum c and c_max = maximum c.\n3. Compute height = r_max - r_min + 1 and width = c_max - c_min + 1.\n4. Create a 2D array block of size height×width and for each i in 0..height-1 and j in 0..width-1 assign block[i][j] = input[r_min + i][c_min + j].\n5. Create a 2D array rot of size width×height and for each i in 0..height-1 and j in 0..width-1 assign rot[j][height - 1 - i] = block[i][j].\n6. Let rows_rot = width and cols_rot = height.\n7. Compute out_rows = rows_rot / 2 and out_cols = cols_rot / 2 (width and height are always even in these tasks).\n8. Create the output grid of size out_rows×out_cols and for each i in 0..out_rows-1 and j in 0..out_cols-1 assign output[i][j] = rot[i][j].\n9. Return the output grid.",
    "83302e8f.json": "1. Let H = number of rows and W = number of columns in the input grid. 2. Identify grid_color as the non-zero value that appears most frequently in the grid. 3. Compute row_lines = sorted list of all row indices r where the count of pixels equal to grid_color in row r is greater than W/2. 4. Compute col_lines = sorted list of all column indices c where the count of pixels equal to grid_color in column c is greater than H/2. 5. Define row_bounds = [-1] + row_lines + [H] and col_bounds = [-1] + col_lines + [W]. 6. For each k from 0 to len(row_bounds)-2 and each l from 0 to len(col_bounds)-2:    a. Let r0 = row_bounds[k], r1 = row_bounds[k+1], c0 = col_bounds[l], c1 = col_bounds[l+1].    b. If r1 - r0 <= 1 or c1 - c0 <= 1, skip to next.    c. Let interior_rows = all r in r0+1..r1-1 and interior_cols = all c in c0+1..c1-1.    d. Set top_ok = true if r0<0 or r0 not in row_lines; otherwise top_ok = true if for all c in interior_cols, input[r0][c] == grid_color.    e. Set bottom_ok = true if r1>=H or r1 not in row_lines; otherwise bottom_ok = true if for all c in interior_cols, input[r1][c] == grid_color.    f. Set left_ok = true if c0<0 or c0 not in col_lines; otherwise left_ok = true if for all r in interior_rows, input[r][c0] == grid_color.    g. Set right_ok = true if c1>=W or c1 not in col_lines; otherwise right_ok = true if for all r in interior_rows, input[r][c1] == grid_color.    h. Let fill_color = 3 if top_ok and bottom_ok and left_ok and right_ok; else fill_color = 4.    i. For each r in interior_rows and c in interior_cols set output[r][c] = fill_color. 7. For all other positions set output[r][c] = input[r][c].",
    "228f6490.json": "1. Let grid be the input 2D array of integers with values 0–9.\n2. Find all grey components: for each unvisited cell (r,c) with grid[r][c]==5, perform a flood‐fill using 4‐adjacency (up/down/left/right) to collect all coordinates in that component G.\n3. For each grey component G:\n   a. Compute minR = minimum row of G, maxR = maximum row of G, minC = minimum column of G, maxC = maximum column of G.\n   b. Compute holeCells = {(r,c) | minR<r<maxR and minC<c<maxC and grid[r][c]==0}.\n   c. Compute holeOffsets: let baseH_R = min r in holeCells, baseH_C = min c in holeCells; holeOffsets = {(r–baseH_R, c–baseH_C) for each (r,c) in holeCells}.\n4. Find all colored components: for each unvisited cell (r,c) with grid[r][c]!=0 and grid[r][c]!=5, flood‐fill using 4‐adjacency to collect its component S and let C = grid[r][c].\n   a. Compute minS_R = min row of S, minS_C = min col of S.\n   b. Compute shapeOffsets = {(r–minS_R, c–minS_C) for each (r,c) in S}.\n5. For each grey component G and its holeOffsets, find the unique colored component S whose shapeOffsets equals holeOffsets.\n   a. For each (r,c) in S set grid[r][c] = 0.\n   b. For each (r,c) in holeCells set grid[r][c] = C.\n6. Return the modified grid.",
    "7f4411dc.json": "1. Let R be the number of rows and C be the number of columns in the input grid. 2. Identify each distinct nonzero pixel value c in the input. 3. For each value c perform the following: 3.1. Find all connected components of cells equal to c using 4-neighbor adjacency. 3.2. For each component compute r_min = minimum row index, r_max = maximum row index, c_min = minimum column index, c_max = maximum column index of its cells. 3.3. If every cell in rows r_min..r_max and columns c_min..c_max equals c then set the selected rectangle for this component to that bounding box. Otherwise, find the axis-aligned subrectangle of maximum area composed entirely of c within that bounding box as follows: for each r1 from r_min to r_max and each r2 from r1 to r_max determine the set of column indices j in c_min..c_max such that for all r in r1..r2 grid[r][j] == c; within that set find each maximal contiguous interval [c1..c2] and compute area = (r2 - r1 + 1) * (c2 - c1 + 1); select the interval and row pair with maximum area and set the selected rectangle to rows r1..r2 and columns c1..c2. 4. Create an output grid of size R x C filled with 0. 5. For each selected rectangle of value c, fill its cells in the output grid with c. 6. Return the output grid.",
    "780d0b14.json": "1. Let G be the input grid of height H and width W. 2. Set background_value=0. 3. Identify all row indices r in [0,H-1] such that for every column c in [0,W-1], G[r][c]==background_value; sort into list R_sep. 4. Identify all column indices c in [0,W-1] such that for every row r in [0,H-1], G[r][c]==background_value; sort into list C_sep. 5. Build row segments: let R_bounds=[-1]+R_sep+[H]; for each k from 0 to len(R_bounds)-2, let r_start=R_bounds[k]+1 and r_end=R_bounds[k+1]-1; if r_start<=r_end then append (r_start,r_end) to R_segments. 6. Build column segments: let C_bounds=[-1]+C_sep+[W]; for each k from 0 to len(C_bounds)-2, let c_start=C_bounds[k]+1 and c_end=C_bounds[k+1]-1; if c_start<=c_end then append (c_start,c_end) to C_segments. 7. Create output grid O with dimensions len(R_segments) rows and len(C_segments) columns. For each i in [0..len(R_segments)-1] and j in [0..len(C_segments)-1]: let (r0,r1)=R_segments[i] and (c0,c1)=C_segments[j]; collect set S={G[r][c] | r0<=r<=r1, c0<=c<=c1, G[r][c]!=background_value}; assert |S|==1; let v be the sole element of S; set O[i][j]=v. 8. Return O.",
    "27a28665.json": "1. Parse the input as a 3×3 integer grid G with row and column indices 0..2.\n2. Determine v = the non-zero integer value present in G (all colored pixels share this value).\n3. If G[1][1] == 0 then return a new 1×1 grid [[1]].\n4. If G[0][1] == v AND G[1][0] == v AND G[1][2] == v AND G[2][1] == v then return [[6]].\n5. If G[0][0] == v AND G[0][2] == v AND G[2][0] == v AND G[2][2] == v then return [[2]].\n6. Otherwise return [[3]].",
    "29c11459.json": "1. Let H = number of rows and W = number of columns in the input grid.\n2. Compute mid = W // 2.\n3. For each row index r from 0 to H-1: If grid[r][0] != 0 and grid[r][W-1] != 0 and all grid[r][c] == 0 for c in 1..W-2, then:\n3.1 Let leftColor = grid[r][0] and rightColor = grid[r][W-1].\n3.2 For c from 0 to mid-1 set grid[r][c] = leftColor.\n3.3 Set grid[r][mid] = 5.\n3.4 For c from mid+1 to W-1 set grid[r][c] = rightColor.\n4. Return the modified grid.",
    "7e0986d6.json": "1. Let background_color = 0.\n2. Scan the input grid and count occurrences of each non-zero value. Define target_color as the non-zero integer with the highest count.\n3. Define the set of orthogonal neighbor offsets N = {(−1,0),(+1,0),(0,−1),(0,+1)}.\n4. Initialize an output grid of the same dimensions as the input.\n5. For each cell at coordinates (r,c):\n   a. Let v = input[r][c].\n   b. If v == target_color, then set output[r][c] = target_color and continue to the next cell.\n   c. If v == background_color, then set output[r][c] = background_color and continue.\n   d. (v is non-zero and not target_color) Compute neighbor_count = number of offsets (dr,dc) in N for which:\n        • (r+dr,c+dc) is inside grid bounds, and\n        • input[r+dr][c+dc] == target_color.\n   e. If neighbor_count >= 2, set output[r][c] = target_color; otherwise set output[r][c] = background_color.\n6. Return the output grid.",
    "272f95fa.json": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Find all row indices r where for every column c in 0..W−1, input[r][c] == 8. There will be exactly two; sort them ascending as r1 < r2.\n3. Find all column indices c where for every row r in 0..H−1, input[r][c] == 8. There will be exactly two; sort them ascending as c1 < c2.\n4. Define horizontal segments:\n   – H0 = rows 0..r1−1\n   – H1 = rows r1+1..r2−1\n   – H2 = rows r2+1..H−1\n5. Define vertical segments:\n   – V0 = columns 0..c1−1\n   – V1 = columns c1+1..c2−1\n   – V2 = columns c2+1..W−1\n6. Initialize the output grid as a copy of the input grid.\n7. For each row r in H0 and each column c in V1, set output[r][c] = 2.\n8. For each row r in H1 and each column c in V0, set output[r][c] = 4.\n9. For each row r in H1 and each column c in V1, set output[r][c] = 6.\n10. For each row r in H1 and each column c in V2, set output[r][c] = 3.\n11. For each row r in H2 and each column c in V1, set output[r][c] = 1.",
    "913fb3ed.json": "1. Let G be the input grid of size H×W, with rows indexed r=0..H-1 and columns indexed c=0..W-1. 2. Initialize output grid O as an exact copy of G. 3. Define surround mapping M: {3→6, 8→4, 2→1}. 4. For each cell (r,c):\n   a. If G[r][c] is a key in M, let s = M[G[r][c]].\n   b. For each (dr,dc) in {(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)}:\n      i. Let nr = r+dr, nc = c+dc.\n      ii. If 0 ≤ nr < H and 0 ≤ nc < W, set O[nr][nc] = s.\n5. Return O.",
    "77fdfe62.json": "1. Let H be number of rows and W be number of columns in input grid.\n2. Identify row_border_top = minimum r such that for every c in [0,W-1], grid[r][c] == 1. Identify row_border_bottom = maximum r with same property.\n3. Identify col_border_left = minimum c such that for every r in [0,H-1], grid[r][c] == 1. Identify col_border_right = maximum c with same property.\n4. Set interior_beg_row = row_border_top + 1, interior_end_row = row_border_bottom - 1, interior_beg_col = col_border_left + 1, interior_end_col = col_border_right - 1.\n5. Compute interior_height = interior_end_row - interior_beg_row + 1, interior_width = interior_end_col - interior_beg_col + 1.\n6. Compute mid_row = row_border_top + interior_height // 2, mid_col = col_border_left + interior_width // 2.\n7. Record corner values: c_tl = grid[0][0], c_tr = grid[0][W-1], c_bl = grid[H-1][0], c_br = grid[H-1][W-1].\n8. Initialize output grid of size interior_height x interior_width with all cells = 0.\n9. For each r in [interior_beg_row, interior_end_row] and each c in [interior_beg_col, interior_end_col]:\n   a. Let i = r - interior_beg_row and j = c - interior_beg_col.\n   b. If grid[r][c] == 8 then:\n      i. If r <= mid_row and c <= mid_col assign output[i][j] = c_tl.\n      ii. Else if r <= mid_row and c > mid_col assign output[i][j] = c_tr.\n      iii. Else if r > mid_row and c <= mid_col assign output[i][j] = c_bl.\n      iv. Else assign output[i][j] = c_br.\n10. Return the output grid.",
    "8e5a5113.json": "1. Let H = number of rows and W = number of columns in inputGrid.\n2. Identify all column indices c where for every row r from 0 to H-1, inputGrid[r][c] == 5. Sort these indices ascending as s1 < s2.\n3. Let B = s1; let start2 = s1 + 1; let start3 = s2 + 1.\n4. Initialize outputGrid as a copy of inputGrid.\n5. For each r from 0 to H-1 and each c from 0 to B-1:\n   a. Set outputGrid[r][start2 + c] = inputGrid[H - 1 - c][r]\n   b. Set outputGrid[r][start3 + c] = inputGrid[H - 1 - r][B - 1 - c]\n6. Return outputGrid.",
    "9172f3a0.json": "1. Let H = number of rows in the input grid and W = number of columns in the input grid (here H=3, W=3).\n2. Create an output grid with 3×H rows and 3×W columns (here 9×9).\n3. For each row index r from 0 to H−1:\n4.   For each column index c from 0 to W−1:\n5.     Let v = input[r][c].\n6.     For dr from 0 to 2:\n7.       For dc from 0 to 2:\n8.         Set output[3*r + dr][3*c + dc] = v.\n9. Return the output grid.",
    "23b5c85d.json": "1. Let G be the input grid with dimensions R rows and C columns. Use 0-based indices (r for rows, c for columns).  \n2. Define colors = the set of distinct values in G excluding 0.  \n3. For each color v in colors, compute count[v] = number of cells (r,c) such that G[r][c] == v.  \n4. Let p be the color with the smallest count[p] among all v in colors.  \n5. Compute min_r = minimum r such that G[r][c] == p for some c; max_r = maximum r such that G[r][c] == p.  \n6. Compute min_c = minimum c such that G[r][c] == p for some r; max_c = maximum c such that G[r][c] == p.  \n7. Define output grid H with height = max_r - min_r + 1 rows and width = max_c - min_c + 1 columns.  \n8. For each cell (i,j) in H set H[i][j] = p.  \n9. Return H as the result.",
    "2bcee788.json": "1. Read input grid of size H×W.  \n2. Identify all non-zero pixels. Group them into clusters by 4-connected adjacency among pixels of the same value. You will obtain exactly two clusters.  \n3. Label the cluster with the larger number of pixels as clusterA (colorA) and the other as clusterB (colorB).  \n4. Compute bounding boxes:  \n   • For clusterA: minR_A = minimum row, maxR_A = maximum row, minC_A = minimum column, maxC_A = maximum column.  \n   • For clusterB: minR_B, maxR_B, minC_B, maxC_B similarly.  \n5. Determine adjacency orientation and mirror axis:  \n   a. If maxC_A + 1 == minC_B and [minR_A,maxR_A] overlaps [minR_B,maxR_B], then orientation = horizontal and axisC = maxC_A + 0.5.  \n   b. Else if minC_A - 1 == maxC_B and rows overlap, then orientation = horizontal and axisC = minC_A - 0.5.  \n   c. Else if maxR_A + 1 == minR_B and [minC_A,maxC_A] overlaps [minC_B,maxC_B], then orientation = vertical and axisR = maxR_A + 0.5.  \n   d. Else if minR_A - 1 == maxR_B and columns overlap, then orientation = vertical and axisR = minR_A - 0.5.  \n6. Create output grid of size H×W filled with 3.  \n7. For each pixel (r,c) in clusterA: set output[r][c] = colorA.  \n8. For each pixel (r,c) in clusterA:  \n   a. If orientation is horizontal, compute mirrored column c' = int(2*axisC - c) and r' = r.  \n   b. If orientation is vertical, compute mirrored row r' = int(2*axisR - r) and c' = c.  \n   c. Set output[r'][c'] = colorA.  \n9. Return the output grid.",
    "8d510a79.json": "1. Copy the input grid to an output grid.\n2. Let H be the number of rows and W be the number of columns. Use zero-based row indices 0..H-1 and column indices 0..W-1.\n3. Find barrierRow: the unique row index r such that for all c in 0..W-1, inputGrid[r][c] == 5.\n4. For each cell (r,c) where inputGrid[r][c] == v and v is 1 or 2:\n   a. If r < barrierRow then:\n      i. If v == 1: for rr from 0 to r-1 inclusive, set outputGrid[rr][c] = 1.\n      ii. If v == 2: for rr from r+1 to barrierRow-1 inclusive, set outputGrid[rr][c] = 2.\n   b. If r > barrierRow then:\n      i. If v == 1: for rr from r+1 to H-1 inclusive, set outputGrid[rr][c] = 1.\n      ii. If v == 2: for rr from barrierRow+1 to r-1 inclusive, set outputGrid[rr][c] = 2.\n5. Return the output grid.",
    "2dc579da.json": "Use 0-based row and column indices: row 0 is top, column 0 is left.\n1. Let G = number of rows in the input grid. Assert the grid is square and G is odd.\n2. Compute mid = (G - 1) / 2. Set midRow = mid, midCol = mid.\n3. Define four quadrants of size mid x mid:\n   • TL (top-left): rows 0..midRow-1, columns 0..midCol-1\n   • TR (top-right): rows 0..midRow-1, columns midCol+1..G-1\n   • BL (bottom-left): rows midRow+1..G-1, columns 0..midCol-1\n   • BR (bottom-right): rows midRow+1..G-1, columns midCol+1..G-1\n4. For each quadrant Q in {TL, TR, BL, BR}:\n   a. Initialize an empty set S.\n   b. For each cell (r, c) in Q, add grid[r][c] to S.\n   c. If |S| > 1, designate Q as the anomalous quadrant and stop scanning.\n5. Let Q* be the anomalous quadrant identified in step 4.\n6. Construct the output grid by extracting, in the same row and column order, the subgrid grid[r][c] for all (r, c) in Q*.\n7. Return this mid x mid subgrid as the output.",
    "8f2ea7aa.json": "1. Partition input grid G (9×9) into nine 3×3 blocks by block indices br=floor(r/3) and bc=floor(c/3); each block (br,bc) covers rows br*3..br*3+2 and columns bc*3..bc*3+2. 2. Identify the source block: find the unique (b0_r,b0_c) such that any G[r][c] != 0 resides in block (b0_r,b0_c). 3. Extract pattern P: for i,j in {0,1,2}, set P[i][j] = G[b0_r*3 + i][b0_c*3 + j]. 4. Initialize H as a 9×9 grid of zeros. 5. For each i,j in {0,1,2}, if P[i][j] != 0 then replicate P into H at block (i,j): for dr,dc in {0,1,2}, set H[i*3 + dr][j*3 + dc] = P[dr][dc]. 6. Return H.",
    "890034e9.json": "1. Compute H = number of rows and W = number of columns. 2. Identify the original hollow rectangle border shape: for each value c from 1 to 9, find each connected component of cells equal to c and compute its bounding box min_row = r0, max_row = r1, min_col = c0, max_col = c1; if every cell on the perimeter of this box (cells with r = r0 or r = r1 and c0 ≤ c ≤ c1, or c = c0 or c = c1 and r0 ≤ r ≤ r1) equals c and every cell strictly inside (r0 < r < r1 and c0 < c < c1) equals 0, then record c_border = c, border_r0 = r0, border_r1 = r1, border_c0 = c0, border_c1 = c1. 3. Compute interior_height = border_r1 - border_r0 - 1 and interior_width = border_c1 - border_c0 - 1; set interior_row0 = border_r0 + 1 and interior_col0 = border_c0 + 1. 4. Search for a second zero block: for r from 0 to H - interior_height and c from 0 to W - interior_width, if (r != interior_row0 or c != interior_col0) and all cells in rows r..r+interior_height-1 and cols c..c+interior_width-1 equal 0, then set new_int_r0 = r and new_int_c0 = c and break loops. 5. Compute new border limits: new_border_r0 = new_int_r0 - 1, new_border_r1 = new_int_r0 + interior_height, new_border_c0 = new_int_c0 - 1, new_border_c1 = new_int_c0 + interior_width. 6. For each cell (r,c) on the perimeter of the rectangle defined by rows new_border_r0..new_border_r1 and cols new_border_c0..new_border_c1 (cells with r = new_border_r0 or r = new_border_r1 and new_border_c0 ≤ c ≤ new_border_c1, or c = new_border_c0 or c = new_border_c1 and new_border_r0 ≤ r ≤ new_border_r1), set grid[r][c] = c_border. 7. Return the modified grid.",
    "8d5021e8.json": "1. Let A be the input grid. Let H be its number of rows and W its number of columns.\n2. Define HFlip(X) as the horizontal mirror of grid X: HFlip(X)[r][c] = X[r][W-1-c] for r in [0..H-1], c in [0..W-1].\n3. Define VFlip(X) as the vertical mirror of grid X: VFlip(X)[r][c] = X[H-1-r][c] for r in [0..H-1], c in [0..W-1].\n4. Compute Ah = HFlip(A).\n5. Compute Av = VFlip(A).\n6. Compute Ahv = VFlip(Ah).\n7. Initialize output grid B with dimensions 3*H rows and 2*W columns.\n8. For each block row index I from 0 to 2:\n   a. If I is even, set Tile0 = Ahv and Tile1 = Av; otherwise set Tile0 = Ah and Tile1 = A.\n   b. For each block column index J in {0,1} and for each local row r in [0..H-1] and local column c in [0..W-1], assign:\n        B[I*H + r][J*W + c] = (J==0 ? Tile0[r][c] : Tile1[r][c]).\n9. Return B as the output grid.",
    "2dee498d.json": "1. Let H = number of rows and W = number of columns of the input grid.\n2. Compute the list of all positive divisors D of W such that D < W.\n3. Sort D in descending order.\n4. For each integer d in D:\n   a. Let k = W / d.\n   b. For j from 0 to k-1, extract subgrid pattern_j of size H by d consisting of columns [j*d..j*d+d-1] and rows [0..H-1].\n   c. Group the patterns by identical cell values and count each pattern's occurrences.\n   d. If any pattern has a count > 1, set selected_width = d and break the loop.\n5. Among the patterns at selected_width, select the pattern with the highest occurrence count. If there is a tie, choose the one with the smallest j (leftmost).\n6. Output that selected pattern as the result: a grid of size H rows and selected_width columns.",
    "8eb1be9a.json": "1. Let bg = inputGrid[0][0].\n2. Compute yMin = min{r | ∃c inputGrid[r][c] ≠ bg}.\n3. Compute yMax = max{r | ∃c inputGrid[r][c] ≠ bg}.\n4. Compute xMin = min{c | ∃r inputGrid[r][c] ≠ bg}.\n5. Compute xMax = max{c | ∃r inputGrid[r][c] ≠ bg}.\n6. Let H = yMax - yMin + 1 and W = xMax - xMin + 1.\n7. Build pattern P of size H×W: for i in 0..H-1 and j in 0..W-1 set P[i][j] = inputGrid[yMin + i][xMin + j].\n8. Create outputGrid with same dimensions as inputGrid.\n9. For each cell (r,c) in outputGrid:\n    a. Compute pr = ((r - yMin) mod H + H) mod H.\n    b. Compute pc = ((c - xMin) mod W + W) mod W.\n    c. Set outputGrid[r][c] = P[pr][pc].\n10. Return outputGrid.",
    "8e1813be.json": "1. Locate the filled square region of pixel value 5:\n   a. Collect all coordinates (r,c) where grid[r][c]==5.\n   b. Compute row_min = min(r), row_max = max(r), col_min = min(c), col_max = max(c).\n   c. Verify row_max - row_min == col_max - col_min; let N = row_max - row_min + 1.\n2. Identify all non-zero pixels outside this region (grid[r][c] != 0 and grid[r][c] != 5) and group them by pixel value C.\n3. For each group of color C:\n   a. Let rows_C = set of r values in the group; cols_C = set of c values in the group.\n   b. If |rows_C| == 1, classify stripe C as horizontal with key = the single value in rows_C.\n   c. Else if |cols_C| == 1, classify stripe C as vertical with key = the single value in cols_C.\n4. Determine stripe_orientation: if all stripes are horizontal, orientation = horizontal; otherwise orientation = vertical.\n5. Sort the stripes by their key in ascending order to obtain [C_0,…,C_{M-1}]; verify M == N.\n6. Initialize an output grid of size N rows and N columns filled with 0.\n7. If orientation == horizontal:\n   For i from 0 to N-1: for j from 0 to N-1: set output[i][j] = C_i.\n8. If orientation == vertical:\n   For j from 0 to N-1: for i from 0 to N-1: set output[i][j] = C_j.\n9. Return the output grid.",
    "29623171.json": "1. Let H = number of rows and W = number of columns in the grid.\n2. Compute R_sep = sorted list of all row indices r in [0..H-1] such that for all c in [0..W-1], grid[r][c] == 5.\n3. Compute C_sep = sorted list of all column indices c in [0..W-1] such that for all r in [0..H-1], grid[r][c] == 5.\n4. Build row_starts = [0] + [r+1 for r in R_sep]; row_ends = [r-1 for r in R_sep] + [H-1]; pair by index into row_segments.\n5. Build col_starts = [0] + [c+1 for c in C_sep]; col_ends = [c-1 for c in C_sep] + [W-1]; pair by index into col_segments.\n6. For each i in 0..len(row_segments)-1 and each j in 0..len(col_segments)-1:\n   a. Let (r0,r1) = row_segments[i], (c0,c1) = col_segments[j].\n   b. Let count[i][j] = number of (r,c) with r0≤r≤r1 and c0≤c≤c1 where grid[r][c] != 0.\n   c. If count[i][j] > 0, let color[i][j] = the unique non-zero value in that region.\n7. Let maxCount = maximum of all count[i][j].\n8. For each block (i,j): for all r in r0..r1 and c in c0..c1:\n   if count[i][j] == maxCount then set grid[r][c] = color[i][j] else set grid[r][c] = 0.\n9. Return the modified grid.",
    "93b581b8.json": "1. Let H and W be the height and width of the input grid. 2. Find all coordinates (r,c) where grid[r][c] ≠ 0. Compute r0 = min{r}, c0 = min{c}. 3. Confirm these non-zero cells exactly occupy (r0,c0),(r0,c0+1),(r0+1,c0),(r0+1,c0+1). 4. Read values: tl = grid[r0][c0], tr = grid[r0][c0+1], bl = grid[r0+1][c0], br = grid[r0+1][c0+1]. 5. Define four target blocks:  a. For corner tl: color = br; rows = [r0-2, r0-1]; cols = [c0-2, c0-1].  b. For corner tr: color = bl; rows = [r0-2, r0-1]; cols = [c0+2, c0+3].  c. For corner bl: color = tr; rows = [r0+2, r0+3]; cols = [c0-2, c0-1].  d. For corner br: color = tl; rows = [r0+2, r0+3]; cols = [c0+2, c0+3]. 6. For each block (each choice a–d), for each r in its rows and each c in its cols, if 0 ≤ r < H and 0 ≤ c < W, set grid[r][c] = color. 7. Return the modified grid.",
    "91714a58.json": "1. Let M = number of rows and N = number of columns in the input grid.\n2. Initialize best_area = 0, best_color = 0, best_r1 = 0, best_c1 = 0, best_r2 = 0, best_c2 = 0.\n3. For r1 from 0 to M-1:\n     For c1 from 0 to N-1:\n         Let v = input[r1][c1]. If v == 0 then continue to next c1.\n         For r2 from r1 to M-1:\n             For c2 from c1 to N-1:\n                 width = c2 - c1 + 1; height = r2 - r1 + 1; area = width * height.\n                 If area <= best_area then continue to next c2.\n                 Check all cells (r,c) for r in r1..r2 and c in c1..c2: if input[r][c] != v then break and continue to next c2.\n                 If all cells match v then set best_area = area, best_color = v, best_r1 = r1, best_c1 = c1, best_r2 = r2, best_c2 = c2.\n4. Create an output grid of size M×N and fill every cell with 0.\n5. For r from best_r1 to best_r2:\n     For c from best_c1 to best_c2:\n         Set output[r][c] = best_color.\n6. Return the output grid.",
    "3428a4f5.json": "1. Let grid be the input 2D array. Let H be the number of rows in grid and W be the number of columns.\n2. Find the unique row index r_sep (0-based) such that for every column c in 0..W-1, grid[r_sep][c] == 4.\n3. Define H_top = r_sep.\n4. Define two subgrids of size H_top × W:\n   a. top_grid[i][j] = grid[i][j] for i in 0..H_top-1, j in 0..W-1.\n   b. bottom_grid[i][j] = grid[r_sep+1 + i][j] for i in 0..H_top-1, j in 0..W-1.\n5. Initialize an output grid out of size H_top × W.\n6. For each i in 0..H_top-1 and each j in 0..W-1:\n   a = top_grid[i][j]\n   b = bottom_grid[i][j]\n   If a == b then set out[i][j] = 0 else set out[i][j] = 3.\n7. Return out as the transformed grid.",
    "941d9a10.json": "1. Identify horizontal separator rows: any row index r for which every cell equals 5.\n2. Identify vertical separator columns: any column index c for which every cell equals 5.\n3. Sort the separator row indices ascending into list H and the separator column indices ascending into list V.\n4. Partition the row index range [0…numRows−1] into segments: initialize prev=0; for each r in H: if prev≤r−1 add segment [prev, r−1]; set prev=r+1; end; after the loop if prev≤numRows−1 add segment [prev, numRows−1]; call this list rowSegments.\n5. Partition the column index range [0…numCols−1] analogously using V to form colSegments.\n6. Let R = length of rowSegments and C = length of colSegments.\n7. Determine three target sections:\n   - Top-left: rowSegments[0] × colSegments[0], fillValue = 1\n   - Center: rowSegments[floor(R/2)] × colSegments[floor(C/2)], fillValue = 2\n   - Bottom-right: rowSegments[R−1] × colSegments[C−1], fillValue = 3\n8. For each target section: for each row i in its row range and each column j in its column range: if grid[i][j] == 0 then set grid[i][j] = fillValue.\n9. Return the modified grid, leaving all other cells unchanged.",
    "9565186b.json": "1. Let R = number of rows and C = number of columns in the input grid.\n2. Create an empty frequency map Count from integer value to integer count.\n3. For each row r from 0 to R-1 and each column c from 0 to C-1:\n   a. Let v = input[r][c].\n   b. Increment Count[v] by 1 (initialize to 0 if v not yet in map).\n4. Find the integer majority_value with the highest Count[majority_value] (assume exactly one such maximum).\n5. Initialize an empty output grid of size R x C.\n6. For each row r from 0 to R-1 and each column c from 0 to C-1:\n   a. If input[r][c] == majority_value, set output[r][c] = majority_value.\n   b. Otherwise, set output[r][c] = 5.\n7. Return the output grid.",
    "91413438.json": "1. Let input_grid have H rows and W columns.\n2. Let background_value = 0.\n3. Compute C = number of cells (r,c) in input_grid where input_grid[r][c] != background_value.\n4. Compute output_blocks_per_dim = 9 - C.\n5. Compute output_height = H * output_blocks_per_dim and output_width = W * output_blocks_per_dim.\n6. Initialize output_grid of size output_height × output_width, filling every cell with background_value.\n7. For block_index from 0 to C - 1 do:\n   a. block_row = block_index // output_blocks_per_dim\n   b. block_col = block_index % output_blocks_per_dim\n   c. For each r from 0 to H - 1 and each c from 0 to W - 1 set\n      output_grid[block_row * H + r][block_col * W + c] = input_grid[r][c]\n8. Return output_grid.",
    "31aa019c.json": "1. Let H be the number of rows and W be the number of columns of the input grid.\n2. Compute the occurrence count of each non-zero color value in the input grid.\n3. Let S be the set of non-zero values whose count equals 1. If |S|>1, let C be the minimum value in S; otherwise let C be the sole element of S.\n4. Locate the coordinates (r, c) of the cell in the input grid with value C.\n5. Create an output grid of size H×W and initialize every cell to 0.\n6. Set output[r][c] = C.\n7. For each offset pair (dr, dc) in {(-1,-1), (-1,0), (-1,1), (0,-1), (0,1), (1,-1), (1,0), (1,1)}:\n   a. Let r2 = r + dr and c2 = c + dc.\n   b. If 0 ≤ r2 < H and 0 ≤ c2 < W, set output[r2][c2] = 2.\n8. Return the output grid.",
    "3618c87e.json": "1. Let H be the height and W the width of the input grid, with rows indexed 0..H-1 and columns 0..W-1.\n2. Initialize the output grid as an exact copy of the input grid.\n3. For each cell at (r, c) where input[r][c] == 1:\n   a. Set output[r][c] = 0.\n   b. Set output[r+2][c] = 1.\n4. Return the output grid.",
    "95990924.json": "1. Let input be a grid of integers and create output as a copy of input. 2. For each row index r from 0 to (num_rows – 2) and each column index c from 0 to (num_cols – 2):\n   a. If input[r][c]==5 and input[r][c+1]==5 and input[r+1][c]==5 and input[r+1][c+1]==5 then:\n      i. Let (r0,c0)=(r,c) be the top-left corner of a 2×2 block of value 5.\n      ii. Set output[r0−1][c0−1]=1  (blue) if within bounds.\n      iii. Set output[r0−1][c0+2]=2  (red) if within bounds.\n      iv. Set output[r0+2][c0−1]=3  (green) if within bounds.\n      v. Set output[r0+2][c0+2]=4  (yellow) if within bounds.\n3. Return output grid of the same size as input, with original 5s preserved and new values 1,2,3,4 placed diagonally outside each 2×2 block of 5s.",
    "928ad970.json": "1. Use zero-based coordinates: (row, col) with row 0 at top and col 0 at left. Pixel values are integers 0–9.\n2. Copy every cell from the input grid into the output grid.\n3. Find all cells where input[row][col] == 5; store their coordinates in list grey_dots (length 4).\n4. Compute r_min = minimum row among grey_dots, r_max = maximum row, c_min = minimum col, c_max = maximum col.\n5. Compute drawing boundaries: top_edge = r_min + 1; bottom_edge = r_max - 1; left_edge = c_min + 1; right_edge = c_max - 1.\n6. Identify rectangle_color c by scanning the input for any cell value not equal to 0 and not equal to 5 (there will be exactly one such value).\n7. For each column j from left_edge to right_edge inclusive:\n   set output[top_edge][j] = c and output[bottom_edge][j] = c.\n8. For each row i from top_edge to bottom_edge inclusive:\n   set output[i][left_edge] = c and output[i][right_edge] = c.\n9. Return the output grid.",
    "2c608aff.json": "1. Identify background_color as the integer that appears most frequently in the input grid. 2. Identify block_color as the non-background integer whose pixels form a filled rectangle of size at least 2 rows by 2 columns: for each color≠background_color compute its bounding box (min_row,max_row,min_col,max_col), select the color where every cell in that box equals the color and max_row−min_row≥1 and max_col−min_col≥1. 3. Compute min_row,max_row,min_col,max_col of block_color. 4. Copy input grid to output_grid. 5. For each cell (r,c) where input_grid[r][c]≠background_color and ≠block_color: a. Let dot_color=input_grid[r][c]. b. Determine direction: if r∈[min_row,max_row] and c<min_col set direction=(0,1); else if r∈[min_row,max_row] and c>max_col set direction=(0,-1); else if c∈[min_col,max_col] and r<min_row set direction=(1,0); else if c∈[min_col,max_col] and r>max_row set direction=(-1,0); else continue to next cell. c. Initialize (y,x)=(r,c). While input_grid[y][x]≠block_color: set output_grid[y][x]=dot_color; y+=direction_row; x+=direction_col. 6. Return output_grid.",
    "97999447.json": "1. Compute H = number of rows and W = number of columns of the input grid.\n2. Initialize the output grid as an exact copy of the input grid.\n3. For each row index r from 0 to H-1:\n   For each column index c from 0 to W-1:\n     Let V = input[r][c]. If V ≠ 0 then:\n       For each offset d from 1 to W-1-c:\n         Let k = c + d.\n         If d mod 2 = 1 then set output[r][k] = 5\n         Else set output[r][k] = V\n4. Return the output grid.",
    "94f9d214.json": "1. Let H = number of rows in the input grid and W = number of columns. Compute M = H / 2 (must be integer).  \n2. Create an output grid of size M rows by W columns.  \n3. For each row index r from 0 to M-1 and each column index c from 0 to W-1:  \n   a. If input_grid[r][c] == 0 AND input_grid[r+M][c] == 0 then set output_grid[r][c] = 2.  \n   b. Otherwise set output_grid[r][c] = 0.  \n4. Return the output grid.",
    "952a094c.json": "1. Use zero-based row and column indexing.\n2. Copy input grid G to output grid O.\n3. Identify border color B as the nonzero pixel value in G that appears most frequently.\n4. Let S be the set of coordinates (r,c) where G[r][c] == B. Compute r_min = min(r), r_max = max(r), c_min = min(c), c_max = max(c).\n5. Define interior corner coordinates:\n   TL = (r_min+1, c_min+1)\n   TR = (r_min+1, c_max-1)\n   BL = (r_max-1, c_min+1)\n   BR = (r_max-1, c_max-1)\n6. Read values v_TL = G[TL], v_TR = G[TR], v_BL = G[BL], v_BR = G[BR]. Set O[TL] = 0, O[TR] = 0, O[BL] = 0, O[BR] = 0.\n7. Define exterior corner coordinates:\n   E_TL = (r_min-1, c_min-1)\n   E_TR = (r_min-1, c_max+1)\n   E_BL = (r_max+1, c_min-1)\n   E_BR = (r_max+1, c_max+1)\n8. Assign O[E_TL] = v_BR, O[E_TR] = v_BL, O[E_BL] = v_TR, O[E_BR] = v_TL.\n9. Return output grid O.",
    "99b1bc43.json": "1. Locate the separator row: find the row index sep such that for every column c, input_grid[sep][c]==4. 2. Define top_block as the 4 rows with indices 0..sep-1 and bottom_block as the 4 rows with indices sep+1..sep+4. 3. Create an empty 4×4 output_grid. 4. For each r in 0..3 and each c in 0..3:   a. Let t = input_grid[r][c].   b. Let b = input_grid[sep+1+r][c].   c. If (t==0 and b==0) or (t!=0 and b!=0), set output_grid[r][c]=0; otherwise set output_grid[r][c]=3. 5. Return output_grid.",
    "2bee17df.json": "1. Let R = number of rows in the input grid, C = number of columns. 2. Initialize an empty list H_runs. 3. For each row r from 0 to R-1:  \n   a. Let c = 0.  \n   b. While c < C:  \n      i. If grid[r][c] == 0, record start = c, set length = 0.  \n      ii. While c < C and grid[r][c] == 0: increment length and c.  \n      iii. Append (r, start, length) to H_runs.  \n      iv. Else increment c.  \n4. Compute H = maximum length among all entries in H_runs.  \n5. For each (r, start, length) in H_runs: if length == H, then for col from start to start+H-1: set grid[r][col] = 3.  \n6. Initialize an empty list V_runs.  \n7. For each column c from 0 to C-1:  \n   a. Let r = 0.  \n   b. While r < R:  \n      i. If grid[r][c] == 0, record start_r = r, set length = 0.  \n      ii. While r < R and grid[r][c] == 0: increment length and r.  \n      iii. Append (c, start_r, length) to V_runs.  \n      iv. Else increment r.  \n8. Compute V = maximum length among all entries in V_runs.  \n9. For each (c, start_r, length) in V_runs: if length == V, then for row from start_r to start_r+V-1: set grid[row][c] = 3.  \n10. Output the resulting grid.",
    "363442ee.json": "1. Identify separator column c_bar as the column index where for every row r, input[r][c_bar] == 5. 2. Determine r_min as the smallest row index and r_max as the largest row index such that there exists a column c in 0..c_bar-1 with input[r][c] != 0; set pattern_height = r_max - r_min + 1 and pattern_width = c_bar. 3. Extract pattern P of size pattern_height x pattern_width by copying P[i][j] = input[r_min + i][j] for i in 0..pattern_height-1 and j in 0..pattern_width-1. 4. Compute pattern_center_i = floor(pattern_height/2) and pattern_center_j = floor(pattern_width/2). 5. Initialize output as a copy of input. 6. For each cell (r,c) where input[r][c] == 1 and c > c_bar, do: for each i in 0..pattern_height-1 and j in 0..pattern_width-1, if P[i][j] != 0 then let tr = r + (i - pattern_center_i) and tc = c + (j - pattern_center_j); set output[tr][tc] = P[i][j]. 7. Return the output grid.",
    "3aa6fb7a.json": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Initialize an output grid as a copy of the input grid.\n3. For each row r from 0 to H-2:\n   a. For each column c from 0 to W-2:\n      i. Define the 2×2 block positions: P = [(r,c), (r,c+1), (r+1,c), (r+1,c+1)].\n      ii. Compute eightCount = the number of positions in P where the input grid value == 8.\n      iii. If eightCount == 3:\n          A. Identify the position (r0,c0) in P where the input grid value != 8.\n          B. Set outputGrid[r0][c0] = 1.\n4. Return the output grid.",
    "3ac3eb23.json": "1. Let R be the number of rows and C be the number of columns in the input grid (0‥R-1 and 0‥C-1 using 0-based indexing).\n2. Initialize the output grid as a copy of the input grid.\n3. Identify all non-zero pixels in the first row (row 0). For each column j where input[0][j] ≠ 0, record a pair (j, color), where color = input[0][j].\n4. For each recorded pair (j, color):\n   a. For each row r from 1 to R−1:\n      i. If r is even (r % 2 == 0), set output[r][j] = color.\n      ii. If r is odd (r % 2 == 1):\n          - If j−1 ≥ 0, set output[r][j−1] = color.\n          - If j+1 < C, set output[r][j+1] = color.\n5. Return the output grid.",
    "88a10436.json": "1. Locate all coordinates (r,c) in input_grid such that input_grid[r][c] > 0 and input_grid[r][c] != 5; call this set S.\n2. Compute r_min = min(r for (r,c) in S), r_max = max(r for (r,c) in S), c_min = min(c for (r,c) in S), c_max = max(c for (r,c) in S). Verify r_max - r_min = 2 and c_max - c_min = 2 (a 3×3 region).\n3. Extract a 3×3 array shape_pattern where for i in {0,1,2}, j in {0,1,2}: shape_pattern[i][j] = input_grid[r_min + i][c_min + j].\n4. Find the unique coordinate (r_gray, c_gray) such that input_grid[r_gray][c_gray] = 5.\n5. Compute dest_r = r_gray - 1 and dest_c = c_gray - 1.\n6. Create output_grid as an exact copy of input_grid.\n7. For each i in {0,1,2}, j in {0,1,2}:\n   a. If shape_pattern[i][j] ≠ 0, set output_grid[dest_r + i][dest_c + j] = shape_pattern[i][j].\n8. Return output_grid.",
    "29ec7d0e.json": "1. Let H = number of rows in the input grid, W = number of columns. 2. For each row r from 0 to H-1 do:\n  a. Let S = { c | 0 ≤ c < W and grid[r][c] ≠ 0 }.\n  b. Find the smallest positive period p (1 ≤ p ≤ W) such that for all c1, c2 in S, if c1 mod p = c2 mod p then grid[r][c1] = grid[r][c2].\n     i. For p from 1 to W:\n        - For each pair c1, c2 in S, if (c1 mod p = c2 mod p) and (grid[r][c1] ≠ grid[r][c2]), then this p is invalid; continue to next p.\n        - If no conflict for this p, break and use it.\n  c. Build an array Pattern of length p: for each k in 0..p-1, pick any c in S with c mod p = k and set Pattern[k] = grid[r][c].\n  d. For each column c from 0 to W-1, if grid[r][c] = 0, set grid[r][c] = Pattern[c mod p].\n3. After processing all rows, output the modified grid.",
    "8731374e.json": "1. Let G be the input grid with H rows and W columns, indexed from 0.\n2. Identify the unique rectangular region B as follows:\n   a. For r1 from 0 to H-2:\n     For c1 from 0 to W-2:\n       For r2 from r1+1 to H-1:\n         For c2 from c1+1 to W-1:\n           Let v = G[r1][c1].\n           If every cell on the border of the rectangle ((r1,c) and (r2,c) for c=c1..c2) and ((r,c1) and (r,c2) for r=r1..r2) equals v, and there exists at least one cell (r,c) with r1<r<r2 and c1<c<c2 for which G[r][c]≠v, then set C_bg=v and record (r1,c1,r2,c2); exit all loops.\n3. Compute region height H_r = r2 - r1 + 1 and width W_r = c2 - c1 + 1.\n4. Initialize output grid O with H_r rows and W_r columns, filling every cell with C_bg.\n5. For each cell (r,c) inside B with G[r][c]≠C_bg (i.e. r1<r<r2 and c1<c<c2):\n   a. Let rr = r - r1 and cc = c - c1 and C_h = G[r][c].\n   b. For k from 0 to W_r-1 set O[rr][k] = C_h.\n   c. For k from 0 to H_r-1 set O[k][cc] = C_h.\n6. Return O as the transformed grid.",
    "80af3007.json": "1. Identify the non-background color C by scanning the input grid; set C = 5. 2. Compute the minimal bounding rectangle of all cells equal to C: r_min = minimum row index with grid[r][c] == C; r_max = maximum such row index; c_min = minimum column index with grid[r][c] == C; c_max = maximum such column index. 3. Let H = r_max - r_min + 1 and W = c_max - c_min + 1; verify H == W and H mod 3 == 0; set m = H / 3. 4. Extract a 3×3 base pattern B of bits: for each i in 0..2 and j in 0..2, let r0 = r_min + i*m, c0 = c_min + j*m; if grid[r0][c0] == C then B[i][j] = 1 else B[i][j] = 0. 5. Initialize an H×W output grid filled with 0. 6. For each i0 in 0..2, j0 in 0..2, i1 in 0..2, j1 in 0..2: if B[i0][j0] == 1 and B[i1][j1] == 1 then set output[i0*m + i1][j0*m + j1] = C. 7. Return the output grid.",
    "9af7a82c.json": "1. Scan the input grid of size H_in×W_in. For each cell at (r,c) with pixel value v>0, increment count[v] by 1.\n2. Collect the list of distinct colors C = {v | count[v] defined}.\n3. Let max_count = the maximum value among all count[v] for v in C.\n4. Sort the list C in descending order of count; if two colors have equal count, order them by ascending numerical value. Call the sorted list L = [c0,c1,…,c_{N-1}].\n5. Set output width W_out = N (the length of L) and output height H_out = max_count.\n6. Initialize an output grid of size H_out×W_out filled with 0.\n7. For each column index i from 0 to N-1:\n   a. Let color = L[i] and n = count[color].\n   b. For each row index r from 0 to n-1, set output_grid[r][i] = color.\n   c. Leave rows r = n to H_out-1 in column i as 0 (background).\n8. Return the output grid.",
    "963e52fc.json": "1. Let H = number of rows and W = number of columns in the input grid.\n2. Let newW = 2 * W.\n3. Create an output grid of size H × newW.\n4. Define patternRows = { r | there exists c in [0..W−1] with input[r][c] ≠ 0 }.\n5. For each row r from 0 to H−1:\n   a. If r ∉ patternRows:\n      For each c from 0 to newW−1, set output[r][c] = input[r][0].\n   b. If r ∈ patternRows:\n      i. Find the smallest integer p in [1..W] such that for all c in [p..W−1], input[r][c] = input[r][c−p].\n      ii. For each c from 0 to newW−1, set output[r][c] = input[r][c mod p].\n6. Return the output grid.",
    "90c28cc7.json": "1. Use 0-based indexing for rows and columns. 2. Scan the input grid to find minRow = min r with grid[r][c] ≠ 0 for some c, maxRow = max r with grid[r][c] ≠ 0; minCol = min c with grid[r][c] ≠ 0 for some r, maxCol = max c with grid[r][c] ≠ 0. 3. Let H = maxRow – minRow + 1 and W = maxCol – minCol + 1. Build subgrid T of size H×W where T[i][j] = grid[minRow+i][minCol+j]. 4. Initialize empty list rowCuts. For each r in 0..H-2, if exists j in 0..W-1 such that T[r][j] ≠ T[r+1][j], append r to rowCuts. 5. Initialize empty list colCuts. For each c in 0..W-2, if exists i in 0..H-1 such that T[i][c] ≠ T[i][c+1], append c to colCuts. 6. Sort rowCuts and colCuts and remove duplicates. 7. Compute rowStarts = [0] + [r+1 for r in rowCuts] and colStarts = [0] + [c+1 for c in colCuts]. 8. Let R = length of rowStarts and C = length of colStarts; initialize output grid U of size R×C. 9. For each i in 0..R-1 and j in 0..C-1, set U[i][j] = T[rowStarts[i]][colStarts[j]]. 10. Return U as the result grid.",
    "234bbc79.json": "1. Let H=3 and W be the number of columns of input grid G.\n2. Compute separator columns S = { j ∈ [0..W−1] | G[0][j]==0 && G[1][j]==0 && G[2][j]==0 }.\n3. Build removal map remap: initialize k=0; for j from 0 to W−1 do if j ∉ S then remap[j]=k and k←k+1.\n4. Identify M shape segments as maximal intervals [c_start_i..c_end_i] of consecutive j ∉ S in [0..W−1], in increasing order of j.\n5. For each shape i from 1 to M:\n   a. Determine main_color_i: collect values v in G[r][c] for r∈[0..2], c∈[c_start_i..c_end_i] where v≠0 and v≠5; assert exactly one unique v; set main_color_i=v.\n   b. Identify connectors:\n      - If i==1: find r_end_i such that G[r_end_i][c_end_i]==5; record end_i = (row=r_end_i, col=remap[c_end_i]).\n      - If i>1: find r_start_i such that G[r_start_i][c_start_i]==5; record start_i = (row=r_start_i, col=remap[c_start_i]).\n      - If i<M: find r_end_i such that G[r_end_i][c_end_i]==5; record end_i = (row=r_end_i, col=remap[c_end_i]).\n   c. Build pixel list P_i: for each r∈[0..2], c∈[c_start_i..c_end_i] if G[r][c]≠0 then let color = (G[r][c]==5 ? main_color_i : G[r][c]) and add (row=r, col=remap[c], color) to P_i.\n6. Initialize offset_row[1] = 0.\n7. For i from 2 to M do offset_row[i] = offset_row[i−1] + end_{i−1}.row − start_i.row.\n8. Let W' = k (final number of non-separator columns). Initialize output grid O of size 3×W' filled with 0.\n9. For each shape i from 1 to M and each (r,c,color) in P_i do set O[r + offset_row[i]][c] = color.\n10. Return O.",
    "25d487eb.json": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Build set S of all coordinates (r,c) with 0≤r<H, 0≤c<W and grid[r][c] ≠ 0.\n3. Compute frequency map freq over S: for each (r,c) in S, increment freq[grid[r][c]].\n4. Let fill_color be the value v for which freq[v] = 1.\n5. Initialize best_length = 0.\n6. For each (r,c) in S:\n   For each (dr,dc) in [(-1,0),(1,0),(0,-1),(0,1)]:\n     Let nr = r + dr, nc = c + dc.\n     If 0≤nr<H, 0≤nc<W and grid[nr][nc] == 0 then:\n       Set length = 0.\n       While 0≤nr<H and 0≤nc<W and grid[nr][nc] == 0 do:\n         length = length + 1;\n         nr = nr + dr; nc = nc + dc;\n       End while.\n       If length > best_length then:\n         Set best_length = length;\n         Set best_r = r; best_c = c;\n         Set best_dr = dr; best_dc = dc;\n       End if;\n     End if;\n7. For i from 1 to best_length do:\n   Set grid[best_r + i*best_dr][best_c + i*best_dc] = fill_color;\n8. Return the modified grid.",
    "99fa7670.json": "1. Let H = number of rows in the input grid, W = number of columns.\n2. Create a list L of all cells (r, c, v) such that input_grid[r][c] != 0, where v = input_grid[r][c].\n3. Sort L in ascending order by r; if two entries share r, sort by ascending c.\n4. Initialize output_grid as a copy of input_grid.\n5. For each (r, c, v) in L, perform:\n   a. For x from c to W-1 inclusive, set output_grid[r][x] = v.\n   b. For y from r to H-1 inclusive, set output_grid[y][W-1] = v.\n6. Return output_grid.",
    "3906de3d.json": "1. Let input_grid be the given grid of size H×W. 2. Initialize output_grid as a copy of input_grid. 3. For each cell (r,c) in output_grid with value 2, set output_grid[r][c] ← 0. 4. For each column c from 0 to W−1 do:   a. In input_grid, collect list R of all row indices r where input_grid[r][c]==2.   b. Sort R in ascending order.   c. Partition R into contiguous runs: for each maximal subsequence [r_start,…,r_end] where consecutive values differ by 1.   d. For each run with r_start (smallest) and r_end (largest):     i. Let L ← r_end−r_start+1.     ii. In input_grid, find r_obst ← max{r | r<r_start and input_grid[r][c]==1}. If no such r, set r_obst ← −1.     iii. Let new_top ← r_obst+1.     iv. For k from 0 to L−1 do set output_grid[new_top+k][c] ← 2. 5. Return output_grid.",
    "3bdb4ada.json": "1. Copy the input grid into an output grid of the same dimensions.\n2. Initialize an empty set VISITED.\n3. For each cell (r,c) in the input grid:\n   a. If inputGrid[r][c] == 0 or (r,c) is in VISITED, skip.\n   b. Otherwise, let COLOR = inputGrid[r][c]. Perform a 4‐connected flood fill starting at (r,c) to collect all cells of value COLOR; add each visited cell to VISITED and record its row and column indices.\n   c. Compute topRow = minimum row index in the component; bottomRow = maximum row index; leftCol = minimum column index; rightCol = maximum column index.\n   d. Compute midRow = topRow + floor((bottomRow – topRow)/2).\n   e. For each col from leftCol to rightCol inclusive:\n      i. If (col – leftCol) mod 2 == 1, set outputGrid[midRow][col] = 0.\n      ii. Else set outputGrid[midRow][col] = COLOR.\n4. After processing all components, return the output grid.",
    "3c9b0459.json": "1. Compute integer H = number of rows in the input grid and integer W = number of columns in each row.\n2. Create an output grid of size H × W.\n3. For each integer r from 0 to H−1:\n4.   For each integer c from 0 to W−1:\n5.     Let v = input[r][c].\n6.     Compute tr = H−1−r and tc = W−1−c.\n7.     Set output[tr][tc] = v.\n8. Return the output grid.",
    "28e73c20.json": "1. Let H = number of rows and W = number of columns of the input grid. 2. Copy the input grid to an output grid; values 0 remain 0. 3. Define spiral_color = 3. 4. Define directions in order: Right = (dr=0,dc=1), Down = (1,0), Left = (0,-1), Up = (-1,0). 5. Initialize: r=0, c=0, dir_idx=0 (Right). Set output[r][c] = spiral_color. 6. Repeat:  \n   a. For i in 0..3:  \n      i. Let d = (dir_idx + i) mod 4.  \n      ii. Let dr,dc = directions[d].  \n      iii. Let r1 = r+dr, c1 = c+dc.  \n      iv. Let r2 = r+2*dr, c2 = c+2*dc.  \n      v. If (r1,c1) is inside [0..H-1]×[0..W-1] AND output[r1][c1]==0 AND ((r2,c2) is outside the grid OR output[r2][c2]==0) then:  \n         – Set dir_idx = d.  \n         – Set r = r1, c = c1.  \n         – Set output[r][c] = spiral_color.  \n         – Go to step 6 (begin next iteration).  \n   b. If no direction in step 6a is valid, exit the loop. 7. Return the output grid.\n",
    "3bd67248.json": "1. Let H be the number of rows and W be the number of columns in the input grid. Index rows from 0 (top) to H-1 (bottom) and columns from 0 (left) to W-1 (right).\n2. Initialize the output grid by copying every cell from the input grid.\n3. Draw a horizontal line of pixel value 4 on the bottom row: for each column c from 1 to W-1 inclusive, set output[H-1][c] = 4.\n4. Draw a descending diagonal line of pixel value 2:\n   a. Initialize r = 0 and c = W-1.\n   b. While r < H-1 and c > 0:\n      i.   Set output[r][c] = 2.\n      ii.  Increment r by 1 and decrement c by 1.\n5. Return the output grid. All other cells remain unchanged, preserving the original vertical line in column 0.",
    "3af2c5a8.json": "1. Let R be the number of rows in the input grid and C be the number of columns.\n2. Create an output grid with 2*R rows and 2*C columns.\n3. For each row index r from 0 to 2*R - 1:\n   a. If r < R then set src_r = r else set src_r = 2*R - 1 - r.\n   b. For each column index c from 0 to 2*C - 1:\n      i. If c < C then set src_c = c else set src_c = 2*C - 1 - c.\n      ii. Set output[r][c] = input[src_r][src_c].\n4. Return the output grid.",
    "9dfd6313.json": "1. Let N be the number of rows (and columns) of the square input grid.\n2. Create an N×N output grid and initialize every cell to 0.\n3. For each index i from 0 to N-1, set output[i][i] = input[i][i] to preserve the main diagonal.\n4. For each row r from 1 to N-1 and each column c from 0 to r-1:\n     a. Read v = input[r][c].\n     b. Set output[c][r] = v to mirror the cell across the main diagonal.\n5. Return the output grid.",
    "a416b8f3.json": "1. Let H = number of rows in the input grid, and W = number of columns in the input grid.\n2. Create an empty output grid with H rows and 2·W columns.\n3. For each row index r from 0 to H−1:\n   a. For each column index c from 0 to W−1:\n      i. Read value v = input[r][c].\n      ii. Set output[r][c] = v.\n      iii. Set output[r][c + W] = v.\n4. Return the output grid.",
    "a3df8b1e.json": "1. Let H be the number of rows and W be the number of columns of the input grid. Index rows 0 to H-1 from top to bottom and columns 0 to W-1 from left to right.\n2. Find the unique start_col such that input[H-1][start_col] == 1.\n3. Initialize an output grid of size H×W filled with 0.\n4. Set current_col = start_col and horizontal direction dx = +1.\n5. Set output[H-1][current_col] = 1.\n6. For each row r from H-2 down to 0 (decrementing r):\n   a. Compute tentative_col = current_col + dx.\n   b. If tentative_col < 0 or tentative_col >= W, then set dx = -dx and recompute tentative_col = current_col + dx.\n   c. Set output[r][tentative_col] = 1.\n   d. Set current_col = tentative_col.\n7. Return the output grid.",
    "995c5fa3.json": "1. Partition the input into three 4×4 blocks: for i in {0,1,2}, block i covers rows 0–3 and columns [i*5 .. i*5+3] (i.e., cols 0–3, 5–8, 10–13). 2. For each block i, compute Z = {(r,c) | r∈{0,1,2,3}, c∈{0,1,2,3}, input[r][i*5+c] == 0}. 3. Determine color_i as follows: if Z is empty then color_i = 2; else if Z == {(1,1),(1,2),(2,1),(2,2)} then color_i = 8; else if Z == {(2,1),(2,2),(3,1),(3,2)} then color_i = 4; else if Z == {(1,0),(2,0),(1,3),(2,3)} then color_i = 3; else abort. 4. Create an output grid of size 3×3. 5. For each i in {0,1,2}, fill entire row i of the output with color_i. 6. Return the output grid.",
    "a1570a43.json": "1. Let H = number of rows, W = number of columns in the input grid. Index rows r=0..H-1 top-to-bottom, columns c=0..W-1 left-to-right.\n2. Identify the frame pixels: F = {(r,c) | grid[r][c] == 3}.\n3. Compute frame bounds: fmin_r = min_{(r,c) in F} r; fmax_r = max_{(r,c) in F} r; fmin_c = min_{(r,c) in F} c; fmax_c = max_{(r,c) in F} c.\n4. Compute the interior origin of the frame: top = fmin_r + 1; left = fmin_c + 1.\n5. Identify the shape pixels: S = {(r,c) | grid[r][c] == 2}.\n6. Compute shape bounding box origin: smin_r = min_{(r,c) in S} r; smin_c = min_{(r,c) in S} c.\n7. Compute translation vector: dr = top - smin_r; dc = left - smin_c.\n8. Remove the original shape: for each (r,c) in S, set grid[r][c] = 0.\n9. Draw the shape at the new location: for each (r,c) in S, set grid[r + dr][c + dc] = 2.\n10. Return the modified grid.",
    "a2fd1cf0.json": "1. Scan the input grid and find the unique pixel with value 2; record its row and column indices as (r2,c2). 2. Scan the input grid and find the unique pixel with value 3; record its row and column indices as (r3,c3). 3. Initialize the output grid as a copy of the input grid. 4. Let c_start = min(c2,c3) and c_end = max(c2,c3). For each integer c in the inclusive range [c_start, c_end]: if the cell (r2,c) in the input is not 2, set output[r2][c] = 8. 5. Let r_start = min(r2,r3) and r_end = max(r2,r3). For each integer r in the inclusive range [r_start, r_end]: if the cell (r,c3) in the input is not 3, set output[r][c3] = 8. 6. Return the output grid.",
    "a3325580.json": "1. Identify all non-zero connected components in the input grid. Two cells at (r, c) and (r\\u2009', c\\u2009') are connected if they share an edge (|r − r\\u2009'| + |c − c\\u2009'| = 1) and have the same non-zero integer value.\n2. For each component:\n   - Let color = the integer value of its cells.\n   - Let size = the number of cells in the component.\n   - Let min_col = the minimum column index among its cells.\n3. Compute max_size = the maximum size among all components.\n4. Let L = list of components whose size == max_size.\n5. Sort L by ascending min_col.\n6. Let N = length of L.\n7. Initialize an output grid of size max_size rows by N columns.\n8. For each j in 0..N−1:\n   a. Let c_j = L[j].color.\n   b. For each r in 0..max_size−1, set output_grid[r][j] = c_j.\n9. Return output_grid.",
    "3f7978a0.json": "1. Identify all coordinates (r,c) in the input grid where the cell value = 5; call this set P.\n2. Compute c_min = minimum c among P and c_max = maximum c among P.\n3. Compute r_min = minimum r among P and r_max = maximum r among P.\n4. Compute r_start = r_min - 1 and r_end = r_max + 1.\n5. Construct the output grid by copying the subgrid of the input from rows r_start through r_end and columns c_min through c_max (inclusive), preserving each cell’s value.\n6. Return the constructed subgrid as the output grid.",
    "32597951.json": "1. Scan the input grid and collect all coordinates (r,c) where the cell value equals 8.  \n2. Compute r_min = minimum r among these coordinates, r_max = maximum r, c_min = minimum c, and c_max = maximum c.  \n3. For each row r in the inclusive range [r_min, r_max]:  \n   For each column c in the inclusive range [c_min, c_max]:  \n      If grid[r][c] == 1, set grid[r][c] = 3.  \n4. Leave all other cells unchanged.  \n5. Return the resulting grid.",
    "9edfc990.json": "1. Let original_grid be the input grid of size R×C. 2. Initialize output_grid as a deep copy of original_grid. 3. Create a boolean matrix visited[R][C], initialized to false. 4. Define four-directional neighbors of (r,c): (r-1,c),(r+1,c),(r,c-1),(r,c+1), constrained to 0≤r<R, 0≤c<C. 5. For each cell (r,c) with visited[r][c]==false and original_grid[r][c]∈{0,1}:\n   a. Initialize an empty list component and a queue Q.  \n   b. Enqueue (r,c) into Q and mark visited[r][c]=true.  \n   c. While Q is not empty:\n      i. Dequeue (i,j) from Q.  \n      ii. Append (i,j) to component.  \n      iii. For each neighbor (i2,j2) of (i,j): if visited[i2][j2]==false and original_grid[i2][j2]∈{0,1}, mark visited[i2][j2]=true, enqueue (i2,j2).  \n   d. After the flood fill, check if any (i,j) in component has original_grid[i][j]==1.  \n   e. If yes, then for each (i,j) in component with original_grid[i][j]==0, set output_grid[i][j]=1.  \n6. Leave all other cells of output_grid unchanged.  \n7. Return output_grid.",
    "3de23699.json": "1. Scan the input grid and identify the unique non-zero integer value c_frame that occurs exactly four times. Record its four coordinates P = {(r_i,c_i)}. 2. Compute r_min = min(r_i), r_max = max(r_i), c_min = min(c_i), c_max = max(c_i). Verify that P equals {(r_min,c_min),(r_min,c_max),(r_max,c_min),(r_max,c_max)}. 3. Let InteriorRows be the list of row indices r with r_min < r < r_max, in ascending order. Let InteriorCols be the list of column indices c with c_min < c < c_max, in ascending order. 4. Initialize an output grid of height = |InteriorRows| and width = |InteriorCols|. 5. For each output cell at (i,j) where 0 ≤ i < |InteriorRows| and 0 ≤ j < |InteriorCols|: let r = InteriorRows[i], c = InteriorCols[j], and let v = input[r][c]. If v ≠ 0 then set output[i][j] = c_frame else set output[i][j] = 0. 6. Return the output grid.",
    "3befdf3e.json": "1. Let height = number of rows of the input grid and width = number of columns.\n2. Initialize output grid as a copy of the input grid.\n3. Identify all connected components of non-zero pixels in the input grid using 4-adjacency.\n4. For each connected component:\n   a. Compute min_row = smallest row index, max_row = largest row index, min_col = smallest column index, max_col = largest column index in the component.\n   b. Compute side_length = max_row - min_row + 1 and interior_size = side_length - 2.\n   c. Let border_color = input[min_row][min_col] and fill_color = input[min_row+1][min_col+1].\n   d. For each r from min_row to max_row and each c from min_col to max_col:\n      If r == min_row or r == max_row or c == min_col or c == max_col then set output[r][c] = fill_color else set output[r][c] = border_color.\n   e. For each r from min_row - interior_size to min_row - 1 and each c from min_col to max_col: if r >= 0 then set output[r][c] = border_color.\n   f. For each r from max_row + 1 to max_row + interior_size and each c from min_col to max_col: if r < height then set output[r][c] = border_color.\n   g. For each r from min_row to max_row and each c from min_col - interior_size to min_col - 1: if c >= 0 then set output[r][c] = border_color.\n   h. For each r from min_row to max_row and each c from max_col + 1 to max_col + interior_size: if c < width then set output[r][c] = border_color.\n5. Return the output grid.",
    "9ecd008a.json": "1. Let N be the number of rows (and columns) of the input grid.\n2. Identify all coordinates (r,c) where input[r][c] == 0.  Verify these form a contiguous 3×3 block.\n3. Let (r0,c0) = (minimum r among zero cells, minimum c among zero cells).\n4. Initialize an empty 3×3 output grid indexed by (dr,dc) for dr,dc∈{0,1,2}.\n5. For each dr∈{0,1,2} and dc∈{0,1,2}:\n   a. Let r = r0 + dr, c = c0 + dc.\n   b. Compute mirror coordinates r' = N + 1 - r, c' = N + 1 - c.\n   c. Set output[dr][dc] = input[r'][c'].\n6. Return the 3×3 output grid.",
    "40853293.json": "1. Let A be the input grid of integers of size R rows by C columns. 2. Initialize an output grid B of the same size with all cells set to 0. 3. Identify all non-zero cells in A and group their coordinates by their integer value v. 4. For each value v that appears exactly twice at positions (r1,c1) and (r2,c2): if c1=c2, classify as a vertical segment; if r1=r2, classify as a horizontal segment. 5. Draw all vertical segments first: for each vertical segment of value v at column c=c1, for r from min(r1,r2) to max(r1,r2) inclusive set B[r][c]=v. 6. Then draw all horizontal segments: for each horizontal segment of value v at row r=r1, for c from min(c1,c2) to max(c1,c2) inclusive if B[r][c]==0 then set B[r][c]=v. 7. Return B as the transformed grid.",
    "a5f85a15.json": "1. Let R be the number of rows and C be the number of columns in the input grid.\n2. For each cell at (r,c) with value v != 0, if r == 0 or c == 0 or grid[r-1][c-1] != v, designate (r,c) as the start of a top-left to bottom-right diagonal of color v.\n3. For each diagonal start (r0,c0):\n   a. Initialize an empty list diag.\n   b. Set (rr,cc) = (r0,c0).\n   c. While rr < R and cc < C and grid[rr][cc] == v:\n      i. Append (rr,cc) to diag.\n      ii. Increment rr by 1 and cc by 1.\n4. For each index i from 0 to length(diag)-1:\n   If i % 2 == 1, let (ri,ci) = diag[i] and set grid[ri][ci] = 4.\n5. Return the modified grid.",
    "9f236235.json": "1. Compute height = number of rows and width = number of columns of the input grid.\n2. Collect sep_rows = all row indices r such that for all c from 0 to width-1, grid[r][c] == grid[r][0].\n3. Let seg_color = grid[sep_rows[0]][0].\n4. Filter sep_rows to only those r in sep_rows where grid[r][0] == seg_color.\n5. Collect sep_cols = all column indices c such that for all r from 0 to height-1, grid[r][c] == seg_color.\n6. Let B = length of sep_rows + 1.\n7. Compute row_starts array of length B: for i from 0 to B-1 set row_starts[i] = 0 if i == 0 else sep_rows[i-1] + 1.\n8. Compute col_starts array of length B: for j from 0 to B-1 set col_starts[j] = 0 if j == 0 else sep_cols[j-1] + 1.\n9. Build block_matrix of size B×B: for each i in 0..B-1 and each j in 0..B-1 set block_matrix[i][j] = grid[row_starts[i]][col_starts[j]].\n10. Build output grid of size B×B: for each i in 0..B-1 and each j in 0..B-1 set output[i][j] = block_matrix[i][B-1-j].\n11. Return the output grid.",
    "4258a5f9.json": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Create an output grid by copying the input grid.\n3. For each row index r from 0 to H-1 and each column index c from 0 to W-1:\n4.   If input[r][c] == 5 then:\n5.     For each dr in [-1, 0, 1] and each dc in [-1, 0, 1]:\n6.       Compute rr = r + dr and cc = c + dc.\n7.       If 0 <= rr < H and 0 <= cc < W and output[rr][cc] == 0 then set output[rr][cc] = 1.\n8. Return the output grid.",
    "41e4d17e.json": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Identify all connected components of cells with value 1, using 4-connectivity.\n3. For each component:\n   a. Compute min_r = minimum row index, max_r = maximum row index, min_c = minimum column index, and max_c = maximum column index of its cells.\n   b. Compute center_r = (min_r + max_r) / 2 and center_c = (min_c + max_c) / 2 (both integers).\n   c. For each row r from 0 to H-1: if grid[r][center_c] ≠ 1 then set grid[r][center_c] = 6.\n   d. For each column c from 0 to W-1: if grid[center_r][c] ≠ 1 then set grid[center_r][c] = 6.\n4. Return the modified grid.",
    "3e980e27.json": "1. Let H×W be the input grid dimensions. Initialize the output grid as a copy of the input grid.\n2. Identify core colors C as any nonzero color for which there is at least one pixel of color C with an 8-adjacent neighbor of color ≠0 and ≠C, and at least one pixel of color C with no 8-adjacent neighbor of color ≠0 and ≠C.\n3. For each such core color C do:\n   a. Let P_cluster=(r_c,c_c) be a pixel of color C that has at least one 8-adjacent neighbor with color ≠0 and ≠C.\n   b. Let Solo_Set be the set of pixels of color C that have no 8-adjacent neighbor of color ≠0 and ≠C.\n   c. Determine neighbor_color N: examine the 8 neighbors of P_cluster, collect all colors ≠0 and ≠C; they will all equal a single value N.\n   d. Build the neighbor cluster component S:\n      i. Let Seed_Set be all 8 neighbors of P_cluster whose color==N.\n      ii. Perform a flood-fill (8-connectivity) on color N starting from Seed_Set to collect all positions S of color N connected to Seed_Set.\n   e. Compute Offsets = { (dy,dx) = (r–r_c, c–c_c) | (r,c) ∈ S }.\n   f. For each solo pixel P_s=(r_s,c_s) in Solo_Set:\n      For each (dy,dx) in Offsets:\n         If C==3 (green): set (r_new,c_new) = (r_s+dy, c_s+dx).\n         If C==2 (red):   set (r_new,c_new) = (r_s+dy, c_s–dx).\n         If (r_new,c_new) is within [0..H)×[0..W), assign output[r_new][c_new]=N.\n4. Return the output grid of size H×W.",
    "39a8645d.json": "1. Let G be the input grid of size H×W with integer values 0–9. Define background=0.\n2. Create an empty map M from key to integer count. A key is (color, mask), where color is an integer 1–9 and mask is a 3×3 binary array.\n3. For each top‐left coordinate (r,c) with 0≤r≤H−3 and 0≤c≤W−3:\n   a. Extract block B of size 3×3: B[i][j]=G[r+i][c+j] for i,j∈{0,1,2}.\n   b. Let C be the set of nonzero values in B. If |C|≠1 then skip to next (r,c).\n   c. Let color be the sole element of C.\n   d. Build binary mask mask[3][3] where mask[i][j]=1 if B[i][j]==color else 0.\n   e. Flatten mask into a tuple of 9 bits in row‐major order. Let key=(color, mask_tuple). Increment M[key] by 1 (default 0).\n4. Find the key (color*, mask*) in M with the largest count.\n5. Build output grid O of size 3×3: for i,j∈{0,1,2}, set O[i][j]=color* if mask*[i*3+j]==1 else 0.\n6. Return O.",
    "a61f2674.json": "1. Let G be the input grid of size H×W. Create an output grid O as a copy of G.  \n2. Identify all positions P = {(r,c) | G[r][c] == 5}.  \n3. Partition P into connected components under 4-neighbor adjacency. Call these components C₁…Cₙ.  \n4. For each component Cᵢ compute:  \n   a. sizeᵢ = number of positions in Cᵢ  \n   b. minColᵢ = minimum column index c among positions in Cᵢ  \n5. Let C_max be the component with the largest sizeᵢ; if multiple components tie, choose the one with smallest minColᵢ.  \n6. Let C_min be the component with the smallest sizeᵢ; if multiple components tie, choose the one with smallest minColᵢ.  \n7. For each (r,c) in C_max set O[r][c] = 1.  \n8. For each (r,c) in C_min set O[r][c] = 2.  \n9. For any (r,c) where G[r][c] == 5 and (r,c) ∉ C_max ∪ C_min set O[r][c] = 0.  \n10. Leave all other cells of O unchanged and return O.",
    "a699fb00.json": "1. Let H be the number of rows and W be the number of columns in the input grid. 2. For each row index r from 0 to H-1:   2.1 For each column index c from 0 to W-3:     a. If grid[r][c] == 1 and grid[r][c+1] == 0 and grid[r][c+2] == 1, then set grid[r][c+1] = 2. 3. Do not modify any other cells. 4. Return the resulting grid.",
    "3eda0437.json": "1. Let the input grid have R rows (indexed 0 to R-1) and C columns (indexed 0 to C-1).\n2. Initialize best_area = 0 and best_r1 = 0, best_c1 = 0, best_r2 = 0, best_c2 = 0.\n3. For each r1 from 0 to R-2:\n     For each c1 from 0 to C-2:\n       For each r2 from r1+1 to R-1:\n         For each c2 from c1+1 to C-1:\n           a. Let height = r2 - r1 + 1 and width = c2 - c1 + 1.\n           b. If height < 2 or width < 2, skip to next.\n           c. If all cells grid[r][c] == 0 for r1 ≤ r ≤ r2 and c1 ≤ c ≤ c2 then:\n              i. Let area = height * width.\n              ii. If area > best_area or (area == best_area and (r1 < best_r1 or (r1 == best_r1 and c1 < best_c1))), then set best_area = area and best_r1 = r1, best_c1 = c1, best_r2 = r2, best_c2 = c2.\n4. Make a copy of the input grid as output grid.\n5. For each r from best_r1 to best_r2 and each c from best_c1 to best_c2, set output[r][c] = 6.\n6. Return the output grid.",
    "4347f46a.json": "1. Let G be the input grid of size H×W, indexed by row r and column c from 0. Pixel value 0 is the background.\n2. Create an output grid O as a copy of G.\n3. Compute the set C of all nonzero values in G.\n4. For each color v in C:\n   a. Let S = {(r,c) | G[r,c] == v}.\n   b. Compute min_r = min{r | (r,c)∈S}, max_r = max{r | (r,c)∈S}, min_c = min{c | (r,c)∈S}, max_c = max{c | (r,c)∈S}.\n   c. For each r in (min_r+1) to (max_r-1), for each c in (min_c+1) to (max_c-1):\n      i. If O[r,c] == v, then set O[r,c] = 0.\n5. Return O as the transformed grid.",
    "a48eeaf7.json": "1. Let H = number of rows and W = number of columns of the input grid using zero-based indexing. 2. Identify set R = {(r,c) | input[r][c] == 2}. 3. Initialize neighbor set N = {}. For each (r,c) in R and each dr in {-1,0,1} and dc in {-1,0,1} with dr != 0 or dc != 0, let rn = r+dr and cn = c+dc. If 0 <= rn < H and 0 <= cn < W and input[rn][cn] == 0 then add (rn,cn) to N. 4. Identify set G = {(r,c) | input[r][c] == 5}. 5. Copy input grid into output grid. 6. For each (r,c) in G set output[r][c] = 0. 7. For each (r0,c0) in G find (r1,c1) in N that minimizes D = |r0-r1| + |c0-c1|; if multiple positions tie choose any. 8. For each selected (r1,c1) set output[r1][c1] = 5. 9. Return output grid.",
    "8efcae92.json": "1. Let G be the input grid of size H×W, with integer values 0–9. 0 is background, 1 and 2 are shape pixels.  \n2. Initialize an empty list Shapes.  \n3. Create a H×W boolean array Visited, all false.  \n4. For each cell (r,c) in G:  \n   a. If G[r][c]≠0 and Visited[r][c]=false, begin a flood fill:  \n      i. Initialize an empty list C, push (r,c).  \n      ii. Mark Visited[r][c]=true.  \n      iii. For each cell (x,y) popped from C, look at its 4‐neighbors (x±1,y) and (x,y±1).  \n         • If neighbor (x',y') is in bounds, G[x'][y']≠0, and Visited[x'][y']=false, add (x',y') to C and mark Visited[x'][y']=true.  \n      iv. After flood fill completes, C contains one connected component; append C to Shapes.  \n5. For each component C in Shapes, compute count2(C)=number of cells (r,c) in C with G[r][c]=2.  \n6. Let C* be the component with maximum count2(C).  \n7. Compute r_min = min_r over (r,c) in C*, r_max = max_r, c_min = min_c, c_max = max_c.  \n8. Set H' = r_max−r_min+1, W' = c_max−c_min+1.  \n9. Create output grid O of size H'×W'.  \n10. For each dr from 0 to H'−1 and each dc from 0 to W'−1:  \n    a. Let r = r_min + dr, c = c_min + dc.  \n    b. Set O[dr][dc] = G[r][c].  \n11. Return O as the transformed grid.",
    "a5313dff.json": "1. Determine H = number of rows and W = number of columns of the input grid.\n2. Create a boolean array visited of size H×W, initialized to false.\n3. Initialize an empty queue Q.\n4. For each boundary cell (r,c) where r==0 or r==H-1 or c==0 or c==W-1:\n     a. If grid[r][c]==0 and visited[r][c]==false, set visited[r][c]=true and enqueue (r,c) into Q.\n5. While Q is not empty:\n     a. Dequeue (r,c).\n     b. For each of its four orthogonal neighbors (r+1,c), (r-1,c), (r,c+1), (r,c-1):\n         i. If neighbor is within 0≤r<H and 0≤c<W, grid[r][c]==0, and visited[r][c]==false:\n             A. Set visited[r][c]=true and enqueue (r,c).\n6. For each cell (r,c) in the grid:\n     a. If grid[r][c]==0 and visited[r][c]==false, set grid[r][c]=1.\n7. Return the modified grid.",
    "321b1fc6.json": "1. Identify all 4-connected (orthogonal) components of cells with value ≠ 0 in the input grid.\n2. For each component, record its set of distinct color values.\n3. Let PATTERN = the component whose set size > 1.\n4. Among components with exactly one distinct non-zero color, let SOLID_COLOR = the color value that appears in more than one such component.\n5. Compute the PATTERN bounding box: rmin = min row, rmax = max row, cmin = min col, cmax = max col over PATTERN. Set H = rmax–rmin+1 and W = cmax–cmin+1.\n6. Initialize arrays PatternMask[0..H−1][0..W−1] and PatternColors[0..H−1][0..W−1]. For dr in 0..H−1 and dc in 0..W−1:\n   a. If (rmin+dr, cmin+dc) ∈ PATTERN then PatternMask[dr][dc]=True and PatternColors[dr][dc]=input[rmin+dr][cmin+dc].\n   b. Else PatternMask[dr][dc]=False.\n7. Create an output grid of the same dimensions, fill all cells with 0.\n8. For each component C of color SOLID_COLOR:\n   a. Compute its bounding box crmin, crmax, ccmin, ccmax; let h=crmax−crmin+1, w=ccmax−ccmin+1.\n   b. If h==H and w==W then build CompMask[0..h−1][0..w−1]: CompMask[dr][dc]=True if (crmin+dr, ccmin+dc)∈C else False.\n   c. If CompMask equals PatternMask element-wise then for each dr,dc with PatternMask[dr][dc]=True set output[crmin+dr][ccmin+dc]=PatternColors[dr][dc].\n9. Return the output grid.",
    "a740d043.json": "1. Interpret the input as a two-dimensional integer array input_grid indexed by row r and column c, using zero-based indexing.\n2. Define background_value = 1.\n3. Collect the set S of all coordinates (r, c) such that input_grid[r][c] != background_value.\n4. Compute min_row = minimum r in S; max_row = maximum r in S; min_col = minimum c in S; max_col = maximum c in S.\n5. Compute output_height = max_row - min_row + 1 and output_width = max_col - min_col + 1.\n6. Initialize output_grid as an integer array of size [output_height][output_width].\n7. For each r from min_row to max_row and each c from min_col to max_col:\n   a. Let v = input_grid[r][c].\n   b. If v == background_value, set output_grid[r - min_row][c - min_col] = 0; otherwise set output_grid[r - min_row][c - min_col] = v.\n8. Return output_grid.",
    "d631b094.json": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Initialize variable V = None.\n3. For each row index r from 0 to H-1 and each column index c from 0 to W-1:\n     a. If input[r][c] != 0 and V is None, set V = input[r][c] and exit both loops.\n4. Initialize counter N = 0.\n5. For each r from 0 to H-1 and each c from 0 to W-1:\n     a. If input[r][c] == V, increment N by 1.\n6. Create an output grid with 1 row and N columns.\n7. For each column index j from 0 to N-1 in the output row, set output[0][j] = V.",
    "445eab21.json": "1. Interpret the input as a 2D integer grid G of size H×W, where background value = 0.\n2. Identify all connected components of non-zero cells using 4-directional adjacency and grouping only cells of the same value v. For each unvisited cell with G[r][c] = v ≠ 0, perform a flood-fill to collect its component.\n3. For each component, compute its bounding rectangle: min_row = minimum r, max_row = maximum r, min_col = minimum c, max_col = maximum c over all its cells; then width = max_col - min_col + 1; height = max_row - min_row + 1; bounding_area = width * height.\n4. Select the component with the largest bounding_area. Let C be its pixel value v.\n5. Create an output grid of size 2×2. For each cell in this grid, set its value to C.\n6. Return the 2×2 grid.",
    "a79310a0.json": "1. Let H be the number of rows and W be the number of columns of the input grid. Use zero-based indexing for rows (0…H-1) and columns (0…W-1).\n2. Create an output grid of size H×W and set every cell to 0.\n3. For each row index r from 0 to H-1 and each column index c from 0 to W-1:\n   a. If input[r][c] == 8 and r + 1 < H, then set output[r+1][c] = 2.\n4. Return the output grid.",
    "a85d4709.json": "1. Let R be the number of rows and C be the number of columns in the input grid. 2. Initialize an output grid of size R×C. 3. For each row index r from 0 to R-1:   a. Find the column index g in [0, C-1] such that input[r][g] == 5.   b. Determine fill_value as follows:      • If g == 0, set fill_value = 2.      • If g == 1, set fill_value = 4.      • If g == 2, set fill_value = 3.   c. For each column index c from 0 to C-1, set output[r][c] = fill_value. 4. Return the output grid.",
    "264363fd.json": "1. Compute background color bc as the value of all cells on the outer border of the grid. 2. Identify the template shape: collect all connected components of non-bc pixels; exclude any component whose pixels form a filled axis-aligned rectangle. The remaining component is the template shape. 3. Compute its center cell: the pixel whose removal splits the component into two connected parts of equal size. For each cell in the template shape, record its offset (dr,dc) from the center and its color. 4. Identify box regions: for each connected component of uniform color fc != bc whose pixels exactly fill its axis-aligned bounding rectangle, record its bounds rmin,rmax,cmin,cmax. 5. For each box region:  a. Locate the single marker pixel inside with color != fc at (rm,cm); set grid[rm][cm]=fc.  b. Copy the template shape: for each (dr,dc,color), set grid[rm+dr][cm+dc]=color.  c. Determine template orientation: if any recorded offset has dc != 0 then it is horizontal else vertical; set perpendicular vector pv=(1,0) if horizontal else (0,1).  d. For each (dr,dc,color): let (r,c)=(rm+dr,cm+dc). For each sign s in {+1,-1}:  repeat r+=pv.dr*s, c+=pv.dc*s while rmin<=r<=rmax and cmin<=c<=cmax; at each step set grid[r][c]=color. 6. Return the modified grid.",
    "a65b410d.json": "1. Let H be the number of rows and W be the number of columns in the grid.\n2. Locate the red bar: find the unique row R containing cells with value 2. In that row, let C0 be the smallest column index with grid[R][c]==2 and let N be the total count of cells equal to 2 in row R.\n3. For each integer d from 1 to R: set grid[R-d][c]=3 (green) for every column c from C0 to C0+N+d-1.\n4. For each integer d from 1 to N-1: if R+d < H, set grid[R+d][c]=1 (blue) for every column c from C0 to C0+N-d-1.\n5. Leave all other cells unchanged.",
    "44d8ac46.json": "1. Identify all connected components of pixels with value 5 using 4-connected adjacency (up, down, left, right).\n2. For each component of 5s, compute its bounding box: r_min = minimum row index, r_max = maximum row index, c_min = minimum column index, c_max = maximum column index.\n3. Define the interior of the component as all cells (r,c) with r_min<r<r_max and c_min<c<c_max.\n4. Within these interior cells, find all connected components of pixels with value 0 using 4-connected adjacency restricted to interior.\n5. For each zero-component, compute its bounding box: r0_min, r0_max, c0_min, c0_max; compute height h = r0_max–r0_min+1 and width w = c0_max–c0_min+1.\n6. If h == w and the number of cells in the zero-component equals h * w, then for each cell in this zero-component set its value to 2.\n7. Leave all other pixels unchanged and return the resulting grid.",
    "a68b268e.json": "1. Let the input be a 9×9 grid of integers 0–9. 1 denotes the divider. 2. Define four 4×4 quadrants as subgrids of the input:   • NW quadrant: rows 0–3, cols 0–3.   • NE quadrant: rows 0–3, cols 5–8.   • SW quadrant: rows 5–8, cols 0–3.   • SE quadrant: rows 5–8, cols 5–8. 3. Initialize an empty 4×4 output grid. 4. For each output cell at (r,c) with r=0..3 and c=0..3, do:   a. Let v_NW = input[r][c]. If v_NW≠0, set output[r][c] = v_NW and continue to the next (r,c).   b. Let v_NE = input[r][c+5]. If v_NE≠0, set output[r][c] = v_NE and continue.   c. Let v_SW = input[r+5][c]. If v_SW≠0, set output[r][c] = v_SW and continue.   d. Let v_SE = input[r+5][c+5]. If v_SE≠0, set output[r][c] = v_SE and continue.   e. Otherwise set output[r][c] = 0. 5. Return the 4×4 output grid.",
    "444801d8.json": "1. Copy the input grid to the output grid.\n2. Identify all connected components of cells with value 1, using 4-way adjacency.\n3. For each component:\n   a. Compute its bounding box: min_row = minimum row index among its cells; max_row = maximum row index; min_col = minimum column index; max_col = maximum column index.\n   b. Scan input grid cells with row in [min_row,max_row] and col in [min_col,max_col] to find the unique value V that is neither 0 nor 1; set fill_color = V.\n   c. For each row r from min_row-1 to max_row (inclusive) and each column c from min_col to max_col (inclusive): if the input grid cell at (r,c) == 0 then set the output grid cell at (r,c) = fill_color.\n4. Return the output grid.",
    "4093f84a.json": "1. Let H = number of rows, W = number of columns in the input grid.\n2. Identify the grey band (value 5):\n   a. Compute horizontal_rows = { r ∈ [0..H-1] | for all c ∈ [0..W-1], input[r][c] == 5 }.\n   b. If horizontal_rows is non-empty, set orientation = horizontal, Rmin = min(horizontal_rows), Rmax = max(horizontal_rows).\n   c. Else, compute vertical_cols = { c ∈ [0..W-1] | for all r ∈ [0..H-1], input[r][c] == 5 } and set orientation = vertical, Cmin = min(vertical_cols), Cmax = max(vertical_cols).\n3. Initialize output grid of size H×W filled with 0.\n4. Copy the grey band into output:\n   – If orientation == horizontal, for r from Rmin to Rmax and c from 0 to W-1, set output[r][c] = 5.\n   – If orientation == vertical, for c from Cmin to Cmax and r from 0 to H-1, set output[r][c] = 5.\n5. Process each non-grey pixel in row-major order: for r from 0 to H-1, for c from 0 to W-1, if input[r][c] != 0 and input[r][c] != 5 then:\n   a. If orientation == horizontal:\n      i. If r < Rmin set base_r = Rmin - 1 and dir = -1, else (r > Rmax) set base_r = Rmax + 1 and dir = +1.\n      ii. curr_r = base_r, curr_c = c.\n   b. Else (orientation == vertical):\n      i. If c < Cmin set base_c = Cmin - 1 and dir = -1, else (c > Cmax) set base_c = Cmax + 1 and dir = +1.\n      ii. curr_r = r, curr_c = base_c.\n   c. While output[curr_r][curr_c] != 0, do:\n      – If orientation == horizontal, curr_r += dir; else curr_c += dir.\n   d. Set output[curr_r][curr_c] = 5.\n6. Return the output grid.",
    "d6ad076f.json": "1. Identify the two non-zero distinct pixel values in the input grid; call them A and B.\n2. For each value v in {A,B}, compute its bounding box:\n   • min_row_v = minimum row index containing v\n   • max_row_v = maximum row index containing v\n   • min_col_v = minimum column index containing v\n   • max_col_v = maximum column index containing v\n3. Determine separation orientation:\n   a. If max_row_A < min_row_B or max_row_B < min_row_A, then orientation = vertical. Define upper = shape with smaller max_row, lower = the other.\n   b. Else (must be max_col_A < min_col_B or max_col_B < min_col_A), orientation = horizontal. Define left = shape with smaller max_col, right = the other.\n4. If orientation = vertical:\n   a. Compute width_A = max_col_A - min_col_A + 1 and width_B = max_col_B - min_col_B + 1. Let S be the shape with smaller width.\n   b. Set col_start = min_col_S + 1 and col_end = max_col_S - 1.\n   c. Set row_start = max_row_upper + 1 and row_end = min_row_lower - 1.\n5. If orientation = horizontal:\n   a. Compute height_A = max_row_A - min_row_A + 1 and height_B = max_row_B - min_row_B + 1. Let S be the shape with smaller height.\n   b. Set row_start = min_row_S + 1 and row_end = max_row_S - 1.\n   c. Set col_start = max_col_left + 1 and col_end = min_col_right - 1.\n6. Copy the input grid to the output grid (same dimensions).\n7. For every cell (r,c) with r in [row_start..row_end] and c in [col_start..col_end], set output[r][c] = 8.\n8. Preserve all other cells unchanged.",
    "2dd70a9a.json": "1. Let H be the number of rows and W be the number of columns of the input grid.\n2. Create output_grid as a copy of the input grid.\n3. Identify all coordinates (r,c) where input_grid[r][c] == 2 and collect them in redCells.\n4. Identify all coordinates (r,c) where input_grid[r][c] == 3 and collect them in greenCells.\n5. Initialize a boolean visited array of size H by W to false, an empty queue Q, and an empty parent map.\n6. For each p in redCells: set visited[p] = true; enqueue p into Q.\n7. Initialize target = null.\n8. While Q is not empty and target is null:\n   a. Dequeue curr from Q.\n   b. If curr is in greenCells then set target = curr; break the loop.\n   c. For each direction (dr,dc) in [(-1,0),(1,0),(0,-1),(0,1)]: let nb = (curr.r + dr, curr.c + dc). If 0 <= nb.r < H and 0 <= nb.c < W and visited[nb] == false and input_grid[nb] != 8 and input_grid[nb] != 2 then set visited[nb] = true; set parent[nb] = curr; enqueue nb.\n9. Reconstruct the path: set cell = target; initialize list path = [cell]; while cell not in redCells: set cell = parent[cell]; append cell to path; reverse path so it starts at a red cell and ends at a green cell.\n10. For each cell in path: if input_grid[cell] == 0 then set output_grid[cell] = 3.\n11. Return output_grid.",
    "46442a0e.json": "1. Let N be the number of rows (and columns) of the input grid. 2. Create an output grid of size 2N × 2N. 3. For each row r from 0 to N−1 and each column c from 0 to N−1, do:\n   a. Set output[r][c] = input[r][c].\n   b. Set output[r][c + N] = input[N−1−c][r].\n   c. Set output[r + N][c] = input[c][N−1−r].\n   d. Set output[r + N][c + N] = input[N−1−r][N−1−c].\n4. Return the output grid.",
    "3345333e.json": "1. Let C be the set of all non‐zero colors present in the grid. 2. For each color c in C, compute its axis‐aligned bounding box: min_r(c), max_r(c), min_c(c), max_c(c), and compute its pixel count count(c). 3. Identify the overlay color B as the color whose bounding‐box area (max_r(B)–min_r(B)+1)×(max_c(B)–min_c(B)+1) equals count(B). 4. Identify the main shape color A as the other color in C (C\\{B}). 5. For every cell (r,c) with value B in the input, set grid[r][c]=0. 6. Compute the bounding box of A in the original grid: r0=min_r(A), r1=max_r(A), c0=min_c(A), c1=max_c(A). 7. For every cell (r,c) in the original grid with value A, compute its horizontal mirror column c' = c0 + (c1 – c). 8. If grid[r][c'] is 0, set grid[r][c'] = A. 9. Return the resulting grid.",
    "44f52bb0.json": "1. Let N be the number of rows and M be the number of columns of the input grid.\n2. Initialize a boolean flag isSymmetric to true.\n3. For each row index r from 0 to N-1 and each column index c from 0 to M-1:\n     a. If input[r][c] != input[N-1-r][M-1-c], then set isSymmetric = false and stop checking further cells.\n4. Create an output grid with 1 row and 1 column.\n5. If isSymmetric is true, set output[0][0] = 1; otherwise set output[0][0] = 7.",
    "a87f7484.json": "1. Let H be the number of rows and W be the number of columns of the input grid.\n2. Determine block orientation:\n   a. If W == 3 and H % 3 == 0, set N = H / 3 and for each i in 0..N-1 define block_i as the 3×3 subgrid at rows 3*i..3*i+2 and cols 0..2.\n   b. Else if H == 3 and W % 3 == 0, set N = W / 3 and for each i in 0..N-1 define block_i as the 3×3 subgrid at rows 0..2 and cols 3*i..3*i+2.\n3. For each block_i, compute count_i = number of cells in block_i whose value != 0.\n4. Identify index k with the maximum count_k (if there is a tie, choose the smallest k).\n5. Set the output grid to block_k, preserving its 3×3 structure and original cell values.",
    "d89b689b.json": "1. Let N = number of rows = number of columns in the input grid.\n2. Locate the unique 2×2 block of value 8: for r from 0 to N-2 and c from 0 to N-2, if input[r][c]==8 and input[r][c+1]==8 and input[r+1][c]==8 and input[r+1][c+1]==8, then set block_r=r and block_c=c and stop scanning.\n3. Create an output grid of size N×N, filling every cell with 0.\n4. For each cell (r,c) in the input grid with value v where v≠0 and v≠8, do:\n   a. If r<block_r and c<block_c, set output[block_r][block_c] = v.\n   b. If r<block_r and c>block_c+1, set output[block_r][block_c+1] = v.\n   c. If r>block_r+1 and c<block_c, set output[block_r+1][block_c] = v.\n   d. If r>block_r+1 and c>block_c+1, set output[block_r+1][block_c+1] = v.\n5. Return the output grid.",
    "aabf363d.json": "1. Let H be the number of rows and W be the number of columns in the input grid. Index rows 0 to H-1 top-to-bottom and columns 0 to W-1 left-to-right.\n2. Read B = grid[H-1][0].\n3. For each cell (r,c) in the grid:\n   a. If (r,c) ≠ (H-1,0) and grid[r][c] ≠ 0, set grid[r][c] = B.\n4. Set grid[H-1][0] = 0.\n5. Return the modified grid.",
    "4522001f.json": "1. Read the input 3 x 3 grid. Use 0-indexed coordinates (row, column), top-left = (0,0). Values: 0 = background, 2 = red, 3 = green.\n2. Identify all input cells with value ≠ 0. Compute minRow = minimum of their row indices, maxRow = maximum of their row indices, minCol = minimum of their column indices, maxCol = maximum of their column indices. Verify maxRow - minRow = 1 and maxCol - minCol = 1 (identifies a 2 x 2 block).\n3. Determine corner orientation: if minRow = 0 then orientationRow = 'top' else 'bottom'; if minCol = 0 then orientationCol = 'left' else 'right'.\n4. Initialize an output grid of size 9 x 9 filled with 0.\n5. Compute firstBlockStartRow = 0 if orientationRow = 'top' else 5; compute firstBlockStartCol = 0 if orientationCol = 'left' else 5.\n6. For r from firstBlockStartRow to firstBlockStartRow + 3 and c from firstBlockStartCol to firstBlockStartCol + 3, set output[r][c] = 3.\n7. Compute rowOffset = +4 if firstBlockStartRow = 0 else -4; compute colOffset = +4 if firstBlockStartCol = 0 else -4.\n8. Set secondBlockStartRow = firstBlockStartRow + rowOffset; set secondBlockStartCol = firstBlockStartCol + colOffset.\n9. For r from secondBlockStartRow to secondBlockStartRow + 3 and c from secondBlockStartCol to secondBlockStartCol + 3, set output[r][c] = 3.\n10. Return the 9 x 9 output grid.",
    "a9f96cdd.json": "1. Let H be the number of rows and W be the number of columns in the input grid. 2. Create an output grid of size H×W by copying every cell from the input grid. 3. Locate the single cell (r,c) such that input[r][c] == 2. 4. If r-1 ≥ 0 and c-1 ≥ 0, set output[r-1][c-1] = 3. 5. If r-1 ≥ 0 and c+1 < W, set output[r-1][c+1] = 6. 6. If r+1 < H and c-1 ≥ 0, set output[r+1][c-1] = 8. 7. If r+1 < H and c+1 < W, set output[r+1][c+1] = 7. 8. Set output[r][c] = 0. 9. Return the output grid.",
    "98cf29f8.json": "1. Let (0,0) be top-left. Let H be number of rows, W be number of columns. 2. Let Colors be the set of grid[r][c] values >0. 3. For each color c in Colors:  a. For each row r from 0 to H-1 find each maximal contiguous interval of columns from c0 to c1 such that for all j in c0…c1 grid[r][j]==c and grid[r-1][j]!=c and grid[r+1][j]!=c (treat out-of-bounds as !=c). If c1-c0+1 ≥2 record horizontal segment S_h at (r,c0…c1).  b. For each column col from 0 to W-1 find each maximal contiguous interval of rows from r0 to r1 such that for all i in r0…r1 grid[i][col]==c and grid[i][col-1]!=c and grid[i][col+1]!=c. If r1-r0+1 ≥2 record vertical segment S_v at (col,r0…r1).  c. For each segment S in S_h ∪ S_v and for each other color d in Colors where d≠c:    i. If S is horizontal at row r spanning c0…c1, let v_lo=grid[r][c0-1], v_hi=grid[r][c1+1]. If one of v_lo,v_hi==c and the other==d then set S_line=S, c_line=c, orientation=H, record r,c0,c1 and side=lo if v_lo==c else side=hi; break.    ii. If S is vertical at column col spanning r0…r1, let v_lo=grid[r0-1][col], v_hi=grid[r1+1][col]. If one of v_lo,v_hi==c and the other==d then set S_line=S, c_line=c, orientation=V, record col,r0,r1 and side=lo if v_lo==c else side=hi; break.  d. If S_line is defined break loop over c. 4. Remove connector: for each (r,c) in S_line set grid[r][c]=0. 5. Let L be number of cells in S_line. 6. Compute shift (δ_row,δ_col): if orientation==H and side==lo then δ_row=0,δ_col=+L; if orientation==H and side==hi then δ_row=0,δ_col=-L; if orientation==V and side==lo then δ_row=+L,δ_col=0; if orientation==V and side==hi then δ_row=-L,δ_col=0. 7. Let C_block be all (r,c) with grid[r][c]==c_line. 8. Erase C_block: set grid[r][c]=0 for each in C_block. 9. Place moved block: for each (r,c) in C_block compute r2=r+δ_row, c2=c+δ_col and set grid[r2][c2]=c_line. 10. Return grid.",
    "46f33fce.json": "1. Let H be the number of rows in the input grid and W be the number of columns.\n2. Create an output grid of size (H // 2 * 4) rows by (W // 2 * 4) columns; initialize every cell to 0.\n3. For each row r from 0 to H-1 and each column c from 0 to W-1:\n   a. Let v = input[r][c].\n   b. If v ≠ 0 then:\n      i. Compute block row index br = r // 2 and block column index bc = c // 2.\n      ii. Compute start row sr = br * 4 and start column sc = bc * 4 in the output grid.\n      iii. For dr from 0 to 3 and dc from 0 to 3, set output[sr + dr][sc + dc] = v.\n4. Return the output grid.",
    "47c1f68c.json": "1. Let N = number of rows in the input grid (equal to its number of columns).  Assume N is odd.\n2. Let B = 0 (background color).  Identify the cross color X and its row and column indices r_cross and c_cross by:\n   a. For each row i from 0 to N-1, if every cell in row i equals the same non-zero value v, set X = v and r_cross = i, then break.\n   b. For each column j from 0 to N-1, if every cell in column j equals X, set c_cross = j, then break.\n3. Compute Q = (N - 1) / 2.  (This is the size of each quadrant.)\n4. Create an output grid of size 2*Q by 2*Q.  Initialize every cell to B.\n5. For each r in 0..Q-1 and each c in 0..Q-1:\n   a. If input[r][c] ≠ B, then for each pair (dr, dc) in {( 1,  1), ( 1, -1), (-1,  1), (-1, -1)} do:\n      i. Compute r_out = (dr == 1 ? r : (2*Q - 1 - r)).\n      ii. Compute c_out = (dc == 1 ? c : (2*Q - 1 - c)).\n      iii. Set output[r_out][c_out] = X.\n6. Return the output grid.",
    "ac0a08a4.json": "1. Let H = number of rows in the input grid and W = number of columns in the input grid.\n2. Identify all cells (r,c) where input[r][c] ≠ 0. Let k = total count of these non-zero cells.\n3. Compute output grid dimensions: H_out = H × k, W_out = W × k. Create an output grid of size H_out × W_out and initialize every cell to 0.\n4. For each input cell at row r from 0 to H−1 and column c from 0 to W−1:\n     a. Let v = input[r][c].\n     b. For dr from 0 to k−1 and dc from 0 to k−1, set output[r*k + dr][c*k + dc] = v.\n5. Return the output grid.",
    "d90796e8.json": "1. Copy the input grid to a new output grid of identical dimensions. 2. Define orthogonal neighbors as cells sharing a side (up, down, left, right). 3. Initialize empty lists coords_to_cyan and coords_to_black. 4. For each position (r,c) in the input grid: reference input values only. If input[r][c]==3 (green) and at least one orthogonal neighbor input[nr][nc]==2 (red), append (r,c) to coords_to_cyan. If input[r][c]==2 (red) and at least one orthogonal neighbor input[nr][nc]==3 (green), append (r,c) to coords_to_black. 5. For each coordinate in coords_to_cyan, set output[r][c]=8 (cyan). 6. For each coordinate in coords_to_black, set output[r][c]=0 (black). 7. Leave all other cells in output unchanged. 8. Return the output grid.",
    "d9fac9be.json": "1. Let H = number of rows in the input grid and W = number of columns.  \n2. For each row index r from 0 to H-3 inclusive and each column index c from 0 to W-3 inclusive, do steps 3–5:  \n3. Extract the 3×3 subgrid S with top-left corner at (r, c).  \n4. Let center = S[1][1].  Let neighbors = the values at S[0][0], S[0][1], S[0][2], S[1][0], S[1][2], S[2][0], S[2][1], S[2][2].  \n5. If all entries in neighbors are equal to some value B and B ≠ center, then:  \n   a. Create an output grid of size 1×1.  \n   b. Set its only cell to center.  \n   c. Return this output grid and stop.",
    "496994bd.json": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Determine P as the number of consecutive rows from the top that contain at least one cell with value != 0: scan rows r from 0 to H-1; the first r where all W cells are 0 defines P = r. If no such row exists, set P = H.\n3. Initialize the output grid as an exact copy of the input grid.\n4. For each k in 0..P-1:\n   a. Compute source_row = P-1-k.\n   b. Compute dest_row = H-P+k.\n   c. For each column c in 0..W-1, set output[dest_row][c] = input[source_row][c].\n5. Return the output grid.",
    "dae9d2b5.json": "1. Let G be the input grid of size 3 rows x 6 columns. 2. Create an output grid O of size 3 rows x 3 columns, initializing all cells to 0. 3. For each row R in 0..2 and each column C in 0..2: if G[R][C] == 4 or G[R][C+3] == 3 then set O[R][C] = 6 else leave O[R][C] = 0. 4. Return O.",
    "49d1d64f.json": "1. Let m = number of rows in the input grid and n = number of columns.  \n2. Create an output grid of size (m+2) rows by (n+2) columns.  \n3. Initialize every cell of the output grid to 0.  \n4. Copy the input grid into the central subgrid of the output:  \n   For each i from 0 to m-1, for each j from 0 to n-1, set output[i+1][j+1] = input[i][j].  \n5. Fill the top border of the output (row 0, columns 1 through n):  \n   For each j from 0 to n-1, set output[0][j+1] = input[0][j].  \n6. Fill the bottom border of the output (row m+1, columns 1 through n):  \n   For each j from 0 to n-1, set output[m+1][j+1] = input[m-1][j].  \n7. Fill the left border of the output (column 0, rows 1 through m):  \n   For each i from 0 to m-1, set output[i+1][0] = input[i][0].  \n8. Fill the right border of the output (column n+1, rows 1 through m):  \n   For each i from 0 to m-1, set output[i+1][n+1] = input[i][n-1].  \n9. Leave the four corner cells of the output at (0,0), (0,n+1), (m+1,0) and (m+1,n+1) equal to 0.",
    "4be741c5.json": "1. Let m = number of rows and n = number of columns of the input grid. 2. Compute the set C of all distinct pixel values present in the input grid. 3. For each value c in C, scan the grid to determine:   a. minRow[c] = smallest row index i (0 ≤ i < m) such that grid[i][j] == c for some j.   b. maxRow[c] = largest row index i such that grid[i][j] == c for some j.   c. minCol[c] = smallest column index j (0 ≤ j < n) such that grid[i][j] == c for some i.   d. maxCol[c] = largest column index j such that grid[i][j] == c for some i.   e. rowSpan[c] = maxRow[c] − minRow[c] + 1.   f. colSpan[c] = maxCol[c] − minCol[c] + 1. 4. Compute maxRowSpan = max(rowSpan[c] for c in C) and maxColSpan = max(colSpan[c] for c in C). 5. If maxRowSpan > maxColSpan then stripes run vertically (side-by-side):   a. Sort the values in C by increasing minCol[c].   b. Create an output grid of size 1 × |C|.   c. For k from 0 to |C|−1, set output[0][k] = the k-th value in the sorted list. Else stripes run horizontally (stacked top-to-bottom):   a. Sort the values in C by increasing minRow[c].   b. Create an output grid of size |C| × 1.   c. For k from 0 to |C|−1, set output[k][0] = the k-th value in the sorted list. 6. Return the output grid.",
    "ae3edfdc.json": "1. Create an output grid of the same dimensions as the input grid and fill every cell with 0.\n2. Scan the input grid to find the unique red center (cell value 2). Record its coordinates as (r_red, c_red).\n3. Scan the input grid to find the unique blue center (cell value 1). Record its coordinates as (r_blue, c_blue).\n4. In the output grid, set output[r_red][c_red] = 2.\n5. In the output grid, set output[r_blue][c_blue] = 1.\n6. For each cell (r, c) in the input grid with value 3 (green):\n   a. If r == r_red and c < c_red, set output[r_red][c_red - 1] = 3.\n   b. If r == r_red and c > c_red, set output[r_red][c_red + 1] = 3.\n   c. If c == c_red and r < r_red, set output[r_red - 1][c_red] = 3.\n   d. If c == c_red and r > r_red, set output[r_red + 1][c_red] = 3.\n7. For each cell (r, c) in the input grid with value 7 (orange):\n   a. If r == r_blue and c < c_blue, set output[r_blue][c_blue - 1] = 7.\n   b. If r == r_blue and c > c_blue, set output[r_blue][c_blue + 1] = 7.\n   c. If c == c_blue and r < r_blue, set output[r_blue - 1][c_blue] = 7.\n   d. If c == c_blue and r > r_blue, set output[r_blue + 1][c_blue] = 7.\n8. Return the output grid.",
    "d9f24cd1.json": "1. Let H = number of rows, W = number of columns. Use 0-based row indices 0..H-1 and column indices 0..W-1. Copy the input grid into the output grid.\n2. For each column c in 0..W-1 where input[H-1][c] == 2:\n   a. Set r = H-1 and col = c.\n   b. While r > 0 do:\n      i. If input[r-1][col] != 5 then:\n         - Set output[r-1][col] = 2; r = r - 1.\n      ii. Else:\n         - Set output[r][col+1] = 2; col = col + 1.\n3. Return the output grid.",
    "48d8fb45.json": "1. Scan the input grid to find the unique marker cell M with value 5; record its coordinates (r0,c0).  \n2. Examine the four orthogonal neighbors of M: positions (r0-1,c0), (r0+1,c0), (r0,c0-1), (r0,c0+1) that lie within the grid. Identify any neighbor(s) whose value v is nonzero and not 5; call this common value C.  \n3. Perform a flood fill to collect the connected region R of color C:  \n   a. Initialize a queue Q with all neighbor coordinates of value C.  \n   b. Initialize a set R containing these coordinates.  \n   c. While Q is nonempty, pop (r,c); for each of its four orthogonal neighbors (r±1,c) and (r,c±1) within bounds, if that neighbor has value C and is not already in R, add it to R and enqueue it.  \n4. After flood fill, compute the minimal bounding rectangle of R:  \n   r_min = min(r for (r,c) in R),  r_max = max(r for (r,c) in R)  \n   c_min = min(c for (r,c) in R),  c_max = max(c for (r,c) in R)  \n5. Let H = r_max - r_min + 1 and W = c_max - c_min + 1. Create an output grid of size H×W.  \n6. For each output cell at (i,j) with 0 ≤ i < H and 0 ≤ j < W, compute the corresponding input coordinates r = r_min + i, c = c_min + j.  \n   If input_grid[r][c] == C, set output[i][j] = C; otherwise set output[i][j] = 0.  \n7. Return the output grid.",
    "db93a21d.json": "1. Identify all connected components of pixels with value 9 using 4‐connectivity.  \n2. For each component:  \n   a. Compute r_min = minimum row index of its cells, r_max = maximum row index; c_min = minimum column index, c_max = maximum column index.  \n   b. Compute size = r_max - r_min + 1 (== c_max - c_min + 1).  \n   c. Compute border_thickness = size / 2.  \n3. Draw the green border (value 3) around each component:  \n   For r from (r_min - border_thickness) to (r_max + border_thickness):  \n     For c from (c_min - border_thickness) to (c_max + border_thickness):  \n       If (r,c) is inside the grid bounds AND not inside the original box (r_min ≤ r ≤ r_max AND c_min ≤ c ≤ c_max) AND grid[r][c] == 0, then set grid[r][c] = 3.  \n4. Draw the vertical blue fill (value 1) under each component:  \n   Let start_row = r_max + border_thickness + 1.  \n   For r from start_row to last row index:  \n     For c from c_min to c_max:  \n       If grid[r][c] == 0, then set grid[r][c] = 1.  \n5. Leave all other cells unchanged and return the grid of the same size.",
    "4c4377d9.json": "1. Let H be the number of rows in the input grid and W be the number of columns.\n2. Initialize an output grid of size (2 * H) rows and W columns.\n3. Use 0‐based indexing: rows 0..H−1, columns 0..W−1 for the input, and rows 0..2H−1 for the output.\n4. For each r in 0..H−1 and each c in 0..W−1:\n   a. Set output[H + r][c] = input[r][c].\n   b. Set output[H − 1 − r][c] = input[r][c].\n5. Return the output grid.",
    "469497ad.json": "1. Let input be a 5×5 grid with values 0–9, where 0=black and other integers represent colors. 2. Compute S = set of unique values in input excluding 0. 3. Let f = |S|. 4. Initialize an output grid of size (5·f)×(5·f) with all entries = 0. 5. For each input cell at (r,c) with value v>0, for i from 0 to f−1 and j from 0 to f−1 set output[r·f + i, c·f + j] = v. 6. Identify square_color = the value >0 whose count in the input = 4. 7. Locate the minimal (r0,c0) such that input[r0,c0], input[r0,c0+1], input[r0+1,c0], input[r0+1,c0+1] all = square_color. 8. Compute row_min = r0·f, row_max = (r0+2)·f − 1, col_min = c0·f, col_max = (c0+2)·f − 1. 9. Define corners: TL = (row_min, col_min), TR = (row_min, col_max), BL = (row_max, col_min), BR = (row_max, col_max). 10. For each corner and its direction d: TL→(−1,−1), TR→(−1,+1), BL→(+1,−1), BR→(+1,+1):\n    a. For step = 1 to f:\n       i. Let (R,C) = corner + step·d.\n       ii. If R<0 or R≥5·f or C<0 or C≥5·f or output[R,C]≠0 then break this loop.\n       iii. Otherwise set output[R,C] = 2. 11. Return the output grid.",
    "aedd82e4.json": "1. Let G be the input grid of size R x C. Create H as an exact copy of G.\n2. Initialize a boolean array visited of size R x C, all false.\n3. For each r in 0..R-1 and each c in 0..C-1:\n   If G[r][c]==2 and visited[r][c]==false then:\n     a. Initialize empty list component and stack with (r,c).\n     b. While stack not empty:\n        i. Pop (i,j) from stack.\n        ii. If visited[i][j] then continue.\n        iii. Set visited[i][j]=true and append (i,j) to component.\n        iv. For each neighbor (ni,nj) in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\n             If 0<=ni<R and 0<=nj<C and G[ni][nj]==2 and visited[ni][nj]==false then push (ni,nj) onto stack.\n     c. If component size equals 1 then let (i0,j0)=component[0] and set H[i0][j0]=1.\n4. Return H as the output grid.",
    "af902bf9.json": "1. Scan the input grid to record all coordinates (r,c) where grid[r][c] == 4.\n2. For every pair of distinct row indices r1 < r2 and distinct column indices c1 < c2, if grid[r1][c1] == 4, grid[r1][c2] == 4, grid[r2][c1] == 4 and grid[r2][c2] == 4, then define a rectangle with corners (r1,c1),(r1,c2),(r2,c1),(r2,c2).\n3. For each such rectangle, for each row r from r1+1 to r2-1 and each column c from c1+1 to c2-1, set grid[r][c] = 2.\n4. Preserve all other pixel values and the original grid dimensions.",
    "db3e9e38.json": "1. Let H be the number of rows and W be the number of columns of the input grid. Initialize the output grid as a copy of the input grid. 2. Identify all coordinates (r,c) where input[r][c] != 0. Verify they share the same column, call it col0. Extract rowIndices as the sorted list of these r values; let rowStart = rowIndices[0] and let N = length of rowIndices. 3. Define originalColor = input[rowStart][col0] and alternateColor = 8. 4. For i from 0 to N-1: set r = rowStart + i and M = N - i - 1; then for each h from -M to M: compute cNew = col0 + h; if 0 <= cNew < W then if abs(h) mod 2 == 0 set output[r][cNew] = originalColor else set output[r][cNew] = alternateColor. 5. Return the output grid.",
    "ae4f1146.json": "1. Let grid be the input 2D array of integers and let H = number of rows, W = number of columns.\n2. Initialize best_count = -1 and best_block = null.\n3. For each row index r from 0 to H-3 inclusive:\n   For each column index c from 0 to W-3 inclusive:\n     a. Define a 3×3 subgrid B where B[i][j] = grid[r+i][c+j] for i, j in {0,1,2}.\n     b. If any cell in B equals 0, then continue to the next (r,c).\n     c. Let count_1 = the number of cells in B equal to 1.\n     d. If count_1 > best_count, then set best_count = count_1 and best_block = B.\n4. Return best_block as the output (a 3×3 array of integers).",
    "d687bc17.json": "1. Let H = number of rows, W = number of columns. Use 0-based indexes: rows r∈[0..H-1], cols c∈[0..W-1]. Define interior cells as those with 1 ≤ r ≤ H−2 and 1 ≤ c ≤ W−2.\n2. Read border‐side colors from the input grid:\n   • c_top = input[0][1]\n   • c_right = input[1][W−1]\n   • c_bottom = input[H−1][1]\n   • c_left = input[1][0]\n   (Each is uniform along its side.)\n3. Initialize output grid as a copy of the input grid.\n4. Clear the entire interior of the output grid: for all r∈[1..H−2], c∈[1..W−2], set output[r][c] = 0.\n5. For each interior cell (r,c) of the input grid with value v = input[r][c] ≠ 0:\n   a. If v == c_top, set output[1][c] = c_top.\n   b. If v == c_right, set output[r][W−2] = c_right.\n   c. If v == c_bottom, set output[H−2][c] = c_bottom.\n   d. If v == c_left, set output[r][1] = c_left.\n   (Ignore any v that does not equal one of c_top,c_right,c_bottom,c_left.)\n6. Leave all border cells (any with r=0 or r=H−1 or c=0 or c=W−1) unchanged in the output.\n7. Return the output grid.",
    "3631a71a.json": "1. Let G be the input grid of size N×N (rows 0..N-1, cols 0..N-1).  \n2. Identify shapeColor:  \n   a. Initialize an empty map count.  \n   b. For each r in 0..N-1 and c in 0..N-1:  \n      if G[r][c] ≠ G[c][r], increment count[G[r][c]] by 1.  \n   c. Set shapeColor to the key v in count with the largest count.  \n3. Create output grid O of size N×N.  \n4. For each r in 0..N-1 and c in 0..N-1:  \n   if G[r][c] = shapeColor then  \n      set O[r][c] = G[c][r]  \n   else  \n      set O[r][c] = G[r][c]  \n5. Return O.",
    "b1948b0a.json": "1. Let G be the input grid of size R×C.\n2. Compute the set U of unique values in G; require |U| = 2.\n3. Identify other_color = the single element of U not equal to 7.\n4. Initialize an output grid H of size R×C.\n5. For each row r from 0 to R-1 and each column c from 0 to C-1:\n   a. If G[r][c] == other_color, set H[r][c] = 2.\n   b. Otherwise, set H[r][c] = G[r][c].\n6. Return H.",
    "dc433765.json": "1. Copy the input grid to an output grid.\n2. Scan the input grid to locate the unique cell (r3, c3) with value 3.\n3. Scan the input grid to locate the unique cell (r4, c4) with value 4.\n4. Compute row_offset: if r4 > r3 then 1; if r4 < r3 then -1; otherwise 0.\n5. Compute col_offset: if c4 > c3 then 1; if c4 < c3 then -1; otherwise 0.\n6. In the output grid, set cell (r3, c3) = 0.\n7. In the output grid, set cell (r3 + row_offset, c3 + col_offset) = 3.\n8. Return the output grid.",
    "dbc1a6ce.json": "1. Let H = number of rows in input_grid, W = number of columns. Create output_grid as a copy of input_grid.  \n2. For each row r from 0 to H-1:  \n   a. Let row_cols = sorted list of all c such that input_grid[r][c] == 1.  \n   b. For each consecutive pair (c_start, c_end) in row_cols:  \n      i. For each c in range(c_start+1, c_end): set output_grid[r][c] = 8.  \n3. For each column c from 0 to W-1:  \n   a. Let col_rows = sorted list of all r such that input_grid[r][c] == 1.  \n   b. For each consecutive pair (r_start, r_end) in col_rows:  \n      i. For each r in range(r_start+1, r_end): set output_grid[r][c] = 8.  \n4. Return output_grid.",
    "50cb2852.json": "1. Let the input be a 2D grid of integers with H rows and W columns. 2. Create an output grid of the same size as the input, initializing it as an exact copy of the input grid. 3. Define the fill color F = 8. 4. For each cell at coordinates (r, c) with value v = input[r][c]:\n   a. If v == 0 or v == F, skip to the next cell.\n   b. Otherwise, check its four orthogonal neighbors:\n      – Up:    (r-1, c)\n      – Down:  (r+1, c)\n      – Left:  (r, c-1)\n      – Right: (r, c+1)\n   c. If all four neighbor coordinates are within the grid bounds and each neighbor’s input value equals v, then cell (r, c) is an interior cell of a shape of color v.\n   d. For each interior cell, set output[r][c] = F.\n5. Leave all other cells (background 0 and shape border cells) unchanged. 6. Return the output grid.",
    "dc1df850.json": "1. Let input_grid be the original grid of size H rows by W columns. 2. Initialize output_grid[r][c] = input_grid[r][c] for all 0 ≤ r < H and 0 ≤ c < W. 3. For each r in 0..H-1 and each c in 0..W-1: if input_grid[r][c] == 2 then\n   a. For each dr in {-1,0,1}:\n      For each dc in {-1,0,1}:\n         i. If dr == 0 and dc == 0, continue to next dc.\n         ii. Let nr = r + dr and nc = c + dc.\n         iii. If nr ≥ 0 and nr < H and nc ≥ 0 and nc < W and input_grid[nr][nc] == 0, then set output_grid[nr][nc] = 1. 4. Return output_grid.",
    "9aec4887.json": "1. Identify the bounding box of the ring shape:\n   a. Let Ring = { (r,c) | grid[r][c] != 0 and grid[r][c] != 8 }.\n   b. Let r0 = min r, r1 = max r, c0 = min c, c1 = max c over Ring.\n   c. Compute H = r1 - r0 + 1, W = c1 - c0 + 1.\n2. Extract rect[0..H-1][0..W-1] = subgrid grid[r0..r1][c0..c1].\n3. Identify the 8-shape bounding box:\n   a. Let Shape = { (r,c) | grid[r][c] == 8 }.\n   b. Let sr0 = min r, sr1 = max r, sc0 = min c, sc1 = max c over Shape.\n   c. Compute h = sr1 - sr0 + 1, w = sc1 - sc0 + 1. Assert h == H-2 and w == W-2.\n4. Insert the 8-shape into rect:\n   For each (r,c) in Shape:\n     i = r - sr0 + 1; j = c - sc0 + 1;\n     Set rect[i][j] = 8.\n5. Recolor adjacent 8s to border colors on each side:\n   For each side in {top, bottom, left, right} do:\n     a. Determine Adj and side parameters:\n        - Top: i=1; side_len=W-2; Adj = { j | 1≤j≤W-2 and rect[1][j]==8 }; border_color[j]=rect[0][j].\n        - Bottom: i=H-2; side_len=W-2; Adj = { j | 1≤j≤W-2 and rect[H-2][j]==8 }; border_color[j]=rect[H-1][j].\n        - Left: j=1; side_len=H-2; Adj = { i | 1≤i≤H-2 and rect[i][1]==8 }; border_color[i]=rect[i][0].\n        - Right: j=W-2; side_len=H-2; Adj = { i | 1≤i≤H-2 and rect[i][W-2]==8 }; border_color[i]=rect[i][W-1].\n     b. If Adj is empty, continue to next side.\n     c. If |Adj| == 1: for k in Adj set rect[...] = border_color[k].\n     d. Else:\n        i. If side_len even: mid_set = { side_len/2, side_len/2+1 } else mid_set = { ceil(side_len/2) }.\n        ii. Let Direct = Adj ∩ mid_set.\n        iii. If Direct non-empty: recolor k in Direct to border_color[k].\n        iv. Else if side_len odd:\n             mid = ceil(side_len/2).\n             Compute d_k = |k - mid| for k in Adj; let d_min = min d_k.\n             Let Closest = { k in Adj | |k-mid| == d_min }.\n             Recolor k in Closest to border_color[k].\n6. Return rect as the output grid.",
    "b190f7f5.json": "1. Let H = number of rows of the input grid and W = number of columns. Let N = min(H, W). Verify that max(H, W) = 2 * N.\n2. Determine orientation: if W = 2 * N then the two N×N blocks lie side by side (horizontal); if H = 2 * N then they lie one above the other (vertical).\n3. Define two N×N subgrids: subgrid0 starts at (r0, c0) = (0, 0); subgrid1 starts at (r1, c1) = (0, N) if W = 2 * N, else (N, 0) if H = 2 * N. Extract each subgrid by taking N rows and N columns from its start.\n4. For k in {0,1}, compute the set S_k of non-zero values in subgrid_k. Identify the template subgrid L as the one with |S_k| = 1, and let M be the other subgrid.\n5. Build a boolean pattern_mask of size N×N where pattern_mask[i][j] = (L[i][j] != 0).\n6. Initialize an output grid of size (N * N) rows by (N * N) columns, filled with 0.\n7. For each r in 0..N-1 and c in 0..N-1:\n   a. Let color = M[r][c].\n   b. For each i in 0..N-1 and j in 0..N-1: if pattern_mask[i][j] then set output[r * N + i][c * N + j] = color.\n8. Return the output grid.",
    "ddf7fa4f.json": "1. Let H = number of rows and W = number of columns of the input grid. 2. Create output_grid as a copy of the input grid. 3. Create a boolean array visited of size H×W, initialized to false. 4. For each cell (r,c) in row-major order:   a. If input_grid[r][c] == 5 and visited[r][c] == false, then begin processing a new gray region:     i. Initialize an empty list component.     ii. Perform a breadth-first or depth-first search from (r,c) using 4-directional connectivity, adding each reached cell (r2,c2) with input_grid[r2][c2] == 5 to component and marking visited[r2][c2] = true.    iii. Let C be the set of all distinct column indices c2 for (r2,c2) in component.    iv. For each col in C, if input_grid[0][col] != 0 then set fill_color = input_grid[0][col] and break.     v. For each (r2,c2) in component, set output_grid[r2][c2] = fill_color. 5. After all cells are processed, return output_grid.",
    "484b58aa.json": "1. Let H be the number of rows and W be the number of columns of the input grid.\n2. Compute the minimal vertical period Q:\n   a. For each q from 1 to H-1, check: for all r in [0, H-q) and all c in [0, W), if grid[r][c] ≠ 0 and grid[r+q][c] ≠ 0 then grid[r][c] == grid[r+q][c].\n   b. If such a q exists, set Q = the smallest such q; otherwise set Q = H.\n3. Compute the minimal horizontal period P:\n   a. For each p from 1 to W-1, check: for all r in [0, H) and all c in [0, W-p), if grid[r][c] ≠ 0 and grid[r][c+p] ≠ 0 then grid[r][c] == grid[r][c+p].\n   b. If such a p exists, set P = the smallest such p; otherwise set P = W.\n4. For each cell (r,c) with grid[r][c] == 0, fill using a nonzero periodic neighbor:\n   a. If r+Q < H and grid[r+Q][c] ≠ 0, set grid[r][c] = grid[r+Q][c] and continue to next cell.\n   b. Else if r–Q ≥ 0 and grid[r–Q][c] ≠ 0, set grid[r][c] = grid[r–Q][c] and continue.\n   c. Else if c+P < W and grid[r][c+P] ≠ 0, set grid[r][c] = grid[r][c+P] and continue.\n   d. Else if c–P ≥ 0 and grid[r][c–P] ≠ 0, set grid[r][c] = grid[r][c–P].\n5. Return the grid (size unchanged).",
    "4612dd53.json": "1. Let H = number of rows, W = number of columns. 2. Initialize an output grid as a copy of the input grid. 3. For each row index r from 0 to H-1:\n   a. Build a list C of all column indices c where input[r][c] == 1.\n   b. If |C| >= 4 then:\n      i. Sort C in ascending order.\n     ii. For each consecutive pair (c1, c2) in the sorted C list:\n         - For c = c1 + 1 to c2 - 1:\n             * If input[r][c] == 0 then set output[r][c] = 2.\n4. For each column index c from 0 to W-1:\n   a. Build a list R of all row indices r where input[r][c] == 1.\n   b. If |R| >= 4 then:\n      i. Sort R in ascending order.\n     ii. For each consecutive pair (r1, r2) in the sorted R list:\n         - For r = r1 + 1 to r2 - 1:\n             * If input[r][c] == 0 then set output[r][c] = 2.\n5. Return the output grid.",
    "5117e062.json": "1. Define G as the input grid with H rows and W columns. Treat pixel value 0 as background. 2. Identify all maximal 4-connected components S_i of pixels where G[r,c] != 0. 3. For each component S_i, form the multiset V_i of values G[r,c] for (r,c) in S_i. Select the component S* whose V* has exactly two distinct values and one of those values occurs exactly once. 4. Let special_color be the value in V* with frequency 1, and let shape_color be the other value. 5. Compute min_row = min(r), max_row = max(r), min_col = min(c), max_col = max(c) over all (r,c) in S*. 6. Create output grid O with (max_row−min_row+1) rows and (max_col−min_col+1) columns. For each output cell (r',c'), set O[r',c'] = G[min_row+r', min_col+c']. 7. In O, replace every cell equal to special_color with shape_color. 8. Return O.",
    "ded97339.json": "1. Let H = number of rows in the input grid, W = number of columns.\n2. Define the target value T = 8.\n3. For each row index r from 0 to H-1:\n   a. Collect the list C = { c | grid[r][c] == T }.\n   b. If |C| ≥ 2, let c_min = minimum(C), c_max = maximum(C).\n   c. For each column c from c_min to c_max inclusive, set grid[r][c] = T.\n4. For each column index c from 0 to W-1:\n   a. Collect the list R = { r | grid[r][c] == T }.\n   b. If |R| ≥ 2, let r_min = minimum(R), r_max = maximum(R).\n   c. For each row r from r_min to r_max inclusive, set grid[r][c] = T.\n5. Return the modified grid as the output.",
    "dc0a314f.json": "1. Let mask_color = 3. 2. Let H = number of rows and W = number of columns in the input grid. 3. Identify the top-left corner of the masked square:\n   a. Let r0 be the smallest row index such that input[r0][c] = mask_color for some c.\n   b. Let c0 be the smallest column index in row r0 with input[r0][c0] = mask_color.\n   c. Determine N by counting consecutive mask_color pixels to the right from (r0,c0) until a different value appears.\n4. Initialize an output grid of size N×N. 5. For each dy in 0..N-1 and each dx in 0..N-1:\n   a. Let r = r0 + dy and c = c0 + dx.\n   b. Compute c_v = W - 1 - c and r_h = H - 1 - r.\n   c. If input[r][c_v] ≠ mask_color then v = input[r][c_v];\n      else if input[r_h][c] ≠ mask_color then v = input[r_h][c];\n      else v = input[r_h][c_v].\n   d. Set output[dy][dx] = v.\n6. Return the output grid.",
    "aba27056.json": "1. Let G be the input grid of size H rows and W columns.\n2. Identify shape color C as the unique nonzero value in G.\n3. Compute bounding box of C:\n   minR = minimum r with G[r][c]==C;\n   maxR = maximum r with G[r][c]==C;\n   minC = minimum c with G[r][c]==C;\n   maxC = maximum c with G[r][c]==C.\n4. Determine gap side and gapCells:\n   a. If any G[minR][c]!=C for c in [minC..maxC], set side=\"top\" and gapCells = all (minR,c) with G[minR][c]!=C.\n   b. Else if any G[maxR][c]!=C, set side=\"bottom\" and gapCells = all (maxR,c) with G[maxR][c]!=C.\n   c. Else if any G[r][minC]!=C, set side=\"left\" and gapCells = all (r,minC) with G[r][minC]!=C.\n   d. Else set side=\"right\" and gapCells = all (r,maxC) with G[r][maxC]!=C.\n5. Initialize O as a copy of G.\n6. Fill the interior and gap: for r from minR to maxR and c from minC to maxC, if G[r][c]!=C then set O[r][c]=4.\n7. Draw cardinal rays:\n   a. Set dNorm = (-1,0) if side==\"top\", (1,0) if \"bottom\", (0,-1) if \"left\", (0,1) if \"right\".\n   b. For each (r0,c0) in gapCells:\n      r=r0 + dNorm.r; c=c0 + dNorm.c;\n      while 0<=r<H and 0<=c<W:\n        O[r][c]=4;\n        r+=dNorm.r; c+=dNorm.c;\n8. Draw diagonal rays:\n   a. If side in {\"top\",\"bottom\"} sort gapCells by c ascending; else sort by r ascending.\n   b. Let first = gapCells[0], last = gapCells[-1].\n   c. If side==\"top\" then diagFirst=(-1,-1), diagLast=(-1,1).\n      If side==\"bottom\" then diagFirst=(1,-1), diagLast=(1,1).\n      If side==\"left\" then diagFirst=(-1,-1), diagLast=(1,-1).\n      If side==\"right\" then diagFirst=(-1,1), diagLast=(1,1).\n   d. For (dr,dc),anchor in [(diagFirst,first),(diagLast,last)]:\n      r=anchor.r+dr; c=anchor.c+dc;\n      while 0<=r<H and 0<=c<W:\n        O[r][c]=4;\n        r+=dr; c+=dc;\n9. Return O as the transformed grid.",
    "d8c310e9.json": "1. Treat rows and columns as 0-indexed. Let B = 0 be the background value. Let H and W be the number of rows and columns in the input grid.\n2. Find rmin = minimum row r where any input[r][c] ≠ B; find rmax = maximum row r where any input[r][c] ≠ B.\n3. Find cmin = minimum column c where any input[r][c] ≠ B; find cmax = maximum column c where any input[r][c] ≠ B.\n4. Find smallest p > 0 such that for all r from rmin to rmax and all c from cmin to cmax - p, if input[r][c + p] ≠ B then input[r][c] = input[r][c + p].\n5. Extract base tile T of size (rmax - rmin + 1) rows and p columns: for i from 0 to rmax - rmin and j from 0 to p - 1, set T[i][j] = input[rmin + i][cmin + j].\n6. Initialize output grid as a copy of input grid.\n7. For each r from rmin to rmax and each c from cmin to W - 1, set output[r][c] = T[r - rmin][(c - cmin) mod p].\n8. Return the output grid.",
    "1f0c79e5.json": "1. Let H = number of rows in input grid, W = number of columns. 2. Scan all cells to find the minimal row index r0 and maximal row index r1 of any cell with value ≠0. Similarly find minimal column c0 and maximal column c1 of any cell with value ≠0. 3. Confirm that r1–r0 == c1–c0; let k = r1–r0+1. 4. Set marker_value = 2. 5. Within the square defined by rows [r0..r1] and cols [c0..c1], find fill_value = the nonzero value ≠ marker_value. 6. Define a list DIRECTIONS = empty. If input[r0][c0]==marker_value, add (dr,dc)=(-1,-1) to DIRECTIONS. If input[r0][c1]==marker_value, add (dr,dc)=(-1,+1). If input[r1][c0]==marker_value, add (dr,dc)=(+1,-1). If input[r1][c1]==marker_value, add (dr,dc)=(+1,+1). 7. Initialize output grid of size H×W with all zeros. 8. For each (dr,dc) in DIRECTIONS do:   a. For t from 0 upward do:     i. Set filled_any = false.     ii. For ri from r0 to r1, for ci from c0 to c1 do:         • Let rn = ri + dr*t, cn = ci + dc*t.         • If 0 ≤ rn < H and 0 ≤ cn < W then set output[rn][cn] = fill_value and set filled_any = true.     iii. If filled_any == false then break the loop over t. 9. Return the output grid.",
    "e179c5f4.json": "1. Let H be the number of rows and W be the number of columns of the input grid.\n2. Find the unique cell with value 1; let its coordinates be (start_row, start_col).\n3. Create an output grid of size H×W.\n4. Set snake_value = 1 and background_value = 8.\n5. Initialize current_col = start_col and dir = +1.\n6. For each row r from start_row down to 0 (inclusive):\n   a. If r < start_row:\n      i. Let tentative_col = current_col + dir.\n      ii. If tentative_col < 0 or tentative_col ≥ W, set dir = -dir and tentative_col = current_col + dir.\n      iii. Set current_col = tentative_col.\n   b. For each column c from 0 to W-1:\n      i. If c == current_col, set output[r,c] = snake_value; otherwise set output[r,c] = background_value.\n7. Return the output grid.",
    "4938f0c2.json": "1. Locate the green 2×2 block (value 3): compute g_r_min = minimum row index with grid[r][c]==3; g_r_max = maximum row index with grid[r][c]==3; g_c_min = minimum column index with grid[r][c]==3; g_c_max = maximum column index with grid[r][c]==3.\n2. Identify all connected components of value 2 using 4-connectivity. For each component i compute its bounding box r_min_i, r_max_i, c_min_i, c_max_i.\n3. For each component i determine its quadrant relative to the green block:\n   • TL if r_max_i == g_r_min - 1 and c_max_i == g_c_min - 1\n   • TR if r_max_i == g_r_min - 1 and c_min_i == g_c_max + 1\n   • BL if r_min_i == g_r_max + 1 and c_max_i == g_c_min - 1\n   • BR if r_min_i == g_r_max + 1 and c_min_i == g_c_max + 1\n4. If all four quadrants TL, TR, BL, BR are present, return the grid unchanged.\n5. Otherwise select one component as the base pattern: choose TL if exists, else TR, else BL, else BR. Let its bounding box be r_min_b, r_max_b, c_min_b, c_max_b, and let P = set of all (r,c) in this component. Compute pattern height h = r_max_b - r_min_b + 1 and width w = c_max_b - c_min_b + 1.\n6. For each missing quadrant Q compute its target origin (r0,c0):\n   • TL: r0 = g_r_min - h; c0 = g_c_min - w\n   • TR: r0 = g_r_min - h; c0 = g_c_max + 1\n   • BL: r0 = g_r_max + 1; c0 = g_c_min - w\n   • BR: r0 = g_r_max + 1; c0 = g_c_max + 1\n   Then for each (r,c) in P compute r_new = r + (r0 - r_min_b), c_new = c + (c0 - c_min_b) and set grid[r_new][c_new] = 2.\n7. Return the resulting grid.",
    "508bd3b6.json": "1. Let H be number of rows and W number of columns of the input grid.\n2. Collect all coordinates (r,c) where grid[r][c]==2 into set B. Compute rmin=min(r for (r,c) in B), rmax=max(r for (r,c) in B), cmin=min(c for (r,c) in B), cmax=max(c for (r,c) in B).\n3. Determine barrier side:\n   - if cmin==0 then side=left\n   - else if cmax==W-1 then side=right\n   - else if rmin==0 then side=top\n   - else side=bottom\n4. Define barrier_vector v_b:\n   - left: v_b=(0,-1)\n   - right: v_b=(0,1)\n   - top: v_b=(-1,0)\n   - bottom: v_b=(1,0)\n5. Collect all coordinates S where grid[r][c]==8.\n6. Sort S by r ascending. Let p1=S[0], p2=S[1]. Compute dr=p2.r-p1.r, dc=p2.c-p1.c. Define v_unit=(dr/abs(dr), dc/abs(dc)).\n7. Compute dot = v_unit.r*v_b.r + v_unit.c*v_b.c. If dot>0 then set e=v_unit; else set e=(-v_unit.r, -v_unit.c).\n8. Find start point: for each p in S compute q=(p.r+e.r, p.c+e.c). If q is inside grid (0≤q.r<H, 0≤q.c<W) and grid[q.r][q.c]==0 then set start=p and break.\n9. Extension phase: set pos=(start.r+e.r, start.c+e.c). While pos inside grid and grid[pos.r][pos.c]!=2:\n   - set grid[pos.r][pos.c]=3\n   - record last=pos\n   - pos=(pos.r+e.r, pos.c+e.c)\n10. Bounce phase: define e_bounce = (e.r, -e.c) if side is left or right, else e_bounce = (-e.r, e.c). Set pos=(last.r+e_bounce.r, last.c+e_bounce.c). While pos inside grid and grid[pos.r][pos.c]!=2:\n   - set grid[pos.r][pos.c]=3\n   - pos=(pos.r+e_bounce.r, pos.c+e_bounce.c)",
    "b27ca6d3.json": "1. Let R be the number of rows and C be the number of columns in the input grid. 2. Find all connected components of cells with value 2 (using 4-adjacency). 3. For each component with exactly two cells: 3.1. Compute its bounding box: let rmin = minimum row index, rmax = maximum row index, cmin = minimum column index, cmax = maximum column index over the two cells. 3.2. For each cell (r,c) such that rmin-1 ≤ r ≤ rmax+1 and cmin-1 ≤ c ≤ cmax+1 and (r == rmin-1 or r == rmax+1 or c == cmin-1 or c == cmax+1): if 0 ≤ r < R and 0 ≤ c < C and the current grid value at (r,c) is 0, set grid[r][c] = 3. 4. Leave all other cells unchanged and output the resulting grid.",
    "5168d44c.json": "1. Collect all coordinates (r,c) where grid[r][c] == 3. If all share the same r value, set orientation = horizontal; else set orientation = vertical.\n2. Collect all coordinates where grid[r][c] == 2. Compute r0 = min(r), r2 = max(r), c0 = min(c), c2 = max(c). Assert r2 - r0 == 2 and c2 - c0 == 2. Define block center at (r1 = r0+1, c1 = c0+1).\n3. Sort track positions:\n   - If orientation == horizontal, let trackCols = sorted unique c from step 1.\n   - If orientation == vertical, let trackRows = sorted unique r from step 1.\n4. Determine movement vector:\n   - If orientation == horizontal: find k such that trackCols[k] == c1; set new_c1 = trackCols[k+1], new_r1 = r1.\n   - If orientation == vertical: find k such that trackRows[k] == r1; set new_r1 = trackRows[k+1], new_c1 = c1.\n   - Compute dr = new_r1 - r1 and dc = new_c1 - c1.\n5. Initialize output grid as a copy of input grid.\n6. Remove original block outline: for r from r0 to r2 and c from c0 to c2, if input[r][c] == 2 then set output[r][c] = 0.\n7. Place block outline at new location: let new_r0 = r0 + dr and new_c0 = c0 + dc; for i in 0..2 and j in 0..2, if input[r0+i][c0+j] == 2 then set output[new_r0+i][new_c0+j] = 2.",
    "b230c067.json": "1. Scan the input grid to collect all coordinates (r, c) where grid[r][c] == 8.\n2. Group these coordinates into connected components using 4-adjacency (two pixels belong to the same component if one is directly above, below, left or right of the other and both have value 8).\n3. Compute the size of each component (the number of coordinates it contains). Identify the component with the smallest size as C_min and the remaining components as C_others.\n4. Initialize an output grid of the same dimensions and fill every cell with 0.\n5. For each coordinate in C_min, set output[r][c] = 2.\n6. For each coordinate in each component in C_others, set output[r][c] = 1.\n7. Leave all other cells as 0.",
    "e3497940.json": "1. Let R = number of rows and C = number of columns of the input grid.\n2. Identify the divider column index D such that for every row r in [0, R) the cell input[r][D] = 5.\n3. Set output_width = D.\n4. Initialize an output grid of size R × output_width with all cells = 0.\n5. For each row r from 0 to R-1:\n   a. For each column c from 0 to D-1:\n      i. If input[r][c] ≠ 0 then set output[r][c] = input[r][c].\n   b. For each column c from D+1 to C-1:\n      i. If input[r][c] ≠ 0 then compute distance d = c - D, compute new_c = D - d, and set output[r][new_c] = input[r][c].\n6. Return the output grid.",
    "b548a754.json": "1. Scan the grid to count occurrences of each nonzero integer. Identify V_dot as the integer with exactly one occurrence; let (R_dot,C_dot) be its coordinates. 2. Collect all coordinates (r,c) where grid[r][c] != 0 and grid[r][c] != V_dot. Compute R_min = min(r), R_max = max(r), C_min = min(c), C_max = max(c). 3. Set border_color = grid[R_min][C_min]. Set fill_color = grid[R_min+1][C_min+1]. 4. Compute R_min_new = min(R_min,R_dot), R_max_new = max(R_max,R_dot), C_min_new = min(C_min,C_dot), C_max_new = max(C_max,C_dot). 5. For r from R_min_new to R_max_new and c from C_min_new to C_max_new: if r == R_min_new or r == R_max_new or c == C_min_new or c == C_max_new then set grid[r][c] = border_color else set grid[r][c] = fill_color. 6. Return the modified grid.",
    "b60334d2.json": "1. Let H be the number of rows and W be the number of columns of the input grid.\n2. Create an output grid of size H by W and initialize all cells to 0.\n3. For each cell (r,c) in the input grid with value 5:\n   a. Set output[r][c] = 0.\n   b. For each orthogonal offset (dr,dc) in {(-1,0),(1,0),(0,-1),(0,1)}: if 0 <= r+dr < H and 0 <= c+dc < W then set output[r+dr][c+dc] = 1.\n   c. For each diagonal offset (dr,dc) in {(-1,-1),(-1,1),(1,-1),(1,1)}: if 0 <= r+dr < H and 0 <= c+dc < W then set output[r+dr][c+dc] = 5.\n4. Return the output grid.",
    "54d9e175.json": "1. Let H be the number of rows and W the number of columns of the input grid.\n2. Identify all horizontal separator rows: those row indices R where for every column C in [0..W-1], input[R][C] == 5.\n3. Identify all vertical separator columns: those column indices C where for every row R in [0..H-1], input[R][C] == 5.\n4. Determine non-separator row segments by grouping consecutive row indices not in the horizontal separator set into ranges [r_start, r_end].\n5. Determine non-separator column segments by grouping consecutive column indices not in the vertical separator set into ranges [c_start, c_end].\n6. Initialize the output grid as a copy of the input grid.\n7. For each row segment [r_start, r_end] and each column segment [c_start, c_end]:\n   a. Compute center_r = r_start + floor((r_end - r_start) / 2) and center_c = c_start + floor((c_end - c_start) / 2).\n   b. Let c = input[center_r][center_c]. Compute new_color = c + 5.\n   c. For all r in [r_start..r_end] and C in [c_start..c_end], set output[r][C] = new_color.\n8. Return the output grid.",
    "7837ac64.json": "1. Let G be the input grid of size R×C.  \n2. Compute line_color: find the nonzero value v>0 that occurs most frequently in G.  \n3. Compute shape_rows: the sorted list of all row indices r such that there exists a column c with G[r][c] ≠ 0 and G[r][c] ≠ line_color.  \n4. Compute shape_cols: the sorted list of all column indices c such that there exists a row r with G[r][c] ≠ 0 and G[r][c] ≠ line_color.  \n5. Let H = shape_rows.length - 1 and W = shape_cols.length - 1.  \n6. Initialize output grid O of size H×W with all entries = 0.  \n7. For i in 0 to H-1 do:  \n   a. Let r1 = shape_rows[i], r2 = shape_rows[i+1].  \n   b. For j in 0 to W-1 do:  \n      i. Let c1 = shape_cols[j], c2 = shape_cols[j+1].  \n      ii. Let v = G[r1][c1].  \n      iii. If v ≠ 0 and v ≠ line_color and G[r1][c2] == v and G[r2][c1] == v and G[r2][c2] == v then set O[i][j] = v.  \n8. Return O as the transformed grid.",
    "5582e5ca.json": "1. Let the input be a 3×3 grid of integer pixel values (0–9).  \n2. Initialize an empty map count[value] = 0 for all possible values.  \n3. For each cell (r, c) in the input grid:  \n   a. Let v = input[r][c].  \n   b. Increment count[v] by 1.  \n4. Identify the integer v_max for which count[v_max] is strictly greater than count[w] for any other w.  \n5. Construct the output grid of size 3×3.  \n6. For each cell (r, c) in the output grid, set output[r][c] = v_max.  \n7. Return the output grid.",
    "a8c38be5.json": "1. Let VOID=0 and BG=5.  Let H and W be input grid height and width.  Initialize an output grid OUT of size 9×9 filled with BG.\n2. For each integer r from 0 to H−3 and each integer c from 0 to W−3 do:\n   a. Extract a 3×3 block B where B[dr][dc]=INPUT[r+dr][c+dc] for dr,dc in {0,1,2}.\n   b. If every B[dr][dc]≠VOID then:\n      i. Let S = {(dr,dc)│B[dr][dc]≠BG}  ▸ set of shape‐cell coordinates in B.\n      ii. Compute four booleans:\n          • T = any dr==0 for (dr,dc) in S  ▸ touches top edge\n          • Bm= any dr==2 for (dr,dc) in S  ▸ touches bottom\n          • L = any dc==0 for (dr,dc) in S  ▸ touches left\n          • R = any dc==2 for (dr,dc) in S  ▸ touches right\n      iii. Determine block_row:\n          if T and not Bm then block_row=0\n          else if Bm and not T then block_row=2\n          else block_row=1\n      iv. Determine block_col:\n          if L and not R then block_col=0\n          else if R and not L then block_col=2\n          else block_col=1\n      v. For dr,dc in {0,1,2}, set OUT[block_row*3+dr][block_col*3+dc] = B[dr][dc].\n3. Return OUT as the 9×9 result.",
    "54d82841.json": "1. Let H be the number of rows and W be the number of columns of the input grid.\n2. Create an output grid as an exact copy of the input grid.\n3. Initialize an empty set visited and an empty list centers.\n4. Iterate over each cell (r,c) in the input grid:\n   a. If input[r][c] == 0 or (r,c) is in visited, skip.\n   b. Otherwise, let C = input[r][c].\n   c. Perform a 4-connected flood fill from (r,c) to collect all cells of value C into component comp.\n   d. Add all cells in comp to visited.\n   e. Compute min_r = minimum row in comp, max_r = maximum row in comp, min_c = minimum column in comp, max_c = maximum column in comp.\n   f. If comp size == 5 AND (max_r - min_r + 1) == 2 AND (max_c - min_c + 1) == 3, then:\n      i. Compute center_c = min_c + 1.\n      ii. Append center_c to centers.\n5. For each center_c in centers, set output_grid[H-1][center_c] = 4.\n6. Return the output grid.",
    "b2862040.json": "1. Let G be the input grid of size H x W. Define constants BACK=9, SHAPE=1, NEW=8.\n2. Label all 4-connected components of BACK pixels: create array BgComp of size H×W initialized to 0. For each cell (r,c) where G[r,c]==BACK and BgComp[r,c]==0, run a flood-fill (BFS/DFS) over 4-neighbors to assign a new component id b to all reachable BACK cells, storing b in BgComp.\n3. Compute InteriorBgIds = { b | no cell (r,c) with BgComp[r,c]==b lies on row 0 or row H−1 or column 0 or column W−1 }.\n4. Label all 4-connected components of SHAPE pixels: create array ShapeComp of size H×W initialized to 0. For each cell (r,c) where G[r,c]==SHAPE and ShapeComp[r,c]==0, run a flood-fill over 4-neighbors to assign a new component id s to all reachable SHAPE cells, storing s in ShapeComp.\n5. Initialize ClosedShapeIds = empty set. For each cell (r,c) with G[r,c]==BACK and BgComp[r,c]∈InteriorBgIds, examine its 4-neighbors (nr,nc) in bounds; if G[nr,nc]==SHAPE then add ShapeComp[nr,nc] to ClosedShapeIds.\n6. For each cell (r,c): if G[r,c]==SHAPE and ShapeComp[r,c]∈ClosedShapeIds then set G[r,c]=NEW.\n7. Return the modified grid G as the output.",
    "b6afb2da.json": "1. Let H be the number of rows and W be the number of columns in the input grid. Index rows r from 0 to H-1 (top to bottom) and columns c from 0 to W-1 (left to right).\n2. Create the output grid as an exact copy of the input grid.\n3. Find all connected components of pixels with value 5 using 4-neighbor connectivity (two pixels are connected if one is directly above, below, left, or right of the other).\n4. For each connected component of value-5 pixels:\n   a. Compute rMin = minimum r index among the component’s pixels, rMax = maximum r index, cMin = minimum c index, and cMax = maximum c index.\n   b. For each r in [rMin..rMax] and each c in [cMin..cMax], if input[r][c] == 5 then:\n      i. If (r == rMin or r == rMax) and (c == cMin or c == cMax) then set output[r][c] = 1.\n      ii. Else if (r == rMin or r == rMax or c == cMin or c == cMax) then set output[r][c] = 4.\n      iii. Else set output[r][c] = 2.\n5. Return the output grid.",
    "543a7ed5.json": "1. Let H and W be the number of rows and columns of the input grid G. Create an output grid O as a copy of G.  \n2. Identify all 4-connected components of cells in G whose value is 6.  \n3. For each component C:  \n   a. Compute its bounding box: minR = minimum row index of C, maxR = maximum row index of C, minC = minimum column index of C, maxC = maximum column index of C.  \n   b. Fill the interior of the box: for each r in minR+1..maxR-1 and c in minC+1..maxC-1, if G[r][c] ≠ 6 then set O[r][c] = 4.  \n   c. Draw the external outline: for each r in minR-1..maxR+1 and c in minC-1..maxC+1, if r<0 or r≥H or c<0 or c≥W skip; else if (r == minR-1 or r == maxR+1 or c == minC-1 or c == maxC+1) and G[r][c] ≠ 6 then set O[r][c] = 3.  \n4. Return O.",
    "e48d4e1a.json": "1. Let R be the number of rows and C the number of columns of the input grid (here R=C=10).\n2. Compute N = total count of cells whose value is 5.\n3. Determine the cross color value c: find the unique integer in the grid not equal to 0 or 5.\n4. Locate the original horizontal line:\n   a. For each row i from 0 to R-1, if every cell in row i has value c, set H = i and stop.\n5. Locate the original vertical line:\n   a. For each column j from 0 to C-1, if every cell in column j has value c, set V = j and stop.\n6. Compute the shifted positions:\n   a. H' = H + N\n   b. V' = V - N\n7. Initialize an output grid of size R×C with all cells = 0.\n8. Draw the shifted horizontal line:\n   a. For each column j from 0 to C-1, set output[H'][j] = c.\n9. Draw the shifted vertical line:\n   a. For each row i from 0 to R-1, set output[i][V'] = c.\n10. Return the output grid.",
    "56ff96f3.json": "1. Let input_grid be the given grid with R rows and C columns. 2. Create output_grid as a copy of input_grid. 3. Let Colors be the set of all values v>0 present in input_grid. 4. For each v in Colors:\n   a. Find all coordinates (r,c) where input_grid[r][c]==v. There will be exactly two such coordinates: (r1,c1) and (r2,c2).\n   b. Let r_min=min(r1,r2), r_max=max(r1,r2), c_min=min(c1,c2), c_max=max(c1,c2).\n   c. For each row r from r_min to r_max and each column c from c_min to c_max, set output_grid[r][c]=v.\n5. Return output_grid.",
    "e5062a87.json": "1. Copy input grid into outputGrid of size numRows×numCols.\n2. Locate all coordinates (r,c) where inputGrid[r][c] == 2; store in list redCoords.\n3. Compute minR = min(r), maxR = max(r) over redCoords; minC = min(c), maxC = max(c).\n4. Let shapeH = maxR - minR + 1 and shapeW = maxC - minC + 1.\n5. Define patternRelative = { (r - minR, c - minC) for each (r,c) in redCoords }.\n6. Initialize empty list placements.\n7. For r0 from 0 to numRows - shapeH:\n     For c0 from 0 to numCols - shapeW:\n         If for every (dr,dc) in patternRelative, inputGrid[r0+dr][c0+dc] == 0, then append (r0,c0) to placements.\n8. For each (r0,c0) in placements:\n     For each (dr,dc) in patternRelative:\n         Set outputGrid[r0+dr][c0+dc] = 2.\n9. Return outputGrid.",
    "5614dbcf.json": "1. Let H be the number of rows and W be the number of columns of the input grid.  \n2. Compute block_h = H ÷ 3 and block_w = W ÷ 3.  \n3. Initialize an empty output grid of size 3 rows by 3 columns.  \n4. For each block row br from 0 to 2 and each block column bc from 0 to 2:  \n   a. Define the subgrid S as all input pixels at (R,C) with R in [br*block_h, (br+1)*block_h - 1] and C in [bc*block_w, (bc+1)*block_w - 1].  \n   b. Collect list L of all values in S excluding any value equal to 5.  \n   c. Count the frequency of each value in L and let v be the value with the highest count.  \n   d. Set output[br][bc] = v.  \n5. Return the 3×3 output grid.",
    "e26a3af2.json": "1. Let H be the number of rows and W the number of columns of the input grid.\n2. For each row index r in 0..H-1:\n   a. Compute the frequency of each pixel value in row r.\n   b. Let rowMode[r] be the value with maximum frequency and rowModeCount[r] its count.\n3. For each column index c in 0..W-1:\n   a. Compute the frequency of each pixel value in column c.\n   b. Let colMode[c] be the value with maximum frequency and colModeCount[c] its count.\n4. Compute minRowPurity = minimum over r of (rowModeCount[r] / W).\n   Compute minColPurity = minimum over c of (colModeCount[c] / H).\n5. If minColPurity ≥ minRowPurity, set orientation = vertical; otherwise set orientation = horizontal.\n6. If orientation = vertical:\n   a. For each column c, define background[c] = colMode[c].\n   b. Scan c from 0 to W-1 to identify contiguous intervals [startC..endC] where background[c] is the same.\n   c. For each interval, for all rows r in 0..H-1 and columns c in startC..endC, set output[r][c] = background[startC].\n7. If orientation = horizontal:\n   a. For each row r, define background[r] = rowMode[r].\n   b. Scan r from 0 to H-1 to identify contiguous intervals [startR..endR] where background[r] is the same.\n   c. For each interval, for all rows r in startR..endR and columns c in 0..W-1, set output[r][c] = background[startR].\n8. Return the resulting grid.",
    "5521c0d9.json": "1. Let H = number of rows and W = number of columns of the input grid.\n2. Initialize an output grid of size H x W filled with 0.\n3. For each distinct non-zero color value v in the input grid:\n   3.1. Let coords = {(r, c) | input[r][c] == v}.\n   3.2. Compute min_r = min(r for (r, c) in coords) and max_r = max(r for (r, c) in coords).\n   3.3. Compute height = max_r - min_r + 1.\n   3.4. For each (r, c) in coords, set output[r - height][c] = v.\n4. Return the output grid.",
    "b527c5c6.json": "1. Let H be the number of rows and W the number of columns of the input grid. The output grid has the same dimensions.\n2. Collect all coordinates (r,c) where input[r][c]==2 into a list red_pixels.\n3. For each (r,c) in red_pixels do:\n   3.1 Determine extension direction d_ext = (dr,dc):\n       For each (dr,dc) in [(-1,0),(1,0),(0,-1),(0,1)] do:\n         Let (nr,nc)=(r+dr,c+dc) and (ir,ic)=(r-dr,c-dc).\n         If (nr,nc) is within [0..H-1]×[0..W-1] and input[nr][nc]!=3 and (ir,ic) is within bounds and input[ir][ic]==3 then select this (dr,dc) as d_ext and break.\n   3.2 Compute thickness:\n       Let d_int = (-dr,-dc). Initialize thickness=0 and (rr,cc)=(r+d_int_row,c+d_int_col).\n       While (rr,cc) in bounds and input[rr][cc]==3 do:\n         thickness += 1;\n         rr += d_int_row; cc += d_int_col;\n   3.3 Extend red line and record its cells:\n       Initialize red_line_cells=[] and set (rr,cc)=(r,c).\n       While (rr,cc) in bounds do:\n         output[rr][cc]=2;\n         Append (rr,cc) to red_line_cells;\n         rr += dr; cc += dc;\n   3.4 Draw green border of width=thickness:\n       Let d_perp1=(dc,-dr) and d_perp2=(-dc,dr).\n       For each (rr,cc) in red_line_cells do:\n         For k from 1 to thickness do:\n           If (rr + k*d_perp1_row, cc + k*d_perp1_col) in bounds then output[...] = 3;\n           If (rr + k*d_perp2_row, cc + k*d_perp2_col) in bounds then output[...] = 3;\n4. All other cells retain their original input value.\n5. Return the output grid.",
    "b91ae062.json": "1. Let G be the 3×3 input grid of integers. 2. Compute the set S of all values v in G such that v ≠ 0. 3. Let k = |S|. 4. Let block = k and size = 3 × block. 5. Initialize an output grid H of dimensions size × size. 6. For each input row r in 0..2 and column c in 0..2:   a. Let v = G[r][c].   b. For dr in 0..block–1 and dc in 0..block–1:      i. Set H[r×block + dr][c×block + dc] = v. 7. Return H.",
    "a8d7556c.json": "1. Let G be the input grid of size H×W. Create an output grid O as a copy of G. 2. For each row r from 0 to H–2 do: 3.   For each column c from 0 to W–2 do: 4.     If G[r][c]==0 AND G[r][c+1]==0 AND G[r+1][c]==0 AND G[r+1][c+1]==0 then: 5.       Set O[r][c]=2; O[r][c+1]=2; O[r+1][c]=2; O[r+1][c+1]=2. 6. Return O as the transformed grid.",
    "e21d9049.json": "1. Compute H as the number of rows and W as the number of columns in the input grid.\n2. Find row_h: the unique row index where the count of cells with value != 0 is greater than 1.\n3. Find col_v: the unique column index where the count of cells with value != 0 is greater than 1.\n4. In row_h, collect C = sorted list of all column indices c where grid[row_h][c] != 0. Let c_start = C[0], c_end = C[-1], N_h = c_end - c_start + 1. Define pattern_h as [ grid[row_h][c] for c from c_start to c_end inclusive ].\n5. In col_v, collect R = sorted list of all row indices r where grid[r][col_v] != 0. Let r_start = R[0], r_end = R[-1], N_v = r_end - r_start + 1. Define pattern_v as [ grid[r][col_v] for r from r_start to r_end inclusive ].\n6. Initialize output as a copy of the input grid.\n7. For each column c from 0 to W-1, set output[row_h][c] = pattern_h[(c - c_start) mod N_h].\n8. For each row r from 0 to H-1, set output[r][col_v] = pattern_v[(r - r_start) mod N_v].\n9. Return the output grid.",
    "42a50994.json": "1. Let R = number of rows and C = number of columns of the input grid. Create an output grid of size R×C as an identical copy of the input. 2. Create a boolean array visited[R][C], initialized to false. 3. For each cell (r,c) with 0 ≤ r < R and 0 ≤ c < C:  3.1. If input[r][c] == 0 or visited[r][c] == true, skip to the next cell.  3.2. Let v = input[r][c]. Initialize a list component = [(r,c)], mark visited[r][c] = true, and initialize a queue Q = [(r,c)].  3.3. While Q is not empty:  • Pop (x,y) from Q.  • For each neighbor offset (dx,dy) in {(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)}:   – Let (nx,ny) = (x+dx,y+dy).   – If 0 ≤ nx < R and 0 ≤ ny < C and visited[nx][ny] == false and input[nx][ny] == v:    • Append (nx,ny) to component, mark visited[nx][ny] = true, and enqueue (nx,ny) into Q.  3.4. If the size of component is 1, let (p,q) = component[0] and set output[p][q] = 0. 4. Return the output grid.",
    "5bd6f4ac.json": "1. Let H = number of rows in the input grid and W = number of columns in the input grid (in all training and test cases H=9 and W=9).\n2. Compute band_height = H / 3 and band_width = W / 3 (here both equal 3).\n3. Define row_start = 0 (top third) and col_start = 2 * band_width (last third): col_start = 6.\n4. Initialize an empty output grid of size band_height × band_width (3 rows × 3 columns).\n5. For each i from 0 to band_height - 1 and each j from 0 to band_width - 1:\n     a. Set output[i][j] = input[row_start + i][col_start + j].\n6. Return the output grid.",
    "56dc2b01.json": "1. Let H be number of rows and W be number of columns. 2. Identify the red line: collect L = {(r,c) | grid[r][c] == 2}. If all (r,c) in L share the same column C, set orientation = vertical and line_index = C; else if they share the same row R, set orientation = horizontal and line_index = R. 3. Identify the green pattern: collect P = {(r,c) | grid[r][c] == 3}. Compute r_min = min_r∈P r, r_max = max_r∈P r, c_min = min_c∈P c, c_max = max_c∈P c. 4. Determine side of pattern relative to line_index: if orientation = vertical then if c_max < line_index set side = left else if c_min > line_index set side = right; if orientation = horizontal then if r_max < line_index set side = above else if r_min > line_index set side = below. 5. Remove original pattern: for each (r,c) in P set grid[r][c] = 0. 6. Compute block dimensions: block_w = c_max - c_min, block_h = r_max - r_min. Compute shift: if orientation = vertical then set row_shift = 0; if side = left then new_c_max = line_index - 1 and new_c_min = new_c_max - block_w else /*side=right*/ new_c_min = line_index + 1 and new_c_max = new_c_min + block_w; set col_shift = new_c_min - c_min; else /*horizontal*/ set col_shift = 0; if side = above then new_r_max = line_index - 1 and new_r_min = new_r_max - block_h else /*below*/ new_r_min = line_index + 1 and new_r_max = new_r_min + block_h; set row_shift = new_r_min - r_min. 7. Paste pattern at new location: for each (r,c) in P set grid[r+row_shift][c+col_shift] = 3. 8. Draw the light‐blue line of 8s parallel to the red line on the opposite side of the pattern: if orientation = vertical then if side = left set new_line_c = new_c_min - 1 else set new_line_c = new_c_max + 1; for r in 0..H-1 set grid[r][new_line_c] = 8; else /*horizontal*/ if side = above set new_line_r = new_r_min - 1 else set new_line_r = new_r_max + 1; for c in 0..W-1 set grid[new_line_r][c] = 8. 9. Return the modified grid.",
    "39e1d7f9.json": "1. Scan all rows to find a separator color P: a non-zero value that fills an entire row. 2. Scan all columns to find the same separator color P filling an entire column. 3. Let separator_rows be the sorted list of row indices where grid[r][*]==P, and separator_cols likewise for columns. 4. Compute the interior row intervals between separators: intervals_rows = [[0, separator_rows[0]-1]] plus for k in 1..len(separator_rows)-1 the ranges [separator_rows[k-1]+1, separator_rows[k]-1], plus [separator_rows[-1]+1, H-1]. Compute intervals_cols similarly. 5. Let C = length of any interval in intervals_rows (all must equal). Let R = number of intervals_rows, Cn = number of intervals_cols. 6. Build a cell_color array of size R×Cn. For each cell (r,c), let its interior block be rows intervals_rows[r] and cols intervals_cols[c]; set cell_color[r][c] = grid[ intervals_rows[r][0] ][ intervals_cols[c][0] ]. 7. Identify a complete plus pattern: find a cell (r0,c0) with cell_color[r0][c0]!=0 and with all four neighbors (r0±1,c0) and (r0,c0±1) in bounds and equal to the same nonzero value Y≠cell_color[r0][c0]. Set center_color = cell_color[r0][c0], arm_color = Y. 8. For each cell (r,c)≠(r0,c0) with cell_color[r][c]==center_color, do: for each (dr,dc) in [(–1,0),(1,0),(0,–1),(0,1)], if 0≤r+dr<R and 0≤c+dc<Cn then for each pixel row i in intervals_rows[r+dr] and each pixel col j in intervals_cols[c+dc], set grid[i][j]=arm_color. 9. Return the modified grid.",
    "5c0a986e.json": "1. Let N = number of rows in the square grid.\n2. Collect all coordinates (r,c) where grid[r][c] == 1. Compute r1 = minimum r among these; c1 = minimum c among these.\n3. Collect all coordinates (r,c) where grid[r][c] == 2. Compute r2 = maximum r among these; c2 = maximum c among these.\n4. Initialize k = 1. While r1 - k >= 0 and c1 - k >= 0:\n     a. Set grid[r1 - k][c1 - k] = 1.\n     b. Increment k by 1.\n5. Initialize k = 1. While r2 + k < N and c2 + k < N:\n     a. Set grid[r2 + k][c2 + k] = 2.\n     b. Increment k by 1.\n6. Return the modified grid.",
    "e76a88a6.json": "1. Let R be the number of rows and C be the number of columns in the input grid.\n2. Initialize an output grid as a copy of the input grid.\n3. Identify the pattern region in the input grid by collecting all cells (r,c) with value neither 0 nor 5. Compute r_min = minimum r, r_max = maximum r, c_min = minimum c, c_max = maximum c among those cells.\n4. Compute H = r_max - r_min + 1 and W = c_max - c_min + 1.\n5. Extract a pattern array P of size H×W: for each i in [0,H-1], j in [0,W-1], set P[i][j] = input[r_min + i][c_min + j].\n6. For each top-left coordinate (r0,c0) with 0 ≤ r0 ≤ R - H and 0 ≤ c0 ≤ C - W, if every input[r0 + i][c0 + j] == 5 for all i in [0,H-1], j in [0,W-1], then for each i,j set output[r0 + i][c0 + j] = P[i][j].\n7. Return the output grid.",
    "b94a9452.json": "1. Identify all distinct non-zero colors in the input grid. Let C1 and C2 be these colors. Determine C_outer as the color with the greater number of cells and C_inner as the other color.\n2. Find the bounding box of the outer square: set big_min_row to the minimum row index of any cell equal to C_outer, big_max_row to the maximum row index, big_min_col to the minimum column index, and big_max_col to the maximum column index.\n3. Find the bounding box of the inner square: set small_min_row to the minimum row index of any cell equal to C_inner, small_max_row to the maximum row index, small_min_col to the minimum column index, and small_max_col to the maximum column index.\n4. Compute big_height = big_max_row - big_min_row + 1 and big_width = big_max_col - big_min_col + 1. Compute small_height = small_max_row - small_min_row + 1 and small_width = small_max_col - small_min_col + 1.\n5. Compute offset_row = small_min_row - big_min_row and offset_col = small_min_col - big_min_col.\n6. Create an output grid with big_height rows and big_width columns.\n7. Fill every cell of the output grid with C_inner.\n8. For row r from offset_row to offset_row + small_height - 1 and column c from offset_col to offset_col + small_width - 1, set output_grid[r][c] = C_outer.\n9. Return the output grid.",
    "b9b7f026.json": "1. Traverse the input grid and identify each 4‐connected component of nonzero cells: for any cell (r,c) with value v≠0 not yet visited, perform a flood fill (up/down/left/right) to collect all its coordinates and mark them visited.\n2. For each component of value v, compute its bounding box: Rmin = min row index, Rmax = max row index, Cmin = min column index, Cmax = max column index among its coordinates.\n3. If Rmax−Rmin ≥ 2 and Cmax−Cmin ≥ 2 then for each cell (r,c) with Rmin<r<Rmax and Cmin<c<Cmax, if grid[r][c] == 0, record v as the target value v_target and stop checking other cells.\n4. Exactly one component will satisfy the hole condition. Let its value be v_target.\n5. Construct the output grid of size 1 row × 1 column and set its single cell to v_target.",
    "b782dc8a.json": "1. Let grid be the input array indexed (r,c) with 0-based rows and columns.\n2. Identify wall color W: for each color v≠0, compute the size of its largest orthogonally connected component; let W be the v with greatest component size.\n3. Define corridor cells V = { (r,c) | grid[r][c] ≠ W }.\n4. Identify seed cells S = { (r,c)∈V | grid[r][c] ≠ 0 }.\n5. Find any two orthogonally adjacent cells P,Q ∈ S. Set S₀ = P, let A = grid[P], B = grid[Q].\n6. Initialize visited = {S₀}, dist[S₀] = 0, queue = [S₀]. Create output = copy of grid.\n7. Set output[S₀] = A.\n8. While queue not empty:\n   a. Pop u from queue.\n   b. For each neighbor v of u in { (u.r+1,u.c),(u.r-1,u.c),(u.r,u.c+1),(u.r,u.c-1) }:\n      i. If v ∈ V and v ∉ visited:\n         - dist[v] = dist[u] + 1\n         - output[v] = (dist[v] mod 2 == 0 ? A : B)\n         - add v to visited and enqueue v\n9. Leave all cells with grid[r][c] == W unchanged in output.\n10. Leave any corridor cell in V not visited (grid==0) unchanged in output.\n11. Return output grid.",
    "b8cdaf2b.json": "1. Let R = number of rows in the input grid and C = number of columns. Use zero-based indexing: (0,0) is top-left. 2. Copy input grid to output_grid. 3. Find r_base = largest row index i such that any input_grid[i][j] != 0. 4. Set r_top = r_base - 1. 5. Set border_color = input_grid[r_base][0] and interior_color = input_grid[r_base][C//2]. 6. On row r_top, scan j from 0 to C-1: let c_left = minimum j with input_grid[r_top][j] == border_color and c_right = maximum j with input_grid[r_top][j] == border_color. 7. Draw left diagonal: set r = r_top, c = c_left; while r > 0 and c > 0: r--, c--, set output_grid[r][c] = interior_color. 8. Draw right diagonal: set r = r_top, c = c_right; while r > 0 and c < C-1: r--, c++, set output_grid[r][c] = interior_color. 9. Return output_grid.",
    "b775ac94.json": "1. Let H = number of rows and W = number of columns of the input grid. 2. Create an output grid of size H×W and copy every cell from the input grid into the output grid. 3. Define a cluster as a maximal set of non-zero cells connected by 8-connectivity (neighbors share a side or a corner). 4. For each cluster:  4.1. Compute the frequency of each color value in the cluster.  4.2. Let M be the color with maximum frequency in that cluster.  4.3. Let S_majority = { (r,c) | input[r,c] == M } and let S_minority = { (r_p,c_p) | input[r_p,c_p] != M }.  4.4. For each (r_p,c_p) in S_minority with color C = input[r_p,c_p]:    4.4.1. For each (r_q,c_q) in S_majority:      a. Compute r_r = 2*r_p - r_q and c_r = 2*c_p - c_q.      b. If 0 ≤ r_r < H and 0 ≤ c_r < W then set output[r_r,c_r] = C.  4.5. (Re-)Set every (r_q,c_q) in S_majority: output[r_q,c_q] = M. 5. Return the output grid.",
    "a61ba2ce.json": "1. Create a 4x4 grid named outputGrid and fill every cell with 0.\n2. Identify each distinct non-zero integer v present in the input grid.\n3. For each such v:\n   a. Let coords = all (r, c) pairs where input[r][c] == v.\n   b. Compute minR = min(r for (r,c) in coords), maxR = max(r for (r,c) in coords), minC = min(c for (r,c) in coords), maxC = max(c for (r,c) in coords) and confirm maxR - minR == 1 and maxC - minC == 1.\n   c. Compute relSet = { (r - minR, c - minC) for each (r, c) in coords }.\n   d. Define fullSet = { (0,0), (0,1), (1,0), (1,1) } and let missing = the single element in fullSet minus relSet.\n   e. Determine (targetRow, targetCol) in outputGrid based on missing:\n      - If missing == (1,1): (targetRow, targetCol) = (0, 0)\n      - If missing == (1,0): (targetRow, targetCol) = (0, 2)\n      - If missing == (0,1): (targetRow, targetCol) = (2, 0)\n      - If missing == (0,0): (targetRow, targetCol) = (2, 2)\n   f. For each (dr, dc) in relSet, set outputGrid[targetRow + dr][targetCol + dc] = v.\n4. Return outputGrid.",
    "e50d258f.json": "1. Let background_color = 0 and red_color = 2.\n2. Let R = number of rows, C = number of columns in the input grid.\n3. Create a boolean array visited[R][C], initialized to false.\n4. Initialize an empty list shapes.\n5. For each cell (r, c) with r in [0..R-1], c in [0..C-1]:\n   a. If grid[r][c] != background_color and visited[r][c] == false, then:\n      i. Perform a flood-fill (BFS or DFS) starting at (r, c), adding each visited cell (ri, ci) with grid[ri][ci] != background_color to a set comp, and mark visited[ri][ci] = true.\n     ii. Compute rmin = min(ri for (ri,ci) in comp), rmax = max(ri), cmin = min(ci), cmax = max(ci).\n    iii. Let height = rmax - rmin + 1, width = cmax - cmin + 1.\n     iv. If comp.size != height * width, skip to next cell (comp is not a full rectangle).\n      v. Let red_count = number of (ri,ci) in comp where grid[ri][ci] == red_color.\n     vi. Let area = height * width.\n    vii. Append object {rmin, cmin, height, width, red_count, area} to shapes.\n6. From shapes, select the shape S with the maximum red_count. If multiple shapes share the maximum red_count, select the one with the maximum area. If still tied, select the one with the smallest rmin, then the smallest cmin.\n7. Allocate an output grid of size S.height rows by S.width columns.\n8. For i in [0..S.height-1] and j in [0..S.width-1], set output[i][j] = input[S.rmin + i][S.cmin + j].\n9. Return the output grid.",
    "e9614598.json": "1. Identify all cells with value 1 in the input grid, using zero-based row and column indices; record their coordinates as (r1,c1) and (r2,c2).\n2. Determine alignment: if r1==r2 then alignment is horizontal; else if c1==c2 then alignment is vertical.\n3. Compute midpoint:\n   - If horizontal: set rowMid = r1 and colMid = (c1 + c2) / 2.\n   - If vertical: set colMid = c1 and rowMid = (r1 + r2) / 2.\n   (The distance between the two 1s is always even, so midpoints are integer.)\n4. Copy the input grid to create the output grid.\n5. On the output grid, set the cell at (rowMid,colMid) to 3 (green).\n6. On the output grid, set its four orthogonal neighbors—(rowMid-1,colMid), (rowMid+1,colMid), (rowMid,colMid-1), (rowMid,colMid+1)—to 3 (green), if each coordinate is within grid bounds.\n7. Return the resulting output grid.",
    "ba26e723.json": "1. Let H be the number of rows and W be the number of columns of the input grid. 2. Initialize the output grid as an exact copy of the input grid. 3. For each column index C from 0 to W-1:   a. If C modulo 3 equals 0, then for each row index R from 0 to H-1:     i. If input[R][C] equals 4, set output[R][C] to 6.     ii. Otherwise leave output[R][C] unchanged. 4. Return the output grid.",
    "bb43febb.json": "1. Identify all connected components of pixels with value 5 using 4-neighbor connectivity.\n2. For each component, compute rmin = minimum row index, rmax = maximum row index, cmin = minimum column index, cmax = maximum column index across its pixels.\n3. If rmax - rmin >= 2 and cmax - cmin >= 2, then for each row r in rmin+1..rmax-1 and each column c in cmin+1..cmax-1, if the original grid value at (r,c) equals 5, set grid[r][c] = 2.\n4. Leave all other pixels unchanged.\n5. Return the resulting grid.",
    "e9afcf9a.json": "1. Let H be the number of rows and W be the number of columns of the input grid.\n2. Let A be the value at input cell (0,0). Let B be the value at input cell (1,0).\n3. Create an output grid of size H by W.\n4. For each row r from 0 to H-1 and each column c from 0 to W-1:\n   a. If (r + c) mod 2 = 0, set output[r][c] = A.\n   b. Otherwise, set output[r][c] = B.\n5. Return the output grid.",
    "90f3ed37.json": "1. Let R = number of rows in the grid, C = number of columns.\n2. For each row r in 0..R-1, compute count8[r] = number of cells in row r whose value is 8.\n3. Identify the reference pattern’s height H and top row r0:\n   a. Initialize bestTotal = -∞, bestH = 0, bestr0 = 0.\n   b. For k from R down to 1:\n      For sr from 0 to R - k:\n         If count8[sr] == count8[sr+1] == … == count8[sr + k - 1]:\n            Let total = k * count8[sr].\n            If total > bestTotal or (total == bestTotal and k > bestH) or (total == bestTotal and k == bestH and sr < bestr0):\n               bestTotal = total; bestH = k; bestr0 = sr.\n   c. Set H = bestH, r0 = bestr0.\n4. Determine the reference bounding columns:\n   a. Let c_min = min{c | there exists i in 0..H-1 with grid[r0 + i][c] == 8}.\n   b. Let c_max = max{c | there exists i in 0..H-1 with grid[r0 + i][c] == 8}.\n   c. Let W = c_max - c_min + 1.\n5. Build a boolean mask S of size H×W:\n   For i in 0..H-1 and j in 0..W-1:\n      S[i][j] = (grid[r0 + i][c_min + j] == 8).\n6. For each vertical shift dy from 1 to R - H:\n   a. Let r1 = r0 + dy.\n   b. Determine if any reference cell appears at this shift:\n      translationHas8 = false;\n      For i in 0..H-1, j in 0..W-1:\n         If S[i][j] and grid[r1 + i][c_min + j] == 8:\n            translationHas8 = true; break out of both loops.\n      If not translationHas8: continue to next dy.\n   c. For each pattern row i in 0..H-1:\n      i.   Let j_max = -1.\n      ii.  For j in 0..W-1:\n              If S[i][j] and grid[r1 + i][c_min + j] == 8:\n                 j_max = max(j_max, j).\n      iii. If j_max < 0: continue to next i.\n      iv.  For j from j_max + 1 to W - 1:\n              If S[i][j] and grid[r1 + i][c_min + j] == 0:\n                 Set grid[r1 + i][c_min + j] = 1.\n7. Return the modified grid.",
    "60b61512.json": "1. Let G be the input grid of size 9×9. 2. Define TARGET = 4 and FILL = 7. 3. Find all connected components of cells with value TARGET using orthogonal (4-directional) adjacency. 4. For each component C:\n   a. Compute min_row = minimum row index of C, max_row = maximum row index of C, min_col = minimum column index of C, and max_col = maximum column index of C.\n   b. If (max_row - min_row == 2) and (max_col - min_col == 2) then:\n      i. For every cell (r, c) in the bounding box rows min_row…max_row and cols min_col…max_col:\n         - If r == min_row or r == max_row or c == min_col or c == max_col (i.e., (r,c) lies on the perimeter) and G[r][c] == 0, set G[r][c] = FILL.\n5. Leave all other cells unchanged. 6. Return the modified grid G.",
    "e8593010.json": "1. Let H = number of rows and W = number of columns of the input grid. Create an output grid of size H×W.\n2. For each position (r,c): if input[r][c] ≠ 0 then set output[r][c] = input[r][c].\n3. Create a boolean matrix visited of size H×W, initialized to false.\n4. For each position (r,c) in row-major order:\n   a. If input[r][c] == 0 and visited[r][c] == false, then:\n      i. Initialize an empty list component and a stack containing (r,c).\n      ii. While stack is not empty:\n          • Pop (x,y) from stack. If visited[x][y] is true, continue. Mark visited[x][y] = true. Append (x,y) to component.\n          • For each orthogonal neighbor (nx,ny) in {(x-1,y),(x+1,y),(x,y-1),(x,y+1)} that lies within 0 ≤ nx < H and 0 ≤ ny < W:\n              – If input[nx][ny] == 0 and visited[nx][ny] == false, push (nx,ny) onto stack.\n      iii. Let N = size of component.\n      iv. If N == 1 set code = 3; else if N == 2 set code = 2; else if N == 3 set code = 1.\n      v. For each (x,y) in component set output[x][y] = code.\n5. Return the output grid.",
    "239be575.json": "1. Locate all cells of value 2 and group them into two 2×2 squares (blocks) by 4-connected adjacency. 2. For each block, record the coordinates of its top-left cell; call these (r1,c1) and (r2,c2). 3. Order the blocks so that either r1<r2, or if r1=r2 then c1<c2. 4. Compute dr = |r2 - r1| and dc = |c2 - c1|. 5. Compute D = dr + dc. 6. If D is odd, output a 1×1 grid with value 0; if D is even, output a 1×1 grid with value 8.",
    "6150a2bd.json": "1. Let R = number of rows in the input grid and C = number of columns.\n2. Create an output grid of size R×C.\n3. For each integer r from 0 to R-1 and each integer c from 0 to C-1:\n   a. Set output[r][c] = input[R-1-r][C-1-c].\n4. Return the output grid.",
    "b7249182.json": "1. Let G be the input grid of size R×C with 0-based indices. 2. Find the two nonzero cells: (r1,c1,v1) and (r2,c2,v2). 3. If c1==c2 then orientation=vertical; else if r1==r2 then orientation=horizontal. 4. Let branch_offset=2. 5. If orientation==vertical then:   a. Let col=c1.   b. If r1<r2 then rt=r1,vt=v1,rb=r2,vb=v2 else rt=r2,vt=v2,rb=r1,vb=v1.   c. Let dist=rb-rt, half=floor(dist/2), main_len=half-1.   d. For i from 0 to main_len-1 do set G[rt+i][col]=vt.   e. For i from 0 to main_len-1 do set G[rb-i][col]=vb.   f. Let branch_top=rt+main_len; for dx from -branch_offset to +branch_offset do set G[branch_top][col+dx]=vt.   g. Let branch_bot=rb-main_len; for dx from -branch_offset to +branch_offset do set G[branch_bot][col+dx]=vb. 6. Else (orientation==horizontal):   a. Let row=r1.   b. If c1<c2 then cL=c1,vL=v1,cR=c2,vR=v2 else cL=c2,vL=v2,cR=c1,vR=v1.   c. Let dist=cR-cL, half=floor(dist/2), main_len=half.   d. For i from 0 to main_len-1 do set G[row][cL+i]=vL.   e. For i from 0 to main_len-1 do set G[row][cR-i]=vR.   f. Let bL=cL+(main_len-1); for dy from -branch_offset to +branch_offset do set G[row+dy][bL]=vL.   g. Let bR=cR-(main_len-1); for dy from -branch_offset to +branch_offset do set G[row+dy][bR]=vR.   h. Set G[row-branch_offset][bL+1]=vL and G[row+branch_offset][bL+1]=vL.   i. Set G[row-branch_offset][bR-1]=vR and G[row+branch_offset][bR-1]=vR. 7. Return G as the output grid.",
    "846bdb03.json": "1. Identify pillar endpoints: scan all cells (r,c) with value 4. 2. Find two pillar columns c₁<c₂ that each have exactly two endpoints. 3. For each pillar at column c∈{c₁,c₂}: let rows₀={r|grid[r][c]≠0}. Compute r_min= min(rows₀), r_max= max(rows₀). Verify grid[r_min][c]==4 and grid[r_max][c]==4. Let interior rows be r_min+1..r_max-1; all grid[r][c] for r in this range share the same non-zero, non-4 value; record leftColor= that value for c₁ and rightColor= that value for c₂. 4. Extract shape region: collect all cells (r,c) where c∉{c₁,c₂} and grid[r][c]≠0 and grid[r][c]≠4. Compute r_minS=min(r), r_maxS=max(r), c_minS=min(c), c_maxS=max(c). Let shapeH=r_maxS–r_minS+1, shapeW=c_maxS–c_minS+1. 5. Decide horizontal flip: for r from r_minS to r_maxS, if grid[r][c_minS]≠0 and ≠4 then let v=grid[r][c_minS]; set doFlip=true if v≠leftColor else doFlip=false; break. 6. Create outputGrid of size (shapeH+2) rows and (shapeW+2) columns filled with 0. 7. Draw left pillar: for i from 0 to shapeH+1 set outputGrid[i][0]=4 if i==0 or i==shapeH+1 else =leftColor. 8. Draw right pillar: for i from 0 to shapeH+1 set outputGrid[i][shapeW+1]=4 if i==0 or i==shapeH+1 else =rightColor. 9. Copy shape region into interior: for dr from 0 to shapeH-1 and dc from 0 to shapeW-1 let v=grid[r_minS+dr][c_minS+dc]; if v≠0 and ≠4 then let rr=dr+1 and cc= doFlip ? shapeW-dc : dc+1; set outputGrid[rr][cc]=v. 10. Return outputGrid.",
    "bbc9ae5d.json": "1. Let w be the number of columns in the input grid.\n2. Let X be the value of the pixel at input row 0, column 0 (this is the non-zero value shown in the single input row).\n3. Count c = the number of consecutive columns i starting at 0 for which input[0][i] == X, stopping when input[0][i] != X or i == w.\n4. Compute h = w / 2.\n5. Initialize an output grid of size h rows and w columns filled with 0.\n6. For each output row index r from 0 to h-1:\n   For each column index col from 0 to w-1:\n      If col < c + r then set output[r][col] = X.\n7. Return the output grid.",
    "b0c4d837.json": "1. Locate container walls:\n   a. Find all cells with value 5.  \n   b. Let wall_cols = sorted(unique column indices of these cells).  \n   c. Assign left_wall_col = wall_cols[0], right_wall_col = wall_cols[-1].  \n2. Determine first and bottom wall rows:\n   a. first_wall_row = minimum row index i such that grid[i][left_wall_col] == 5.  \n   b. bottom_border_row = maximum row index i such that grid[i][left_wall_col] == 5.  \n3. Determine water-top row:\n   a. min_water_row = minimum row index i such that grid[i][j] == 8 for any column j.  \n4. Compute segment count:\n   a. segments = min_water_row - first_wall_row.  \n5. Initialize a 3×3 output grid of zeros.  \n6. Define border sequence of output coordinates (0-based):\n   border_seq = [(0,0),(0,1),(0,2),(1,2),(2,2),(2,1),(2,0),(1,0)].  \n7. Draw segments:\n   For k from 0 to segments-1, if k < len(border_seq):\n      let (r,c) = border_seq[k]; set output[r][c] = 8.  \n8. Return the 3×3 output grid.",
    "e98196ab.json": "1. Use zero-based indexing for row and column positions.\n2. Locate separator_row: the unique row index R such that for all columns C from 0 to W-1, input_grid[R][C] == 5.\n3. Define H = separator_row and W = number of columns in input_grid.\n4. Initialize output_grid as an empty H x W integer grid.\n5. For each i from 0 to H-1 and each j from 0 to W-1:\n   a. Set top_val = input_grid[i][j]\n   b. Set bottom_val = input_grid[separator_row + 1 + i][j]\n   c. If top_val != 0 then set output_grid[i][j] = top_val else set output_grid[i][j] = bottom_val\n6. Return output_grid.",
    "ea32f347.json": "1. Let G be the input grid of size H×W. 2. Initialize output grid O as a copy of G. 3. Identify all maximal 4-connected components of cells in G with value 5; there will be exactly three such components. 4. For each component C, compute its size s(C) = number of cells. 5. Sort the three components by size: let C_max be the component with maximum size, C_mid the component with the middle size, and C_min the component with minimum size. 6. For each cell (r,c) in C_max, set O[r][c] = 1. 7. For each cell (r,c) in C_mid, set O[r][c] = 4. 8. For each cell (r,c) in C_min, set O[r][c] = 2. 9. Leave all other cells in O unchanged. 10. Return O.",
    "7df24a62.json": "1. Let borderColor = 1 and interiorColor = 4.  Let H and W be the grid dimensions.  2. Identify the reference cluster:   a. Find all connected components of pixels == borderColor.   b. For each component, compute minRow, maxRow, minCol, maxCol over its pixels.   c. For each rectangle R defined by (minRow,minCol) to (maxRow,maxCol), inspect its interior cells (rows minRow+1 to maxRow–1, cols minCol+1 to maxCol–1).   d. Select the rectangle Rref whose interior contains at least one pixel == interiorColor.   e. Record refTop = minRow, refLeft = minCol, refHeight = maxRow – minRow + 1, refWidth = maxCol – minCol + 1.  3. Compute relative offsets for the reference pattern:   a. interiorOffsets = {(r – refTop, c – refLeft) | refTop < r < refTop+refHeight–1 and refLeft < c < refLeft+refWidth–1 and grid[r][c] == interiorColor}.   b. borderOffsets = {(dr,dc) | dr == 0 or dr == refHeight–1 or dc == 0 or dc == refWidth–1, with 0 ≤ dr < refHeight, 0 ≤ dc < refWidth}.  4. Define a function rotateOffsets(offsets, h, w, k) that returns the set of offsets rotated k degrees clockwise around a box of size h×w:   – For k=0: return offsets, dims=(h,w).   – For k=90: return {(dc, h–1–dr) | (dr,dc) in offsets}, dims=(w,h).   – For k=180: return {(h–1–dr, w–1–dc) | (dr,dc) in offsets}, dims=(h,w).   – For k=270: return {(w–1–dc, dr) | (dr,dc) in offsets}, dims=(w,h).  5. For each rotation k in {0,90,180,270}:   a. (h_k, w_k) = dims returned by rotateOffsets.   b. interior_k = rotateOffsets(interiorOffsets, refHeight, refWidth, k).   c. border_k   = rotateOffsets(borderOffsets,   refHeight, refWidth, k).   d. For each candidate top‐left (r0,c0) with 0 ≤ r0 ≤ H–h_k and 0 ≤ c0 ≤ W–w_k:     i. If for all (dr,dc) in interior_k, grid[r0+dr][c0+dc] == interiorColor, and for all (dr,dc) in border_k, grid[r0+dr][c0+dc] != borderColor:       – For each (dr,dc) in border_k, set grid[r0+dr][c0+dc] = borderColor.  6. Return the modified grid.",
    "ba97ae07.json": "1. Let input_grid be the given 2D array of integers.\n2. Compute colors = set of all values in input_grid minus {0}.\n3. Let [c1, c2] be the two elements of colors.\n4. For i in {1,2}:  \n   a. Compute rmin_i = minimum row index r where input_grid[r][c] == ci for some c.  \n   b. Compute rmax_i = maximum row index r where input_grid[r][c] == ci for some c.  \n   c. Compute cmin_i = minimum column index c where input_grid[r][c] == ci for some r.  \n   d. Compute cmax_i = maximum column index c where input_grid[r][c] == ci for some r.\n5. For i in {1,2}: set height_i = rmax_i - rmin_i + 1 and width_i = cmax_i - cmin_i + 1.\n6. If width_1 > height_1 then set c_h = c1, rmin_h = rmin_1, rmax_h = rmax_1; else set c_h = c2, rmin_h = rmin_2, rmax_h = rmax_2.\n7. Set c_v to the other color of {c1,c2}, and assign rmin_v, rmax_v, cmin_v, cmax_v accordingly.\n8. Define h_rows = all integers from rmin_h to rmax_h inclusive; define v_cols = all integers from cmin_v to cmax_v inclusive.\n9. Let over_color = input_grid[rmin_h][cmin_v]. If over_color == c_h then set under_color = c_v else set under_color = c_h.\n10. Copy input_grid to output_grid.\n11. For each r in h_rows and each c in v_cols: set output_grid[r][c] = under_color.\n12. Return output_grid.",
    "ea786f4a.json": "1. Let n be the number of rows in input_grid. 2. Compute center_index = (n - 1) / 2 using integer division. 3. Let center_color = input_grid[center_index][center_index]. 4. Let background_color = input_grid[0][0]. 5. Initialize output_grid as a new n by n grid. 6. For each row r from 0 to n - 1: 7.   For each column c from 0 to n - 1: 8.     If r == c or r + c == n - 1 then set output_grid[r][c] = center_color else set output_grid[r][c] = background_color. 9. Return output_grid.",
    "62c24649.json": "1. Let the input be a 3×3 grid G and create an empty 6×6 grid H.\n2. For each row r from 0 to 5 and each column c from 0 to 5:\n   a. If r < 3 then set sr = r else set sr = 5 - r.\n   b. If c < 3 then set sc = c else set sc = 5 - c.\n   c. Set H[r][c] = G[sr][sc].\n3. Return H as the output grid.",
    "bd4472b8.json": "1. Use 0-based indexing. Let H be the number of rows and W be the number of columns of the input grid named input. 2. Initialize an output grid named output as a copy of input. 3. Create an array Pattern of length W where for each column j in 0..W-1: Pattern[j] = input[0][j]. 4. For each row r from 2 to H-1 inclusive:   a. Compute idx = (r - 2) mod W.   b. Let color = Pattern[idx].   c. For each column c from 0 to W-1 inclusive: set output[r][c] = color. 5. Return output as the transformed grid.",
    "36fdfd69.json": "1. Let grid be the input 2D array of integers. 2. Define value 2 as the “red” pixels and value 4 as the “yellow” fill. 3. Find all connected components of red pixels using 8‐direction connectivity: two red pixels at (r1,c1) and (r2,c2) belong to the same component if |r1–r2|≤1 and |c1–c2|≤1. 4. For each red component:  a. Compute r_min = minimum row of its pixels; r_max = maximum row.  b. Compute c_min = minimum column; c_max = maximum column.  c. For each row r from r_min to r_max and each column c from c_min to c_max:     i. If grid[r][c] ≠ 2 then set grid[r][c] = 4. 5. Return the modified grid as the output.",
    "bdad9b1f.json": "1. Let H = number of rows, W = number of columns in the input grid.\n2. Let S2 = {(r,c) | input[r][c] == 2}. All r in S2 are equal; denote that common row index by R.\n3. Let S8 = {(r,c) | input[r][c] == 8}. All c in S8 are equal; denote that common column index by C.\n4. Copy the input grid to an output grid.\n5. For each column j from 0 to W-1, set output[R][j] = 2.\n6. For each row i from 0 to H-1, set output[i][C] = 8.\n7. Set output[R][C] = 4.",
    "6455b5f5.json": "1. Scan the grid and find all regions of orthogonally connected cells with value 0 (use 4-directional adjacency).  \n2. For each region, count its cells to compute its area.  \n3. Let M = the maximum area and m = the minimum area among these regions.  \n4. For each region:  \n   a. If its area == M, set every cell in that region to value 1.  \n   b. If its area == m, set every cell in that region to value 8.  \n5. Leave all other cells (including cells with value 2 and zeros in regions of intermediate size) unchanged.",
    "be94b721.json": "1. Let grid be the input 2D array of integers; treat 0 as the background.\n2. Create a boolean array visited of same dimensions, initialized to false.\n3. Initialize an empty list components.\n4. For each cell (r,c) in row-major order:\n   a. If grid[r][c] != 0 and visited[r][c] is false:\n      i. Let color = grid[r][c].\n      ii. Perform a flood-fill (BFS or DFS) from (r,c), visiting 4-connected neighbors (up, down, left, right) that have value == color and not yet visited.\n      iii. Collect all visited positions into a list P, mark visited[r'][c'] = true for each (r',c') in P.\n      iv. Append P to components.\n5. For each component in components, compute its size = number of positions; select the component P_max with the largest size.\n6. Compute min_r = min(r) over (r,c) in P_max; max_r = max(r); min_c = min(c); max_c = max(c).\n7. Let H = max_r - min_r + 1 and W = max_c - min_c + 1. Initialize output grid of size H×W.\n8. For i from 0 to H-1 and j from 0 to W-1, set output[i][j] = grid[min_r + i][min_c + j].\n9. Return the output grid.",
    "662c240a.json": "1. Divide the 9x3 input grid into three 3x3 blocks: for k in {0,1,2}, block k spans rows 3*k..3*k+2 and columns 0..2. 2. For each block k: set row_offset=3*k. For all local coordinates i,j in 0..2, compare grid[row_offset+i][j] with grid[row_offset+j][i]. If any comparison fails, record k as the asymmetric index. 3. Let a be the recorded asymmetric index. 4. Extract and return rows 3*a..3*a+2 and columns 0..2 as the 3x3 output grid.",
    "ed36ccf7.json": "1. Let H = number of rows in the input grid and W = number of columns.\n2. Initialize an output grid of size H × W.\n3. For each row index r from 0 to H−1 and each column index c from 0 to W−1, set\n   output[r][c] = input[c][W−1−r]\n   This mapping takes the pixel at (c, W−1−r) in the input and places it at (r, c) in the output, performing a 90° counter-clockwise rotation.\n4. Return the output grid.",
    "c0f76784.json": "1. Copy the input grid to an output grid of the same dimensions.\n2. Identify all 4-connected components of pixels with value 5 (border pixels of squares).\n3. For each component:\n   a. Let r_min = minimum row index of its pixels, r_max = maximum row index; let c_min = minimum column index, c_max = maximum column index.\n   b. Compute side_length = r_max - r_min + 1 (this equals the square’s side).\n   c. Compute fill_value = side_length + 3 (so 3×3 squares→6, 4×4→7, 5×5→8).\n   d. For each row r from r_min+1 to r_max-1:\n        For each column c from c_min+1 to c_max-1:\n            If input_grid[r][c] == 0 then set output_grid[r][c] = fill_value.\n4. Return the output grid.",
    "beb8660c.json": "1. Let H be the number of rows and W be the number of columns.\n2. Initialize an empty list segments and integer E = 0.\n3. For each row r from 0 to H-1: compute nonZeroCols = all c in 0..W-1 with grid[r][c] != 0. If nonZeroCols is empty then E = E + 1. Otherwise let c_min = min(nonZeroCols), c_max = max(nonZeroCols), let v = grid[r][c_min], let L = c_max - c_min + 1, append (v, L) to segments.\n4. Sort segments in ascending order of L.\n5. Create output grid of size H x W filled with 0.\n6. For i from 0 to segments.size()-1: let (v, L) = segments[i], let target_r = E + i; for j from 0 to L-1 set output[target_r][W-1-j] = v.\n7. Return the output grid.",
    "6430c8c4.json": "1. Locate the divider row: scan the input grid and find the row where all 4 cells equal 4 (value 4); this occurs at row index 4.\n2. Extract two 4×4 blocks: top_block = input rows 0–3 and columns 0–3; bottom_block = input rows 5–8 and columns 0–3.\n3. Create a 4×4 output_grid and initialize every cell to 0.\n4. For each row r in 0..3 and each column c in 0..3:\n   a. If top_block[r][c] == 0 AND bottom_block[r][c] == 0, then set output_grid[r][c] = 3.\n   b. Otherwise leave output_grid[r][c] = 0.\n5. Return output_grid.",
    "bc1d5164.json": "1. Let G be the input grid with 5 rows (indices 0–4) and 7 columns (indices 0–6). 2. Create an empty output grid O with 3 rows (0–2) and 3 columns (0–2). 3. Set the four corner cells of O from the four corner cells of G:\n   • O[0][0] = G[0][0]\n   • O[0][2] = G[0][6]\n   • O[2][0] = G[4][0]\n   • O[2][2] = G[4][6]\n4. Set the four edge‐center cells of O by taking the maximum (nonzero) of the two corresponding input cells:\n   • O[0][1] = max(G[0][1], G[0][5])\n   • O[1][0] = max(G[1][0], G[3][0])\n   • O[1][2] = max(G[1][6], G[3][6])\n   • O[2][1] = max(G[4][1], G[4][5])\n5. Set the center cell of O by taking the maximum of the four diagonally adjacent cells around the central barrier in G:\n   • O[1][1] = max(G[1][1], G[1][5], G[3][1], G[3][5])\n6. Return O.",
    "623ea044.json": "1. Let num_rows be the number of rows and num_cols be the number of columns in the input grid.\n2. Scan the grid to find the unique cell with a non-zero value. Call its row index r0, its column index c0, and its value C (1–9).\n3. For each diagonal direction (dr,dc) in the set {(-1,-1),(-1,1),(1,-1),(1,1)} do:\n   a. Initialize r = r0 + dr and c = c0 + dc.\n   b. While 0 ≤ r < num_rows and 0 ≤ c < num_cols:\n      i. Set grid[r][c] = C.\n      ii. Increment r by dr and c by dc.\n4. Leave all other cells (including the original at r0,c0) unchanged.\n5. Return the resulting grid of the same dimensions.",
    "67385a82.json": "1. Let H be the number of rows and W be the number of columns of the input grid. 2. Initialize an output grid of size H×W as an exact copy of the input grid. 3. Create a boolean array visited of size H×W, initialized to false. 4. For each cell (r,c) with 0 ≤ r < H and 0 ≤ c < W, if input[r][c] == 3 and visited[r][c] == false, then:   a. Initialize an empty list component and a queue Q.   b. Enqueue (r,c) into Q and set visited[r][c] = true.   c. While Q is not empty:      i. Dequeue (x,y) from Q and append (x,y) to component.      ii. For each of the four orthogonal neighbors (nx,ny) in {(x+1,y),(x-1,y),(x,y+1),(x,y-1)} that lie within the grid: if input[nx][ny] == 3 and visited[nx][ny] == false, then set visited[nx][ny] = true and enqueue (nx,ny).   d. Let S be the number of cells in component.   e. If S > 2, then for each (x,y) in component set output[x][y] = 8. 5. Return the output grid.",
    "c3e719e8.json": "1. Let A be the 3×3 input grid with rows and columns indexed 0..2. 2. Compute the count of each integer in A; let M be the integer with the highest count. 3. Initialize a 9×9 grid B with all entries set to 0; index B by rows and columns 0..8. 4. For each r in 0..2 and each c in 0..2: if A[r,c] == M then for each i in 0..2 and each j in 0..2 set B[r*3 + i, c*3 + j] = A[i,j]. 5. Return B as the output grid.",
    "67a3c6ac.json": "1. Let H = number of rows in the input grid.\n2. Let W = number of columns in the input grid.\n3. Initialize an empty output grid of size H×W.\n4. For each row index r from 0 to H−1:\n   a. For each column index c from 0 to W−1:\n      i. Read v = input_grid[r][c].\n      ii. Set output_grid[r][W−1−c] = v.\n5. Return output_grid.",
    "ec883f72.json": "1. Let H = number of rows, W = number of columns in input grid.\n2. Identify all non-zero colors present; there will be exactly two such colors.\n3. For each color c:\n   a. Compute minRow[c], maxRow[c], minCol[c], maxCol[c] over all cells of color c.\n   b. Compute count[c] = number of cells with color c.\n   c. Compute area[c] = (maxRow[c] - minRow[c] + 1) * (maxCol[c] - minCol[c] + 1).\n4. Set fillColor = the color c for which count[c] == area[c]. Set borderColor = the other non-zero color.\n5. Let minBR = minRow[borderColor], maxBR = maxRow[borderColor], minBC = minCol[borderColor], maxBC = maxCol[borderColor].\n6. Compute centerRow = (minBR + maxBR) / 2.0 and centerCol = (minBC + maxBC) / 2.0.\n7. Define sign(x):\n   if x > 0 return +1; if x < 0 return -1.\n8. Initialize outputGrid as a copy of input grid.\n9. Define corners = [(minBR, minBC), (minBR, maxBC), (maxBR, minBC), (maxBR, maxBC)].\n10. For each (r0, c0) in corners:\n    a. If inputGrid[r0][c0] != borderColor, continue to next corner.\n    b. Compute dr = sign(r0 - centerRow), dc = sign(c0 - centerCol).\n    c. If dr == 0 or dc == 0, continue to next corner.\n    d. Set r = r0 + dr, c = c0 + dc.\n    e. While 0 <= r < H and 0 <= c < W:\n         i. Set outputGrid[r][c] = fillColor.\n         ii. r += dr; c += dc.\n11. Return outputGrid.",
    "c3f564a4.json": "1. Let H be the number of rows and W be the number of columns in the input grid.  \n2. Compute N = maximum value among all non-zero cells in the grid.  \n3. For each cell at row r and column c (with r and c indexed from 1):  \n   a. If grid[r][c] ≠ 0, leave its value unchanged.  \n   b. If grid[r][c] = 0, compute new_value = ((r + c - 2) mod N) + 1, and set grid[r][c] = new_value.  \n4. Return the modified grid of size H×W.",
    "c59eb873.json": "1. Let the input grid have R rows and C columns, indexed 0 to R-1 and 0 to C-1.\n2. Create an empty output grid of size (2×R) rows by (2×C) columns.\n3. For each input cell at row r (0≤r<R) and column c (0≤c<C):\n   a. Let v = input[r][c].\n   b. For dr in {0,1} and dc in {0,1}:\n      i. Compute output row = 2×r + dr and output column = 2×c + dc.\n      ii. Set output[output row][output column] = v.\n4. Return the output grid.",
    "63613498.json": "1. Locate all cells with value 5. Let rMin = minimum row index among them, rMax = maximum row index, cMin = minimum column index, cMax = maximum column index.\n2. Define the interior region as rows r where rMin ≤ r < rMax and columns c where cMin ≤ c < cMax.\n3. In the interior region, find the unique non-zero value k (k ≠ 5). Collect interiorCells = {(r,c) | grid[r][c] == k}.\n4. Compute the interior shape pattern: let r0 = min(r in interiorCells), c0 = min(c in interiorCells). Define pattern = {(r - r0, c - c0) | (r,c) in interiorCells}.\n5. Find matching shapes outside the interior region:\n   a. Identify all connected components candidateCells of any color v where v ≠ 0 and v ≠ 5, using orthogonal adjacency.\n   b. For each candidateCells, let r1 = min(r in candidateCells), c1 = min(c in candidateCells). Compute candPattern = {(r - r1, c - c1) | (r,c) in candidateCells}.\n   c. If candPattern == pattern and candidateCells ∩ interiorCells is empty, mark candidateCells as a match.\n6. For each marked candidateCells, set grid[r][c] = 5 for all (r,c) in that component.\n7. Return the modified grid.",
    "c1d99e64.json": "1. Let H be the number of rows and W be the number of columns in the input grid. 2. Define line_color = 0 and fill_color = 2. 3. Initialize an empty list full_rows. 4. For each row index r from 0 to H-1: if for every column c from 0 to W-1 grid[r][c] == line_color, append r to full_rows. 5. Initialize an empty list full_cols. 6. For each column index c from 0 to W-1: if for every row r from 0 to H-1 grid[r][c] == line_color, append c to full_cols. 7. Create output grid as a copy of input grid. 8. For each r in full_rows and each c from 0 to W-1: set output[r][c] = fill_color. 9. For each c in full_cols and each r from 0 to H-1: set output[r][c] = fill_color. 10. Return the output grid.",
    "97a05b5b.json": "1. Identify the main block:\n   1.1. For each color v in 1..9, find all orthogonally connected components of v in the input grid.\n   1.2. Choose the component with the largest number of cells. Let C = its color. Let R be the set of its cell coordinates.\n2. Compute the bounding box of R:\n   2.1. r_min = min(r for (r,c) in R), r_max = max(r for (r,c) in R)\n   2.2. c_min = min(c for (r,c) in R), c_max = max(c for (r,c) in R)\n3. Extract the region grid G of size H = r_max–r_min+1, W = c_max–c_min+1:\n   For i in 0..H-1, j in 0..W-1: G[i][j] = input[r_min+i][c_min+j]\n4. Extract puzzle pieces:\n   4.1. Let P = all input cells (r,c) where input[r][c] ≠ 0 and (r<r_min or r>r_max or c<c_min or c>c_max).\n   4.2. Find orthogonal connected components of P. For each component k:\n     a. Compute its bounding box pr_min..pr_max, pc_min..pc_max.\n     b. Define piece grid Pk of size ph = pr_max–pr_min+1, pw = pc_max–pc_min+1:\n        For i in 0..ph-1, j in 0..pw-1: Pk.grid[i][j] = input[pr_min+i][pc_min+j]\n     c. Define mask M[i][j] = True if Pk.grid[i][j] ≠ 0, else False.\n     d. Store piece k with (grid, mask).\n5. For each piece k:\n   5.1. For each rotation t in {0°,90°,180°,270°} of Pk.grid and M:\n     a. Let Rk = rotated grid, Mk = rotated mask, with dimensions h×w.\n     b. For dr in 0..H−h, dc in 0..W−w:\n        i. For all i in 0..h-1, j in 0..w-1:\n           • If Mk[i][j]:\n             – If Rk[i][j] == C, require G[dr+i][dc+j] == 0\n             – Else require G[dr+i][dc+j] == C\n           • Else require G[dr+i][dc+j] == C\n        ii. If all checks pass, record placement (k, dr, dc, rotation t) and break out of loops.\n6. Overlay each placed piece onto G:\n   For each stored placement (k, dr, dc, t):\n     a. For each i in 0..h-1, j in 0..w-1:\n        If Mk[i][j], set G[dr+i][dc+j] = Rk[i][j]\n7. Return G as the output grid.",
    "f25fbde4.json": "1. Let input be a 2D array input[r][c] indexed from 0. 2. Collect all coordinates (r,c) such that input[r][c] == 4. 3. Compute min_r = minimum r, max_r = maximum r, min_c = minimum c, max_c = maximum c over those coordinates. 4. Let h = max_r - min_r + 1 and w = max_c - min_c + 1. 5. Create an output array output of size (2*h) rows and (2*w) columns, initialized to 0. 6. For each r in min_r..max_r and each c in min_c..max_c:   a. Let v = input[r][c].   b. Let i = r - min_r and j = c - min_c.   c. For dr in {0,1} and dc in {0,1}:      output[2*i + dr][2*j + dc] = v. 7. Return output.",
    "67e8384a.json": "1. Let G be the input grid of size N×N (here N=3).\n2. Initialize an empty output grid O of size 2N×2N (6×6).\n3. For each r in 1..N and each c in 1..N:\n   a. Let v = G[r][c].\n   b. Set O[r][c] = v.                           (top-left quadrant)\n   c. Set O[r][2*N+1-c] = v.                   (top-right: horizontal reflection)\n   d. Set O[2*N+1-r][c] = v.                   (bottom-left: vertical reflection)\n   e. Set O[2*N+1-r][2*N+1-c] = v.             (bottom-right: both reflections)\n4. Return O as the 6×6 output grid.",
    "53b68214.json": "1. Identify the single non-zero color value C in the input grid. 2. Let H = number of input rows, W = number of columns (always 10). 3. Build an array R of length H: for each row r in 0..H-1, let R[r] be the sorted list of column indices c where input[r][c] == C. 4. If H == 10, return the input grid unchanged. 5. For P from 1 to H, attempt to find an integer δcol as follows:   a. Initialize δcol as undefined and a flag valid = true.   b. For each block index j = 1 to floor((H-1)/P):     For each base row r0 in 0..P-1 such that r1 = r0 + j*P < H:       i. If len(R[r1]) != len(R[r0]), set valid = false and break.       ii. For each k in 0..len(R[r0])-1, compute Δ = R[r1][k] - R[r0][k].       iii. If Δ mod j != 0, or if δcol is defined and Δ/j != δcol, set valid = false and break; otherwise set δcol = Δ/j.     If valid becomes false, break to next P.   c. If valid remains true after all j and r0, accept this P and δcol and break. 6. Initialize the output grid as a copy of the input. 7. For each new row r in H..9:   a. Compute block = floor(r / P) and baseRow = r mod P.   b. For each c in R[baseRow]:       i. Compute newC = c + block * δcol.       ii. If 0 ≤ newC < W, set output[r][newC] = C. 8. Fill all other cells with 0. 9. Return the 10×10 output grid.",
    "ecdecbb3.json": "1. Let x_color=8 and y_color=2.\n2. Copy input grid to output_grid.\n3. Detect orientation of x-color lines:\n   a. Find any two orthogonally adjacent cells with value x_color in input. If they share a row, set orientation=\"horizontal\"; otherwise set orientation=\"vertical\".\n4. Collect all line positions:\n   if orientation==\"horizontal\":\n     lines = sorted list of all row indices r where input_grid[r][c]==x_color for some c.\n   else (orientation==\"vertical\"):\n     lines = sorted list of all column indices c where input_grid[r][c]==x_color for some r.\n5. Identify all dot positions: list dots = all (r_d,c_d) where input_grid[r_d][c_d]==y_color.\n6. For each dot (r_d,c_d) in dots do:\n   if orientation==\"horizontal\":\n     a. above = [r for r in lines if r<r_d]; below = [r for r in lines if r>r_d];\n     b. if above nonempty and below nonempty: targets = [max(above), min(below)];\n        else if above nonempty: targets = [max(above)];\n        else: targets = [min(below)];\n     c. For each r_t in targets:\n        i. For r from min(r_d,r_t) to max(r_d,r_t): set output_grid[r][c_d]=y_color.\n        ii. For i from r_t-1 to r_t+1 and j from c_d-1 to c_d+1, if (i,j) inside grid:\n              set output_grid[i][j]=x_color.\n        iii. Then set output_grid[r_t][c_d]=y_color.\n   else (orientation==\"vertical\"):\n     a. left = [c for c in lines if c<c_d]; right = [c for c in lines if c>c_d];\n     b. if left nonempty and right nonempty: targets = [max(left), min(right)];\n        else if left nonempty: targets = [max(left)];\n        else: targets = [min(right)];\n     c. For each c_t in targets:\n        i. For c from min(c_d,c_t) to max(c_d,c_t): set output_grid[r_d][c]=y_color.\n        ii. For i from r_d-1 to r_d+1 and j from c_t-1 to c_t+1, if (i,j) inside grid:\n              set output_grid[i][j]=x_color.\n        iii. Then set output_grid[r_d][c_t]=y_color.\n7. Return output_grid.",
    "c8f0f002.json": "1. Let R be the number of rows and C be the number of columns in the input grid.\n2. Create an output grid of size R×C.\n3. For each row index r from 0 to R−1 and each column index c from 0 to C−1:\n   a. Let v = input[r][c].\n   b. If v == 7 then set output[r][c] = 5; otherwise set output[r][c] = v.\n4. Return the output grid.",
    "5daaa586.json": "1. Let H0 = number of rows and W0 = number of columns of the input grid.\n2. Initialize empty lists horizontal_borders and vertical_borders.\n3. For each unique nonzero value C in the grid:\n   a. Let pos_C = list of (r,c) where grid[r][c] == C.\n   b. Let rows_C = set of r from pos_C; let cols_C = set of c from pos_C.\n   c. If |rows_C| == 1 and len(pos_C) >= W0 - 1, append (type=\"H\", index=r0, color=C) to horizontal_borders, where r0 is the single element of rows_C.\n   d. Else if |cols_C| == 1 and len(pos_C) >= H0 - 1, append (type=\"V\", index=c0, color=C) to vertical_borders, where c0 is the single element of cols_C.\n4. Let top_border = element of horizontal_borders with smaller index; bottom_border = the other.\n   Let left_border = element of vertical_borders with smaller index; right_border = the other.\n5. Let r1 = top_border.index, r2 = bottom_border.index, c1 = left_border.index, c2 = right_border.index.\n   Compute H = r2 - r1 + 1, W = c2 - c1 + 1.\n6. Build subgrid of size H×W: for r in r1..r2 and c in c1..c2, set subgrid[r-r1][c-c1] = grid[r][c].\n7. Record border colors: top_color = top_border.color; bottom_color = bottom_border.color;\n   left_color = left_border.color; right_color = right_border.color.\n8. For each interior cell (i,j) in subgrid with 0 < i < H-1 and 0 < j < W-1:\n   a. Let v = subgrid[i][j]. If v == 0, continue.\n   b. If v == top_color, then for rr from 0 to i inclusive set subgrid[rr][j] = v.\n   c. Else if v == bottom_color, then for rr from i to H-1 inclusive set subgrid[rr][j] = v.\n   d. Else if v == left_color, then for cc from 0 to j inclusive set subgrid[i][cc] = v.\n   e. Else if v == right_color, then for cc from j to W-1 inclusive set subgrid[i][cc] = v.\n9. Return subgrid as the output grid.",
    "f25ffba3.json": "1. Determine the number of rows H and columns W in the input grid.\n2. Compute half-height h = H / 2.\n3. Initialize an empty output grid of size H x W.\n4. For each row index r from 1 to h and each column index c from 1 to W, set output[r][c] = input[H - r + 1][c].\n5. For each row index r from h + 1 to H and each column index c from 1 to W, set output[r][c] = input[r][c].\n6. Return the output grid.",
    "67a423a3.json": "1. Let row_count = number of rows, col_count = number of columns, with rows and columns zero-indexed from 0 to row_count-1 and 0 to col_count-1. 2. For each non-zero pixel value v in the grid, collect S_v = {(r,c) | grid[r][c] == v}. 3. Identify the horizontal line: find the value H for which all (r,c) in S_H share the same row index R. 4. Identify the vertical line: find the value V≠H for which all (r,c) in S_V share the same column index C. 5. Compute the intersection coordinate (R,C). 6. For each offset (dr,dc) in {(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)}: if 0 ≤ R+dr < row_count and 0 ≤ C+dc < col_count, set grid[R+dr][C+dc] = 4. 7. Leave grid[R][C] and all other cells unchanged. 8. Return the modified grid.",
    "6773b310.json": "1. Use zero-based indexing. 2. Identify horizontal separators: collect all row indices r for which input[r][c] == 8 for every column c. 3. Identify vertical separators: collect all column indices c for which input[r][c] == 8 for every row r. 4. Determine rowSegments: take the set of all row indices not in horizontal separators, sort them, and group into contiguous runs of consecutive indices. 5. Determine colSegments: take the set of all column indices not in vertical separators, sort them, and group into contiguous runs. 6. Initialize an output grid of size rowSegments.length rows by colSegments.length columns, filling every cell with 0. 7. For each segment index i from 0 to rowSegments.length-1 and each j from 0 to colSegments.length-1:   a. Let rows = rowSegments[i] and cols = colSegments[j].   b. Compute pinkCount = number of pairs (r,c) with r in rows and c in cols such that input[r][c] == 6.   c. If pinkCount == 2, set output[i][j] = 1. 8. Return the output grid.",
    "68b16354.json": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Initialize an output grid of size H×W.\n3. For each row index r from 0 to H−1 and for each column index c from 0 to W−1:\n     a. Set output[r][c] = input[H−1−r][c].\n4. Return the output grid.",
    "c444b776.json": "1. Let H = number of rows, W = number of columns. 2. Identify all row indices R where for every C from 0 to W-1 grid[R][C]==4; store sorted in divider_rows. 3. Identify all column indices C where for every R from 0 to H-1 grid[R][C]==4; store sorted in divider_cols. 4. Define row_bounds = [-1] + divider_rows + [H] and col_bounds = [-1] + divider_cols + [W]. 5. For each i in 0..len(row_bounds)-2 and each j in 0..len(col_bounds)-2 define a section with top-left (r0=row_bounds[i]+1, c0=col_bounds[j]+1) and bottom-right (r1=row_bounds[i+1]-1, c1=col_bounds[j+1]-1) if r0<=r1 and c0<=c1. 6. For each section scan cells (r,c) in [r0..r1]×[c0..c1]; if any grid[r][c]!=0 and !=4 designate this as source section with bounds r0_s,c0_s,r1_s,c1_s and stop. 7. Initialize shapes = empty list. For r from r0_s to r1_s and c from c0_s to c1_s: if grid[r][c]!=0 and !=4 compute dr=r-r0_s, dc=c-c0_s and append (dr,dc,grid[r][c]) to shapes. 8. For each section other than source with top-left (r0,c0), for each (dr,dc,v) in shapes set grid[r0+dr][c0+dc]=v. 9. Return the modified grid.",
    "b8825c91.json": "1. Let N = number of rows in the input grid (equal to number of columns).\n2. For each row index r from 0 to N-1 and each column index c from 0 to N-1:\n   a. If grid[r][c] == 4 then:\n      i. Compute c_v = N - 1 - c and r_h = N - 1 - r.\n      ii. If grid[r][c_v] != 4 then set grid[r][c] = grid[r][c_v].\n      iii. Else if grid[r_h][c] != 4 then set grid[r][c] = grid[r_h][c].\n      iv. Else set grid[r][c] = grid[r_h][c_v].\n3. Return the modified grid.",
    "f2829549.json": "1. Let H = number of rows in input grid and C = number of columns.\n2. Identify sep = the unique column index in [0..C-1] such that input[r][sep] == 1 for all r in [0..H-1].\n3. Set region_width = sep and region_height = H.\n4. Initialize an output grid of size region_height rows by region_width columns.\n5. For each row r from 0 to region_height-1 and each column c from 0 to region_width-1:\n   a. Let left_pixel = input[r][c].\n   b. Let right_pixel = input[r][sep + 1 + c].\n   c. If left_pixel == 0 AND right_pixel == 0, set output[r][c] = 3; otherwise set output[r][c] = 0.\n6. Return the output grid.",
    "eb5a1d5d.json": "1. Parse the input as a 2D array grid of integers. 2. Initialize a boolean array VISITED of the same shape, all false. 3. Initialize an empty list CLUSTERS. 4. For each cell (r,c) in grid in row-major order: if VISITED[r][c] is false, let color = grid[r][c]; perform a flood-fill (4-connected) from (r,c) to collect all cells of this cluster; mark them visited; compute min_row, max_row, min_col, max_col over these cells; append to CLUSTERS an object with fields {color, min_row, max_row, min_col, max_col}. 5. For each cluster compute area = (max_row - min_row + 1) * (max_col - min_col + 1). 6. Sort CLUSTERS in descending order by area. 7. Let K = length of CLUSTERS; define RING_COLORS as the list of cluster.color in sorted order (index 0 = outermost). 8. Compute N = 2 * K - 1. 9. Initialize an output grid OUT of size N×N. 10. For each 0 ≤ r < N and 0 ≤ c < N compute d = min(r, c, N-1-r, N-1-c) and set OUT[r][c] = RING_COLORS[d]. 11. Return OUT.",
    "f76d97a5.json": "1. Let background_value = 5. 2. Let values = set of all cell values in the input grid. 3. Remove background_value from values; the remaining single element is target_value. 4. Initialize an output grid of the same dimensions as the input grid. 5. For each cell at row r and column c:   a. If input[r][c] == background_value, set output[r][c] = target_value.   b. Otherwise (input[r][c] == target_value), set output[r][c] = 0. 6. Return the output grid.",
    "eb281b96.json": "1. Let H = number of rows of the input grid; W = number of columns of the input grid.\n2. Compute P = 2 * H - 2.\n3. Construct an array pattern_rows of length P:\n   For k from 0 to P-1:\n     If k < H:\n       pattern_rows[k] = the entire row k of the input grid.\n     Else:\n       pattern_rows[k] = the entire row at index (2*H - 2 - k) of the input grid.\n4. Set output_height = 2 * P + 1; output_width = W.\n5. Initialize an empty output grid of size output_height × output_width.\n6. For each row index i from 0 to output_height - 1:\n     Let j = i mod P.\n     Copy pattern_rows[j] into row i of the output grid.\n7. Return the output grid.",
    "c9e6f938.json": "1. Determine H as the number of rows and W as the number of columns in the input grid.\n2. Create an output grid with H rows and 2*W columns.\n3. For each row r in [0..H-1] and each column c in [0..W-1]:\n   a. Set output[r][c] = input[r][c].\n   b. Set output[r][W + c] = input[r][W - 1 - c].\n4. Return the output grid.",
    "694f12f3.json": "1. Denote the input grid as grid[r][c] with zero-based row index r and column index c.\n2. Identify all connected components of pixels with value 4 using 4-way adjacency; there will be exactly two components.\n3. For each component compute its size as the count of pixels in that component.\n4. Designate the component with larger size as large and the other as small.\n5. For each component compute its bounding box: min_row, max_row, min_col, max_col over its pixels.\n6. For the large component, for each r in the range min_row+1 through max_row-1 and each c in the range min_col+1 through max_col-1, set grid[r][c] = 2.\n7. For the small component, for each r in the range min_row+1 through max_row-1 and each c in the range min_col+1 through max_col-1, set grid[r][c] = 1.\n8. Leave all other cells unchanged and return the modified grid.",
    "673ef223.json": "1. Let H be the number of rows and W be the number of columns of the input grid. 2. Compute red_columns = sorted list of all column indices j such that any cell grid[r][j] == 2; assert len(red_columns) == 2. 3. For each j in red_columns, compute red_rows[j] = sorted list of row indices r where grid[r][j] == 2. 4. Compute dots = list of pairs (r,c) where grid[r][c] == 8 and dot_rows = set of their r values. 5. Let col_A be the column in red_columns whose red_rows intersect dot_rows; let col_B be the other column. Let shape_A_rows = red_rows[col_A] and shape_B_rows = red_rows[col_B]. 6. Initialize output grid as a deep copy of the input grid. 7. For each (r,c) in dots: compute left = min(c,col_A) and right = max(c,col_A); for x from left+1 to right-1 inclusive set output[r][x] = 8; then set output[r][c] = 4. 8. For each (r,c) in dots: let idx = index of r in shape_A_rows (0-based); let r_b = shape_B_rows[idx]; if col_B > col_A then for x from 0 to col_B-1 inclusive set output[r_b][x] = 8 else for x from col_B+1 to W-1 inclusive set output[r_b][x] = 8. 9. Leave all other cells unchanged and return the output grid.",
    "4c5c2cf0.json": "1. Scan grid to collect all distinct non-zero values. Identify center_color as the value occurring exactly 5 times; let quad_color be the other non-zero value.\n2. Locate the center of the center_shape: find coordinate (r0,c0) where grid[r0][c0]==center_color and its four diagonal neighbors (r0-1,c0-1),(r0-1,c0+1),(r0+1,c0-1),(r0+1,c0+1) also equal center_color.\n3. Build list P of all coordinates (r,c) where grid[r][c]==quad_color.\n4. For each (r,c) in P:\n   a. Compute dr = r - r0 and dc = c - c0.\n   b. For each pair (sign_r,sign_c) in {(1,1),(1,-1),(-1,1),(-1,-1)}:\n      i. Compute r_new = r0 + sign_r * dr and c_new = c0 + sign_c * dc.\n      ii. If 0 ≤ r_new < num_rows and 0 ≤ c_new < num_cols, set grid[r_new][c_new] = quad_color.\n5. Return the modified grid.",
    "00d62c1b.json": "1. Let H be the number of rows and W be the number of columns in the input grid. 2. Initialize the output grid as an exact copy of the input grid. 3. Create an empty set VISITED. 4. For each cell (r,c) with 0 ≤ r < H and 0 ≤ c < W, if input[r][c] == 0 and (r,c) is not in VISITED, then perform a flood fill:   a. Initialize a list REGION ← [] and a queue Q ← [(r,c)], and set TOUCHES_BORDER ← false.   b. While Q is not empty:     i. Pop (y,x) from Q.     ii. If (y,x) ∈ VISITED, continue.     iii. Add (y,x) to VISITED and append (y,x) to REGION.     iv. If y == 0 or y == H-1 or x == 0 or x == W-1, set TOUCHES_BORDER ← true.     v. For each of the four cardinal neighbors (y+1,x), (y-1,x), (y,x+1), (y,x-1) that lie within 0 ≤ y < H and 0 ≤ x < W, if input[y][x] == 0 and that neighbor is not in VISITED, add it to Q.   c. After the flood fill completes, if TOUCHES_BORDER is false, then for each (y,x) in REGION set output[y][x] ← 4. 5. Return the output grid.",
    "c9f8e694.json": "1. Compute R = number of rows and C = number of columns in input grid G.\n2. Initialize output grid O with dimensions R x C.\n3. For each row index r from 0 to R-1 and each column index c from 0 to C-1: if G[r][c] == 5 then set O[r][c] = G[r][0] else set O[r][c] = G[r][c].\n4. Return O.",
    "f5b8619d.json": "1. Use 0-based indexing. Let H = number of rows and W = number of columns of the input grid. 2. Initialize a working grid Q of size H×W as a copy of the input grid. 3. For each cell (r,c) where input[r][c] ≠ 0 do:   a. For i from r−1 down to 0: if input[i][c] = 0 then set Q[i][c] = 8 else break this loop.   b. For i from r+1 up to H−1: if input[i][c] = 0 then set Q[i][c] = 8 else break this loop. 4. Initialize an output grid O of size 2H×2W. 5. For each quadrant offset (dr,dc) in {(0,0),(0,W),(H,0),(H,W)} and for each r in 0..H−1, c in 0..W−1, set O[dr+r][dc+c] = Q[r][c]. 6. Return O.",
    "681b3aeb.json": "1. Scan input grid to collect all nonzero values; there will be exactly two distinct values, call them v1 and v2.\n2. For each value vi in {v1, v2}:\n   a. Let Ci = { (r,c) | input_grid[r][c] == vi }.\n   b. Compute min_row_i = min(r), max_row_i = max(r), min_col_i = min(c), max_col_i = max(c) over Ci.\n   c. Let height_i = max_row_i - min_row_i + 1 and width_i = max_col_i - min_col_i + 1.\n   d. Define pattern Pi = { (r - min_row_i, c - min_col_i) | (r,c) in Ci }.\n3. Define T = { (r,c) | 0 ≤ r < 3 and 0 ≤ c < 3 }.\n4. Find integer offsets (dr1, dc1) with 0 ≤ dr1 ≤ 3 - height_1, 0 ≤ dc1 ≤ 3 - width_1 and (dr2, dc2) with 0 ≤ dr2 ≤ 3 - height_2, 0 ≤ dc2 ≤ 3 - width_2 such that:\n   a. S1 = { (dr1 + r, dc1 + c) | (r,c) in P1 }\n   b. S2 = { (dr2 + r, dc2 + c) | (r,c) in P2 }\n   c. S1 ∩ S2 = ∅\n   d. S1 ∪ S2 = T\n5. Initialize a 3×3 output grid filled with zeros.\n6. For each (r,c) in S1 set output_grid[r][c] = v1; for each (r,c) in S2 set output_grid[r][c] = v2.\n7. Return the 3×3 output grid.",
    "bda2d7a6.json": "1. Let N = number of rows in the input grid (equal to number of columns).\n2. Let L = (N + 1) // 2  (integer division).\n3. Initialize an empty list CYCLE.\n4. For d from L - 1 down to 0:\n   a. Let color = input_grid[d][d].  // each nested square or ring is uniform, so (d,d) samples its color\n   b. If color is not already in CYCLE, append color to CYCLE.\n5. Let M = length of CYCLE.\n6. Create an output_grid of size N×N.\n7. For each row r from 0 to N-1 and each column c from 0 to N-1:\n   a. Let v = input_grid[r][c].\n   b. If v appears in CYCLE at index i (0-based), set output_grid[r][c] = CYCLE[(i + 1) mod M]; otherwise set output_grid[r][c] = v.\n8. Return output_grid.",
    "e6721834.json": "Step 1: Let H = number of rows and W = number of columns in the input grid.\nStep 2: Determine a two-section split:\n  If W mod 2 == 0 then\n    set mid = W/2;\n    define regionA as all cells with column index in [0..mid-1], same rows;\n    define regionB as all cells with column index in [mid..W-1], same rows.\n  Else\n    set mid = H/2;\n    define regionA as all cells with row index in [0..mid-1], same columns;\n    define regionB as all cells with row index in [mid..H-1], same columns.\nStep 3: Classify the two halves:\n  For each region in {regionA, regionB}:\n    compute bg = the value that appears most frequently in that region;\n    scan each cell (r,c) in the region; if grid[r][c] != bg and any 4‐neighbor (r+dr,c+dc) inside the same region also has value != bg, mark this region as boxRegion.\nStep 4: Let markerRegion be the other region (not boxRegion).\nStep 5: Extract shapeGrid = subgrid of boxRegion; markerGrid = subgrid of markerRegion.\nStep 6: Compute markerBG = most frequent value in markerGrid.\nStep 7: Initialize outputGrid of same dimensions as markerGrid, filling every cell with markerBG.\nStep 8: In shapeGrid:\n  let bgBox = most frequent value in shapeGrid;\n  find all connected components (4‐neighbors) of cells with value != bgBox;\n  for each component comp:\n    a. compute minR = min row, maxR = max row, minC = min col, maxC = max col over comp;\n    b. for each cell (r,c) in comp, record shapePattern entry (dr = r - minR, dc = c - minC, val = shapeGrid[r][c]);\n    c. count occurrences of each val in shapePattern; let borderVal = value with highest count; let interiorVals = set of values ≠ borderVal (should be one); let interiorVal = that single value;\n    d. let interiorOffsets = list of (dr,dc) from shapePattern where val == interiorVal;\n    e. store descriptor {shapePattern, interiorVal, interiorOffsets}.\nStep 9: In markerGrid, for each cell (r,c) with value != markerBG, append (r,c) to markersByColor[value].\nStep 10: For each shape descriptor:\n  a. let IV = interiorVal, IOffs = interiorOffsets, Pat = shapePattern;\n  b. let M = markersByColor[IV] (list of marker coords);\n  c. for each m in M:\n       compute offR = m.r - IOffs[0].dr, offC = m.c - IOffs[0].dc;\n       if the set {(dr+offR, dc+offC) for each (dr,dc) in IOffs} equals the set M, break and keep (offR,offC);\n  d. for each (dr,dc,val) in Pat: set outputGrid[dr+offR][dc+offC] = val.\nStep 11: Return outputGrid.",
    "007bbfb7.json": "1. Let A be the input grid of size 3×3 with indices r,c in {0,1,2}. 2. Create an output grid B of size 9×9 and set every B[x][y]=0 for x,y in {0…8}. 3. Identify the unique non-zero integer value c present in A. 4. For each r in 0…2 and each c₁ in 0…2: if A[r][c₁]=c then copy the entire 3×3 array A into the 3×3 block of B whose top-left corner is at (r*3, c₁*3): for i in 0…2 and j in 0…2 set B[r*3 + i][c₁*3 + j] = A[i][j]. 5. Return B.",
    "f8b3ba0a.json": "1. Let U be the set of all distinct values >0 in the input grid.\n2. For each color c in U, compute count[c] = number of cells in the input grid equal to c.\n3. Create list L of the values in U sorted in ascending order by count[c].\n4. Remove the last element of L (the color with the highest count); now L has length 3.\n5. Initialize an output grid G of size 3 rows × 1 column filled with 0.\n6. Assign G[0][0] = L[2], G[1][0] = L[1], G[2][0] = L[0].\n7. Return G.",
    "c909285e.json": "1. Let G be the input grid with height H and width W, with rows indexed 0..H-1 and columns indexed 0..W-1.\n2. For each integer v in 0..9:\n   a. Let P_v = {(r,c) | G[r][c] == v}.\n   b. If |P_v| < 4, continue to next v.\n   c. Compute r_min = min r over P_v, r_max = max r, c_min = min c, c_max = max c.\n   d. Let height = r_max - r_min + 1 and width = c_max - c_min + 1.\n   e. If height == width and |P_v| == 4*height - 4, then set border_value = v, top = r_min, left = c_min, size = height, and break the loop.\n3. Create output grid O of dimensions size × size.\n4. For dr from 0 to size-1 and dc from 0 to size-1, set O[dr][dc] = G[top + dr][left + dc].\n5. Return O as the result grid.",
    "cce03e0d.json": "1. Let G be the input grid of size 3 rows by 3 columns.  Use 0-based indexing for rows and columns. 2. Create an output grid R of size 9 rows by 9 columns.  Initialize every cell of R to 0. 3. For each input cell at row r from 0 to 2 and column c from 0 to 2:    a. If G[r][c] == 2 then:       i. For each i from 0 to 2 and each j from 0 to 2:          – Set R[r*3 + i][c*3 + j] = G[i][j]. 4. Return R as the transformed 9×9 grid.",
    "f8ff0b80.json": "1. Initialize an empty dictionary counts.\n2. For each coordinate (r, c) in the input grid, let v = input[r][c]. If v != 0, then if counts[v] exists increment it by 1; otherwise set counts[v] = 1.\n3. Let values be the list of keys from counts (distinct non-zero integers).\n4. Sort values in descending order by counts[v]; if two values have equal counts, sort by v in ascending order.\n5. Let K = length of values (should be 3). Create an output grid with K rows and 1 column.\n6. For each index i from 0 to K-1, set the output grid cell at (i, 0) to values[i].\n7. Return the output grid.",
    "447fd412.json": "1. Let grid_height = number of rows and grid_width = number of columns. Copy input grid to output grid.\n2. Identify all non-zero connected components using 4-connectivity; let components = list of sets of (r,c).\n3. Select template component: the component containing at least two distinct non-zero values; let template_cells = list of (r,c,value) in this component.\n4. Compute template_min_row = min(r for (r,c,_) in template_cells) and template_min_col = min(c for (r,c,_) in template_cells).\n5. Let values = set(value for (_,_,value) in template_cells). For each v in values compute total_count[v] in input; let endpoint_value = v for which total_count[v] > number of template_cells with value v; let interior_value = the other.\n6. Let endpoint_cells_template = sorted list of (r,c) in template_cells where value = endpoint_value; let E = length of endpoint_cells_template.\n7. From input, find all connected components of cells with value = endpoint_value that are not the template component; let endpoint_components = list of these components. For each comp in endpoint_components compute comp.min_row, comp.max_row, comp.min_col, comp.max_col.\n8. Let N = number of endpoint_components; compute shape_count S = N / E (integer).\n9. Determine primary axis: if all r in endpoint_cells_template are equal then primary='row', else primary='col'; let secondary be the other axis.\n10. Sort endpoint_components ascending by comp.min_<primary>; partition into S groups of E components in sequence; let shape_groups = list of these groups.\n11. Sort endpoint_cells_template ascending by their <secondary> coordinate.\n12. For each group g in shape_groups:\n    a. Sort g ascending by comp.min_<secondary>.\n    b. For i from 0 to E-1 assign comp_i = g[i] and endpoint_i = endpoint_cells_template[i].\n    c. Let comp_anchor = comp_0; compute s_row = comp_anchor.max_row - comp_anchor.min_row + 1; compute s_col = comp_anchor.max_col - comp_anchor.min_col + 1; assert s_row == s_col; let s = s_row.\n    d. Let endpoint_anchor = endpoint_cells_template[0]; compute target_row = comp_anchor.min_row - (endpoint_anchor.r - template_min_row) * s; compute target_col = comp_anchor.min_col - (endpoint_anchor.c - template_min_col) * s.\n    e. For each (r_tpl,c_tpl,value) in template_cells and for dr in 0..s-1 and dc in 0..s-1:\n         out_r = target_row + (r_tpl - template_min_row) * s + dr\n         out_c = target_col + (c_tpl - template_min_col) * s + dc\n         If 0 <= out_r < grid_height and 0 <= out_c < grid_width then set output_grid[out_r][out_c] = value.\n13. Return output_grid.",
    "ce22a75a.json": "1. Let H be the number of rows and W the number of columns of the input grid.\n2. Initialize an output grid of size H×W with all cells set to 0.\n3. For each row index r from 0 to H–1 and each column index c from 0 to W–1:\n   a. If the input cell at (r,c) has value 5, then:\n      i. For each dr in {–1, 0, 1}:\n         1. For each dc in {–1, 0, 1}:\n            A. Let nr = r + dr and nc = c + dc.\n            B. If 0 ≤ nr < H and 0 ≤ nc < W, set output[nr][nc] = 1.\n4. Return the output grid.",
    "5c2c9af4.json": "Use zero-based indexing for rows and columns. Let R be the number of rows and C be the number of columns in the input grid.\n\n1. Locate all cells (r, c) where input[r][c] != 0; let P be the list of these coordinates. Let color = the nonzero value at these cells. Assert |P| = 3.\n2. Sort P by r ascending, then by c ascending. Denote the sorted points P1 = (r1, c1), P2 = (r2, c2), P3 = (r3, c3).\n3. Compute d_row = abs(r3 - r1), d_col = abs(c3 - c1). Set initial_side = min(d_row, d_col) + 1.\n4. Compute half = (initial_side - 1) / 2 (integer division; initial_side is odd so half is integer).\n5. Let center = P2.\n6. Initialize output grid as a copy of the input grid.\n7. For k = 0, 1, 2, ...:\n   a. Let h = half + k.\n   b. Compute r_top = center.r - h, r_bottom = center.r + h, c_left = center.c - h, c_right = center.c + h.\n   c. Initialize an empty set S of coordinates.\n   d. For x from c_left to c_right:\n      - If 0 <= r_top < R and 0 <= x < C, add (r_top, x) to S.\n      - If 0 <= r_bottom < R and 0 <= x < C, add (r_bottom, x) to S.\n   e. For y from r_top + 1 to r_bottom - 1:\n      - If 0 <= y < R and 0 <= c_left < C, add (y, c_left) to S.\n      - If 0 <= y < R and 0 <= c_right < C, add (y, c_right) to S.\n   f. If S is empty, break the loop.\n   g. For each (r, c) in S, set output[r][c] = color.\n8. Return the output grid.",
    "6c434453.json": "1. Let inputGrid be the given H×W grid of integers. Create outputGrid as a copy of inputGrid.  \n2. For each row r from 1 to H-2 and each column c from 1 to W-2, do:  \n   a. If inputGrid[r][c] == 0 and for all (dr,dc) ∈ {(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)} we have inputGrid[r+dr][c+dc] == 1, then this 3×3 block is a hollow blue square.  \n   b. In outputGrid, replace this 3×3 block with a red cross:  \n      i. Set outputGrid[r][c] = 2.  \n      ii. Set outputGrid[r-1][c], outputGrid[r+1][c], outputGrid[r][c-1], outputGrid[r][c+1] = 2.  \n      iii. Set outputGrid[r-1][c-1], outputGrid[r-1][c+1], outputGrid[r+1][c-1], outputGrid[r+1][c+1] = 0.  \n3. Leave all other cells unchanged.  \n4. Return outputGrid of same dimensions as inputGrid.",
    "cdecee7f.json": "1. Identify all non-zero pixels in the input grid; record each as a tuple (r, c, v), where v is the pixel value 1–9.\n2. Sort the list of tuples by ascending c (column); if two tuples share the same c, sort those by ascending r (row).\n3. Extract the sorted values into a list L of length N (1 ≤ N ≤ 9).\n4. Create an output grid of 3 rows and 3 columns; initialize every cell to 0.\n5. Build a list S of the 9 output coordinates in “snake” order: row 0 columns 0→2, row 1 columns 2→0, row 2 columns 0→2.\n6. For each i from 0 to N−1, let (r_out, c_out) = S[i] and set output[r_out][c_out] = L[i].\n7. Leave any remaining output cells (for i ≥ N) as 0.",
    "f8a8fe49.json": "1. Locate all pixels with value 2. Compute minRow = minimum row index of these pixels, maxRow = maximum row index, minCol = minimum column index, maxCol = maximum column index.\n2. Define interior as rows r satisfying minRow<r<maxRow and columns c satisfying minCol<c<maxCol.\n3. Collect set P of all pixels (r,c) with value 5 that lie in the interior.\n4. Partition P into connected components by 4-connectivity. Let comps be the list of these components.\n5. Compute centerRowRect = (minRow + maxRow) / 2.0 and centerColRect = (minCol + maxCol) / 2.0.\n6. For each component S in comps compute avgRow(S) = average of r over (r,c) in S, avgCol(S) = average of c over (r,c) in S.\n7. Determine separation axis:\n   a. If exists S1,S2 in comps with avgRow(S1)<centerRowRect and avgRow(S2)>centerRowRect then axis = horizontal.\n   b. Else if exists S1,S2 in comps with avgCol(S1)<centerColRect and avgCol(S2)>centerColRect then axis = vertical.\n   c. Else axis = none.\n8. Initialize empty list newPositions.\n9. If axis = horizontal then:\n   For each component S in comps:\n     If avgRow(S) < centerRowRect then // S lies in top half\n       For each (r,c) in S compute newR = minRow - (r - minRow), newC = c, append (newR,newC) to newPositions.\n     Else // S lies in bottom half\n       For each (r,c) in S compute newR = maxRow + (maxRow - r), newC = c, append (newR,newC).\n10. Else if axis = vertical then:\n    For each component S in comps:\n      If avgCol(S) < centerColRect then // S lies in left half\n        For each (r,c) in S compute newR = r, newC = minCol - (c - minCol), append (newR,newC).\n      Else // S lies in right half\n        For each (r,c) in S compute newR = r, newC = maxCol + (maxCol - c), append (newR,newC).\n11. Else (axis = none) then for each (r,c) in P:\n    Compute dTop = r - minRow, dBottom = maxRow - r, dLeft = c - minCol, dRight = maxCol - c.\n    Let side = one of {top,bottom,left,right} with minimal d. If tie, prefer left/right over top/bottom.\n    If side = top then newR = minRow - dTop, newC = c.\n    If side = bottom then newR = maxRow + dBottom, newC = c.\n    If side = left then newR = r, newC = minCol - dLeft.\n    If side = right then newR = r, newC = maxCol + dRight.\n    Append (newR,newC) to newPositions.\n12. Copy input grid to output grid. For each (r,c) in P set output[r][c] = 0. For each (r,c) in newPositions set output[r][c] = 5.\n13. Return the output grid (same dimensions as input).",
    "025d127b.json": "1. Let R be the number of rows and C be the number of columns of the input grid.\n2. Create an output grid of size R×C, initializing every cell to 0.\n3. Identify V = the set of all distinct non-zero values in the input grid.\n4. For each v in V, compute b_v = the maximum row index r such that input[r][c] == v for some column c.\n5. For each row r from 0 to R-1 and each column c from 0 to C-1:\n   a. If input[r][c] == 0, continue to next cell.\n   b. Let v = input[r][c].\n   c. If r == b_v or input[r+1][c] == v, set output[r][c] = v.\n   d. Otherwise set output[r][c+1] = v.\n6. Return the output grid.",
    "017c7c7b.json": "1. Let H = number of rows in input grid, W = number of columns.\n2. Find the smallest integer k (1 ≤ k < H) such that for every row index r in 0..H-k-1 and every column index c in 0..W-1: input[r][c] = input[r+k][c].\n3. Compute new height H2 = H + H/2.\n4. Create output grid of size H2 x W.\n5. For each row index r in 0..H2-1:\n    a. If r < H then set src_r = r; otherwise set src_r = r mod k.\n    b. For each column index c in 0..W-1:\n        i. Let v = input[src_r][c].\n        ii. If v = 1 then set output[r][c] = 2; else set output[r][c] = v.",
    "0520fde7.json": "1. Locate the vertical line of grey pixels (value 5) in the input grid; let divider_col be its column index.\n2. Let H = number of rows in the input grid; let W_total = number of columns; compute W_left = divider_col and W_right = W_total - divider_col - 1; ensure W_right == W_left.\n3. Initialize an output grid of size H × W_left with all cells set to 0.\n4. For each row r in 0..H-1 and each column c in 0..W_left-1:\n     a. Let left_value = input[r][c].\n     b. Let right_value = input[r][c + divider_col + 1].\n     c. If left_value == 1 AND right_value == 1, set output[r][c] = 2; otherwise leave output[r][c] = 0.\n5. Return the output grid.",
    "6cf79266.json": "1. Let H be the number of rows and W be the number of columns of the input grid.\n2. Create an output grid by copying every cell of the input grid.\n3. For each row index r from 0 to H-3 inclusive and each column index c from 0 to W-3 inclusive:\n   a. Check the 3×3 block of cells with top-left corner at (r,c): for all dr in {0,1,2} and dc in {0,1,2}, verify input[r+dr][c+dc] == 0.\n   b. If the entire 3×3 block equals 0, then for all dr in {0,1,2} and dc in {0,1,2}, set output[r+dr][c+dc] = 1.\n4. After scanning all positions, return the output grid.",
    "a64e4611.json": "1. Let H = number of rows and W = number of columns in the input grid. 2. Define BACK=0 and FILL=3. 3. Initialize best_area=0 and best_rectangle=(0,0,0,0). 4. For r1 from 0 to H-1:   For r2 from r1 to H-1:     For c1 from 0 to W-1:       For c2 from c1 to W-1:         a. Compute area = (r2 - r1 + 1) * (c2 - c1 + 1).         b. If area <= best_area then continue.         c. For each r in [r1..r2] and c in [c1..c2], if grid[r][c] != BACK then skip to next (c2).         d. At this point all cells in the subgrid are BACK. Set best_area = area and best_rectangle = (r1, r2, c1, c2). 5. Let (r1, r2, c1, c2) = best_rectangle. 6. For each r in [r1..r2] and each c in [c1..c2], set grid[r][c] = FILL. 7. Output the modified grid.",
    "fafffa47.json": "1. Interpret the input as a grid G with 6 rows and 3 columns.\n2. Initialize an output grid O with 3 rows and 3 columns.\n3. For each row index r from 0 to 2 and each column index c from 0 to 2:\n   a. Let a = G[r][c] and b = G[r+3][c].\n   b. If a == 0 and b == 0 then set O[r][c] = 2 else set O[r][c] = 0.\n4. Return O.",
    "caa06a1f.json": "1. Let H = number of rows in input grid, W = number of columns.  Use 0-based indexing for rows R ∈ [0,H-1] and columns C ∈ [0,W-1].\n2. Let border_color = grid[H-1][W-1].\n3. Compute bottom_border_rows: the largest integer k1 ≥ 1 such that for each r in 0..k1-1 and each C in 0..W-1, grid[H-1-r][C] == border_color.\n4. Compute right_border_cols: the largest integer k2 ≥ 1 such that for each c in 0..k2-1 and each R in 0..H-1, grid[R][W-1-c] == border_color.\n5. Let k = min(k1, k2).\n6. Define interior region as rows R in [0, H-k-1] and columns C in [0, W-k-1].  Let Hi = H-k, Wi = W-k.\n7. Determine tile_h: the smallest integer h in [1, Hi] such that for all R in 0..Hi-1 and C in 0..Wi-1, grid[R][C] == grid[R mod h][C].\n8. Determine tile_w: the smallest integer w in [1, Wi] such that for all R in 0..Hi-1 and C in 0..Wi-1, grid[R][C] == grid[R][C mod w].\n9. Extract tile T of size tile_h × tile_w: for r in 0..tile_h-1 and c in 0..tile_w-1, T[r][c] = grid[r][c].\n10. Initialize output grid of size H × W.\n11. For each output cell at (R,C) set output[R][C] = T[R mod tile_h][(C + 1) mod tile_w].\n12. Return the output grid.",
    "ef135b50.json": "1. Let H be the number of rows in the input grid and W the number of columns. 2. Create the output grid as an exact copy of the input grid. 3. For each row index r from 1 to H-2 (i.e. skip the first and last rows):\n   a. Collect all column indices c where input[r][c] == 2.  \n   b. If fewer than two such indices exist, continue to the next row.  \n   c. Let c_min be the minimum of these indices and c_max the maximum.  \n   d. For each column c in the range c_min+1 to c_max-1 inclusive:\n      i. If input[r][c] == 0, set output[r][c] = 9.  \n4. Return the output grid.",
    "ce4f8723.json": "1. Compute R = number of rows and C = number of columns of the input grid.\n2. Locate the separator row index S such that for every column j in 0..C-1, input[S][j] == 4.\n3. Define M = S and N = C.\n4. Initialize an output grid O with M rows and N columns.\n5. For each i in 0..M-1 and j in 0..N-1:\n   a. Let A = input[i][j] and B = input[S+1+i][j].\n   b. If A == 0 and B == 0 then set O[i][j] = 0 else set O[i][j] = 3.\n6. Return O.",
    "6cdd2623.json": "1. Let M be the number of rows and N be the number of columns in the input grid.\n2. Count the occurrences of each non-zero integer in the grid and identify the integer d that appears exactly 4 times.\n3. Collect the list P of all coordinates (r,c) such that input[r][c] == d.\n4. Initialize an output grid of size M×N with every cell set to 0.\n5. Compute the set Cols = { c | (r,c) ∈ P and (r == 0 or r == M-1) }.\n6. For each column index c in Cols, set output[r][c] = d for all r from 0 to M-1.\n7. Compute the set Rows = { r | (r,c) ∈ P and (c == 0 or c == N-1) }.\n8. For each row index r in Rows, set output[r][c] = d for all c from 0 to N-1.\n9. Return the output grid.",
    "e8dc4411.json": "1. Let rows = number of rows in the input grid, cols = number of columns.\n2. Compute the frequency of each integer value in the grid. Let bg be the value with the highest frequency.\n3. Identify the pattern color patCol as the integer value ≠ bg whose frequency is greater than 1.\n4. Let P = { (r,c) | grid[r][c] == patCol }.\n5. Let candidates = { (r,c) | grid[r][c] ≠ bg and grid[r][c] ≠ patCol }.\n6. Find the unique coordinate C = (rC,cC) in candidates such that there exists (r_p,c_p) in P with max(|r_p - rC|, |c_p - cC|) == 1. Let colC = grid[rC][cC].\n7. Choose p0 = any (r_p,c_p) in P satisfying max(|r_p - rC|, |c_p - cC|) == 1. Compute direction dr = rC - r_p, dc = cC - c_p (dr,dc ∈ {-1,0,1}).\n8. For each (r_p,c_p) in P:\n     For k from 1 to max(rows,cols):\n         Let r' = r_p + k*dr, c' = c_p + k*dc.\n         If r' < 0 or r' ≥ rows or c' < 0 or c' ≥ cols then continue to next k.\n         If grid[r'][c'] == bg then set grid[r'][c'] = colC.\n9. Return the modified grid.",
    "6d0aefbc.json": "1. Let H be the number of rows in the input grid. 2. Let W be the number of columns in the input grid. 3. Initialize an output grid out with H rows and 2*W columns. 4. For each row index r from 0 to H-1:   4.1 For each column index c from 0 to W-1:     4.1.1 Let v = input[r][c].     4.1.2 Set out[r][c] = v.     4.1.3 Set out[r][2*W - 1 - c] = v. 5. Return out.",
    "05269061.json": "1. Let N be the number of rows (and columns) of the input grid. 2. Compute the set S of distinct non-zero values present in the input. 3. Let P = |S|. 4. Create an array diag_color of length P, initially unassigned for each index 0..P-1. 5. For each cell (r,c) with input[r][c] != 0:  \n   a. Compute k = (r + c) mod P.  \n   b. If diag_color[k] is unassigned, set diag_color[k] = input[r][c]; otherwise verify diag_color[k] == input[r][c].  \n6. Create an output grid of size N×N. 7. For each cell (r,c) in the output grid, set output[r][c] = diag_color[(r + c) mod P]. 8. Return the output grid.",
    "f9012d9b.json": "1. Let A be the input grid of size H×W, with rows indexed r=0…H–1 and columns c=0…W–1.\n2. Identify all cells with A[r][c]!=0. Let V be the set of distinct non‐zero values (should be two values).\n3. Find the bounding rectangle of zero cells: r_min = min{r | ∃c: A[r][c]=0}, r_max = max{r | ∃c: A[r][c]=0}, c_min = min{c | ∃r: A[r][c]=0}, c_max = max{c | ∃r: A[r][c]=0}.\n4. Compute the smallest vertical period P (1 ≤ P < H) such that for all r,c with r+P < H: if A[r][c]≠0 and A[r+P][c]≠0 then A[r][c]=A[r+P][c].\n5. Compute the smallest horizontal period Q (1 ≤ Q < W) such that for all r,c with c+Q < W: if A[r][c]≠0 and A[r][c+Q]≠0 then A[r][c]=A[r][c+Q].\n6. Initialize an empty tile T of size P×Q.\n7. For each r=0…H–1, c=0…W–1 with A[r][c]≠0: set i = r mod P, j = c mod Q, and assign T[i][j] = A[r][c].\n8. Let out_h = r_max – r_min + 1 and out_w = c_max – c_min + 1. Initialize output grid B of size out_h×out_w.\n9. For each u=0…out_h–1 and v=0…out_w–1: set B[u][v] = T[(r_min+u) mod P][(c_min+v) mod Q].\n10. Return B.",
    "f35d900a.json": "1. Copy the input grid into an output grid of the same size.  \n2. Find all cells with value ≠0. There will be exactly four. Let the two distinct nonzero values be A and B (each appears twice).  \n3. For each of these four cells at (r,c) with value v:  \n   a. Let other = (v==A ? B : A).  \n   b. For each (dr,dc) in {(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)}:  \n      • Set output[r+dr][c+dc] = other.  \n4. Let rows = sorted unique row indices of the four colored cells; let r_top = rows[0], r_bottom = rows[1].  \n5. Let cols = sorted unique column indices; let c_left = cols[0], c_right = cols[1].  \n6. Define the four connections between the 3×3 squares:  \n   • Top edge: between the squares centered at (r_top,c_left) and (r_top,c_right), along row=r_top.  \n   • Bottom edge: between squares at (r_bottom,c_left) and (r_bottom,c_right), along row=r_bottom.  \n   • Left edge: between squares at (r_top,c_left) and (r_bottom,c_left), along col=c_left.  \n   • Right edge: between squares at (r_top,c_right) and (r_bottom,c_right), along col=c_right.  \n7. For each horizontal connection on row R between centers at columns c1< c2:  \n   a. Let start_col = c1+2, end_col = c2-2, gap = end_col - start_col + 1.  \n   b. For i in 1..gap:  \n      • If (i%2==1 or i==gap), set output[R][start_col + i-1] = 5.  \n8. For each vertical connection on column C between centers at rows r1< r2:  \n   a. Let start_row = r1+2, end_row = r2-2, gap = end_row - start_row + 1.  \n   b. For i in 1..gap:  \n      • If (i%2==1 or i==gap), set output[start_row + i-1][C] = 5.  \n9. Return the output grid.",
    "05f2a901.json": "1. Identify S_blue = {(r,c) | input[r][c] = 8}. Compute blue_top = min_r, blue_bottom = max_r, blue_left = min_c, blue_right = max_c.\n2. Identify S_red = {(r,c) | input[r][c] = 2}. Compute red_top = min_r, red_bottom = max_r, red_left = min_c, red_right = max_c.\n3. If red_left ≤ blue_right AND blue_left ≤ red_right then axis = row else axis = col.\n4. If axis = row:\n     if red_bottom < blue_top then shift_r = blue_top - red_bottom - 1 else shift_r = blue_bottom - red_top + 1\n     shift_c = 0\n   Else (axis = col):\n     if red_right < blue_left then shift_c = blue_left - red_right - 1 else shift_c = blue_right - red_left + 1\n     shift_r = 0\n5. Copy input grid to output grid.\n6. For each (r,c) in S_red, set output[r][c] = 0.\n7. For each (r,c) in S_red, compute new coordinates (r+shift_r, c+shift_c) and set output[r+shift_r][c+shift_c] = 2.\n8. Return the output grid with the blue shape (8) unchanged and the red shape (2) translated until it orthogonally touches the blue shape.",
    "fcb5c309.json": "1. For each nonzero color value v in the input grid, find all 4-connected components of pixels equal to v.\n2. For each component S of color v:\n   a. Compute min_r and max_r as the minimum and maximum row indices of S.\n   b. Compute min_c and max_c as the minimum and maximum column indices of S.\n   c. Let h = max_r - min_r + 1 and w = max_c - min_c + 1.\n   d. Compute expected_border = 2*h + 2*w - 4.\n   e. If |S| equals expected_border, record this component as a frame of color v with bounding box (min_r, max_r, min_c, max_c), height h, and width w.\n3. Choose the recorded frame with the largest area (h * w). Let its bounding box be (min_r, max_r, min_c, max_c), and set H = max_r - min_r + 1 and W = max_c - min_c + 1.\n4. Let random_colors = set of all nonzero color values in the input minus the set of recorded frame colors. Let Y be the single element of random_colors.\n5. Create an output grid of size H rows and W columns, initialized to 0.\n6. For each output cell at (r, c) with 0 ≤ r < H and 0 ≤ c < W:\n   a. Compute R = min_r + r and C = min_c + c.\n   b. If r == 0 or r == H - 1 or c == 0 or c == W - 1, set output[r][c] = Y.\n   c. Otherwise, if input[R][C] == Y, set output[r][c] = Y.\n7. Return the output grid.",
    "fcc82909.json": "1. Let input_grid be the given grid of size M×N with 0 ≤ values ≤ 9. 2. Initialize output_grid as a deep copy of input_grid. 3. For each row r from 0 to M-2 and each column c from 0 to N-2, do:\n   a. If input_grid[r][c], input_grid[r][c+1], input_grid[r+1][c], and input_grid[r+1][c+1] are all non-zero, then:\n      i. Compute the set S = {input_grid[r][c], input_grid[r][c+1], input_grid[r+1][c], input_grid[r+1][c+1]}.  \n      ii. Let h = |S| (the number of distinct values in the 2×2 block).\n      iii. For i from 1 to h, and for j in 0 to 1, set output_grid[r+1+i][c+j] = 3.  \n4. Return output_grid.",
    "ce9e57f2.json": "1. Determine H = number of rows and W = number of columns.\n2. For each column index c from 0 to W-1:\n   a. If grid[H-1][c] == 2 then:\n      i. Initialize length = 0.\n      ii. For r from H-1 down to 0 while grid[r][c] == 2: increment length.\n      iii. Compute lower_count = floor(length / 2).\n      iv. For offset from 0 to lower_count - 1: set grid[H-1-offset][c] = 8.\n   b. Otherwise skip this column.\n3. Return the modified grid (all other cells remain unchanged).",
    "6d75e8bb.json": "1. Let region_value = 8, fill_value = 2, background_value = 0.\n2. Scan every cell (r,c) of the input grid; collect all r into set R and all c into set C for which grid[r][c] == region_value.\n3. Compute min_r = min(R), max_r = max(R), min_c = min(C), max_c = max(C).\n4. For each row r from min_r to max_r inclusive and each column c from min_c to max_c inclusive:\n   a. If grid[r][c] == background_value, then set grid[r][c] = fill_value.\n   b. Otherwise leave grid[r][c] unchanged.\n5. Return the resulting grid (same dimensions as input).",
    "cf98881b.json": "1. Let H = number of rows and C = number of columns of the input grid.\n2. Identify all column indices j where for every row i (0 ≤ i < H), grid[i][j] == 2. There will be exactly two such indices; sort them as s1 < s2.\n3. Define three subgrids of size H×W where W = s1:\n   • region1 = grid rows [0..H-1], columns [0..s1-1]\n   • region2 = grid rows [0..H-1], columns [s1+1..s2-1]\n   • region3 = grid rows [0..H-1], columns [s2+1..C-1]\n4. Initialize an output grid of size H×W by making a deep copy of region3.\n5. For each cell (i,j) in region2 (0 ≤ i < H, 0 ≤ j < W): if region2[i][j] != 0 then set output[i][j] = region2[i][j].\n6. For each cell (i,j) in region1 (0 ≤ i < H, 0 ≤ j < W): if region1[i][j] != 0 then set output[i][j] = region1[i][j].\n7. Return the output grid.",
    "08ed6ac7.json": "1. Identify all columns c such that input_grid[r][c] == 5 for one or more r. For each such column, define R_c = {r | input_grid[r][c] == 5}. 2. Compute the height of each bar as height = |R_c|. 3. Form a list of bars as tuples (c, R_c, height). 4. Sort the list in descending order by height; if two heights are equal, sort by ascending c. 5. For each bar at index i in the sorted list, set new_val = i+1 (longest->1, second->2, third->3, shortest->4). 6. Initialize output_grid as a copy of input_grid. 7. For each bar (c, R_c) with its new_val, set output_grid[r][c] = new_val for all r in R_c, leaving all other cells unchanged.",
    "feca6190.json": "1. Compute W = number of columns in the input grid.\n2. Extract the single input row into array P of length W, where P[j] = input[0][j] for each j from 0 to W-1.\n3. Identify list L of all indices j where P[j] != 0. Let k = length of L.\n4. Compute S = k * W.\n5. Initialize an output grid of size S rows by S columns, filled with 0.\n6. For each row r from 0 to S-1:\n   a. Compute horizontal offset c = (S - 1) - r.\n   b. For each j in L:\n      i. Compute target column x = c + j.\n      ii. If 0 <= x < S, set output[r][x] = P[j].\n7. Return the output grid.",
    "6e02f1e3.json": "1. Let D = number of rows (and columns) of the input grid (here D=3).\n2. Compute the set S of all values in the input grid; let N = |S|.\n3. Initialize an output grid of size D×D, setting every cell to 0.\n4. If N == 1: for c from 0 to D-1 do output[0][c] = 5.\n5. Else if N == 2: for i from 0 to D-1 do output[i][i] = 5.\n6. Else if N == 3: for i from 0 to D-1 do output[i][D-1-i] = 5.\n7. Return the output grid.",
    "6d0160f0.json": "1. Let H = grid height, W = grid width. 2. Identify dividing rows: collect all indices r in [0..H-1] such that for every c in [0..W-1], grid[r][c]==5. Call this list R_div of length 2, sorted ascending. 3. Identify dividing columns: collect all indices c in [0..W-1] such that for every r in [0..H-1], grid[r][c]==5. Call this list C_div of length 2, sorted ascending. 4. Compute block row start positions BR = [0, R_div[0]+1, R_div[1]+1] and block column start positions BC = [0, C_div[0]+1, C_div[1]+1]. 5. For each block coordinate (bi,bj) with bi,bj∈{0,1,2}: let r0=BR[bi], c0=BC[bj]. If any grid[r][c]==4 for r∈[r0..r0+2], c∈[c0..c0+2], record (sel_bi,sel_bj)=(bi,bj). 6. Within block (sel_bi,sel_bj), find the unique cell (r4,c4) with grid[r4][c4]==4. Compute row_offset = r4 – BR[sel_bi], col_offset = c4 – BC[sel_bj]. 7. Build a 3×3 array BLOCK_COPY where for di,dj∈{0,1,2}: p = grid[BR[sel_bi]+di][BC[sel_bj]+dj]; then BLOCK_COPY[di][dj] = (p==5 ? 0 : p). 8. Create output grid of size H×W initialized to 0. 9. For each r in R_div and each c∈[0..W-1], set output[r][c]=5. For each c in C_div and each r∈[0..H-1], set output[r][c]=5. 10. Let tr=BR[row_offset], tc=BC[col_offset]. For di,dj∈{0,1,2}, set output[tr+di][tc+dj] = BLOCK_COPY[di][dj]. 11. Return output grid.",
    "ff28f65a.json": "1. Compute H = number of rows in the input grid and W = number of columns.\n2. Initialize block_count = 0.\n3. For each r from 0 to H-2 and each c from 0 to W-2 inclusive:\n   If input[r][c] == 2 AND input[r][c+1] == 2 AND input[r+1][c] == 2 AND input[r+1][c+1] == 2, then increment block_count.\n4. Create a new output grid of size 3×3 and set all cells to 0.\n5. Define positions = [(0,0),(0,2),(1,1),(2,0),(2,2)].\n6. For each i from 0 to min(block_count,5)-1:\n   Let (r_out,c_out) = positions[i] and set output[r_out][c_out] = 1.\n7. Return the output grid.",
    "d037b0a7.json": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Create the output grid as an exact copy of the input grid.\n3. For each column index c from 0 to W-1:\n   a. For each row index r from 0 to H-1:\n      i. If input[r][c] ≠ 0 then:\n         1. Let v = input[r][c].\n         2. For each row index i from r+1 to H-1: set output[i][c] = v.\n         3. Break the loop over rows for this column c.\n4. Return the output grid.",
    "d10ecb37.json": "1. Let input_grid be the given grid with dimensions H×W, where H ≥ 2 and W ≥ 2.\n2. Initialize an output grid of size 2 rows and 2 columns.\n3. For each row index r in {0, 1} and each column index c in {0, 1}, set output[r][c] = input_grid[r][c].\n4. Return the output grid.",
    "cbded52d.json": "1. Scan all rows of the input grid to find indices Rsep[0], Rsep[1] where every cell in that row equals 0. Sort ascending. Scan all columns to find indices Csep[0], Csep[1] where every cell in that column equals 0. Sort ascending.\n2. Let numRows and numCols be grid dimensions. Construct SegmentRows and SegmentCols as arrays of three index lists:\n   - SegmentRows[0] = { r | 0 ≤ r < Rsep[0] }\n   - SegmentRows[1] = { r | Rsep[0] + 1 ≤ r < Rsep[1] }\n   - SegmentRows[2] = { r | Rsep[1] + 1 ≤ r < numRows }\n   - SegmentCols[0] = { c | 0 ≤ c < Csep[0] }\n   - SegmentCols[1] = { c | Csep[0] + 1 ≤ c < Csep[1] }\n   - SegmentCols[2] = { c | Csep[1] + 1 ≤ c < numCols }\n3. For each blockRow in {0,1,2} and blockCol in {0,1,2}, let Block[blockRow][blockCol] be the cells at all combinations of rows in SegmentRows[blockRow] and cols in SegmentCols[blockCol]. Each block has size 2 rows x 2 cols.\n4. For each Block[blockRow][blockCol], collect its four values. If there are exactly two distinct integers and one occurs exactly once, let v be the unique value and let (lr,lc) be its zero-based local row and col within the block (lr,lc in {0,1}). Set Out[blockRow][blockCol] = (lr,lc,v). Otherwise set Out[blockRow][blockCol] = null.\n5. Copy the input grid to outputGrid.\n6. For each blockRow in {0,1,2}:\n   a. Gather non-null Out[blockRow][0], Out[blockRow][1], Out[blockRow][2].\n   b. If exactly two of these share identical (lr,lc,v), let that triple be (dr,dc,v) and let blockCol3 be the remaining index in {0,1,2}. Compute R = SegmentRows[blockRow][dr], C = SegmentCols[blockCol3][dc], and set outputGrid[R][C] = v.\n7. For each blockCol in {0,1,2}:\n   a. Gather non-null Out[0][blockCol], Out[1][blockCol], Out[2][blockCol].\n   b. If exactly two of these share identical (lr,lc,v), let that triple be (dr,dc,v) and let blockRow3 be the remaining index in {0,1,2}. Compute R = SegmentRows[blockRow3][dr], C = SegmentCols[blockCol][dc], and set outputGrid[R][C] = v.\n8. Return outputGrid.",
    "0a938d79.json": "1. Let H = number of rows and W = number of columns of the input grid.\n2. Scan the grid in row-major order to locate the two non-zero cells. Let the first be P1 = (r1,c1) with color v1, the second be P2 = (r2,c2) with color v2.\n3. Initialize an output grid of size H×W filled with 0.\n4. If W > H then create vertical stripes as follows:\n   a. Let spacing = |c2 - c1| (must be >0).\n   b. For k = 0,1,2,... while c = c1 + k*spacing < W do:\n      i.   Let col = c1 + k*spacing.\n      ii.  Let color = v1 if k mod 2 = 0, else color = v2.\n      iii. For each row r from 0 to H-1 set output[r][col] = color.\n5. Otherwise (H ≥ W) create horizontal stripes as follows:\n   a. Let spacing = |r2 - r1| (must be >0).\n   b. For k = 0,1,2,... while r = r1 + k*spacing < H do:\n      i.   Let row = r1 + k*spacing.\n      ii.  Let color = v1 if k mod 2 = 0, else color = v2.\n      iii. For each column c from 0 to W-1 set output[row][c] = color.\n6. Return the output grid of the same dimensions as the input.",
    "d0f5fe59.json": "1. Interpret the input as a 2D grid indexed by row r (0..H-1) and column c (0..W-1). 2. Determine the shape color C: scan all cells and collect values >0; there will be exactly one unique non-zero value, assign shape_color = C. 3. Initialize a boolean array visited[H][W] to false. 4. Initialize component_count = 0. 5. For each cell (r,c): if grid[r][c] == C and visited[r][c] == false then\n   a. Increment component_count by 1.\n   b. Perform a flood-fill (BFS or DFS) from (r,c), visiting all 4-directionally adjacent cells with value C; for each visited cell mark visited[row][col] = true. 6. Let n = component_count. 7. Create an output grid of size n rows and n columns; set all cells to 0. 8. For i from 0 to n-1: set output_grid[i][i] = C. 9. Return output_grid.",
    "6f8cd79b.json": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Create an output grid of size H×W by copying each cell value from the input grid.\n3. For each row index r from 0 to H−1 and each column index c from 0 to W−1:\n   a. If r == 0 or r == H−1 or c == 0 or c == W−1, set output[r][c] = 8.\n   b. Otherwise, leave output[r][c] unchanged (it will be 0).\n4. Return the output grid.",
    "6fa7a44f.json": "1. Let R = number of rows in the input grid and C = number of columns.\n2. Create an empty grid Output with 2*R rows and C columns.\n3. For each row r in 0..R-1 and column c in 0..C-1, set Output[r][c] = Input[r][c].\n4. For each row r in 0..R-1 and column c in 0..C-1, set Output[R + r][c] = Input[R - 1 - r][c].\n5. Return the Output grid.",
    "0d3d703e.json": "1. Determine the input grid dimensions H (rows) and W (columns).\n2. Initialize an output grid of size H×W.\n3. Define a mapping M between input values and output values:\n   • 1 → 5\n   • 5 → 1\n   • 2 → 6\n   • 6 → 2\n   • 3 → 4\n   • 4 → 3\n   • 8 → 9\n   • 9 → 8\n4. For each row index r from 0 to H−1 and each column index c from 0 to W−1:\n   a. Let v = input_grid[r][c].\n   b. Set output_grid[r][c] = M[v].\n5. Return output_grid.",
    "36d67576.json": "1. Identify all 4-connected components of grid cells with value 4; store each component as a list of (r,c) coordinates.\n2. Let source_component = the component that has at least one orthogonal neighbor cell with value 1 and at least one with value 3.\n3. Compute source bounding box: row_min_src = min r over source_component, row_max_src = max r; col_min_src = min c; col_max_src = max c.\n4. Extract P of size H_src=(row_max_src−row_min_src+1), W_src=(col_max_src−col_min_src+1). For i in [0..H_src-1], j in [0..W_src-1], set P[i][j] = input_grid[row_min_src+i][col_min_src+j].\n5. Record S_src = {(i,j) | P[i][j] == 4}.\n6. For each other component comp:\n  a. Compute its bounding box row_min = min r, row_max = max r, col_min = min c, col_max = max c.\n  b. Compute S_tgt_rel = {(r−row_min, c−col_min) | (r,c) in comp}.\n  c. For each θ in {0°,90°,180°,270°}:\n    i. Rotate P by θ around its top-left to get P_rot; let H_rot,W_rot be its dimensions.\n    ii. Compute S_src_rot = {(i,j) | P_rot[i][j] == 4}.\n    iii. If |S_src_rot| != |S_tgt_rel|, continue next θ.\n    iv. Sort S_src_rot and S_tgt_rel lex in (row,col); let (i0_src,j0_src)=first of S_src_rot, (i0_tgt,j0_tgt)=first of S_tgt_rel.\n    v. Compute translation T_r = row_min + i0_tgt − i0_src, T_c = col_min + j0_tgt − j0_src.\n    vi. If for all (i,j) in S_src_rot, input_grid[T_r+i][T_c+j] == 4, then break (use this θ and T_r,T_c).\n  d. For each (i,j) in P_rot where P_rot[i][j] > 0 and P_rot[i][j] != 4, set output_grid[T_r+i][T_c+j] = P_rot[i][j].\n7. Return output_grid with all other cells unchanged.",
    "6e82a1ae.json": "1. Let the input grid dimensions be H rows by W columns. Initialize the output grid as a copy of the input grid.  \n2. Initialize an empty set VISITED.  \n3. For each cell (r,c) in the input grid:  \n   a. If input[r][c] ≠ 5 or (r,c) is in VISITED, skip.  \n   b. Otherwise, perform a flood‐fill (orthogonal adjacency) starting at (r,c) over cells with value 5 to collect all coordinates of the connected component COMP.  \n   c. Mark all cells in COMP as visited by adding them to VISITED.  \n   d. Let s = size of COMP (number of cells).  \n   e. Compute new_color = 5 − s.  \n   f. For each (ri,ci) in COMP, set output[ri][ci] = new_color.  \n4. After processing all cells, leave all other cells unchanged.  \n5. Return the output grid.",
    "6e19193c.json": "1. Let R = number of rows and C = number of columns in the input grid. Coordinates are zero-based: (r,c) where 0 <= r < R and 0 <= c < C.\n2. Identify all connected components of non-zero cells using 4-neighbor adjacency (up/down/left/right). Each component has exactly three cells.\n3. For each component comp:\n   a. Let col = value at any cell in comp.\n   b. For each cell p in comp, count neighbors in comp that share an edge; select corner = the cell with exactly two such neighbors.\n   c. Let H = neighbor of corner with the same row (horizontal neighbor) and V = neighbor of corner with the same column (vertical neighbor).\n   d. Compute the missing cell of the 2×2 square: miss_r = H.r + V.r - corner.r; miss_c = H.c + V.c - corner.c.\n   e. Compute extension vector v_r = miss_r - corner.r and v_c = miss_c - corner.c.\n   f. For n = 1,2,...:\n       i.   r = miss_r + n * v_r; c = miss_c + n * v_c.\n       ii.  If r < 0 or r >= R or c < 0 or c >= C, break the loop.\n       iii. Otherwise, set grid[r][c] = col.\n4. Return the modified grid of size R×C as the output.",
    "f1cefba8.json": "1. Let GRID be the input grid with dimensions ROWS x COLS and 0-based indexing.\n2. Identify C_BORDER:\n   a. Compute BORDER_CELLS = {(r,c) | GRID[r,c] != 0 and any neighbor among (r-1,c),(r+1,c),(r,c-1),(r,c+1) is 0 or out of bounds}.\n   b. C_BORDER = the unique GRID value found at BORDER_CELLS.\n3. Identify C_INT as the non-zero value in GRID distinct from C_BORDER.\n4. Define INTERIOR = {(r,c) | GRID[r,c] == C_INT}.\n5. Define EXTRUDED = {(r,c) in INTERIOR | exists (dr,dc) in {(1,0),(-1,0),(0,1),(0,-1)} with GRID[r+dr,c+dc] == C_BORDER}.\n6. For each (r,c) in EXTRUDED:\n   a. Find (dr,dc) such that GRID[r+dr,c+dc] == C_BORDER.\n   b. Set GRID[r,c] = C_BORDER.\n   c. Remove the original interior line:\n      - If dr != 0, then for all (r2,c2) in INTERIOR with c2 == c set GRID[r2,c2] = C_BORDER.\n      - If dc != 0, then for all (r2,c2) in INTERIOR with r2 == r set GRID[r2,c2] = C_BORDER.\n   d. Draw the extension beyond the border:\n      i. Let (sr,sc) = (r + 2*dr, c + 2*dc).\n      ii. While 0 <= sr < ROWS and 0 <= sc < COLS and GRID[sr,sc] == 0:\n          - Set GRID[sr,sc] = C_INT\n          - sr += dr; sc += dc\n7. Return GRID as the transformed output.",
    "d06dbe63.json": "1. Let H = number of rows and W = number of columns of the input grid.\n2. Locate the pivot cell: find r0, c0 such that input[r0][c0] == 8.\n3. Copy the input grid into the output grid.\n4. Define two direction sequences:\n   Sequence A = [(-1, 0), (0, +1)]\n   Sequence B = [(+1, 0), (0, -1)]\n5. For each sequence in [Sequence A, Sequence B]:\n   a. Set r = r0, c = c0, phase = 0.\n   b. Loop indefinitely:\n      i. Let (dr, dc) = sequence[phase mod 2].\n      ii. For step = 1 to 2:\n         - Compute r_new = r + dr and c_new = c + dc.\n         - If r_new < 0 or r_new >= H or c_new < 0 or c_new >= W: exit this loop for the current sequence.\n         - Else: set r = r_new, c = c_new and set output[r][c] = 5.\n      iii. phase = phase + 1.\n6. Return the output grid.",
    "09629e4f.json": "1. Identify all rows r where for every column c, grid[r][c]==5. Call this list H (horizontal separators). 2. Identify all columns c where for every row r, grid[r][c]==5. Call this list V (vertical separators). 3. Sort H and V in ascending order. 4. Define row bands RB[0..2] as the three intervals: [0 to H[0]-1], [H[0]+1 to H[1]-1], [H[1]+1 to N-1], where N is grid height. 5. Define column bands CB[0..2] as the three intervals: [0 to V[0]-1], [V[0]+1 to V[1]-1], [V[1]+1 to M-1], where M is grid width. 6. For each block index (br,bc) in {0,1,2}×{0,1,2}, let S(br,bc) be the set of cells {(r,c) | r∈RB[br], c∈CB[bc]}. 7. For each (br,bc), count C(br,bc)=|{(r,c)∈S(br,bc) | grid[r][c]≠0}|. 8. Let (pr,pc) be the unique block indices where C(pr,pc)==4. 9. Build pattern P of size k×k (k=|RB[0]|): for i,j in {0,…,k-1}, set P[i][j]=grid[RB[pr][i]][CB[pc][j]]. 10. Initialize output=copy of input. 11. For each block index (br,bc) and for each i,j in {0,…,k-1}: let r_out=RB[br][i], c_out=CB[bc][j]; set output[r_out][c_out]=P[br][bc]. 12. Leave all cells with value 5 unchanged. 13. Return output.",
    "de1cd16c.json": "1. Let R = number of rows and C = number of columns of the input grid.\n2. Compute freq[v] = total count of cells equal to v for each v in 0..9. Let D = the value v with the smallest freq[v].  // defect color\n3. Initialize a boolean array visited[R][C] all false. Initialize an empty list regions.\n4. For each cell (r,c) with 0 ≤ r < R and 0 ≤ c < C:\n   a. If visited[r][c] or grid[r][c] == D, continue.\n   b. Let B = grid[r][c].\n   c. Perform a flood‐fill (BFS or DFS) starting at (r,c) to collect all cells of value B into a set S, marking each visited[x][y] = true when added.\n   d. Compute rmin = min(x for (x,y) in S), rmax = max(x), cmin = min(y), cmax = max(y).\n   e. Compute defectCount = number of cells (i,j) with rmin ≤ i ≤ rmax and cmin ≤ j ≤ cmax such that grid[i][j] == D.\n   f. Compute area = (rmax - rmin + 1) * (cmax - cmin + 1).\n   g. Append the tuple (B, defectCount, area) to regions.\n5. Let maxDef = maximum defectCount among all entries in regions. Filter regions to those with defectCount == maxDef.\n6. If there is more than one region in that filtered list, choose the one with the largest area.\n7. Let resultColor = B of the selected region.\n8. Return a 1×1 grid whose sole cell is resultColor.",
    "d23f8c26.json": "1. Let H be the number of rows and W be the number of columns in the input grid.\n2. Compute the middle column index M = floor(W ÷ 2).\n3. Initialize an output grid of size H × W.\n4. For each row r from 0 to H–1:\n   For each column c from 0 to W–1:\n     If c == M, set output[r][c] = input[r][c].\n     Otherwise, set output[r][c] = 0.\n5. Return the output grid.",
    "6d58a25d.json": "1. Let H and W be the number of rows and columns of the input grid. 2. Identify all non-zero colors present; call them C. 3. Determine the shape color A as the color in C whose maximum 4-connected component size is greater than 1. 4. Let B be the only other non-zero color in C (the color of the isolated small squares). 5. Collect all coordinates of A: shape_positions = {(r,c) | grid[r][c] == A}. 6. Compute min_col = min(c for (_,c) in shape_positions) and max_col = max(c for (_,c) in shape_positions). 7. For each column c in the inclusive range [min_col, max_col]:\n   a. Compute bottom_shape_row[c] = max(r | grid[r][c] == A).\n8. For each column c in [min_col, max_col]:\n   a. If there exists any row r (0 ≤ r < H) with grid[r][c] == B, then:\n       i. Let r_start = bottom_shape_row[c] + 1.\n      ii. For r from r_start to H-1: if grid[r][c] == 0 then set grid[r][c] = B.\n9. Return the modified grid as the output.",
    "d13f3404.json": "1. Let H = number of rows and W = number of columns in the input grid.\n2. Create an output grid of size 2*H rows by 2*W columns and initialize all cells to 0.\n3. For each cell at coordinates (r0, c0) in the input grid:\n   a. Let V = input[r0][c0].\n   b. If V = 0, skip to the next cell.\n   c. Compute K = min(2*H - r0, 2*W - c0).\n   d. For k from 0 to K - 1 do:\n       i. Set output[r0 + k][c0 + k] = V.\n4. Return the output grid.",
    "0ca9ddb6.json": "1. Let H = number of rows and W = number of columns of the input grid.\n2. Initialize the output grid as an exact copy of the input grid.\n3. For each position (r,c) where input[r][c] == 2:\n   a. For each diagonal offset (dr,dc) in {(-1,-1), (-1,1), (1,-1), (1,1)}:\n      i. Compute nr = r + dr, nc = c + dc.\n      ii. If 0 ≤ nr < H and 0 ≤ nc < W and output[nr][nc] == 0, then set output[nr][nc] = 4.\n4. For each position (r,c) where input[r][c] == 1:\n   a. For each orthogonal offset (dr,dc) in {(-1,0), (1,0), (0,-1), (0,1)}:\n      i. Compute nr = r + dr, nc = c + dc.\n      ii. If 0 ≤ nr < H and 0 ≤ nc < W and output[nr][nc] == 0, then set output[nr][nc] = 7.\n5. Return the output grid.",
    "0962bcdd.json": "1. Let H and W be the input grid height and width. Create an output grid by copying the input.\n2. Initialize an empty list of plus shapes.\n3. For each cell (r,c) with 0≤r<H and 0≤c<W:\n   a. Let C = input[r][c]. If C==0, continue.\n   b. If the four orthogonal neighbors (r-1,c), (r+1,c), (r,c-1), (r,c+1) all exist within bounds and have the same non-zero value V ≠ C,\n      and the four diagonal neighbors (r-1,c-1), (r-1,c+1), (r+1,c-1), (r+1,c+1) either are out of bounds or equal 0,\n      then record a plus with center=(r,c), center_color=C, outer_color=V.\n4. For each recorded plus with center (r,c), center_color=C, outer_color=V:\n   a. For δ from -2 to +2:\n      i. If 0≤c+δ<W then set output[r][c+δ] = V.\n      ii. If 0≤r+δ<H then set output[r+δ][c] = V.\n   b. For k from -2 to +2:\n      i. If 0≤r+k<H and 0≤c+k<W then set output[r+k][c+k] = C.\n      ii. If 0≤r+k<H and 0≤c-k<W then set output[r+k][c-k] = C.\n5. Return the output grid (same size as input).",
    "6a1e5592.json": "1. Let input_grid be the given grid. Create working_grid as a copy of input_grid.\n2. Identify all grey shape clusters: for each cell (r,c) with input_grid[r][c]==5 not yet visited, perform a 4-adj flood fill to collect one shape_cluster S as a list of its (r,c) cells.\n3. Remove grey shapes from working_grid: for every cell (r,c) where working_grid[r][c]==5 set working_grid[r][c]=0.\n4. Identify hole_cells: collect every (r,c) such that input_grid[r][c]==0 and at least one of its 4-neighbors in input_grid has value 2.\n5. Group hole_cells into hole_clusters by 4-adj connectivity.\n6. For each hole_cluster H:\n   a. Let rows_H = sorted unique row indices of H.\n   b. For each row r in rows_H in ascending order, let count_H[r] = number of cells in H with row==r.\n   c. Define hole_pattern_H as the list [count_H[r] for r in rows_H].\n7. For each shape_cluster S:\n   a. Let rows_S = sorted unique row indices of S.\n   b. For each r in rows_S, let count_S[r] = number of cells in S with row==r.\n   c. Define shape_pattern_S as [count_S[r] for r in rows_S].\n8. Map each hole_cluster H to the unique shape_cluster S whose shape_pattern_S begins with hole_pattern_H (i.e. shape_pattern_S[0:len(hole_pattern_H)]==hole_pattern_H).\n9. Fill holes in working_grid: for each (r,c) in hole_cells set working_grid[r][c]=1.\n10. For each mapped pair (H→S):\n    a. Let hole_anchor be the cell in H with minimal row; if tie, minimal column.\n    b. Let shape_anchor be the cell in S with minimal row; if tie, minimal column.\n    c. Compute dr = hole_anchor.row - shape_anchor.row, dc = hole_anchor.col - shape_anchor.col.\n    d. For each cell (r_s,c_s) in S:\n       i. Let r2 = r_s + dr, c2 = c_s + dc.\n       ii. If working_grid[r2][c2]==0 then set working_grid[r2][c2]=1.\n11. Return working_grid as the output.",
    "d2abd087.json": "1. Let input be an M×N grid of integers. 2. Initialize output grid as a copy of input grid. 3. Create an M×N boolean array visited, all false. 4. For each cell (r,c) in input:  \n   a. If input[r][c]≠5 or visited[r][c] is true, skip.  \n   b. Otherwise start a new component: initialize empty list comp; initialize a queue Q and enqueue (r,c); mark visited[r][c]=true.  \n   c. While Q not empty: dequeue (i,j); append (i,j) to comp; for each of its 4‐neighbors (i±1,j) and (i,j±1) within grid bounds: if input[ni][nj]==5 and visited[ni][nj]==false, mark visited[ni][nj]=true and enqueue (ni,nj).  \n   d. After flood fill, let size = length of comp.  \n   e. If size==6 set newValue=2 else set newValue=1.  \n   f. For each (i,j) in comp set output[i][j]=newValue.  \n5. Return the output grid.",
    "1b60fb0c.json": "1. Read the input grid of size H×W. 2. Identify all coordinates (r,c) where grid[r][c]==1; call this set S. 3. Build an undirected graph G on S where two nodes are adjacent if they differ by one in row or column. 4. For each node in S, count its degree (number of neighbors in G). 5. Let center be the node in S with the maximum degree. 6. Remove center from S and from G. 7. Identify right_start as the neighbor of center in the original grid at (center_row, center_col+1) (must satisfy grid[center_row][center_col+1]==1). 8. Perform a flood-fill (BFS or DFS) on G starting from right_start to collect the connected component BRANCH⊆S. 9. For each (r,c) in BRANCH:   a. Compute mirror_c = 2*center_col - c.   b. If 0≤mirror_c<W and input_grid[r][mirror_c]==0, set output_grid[r][mirror_c]=2. 10. For all other positions, copy input_grid to output_grid unchanged. 11. Return output_grid.",
    "22233c11.json": "1. Parse input grid of size H×W. 2. Identify each connected component of pixels with value 3 (green) that forms a straight diagonal line segment (slope +1 or slope -1) of length ≥2.   \n   a. For each component, find its two endpoints: pixels in the component with only one orthogonal-neighbor in the component.   \n3. For each diagonal component:   \n   a. Let (r1,c1) and (r2,c2) be the row/column of the two endpoints.   \n   b. Compute the midpoint M = ( (r1 + r2)/2.0, (c1 + c2)/2.0 ).   \n   c. Determine the perpendicular direction vectors D1 and D2:   \n      i. If (r2 - r1) and (c2 - c1) have the same sign (slope +1), set D1 = (-1,+1), D2 = (+1,-1).   \n      ii. Otherwise (slope -1), set D1 = (-1,-1), D2 = (+1,+1).   \n   d. For each D in {D1,D2}:   \n      i. Compute float point P = ( M.row + D.row , M.col + D.col ).   \n      ii. Compute integer coordinates (pr,pc):   \n         - pr = floor(P.row) if D.row < 0, else ceil(P.row).   \n         - pc = floor(P.col) if D.col < 0, else ceil(P.col).   \n      iii. If (pr,pc) is inside grid and its value is 0, set grid[pr][pc] = 8 (light blue).   \n4. Return the modified grid (unchanged size).",
    "d364b489.json": "1. Let N be the number of rows and M be the number of columns of the input grid. 2. Create an output grid of size N×M initialized with 0. 3. For each coordinate (r,c) where input[r][c] == 1 (blue):\n   a. Set output[r][c] = 1.\n   b. If r > 0, set output[r-1][c] = 2 (red).\n   c. If c > 0, set output[r][c-1] = 7 (orange).\n   d. If c < M-1, set output[r][c+1] = 6 (pink/purple).\n   e. If r < N-1, set output[r+1][c] = 8 (cyan/light blue).\n4. Return the output grid.",
    "5ad4f10b.json": "1. Identify all unique non-zero integers in the input grid. 2. Count occurrences of each; let primary_color be the integer with the largest count, and mark_color be the other non-zero integer. 3. Compute the bounding box of primary_color: row_min = minimum row index containing primary_color; row_max = maximum row index containing primary_color; col_min = minimum column index containing primary_color; col_max = maximum column index containing primary_color. 4. total_height = row_max - row_min + 1; total_width = col_max - col_min + 1. 5. cell_height = ceil(total_height / 3); cell_width = ceil(total_width / 3). 6. Initialize a 3×3 output grid filled with 0. 7. For cell_row in 0..2: row_start = row_min + cell_row * cell_height; row_end = (cell_row < 2 ? row_start + cell_height - 1 : row_max). 8. For cell_col in 0..2: col_start = col_min + cell_col * cell_width; col_end = (cell_col < 2 ? col_start + cell_width - 1 : col_max). 9. If any input cell (r,c) with r∈[row_start..row_end] and c∈[col_start..col_end] has value primary_color, set output[cell_row][cell_col] = mark_color. 10. Return the 3×3 output grid.",
    "6b9890af.json": "1. Identify all non-zero colors in the input grid; record them in a set C.\n2. For each color c in C compute its bounding box by finding r_min[c], r_max[c], c_min[c], c_max[c] over all cells with value c.\n3. Choose borderColor as the color in C whose bounding-box perimeter cells (r=r_min[c] or r=r_max[c] or c=c_min[c] or c=c_max[c]) all equal c, and whose interior cells (r_min[c]<r<r_max[c] and c_min[c]<c<c_max[c]) all equal 0. Let shapeColor be the other color in C.\n4. Let H = r_max[borderColor] - r_min[borderColor] + 1 and W = c_max[borderColor] - c_min[borderColor] + 1.\n5. Initialize an output grid of size H×W, filled with 0.\n6. Fill the border of the output grid: for col from 0 to W-1 set output[0][col]=borderColor and output[H-1][col]=borderColor; for row from 0 to H-1 set output[row][0]=borderColor and output[row][W-1]=borderColor.\n7. Compute shapeH = r_max[shapeColor] - r_min[shapeColor] + 1 and shapeW = c_max[shapeColor] - c_min[shapeColor] + 1.\n8. Let iH = H - 2 and iW = W - 2; compute scale = iH ÷ shapeH (verify scale = iW ÷ shapeW).\n9. For i from 0 to shapeH-1 and j from 0 to shapeW-1:\n     let v = input[r_min[shapeColor] + i][c_min[shapeColor] + j];\n     if v ≠ 0 then\n       for dr from 0 to scale-1 and dc from 0 to scale-1:\n         set output[1 + i*scale + dr][1 + j*scale + dc] = v.\n10. Return the output grid.",
    "0b148d64.json": "1. Let G be the input grid with H rows and W columns.\n2. Identify blank rows R0 = []\n   For r from 0 to H-1:\n     If for all c from 0 to W-1, G[r][c] == 0, append r to R0.\n   Set r_start = minimum of R0; r_end = maximum of R0.\n3. Identify blank columns C0 = []\n   For c from 0 to W-1:\n     If for all r from 0 to H-1, G[r][c] == 0, append c to C0.\n   Set c_start = minimum of C0; c_end = maximum of C0.\n4. Define index ranges:\n   rows_top = list of r from 0 to r_start-1;\n   rows_bottom = list of r from r_end+1 to H-1;\n   cols_left = list of c from 0 to c_start-1;\n   cols_right = list of c from c_end+1 to W-1.\n5. Extract four quadrant grids:\n   Initialize empty lists TL, TR, BL, BR.\n   For each r in rows_top:\n     Append [G[r][c] for c in cols_left] as a new row to TL.\n     Append [G[r][c] for c in cols_right] as a new row to TR.\n   For each r in rows_bottom:\n     Append [G[r][c] for c in cols_left] as a new row to BL.\n     Append [G[r][c] for c in cols_right] as a new row to BR.\n6. For each subgrid S in [TL, TR, BL, BR]:\n   Collect set C_S of all values v in S where v != 0.\n   Assert |C_S| == 1.\n   Let color_S = the single element of C_S.\n7. Count the frequency of each color_S. Let target_color be the color with frequency 1.\n8. Identify subgrid S_target whose color_S equals target_color.\n9. Return S_target as the output grid.",
    "d4469b4b.json": "1. Treat grid coordinates as zero-based (row,column), with (0,0) at the top-left.\n2. Let X be the unique non-zero value in the input grid (guaranteed to be 1, 2 or 3).\n3. Create a new 3×3 grid and fill all cells with 0.\n4. If X == 1: set cells (0,1), (1,0), (1,1), (1,2), (2,1) to 5.\n5. If X == 2: set cells (0,0), (0,1), (0,2), (1,1), (2,1) to 5.\n6. If X == 3: set cells (0,2), (1,2), (2,0), (2,1), (2,2) to 5.\n7. Return the resulting 3×3 grid.",
    "74dd1130.json": "1. Let N be the number of rows (and columns) of the input grid.\n2. Initialize an empty output grid of size N×N.\n3. For each row index r from 0 to N−1:\n     For each column index c from 0 to N−1:\n         Set output[r][c] = input[c][r].\n4. Return the output grid.",
    "10fcaaa3.json": "1. Let H = number of rows in the input grid and W = number of columns. Use 0-based indexing: input rows 0…H-1, columns 0…W-1.\n2. Create an output grid of size 2*H rows by 2*W columns (indices 0…2*H-1 and 0…2*W-1), initialize all cells to 0.\n3. For each input cell at (r,c) where input[r][c] != 0:\n   a. Let V = input[r][c].\n   b. For each dy in {0,1} and each dx in {0,1}:\n      i. Set output[r + dy*H][c + dx*W] = V.\n4. For each input cell at (r,c) where input[r][c] != 0:\n   a. For each dy in {0,1} and each dx in {0,1}:\n      i. Let R = r + dy*H and C = c + dx*W.\n      ii. For each (dr,dc) in {(-1,-1),(-1,1),(1,-1),(1,1)}:\n          - Compute R2 = R + dr and C2 = C + dc.\n          - If 0 ≤ R2 < 2*H and 0 ≤ C2 < 2*W and output[R2][C2] == 0, set output[R2][C2] = 8.\n5. Return the output grid.",
    "8a004b2b.json": "1. Scan the input grid. Record all coordinates (r,c) where the cell value is 4. Compute minRow4=min(r), maxRow4=max(r), minCol4=min(c), maxCol4=max(c).\n2. Let outRows = maxRow4 - minRow4 + 1, outCols = maxCol4 - minCol4 + 1.\n3. Initialize an output grid of size outRows × outCols filled with 0.\n4. Set the four corners of the output grid to 4: output[0][0]=4, output[0][outCols-1]=4, output[outRows-1][0]=4, output[outRows-1][outCols-1]=4.\n5. Identify all nonzero cells in the input that lie strictly outside the rectangle [minRow4..maxRow4]×[minCol4..maxCol4]. Compute minRowP, maxRowP, minColP, maxColP over those cells. Extract pattern P of size pRows = maxRowP-minRowP+1 and pCols = maxColP-minColP+1 where P[i][j] = input[minRowP+i][minColP+j].\n6. In P scan rows i=0..pRows-1 and columns j=0..pCols-1 in row-major order to find the first cell P[pAnchorRow][pAnchorCol] ≠ 0. Let vAnchor = that value.\n7. In the input rectangle interior (rows r from minRow4+1 to maxRow4-1, columns c from minCol4+1 to maxCol4-1) scan row-major to find the first input[r][c] == vAnchor. Record (rAnchorInt,cAnchorInt).\n8. Compute rAnchorOut = rAnchorInt - minRow4, cAnchorOut = cAnchorInt - minCol4.\n9. In P find the bounding box of all cells equal to vAnchor: let pMinR = min i, pMaxR = max i, pMinC = min j, pMaxC = max j over P[i][j]==vAnchor. Compute PHeight = pMaxR-pMinR+1, PWidth = pMaxC-pMinC+1.\n10. In the input rectangle interior find bounding box of all cells equal to vAnchor: over (r,c) with input[r][c]==vAnchor and r∈[minRow4+1..maxRow4-1], c∈[minCol4+1..maxCol4-1]. Let iMin = min(r-minRow4-1), iMax = max(r-minRow4-1), jMin = min(c-minCol4-1), jMax = max(c-minCol4-1). Compute RHeight = iMax-iMin+1, RWidth = jMax-jMin+1.\n11. Compute integer scale factors Srow = RHeight / PHeight, Scol = RWidth / PWidth.\n12. Build a scaled pattern P2 of size (pRows×Srow) × (pCols×Scol). For each i in 0..pRows-1 and j in 0..pCols-1 and for di in 0..Srow-1 and dj in 0..Scol-1, set P2[i*Srow+di][j*Scol+dj] = P[i][j].\n13. Compute paste offsets in the output grid: rowOffset = rAnchorOut - pAnchorRow*Srow, colOffset = cAnchorOut - pAnchorCol*Scol.\n14. For each u in 0..(pRows×Srow)-1 and v in 0..(pCols×Scol)-1, set output[rowOffset+u][colOffset+v] = P2[u][v].\n15. Return the output grid.",
    "1190e5a7.json": "1. Let grid be the input 2D array of integers; let R = number of rows; C = number of columns.\n2. Compute the set S of unique values in grid; S should contain exactly two integers.\n3. Identify line_color as the integer v in S for which there exists at least one row r (0 ≤ r < R) or one column c (0 ≤ c < C) such that every cell in that row or column equals v.\n4. Let interior_color be the single value in S that is not equal to line_color.\n5. Initialize H = 0. For each row r from 0 to R–1, if for all c from 0 to C–1 grid[r][c] == line_color, increment H by 1.\n6. Initialize V = 0. For each column c from 0 to C–1, if for all r from 0 to R–1 grid[r][c] == line_color, increment V by 1.\n7. Compute output_rows = H + 1 and output_cols = V + 1.\n8. Create a new 2D array output of size output_rows × output_cols.\n9. For each cell (i, j) in output, set output[i][j] = interior_color.\n10. Return output.",
    "11852cab.json": "1. Identify all coordinates (r,c) where grid[r][c] != 0.\n2. Let r_min = min(r), r_max = max(r), c_min = min(c), c_max = max(c).\n3. Verify r_max - r_min == 4 and c_max - c_min == 4.\n4. Compute center R = r_min + 2, C = c_min + 2.\n5. Define three lists of offsets:\n   inner_diag = [(-1,-1),(-1,1),(1,-1),(1,1)]\n   mid_card   = [(-2,0),(0,-2),(0,2),(2,0)]\n   outer_diag = [(-2,-2),(-2,2),(2,-2),(2,2)]\n6. For each offsets list in [inner_diag, mid_card, outer_diag]:\n   a. Count non_zero = number of (dr,dc) where grid[R+dr][C+dc] != 0.\n   b. If non_zero == 1:\n      i. Set target_offsets = this list.\n      ii. Let (dr0,dc0) be the only offset in this list with grid[R+dr0][C+dc0] != 0.\n      iii. Set target_color = grid[R+dr0][C+dc0].\n      iv. Break loop.\n7. For each (dr,dc) in target_offsets:\n   If grid[R+dr][C+dc] == 0, set grid[R+dr][C+dc] = target_color.\n8. Return the modified grid.",
    "7468f01a.json": "1. Let G be the input grid of size R×C.  Identify the set S = { (r,c) | G[r][c] ≠ 0 }. 2. Compute row_min = min{r | (r,c)∈S}, row_max = max{r | (r,c)∈S}, col_min = min{c | (r,c)∈S}, col_max = max{c | (r,c)∈S}. 3. Let H = row_max - row_min + 1 and W = col_max - col_min + 1. 4. Extract region A of size H×W by A[i][j] = G[row_min + i][col_min + j] for i∈[0..H-1], j∈[0..W-1]. 5. Let outer_color = A[0][0]. 6. Let inner_color be the unique value in A such that inner_color ≠ 0 and inner_color ≠ outer_color. 7. Create an output grid O of size H×W and fill every cell with outer_color. 8. For each i∈[0..H-1], j∈[0..W-1], if A[i][j] = inner_color then set O[i][W-1-j] = inner_color. 9. Return O.",
    "d511f180.json": "1. Let M = number of rows in the input grid, N = number of columns. 2. Create an output grid of size M × N. 3. For each row index r from 0 to M−1 and each column index c from 0 to N−1:  \n   a. Let v = input_grid[r][c].  \n   b. If v == 5 then set output_grid[r][c] = 8.  \n   c. Else if v == 8 then set output_grid[r][c] = 5.  \n   d. Else set output_grid[r][c] = v.  \n4. Return the output grid.",
    "72ca375d.json": "1. Initialize an empty set VISITED and an empty list COMPONENTS.\n2. For each cell (r, c) in the input grid:\n   a. If grid[r][c] = V ≠ 0 and (r, c) ∉ VISITED, then:\n      i. Initialize CELLS = {(r, c)}, add (r, c) to VISITED, and initialize queue Q = [(r, c)].\n      ii. While Q not empty, pop (r0, c0); for each neighbor (r1, c1) in {(r0-1,c0),(r0+1,c0),(r0,c0-1),(r0,c0+1)} within grid bounds: if grid[r1][c1] = V and (r1, c1) ∉ VISITED, add (r1, c1) to CELLS and VISITED, and enqueue (r1, c1).\n      iii. Append (CELLS, V) to COMPONENTS.\n3. For each component (CELLS, V) in COMPONENTS:\n   a. Compute r_min = min(r ∈ CELLS), r_max = max(r), c_min = min(c), c_max = max(c).\n   b. Compute H = r_max - r_min + 1 and W = c_max - c_min + 1.\n   c. Build subgrid S of size H×W where S[dr][dc] = grid[r_min+dr][c_min+dc] for dr in 0..H-1 and dc in 0..W-1.\n4. For each subgrid S, test horizontal symmetry:\n   a. For dr in 0..H-1 and dc in 0..⌊(W-1)/2⌋, if S[dr][dc] ≠ S[dr][W-1-dc], mark S as not symmetric and stop testing this S.\n   b. If no mismatches occur, mark S as symmetric.\n5. Identify the unique symmetric subgrid S among all components. Return this symmetric S as the output grid.",
    "178fcbfb.json": "1. Let H be the number of rows and W the number of columns of the input grid.\n2. Initialize an output grid of size H×W with all cells set to 0.\n3. Identify all red pixels (value 2) in the input. Build the set red_cols = {c | ∃r, input[r][c] == 2}.\n4. Identify all green pixels (value 3) in the input. Build the set green_rows = {r | ∃c, input[r][c] == 3}.\n5. Identify all blue pixels (value 1) in the input. Build the set blue_rows = {r | ∃c, input[r][c] == 1}.\n6. For each column c in red_cols:\n   a. For each row r from 0 to H-1, set output[r][c] = 2.\n7. For each row r in green_rows:\n   a. For each column c from 0 to W-1, set output[r][c] = 3 (overwriting any 2 at intersections).\n8. For each row r in blue_rows:\n   a. For each column c from 0 to W-1, set output[r][c] = 1 (overwriting any 2 at intersections).\n9. Return the output grid.",
    "d406998b.json": "1. Let R be the number of rows and C be the number of columns in the input grid.\n2. Compute target_parity = C mod 2.\n3. Initialize the output grid as a copy of the input grid.\n4. For each row index i from 1 to R and each column index j from 1 to C:\n   a. If (j mod 2 == target_parity) and the input cell at (i,j) equals 5, set the output cell at (i,j) = 3.\n   b. Otherwise leave the output cell at (i,j) unchanged.\n5. Return the output grid.",
    "e73095fd.json": "1. Let barrier_color=5, fill_color=4, background_color=0. Let H = number of rows, W = number of columns. 2. Initialize an empty list rectangles. 3. For each r1 in 0..H-1 and each c1 in 0..W-1:\n   a. If grid[r1][c1] ≠ barrier_color, continue to next c1.\n   b. For each c2 in (c1+1)..W-1:\n      i. If grid[r1][c2] ≠ barrier_color, continue to next c2.\n      ii. If c2–c1 < 2, continue (no room for interior).\n      iii. For each r2 in (r1+1)..H-1:\n          A. If grid[r2][c1] ≠ barrier_color or grid[r2][c2] ≠ barrier_color, continue to next r2.\n          B. If r2–r1 < 2, continue (no room for interior).\n          C. Check all cells on the four edges:\n             – Top edge: for c in c1..c2, grid[r1][c] must equal barrier_color.\n             – Bottom edge: for c in c1..c2, grid[r2][c] must equal barrier_color.\n             – Left edge: for r in r1..r2, grid[r][c1] must equal barrier_color.\n             – Right edge: for r in r1..r2, grid[r][c2] must equal barrier_color.\n          D. If all four edges are barrier_color, append (r1, r2, c1, c2) to rectangles. 4. For each (r1, r2, c1, c2) in rectangles:\n   For r in (r1+1)..(r2-1) and c in (c1+1)..(c2-1):\n      If grid[r][c] == background_color, set grid[r][c] = fill_color. 5. Return the modified grid.",
    "75b8110e.json": "1. Let G be the input grid of size 8×8, indexed by row r and column c with 0 ≤ r,c ≤ 7.\n2. Extract subgrid TL of size 4×4: for each 0 ≤ r,c ≤ 3 set TL[r,c] = G[r,c].\n3. Extract subgrid TR of size 4×4: for each 0 ≤ r,c ≤ 3 set TR[r,c] = G[r,c+4].\n4. Extract subgrid BL of size 4×4: for each 0 ≤ r,c ≤ 3 set BL[r,c] = G[r+4,c].\n5. Extract subgrid BR of size 4×4: for each 0 ≤ r,c ≤ 3 set BR[r,c] = G[r+4,c+4].\n6. Initialize output grid O of size 4×4: for each 0 ≤ r,c ≤ 3 set O[r,c] = TL[r,c].\n7. Overlay BR onto O: for each 0 ≤ r,c ≤ 3, if BR[r,c] ≠ 0 then set O[r,c] = BR[r,c].\n8. Overlay BL onto O: for each 0 ≤ r,c ≤ 3, if BL[r,c] ≠ 0 then set O[r,c] = BL[r,c].\n9. Overlay TR onto O: for each 0 ≤ r,c ≤ 3, if TR[r,c] ≠ 0 then set O[r,c] = TR[r,c].\n10. Return O as the 4×4 result. Treat pixel value 0 as transparent (background).",
    "d4f3cd78.json": "1. Let H = number of rows, W = number of columns. 2. Scan all grid cells and collect coordinates where value == 5. Compute row_min = minimum row, row_max = maximum row, col_min = minimum column, col_max = maximum column among these coordinates. 3. Identify the single gap on the rectangle perimeter: for each (r,c) where (r==row_min or r==row_max) and col_min<=c<=col_max, or (c==col_min or c==col_max) and row_min<=r<=row_max, find the one position where grid[r][c] != 5. Record gap_r = r, gap_c = c. 4. Fill interior of the rectangle: for R from row_min+1 to row_max-1 inclusive, for C from col_min+1 to col_max-1 inclusive, set grid[R][C] = 8. 5. Determine extension direction (dr,dc): if gap_r == row_min then dr = -1, dc = 0; else if gap_r == row_max then dr = 1, dc = 0; else if gap_c == col_min then dr = 0, dc = -1; else if gap_c == col_max then dr = 0, dc = 1. 6. Draw the line of 8's from the gap to the grid edge: initialize r = gap_r, c = gap_c; while 0 <= r < H and 0 <= c < W, set grid[r][c] = 8; then r += dr, c += dc; 7. Return the modified grid with the same dimensions.",
    "d43fd935.json": "1. Let input_grid be the given H×W array of integers (0–9). 2. Initialize output_grid as a copy of input_grid. 3. Identify all positions (r,c) where input_grid[r][c] == 3. Compute min_r, max_r, min_c, max_c over these positions. (They form a 2×2 block since max_r = min_r+1 and max_c = min_c+1.) 4. Define the four corners: top_left = (min_r,min_c), top_right = (min_r,max_c), bottom_left = (max_r,min_c), bottom_right = (max_r,max_c). 5. Define directions = [(-1,0),(1,0),(0,-1),(0,1)]. 6. For each corner (r0,c0) in [top_left, top_right, bottom_left, bottom_right]:\n   For each (dr,dc) in directions:\n     a. Set r = r0 + dr, c = c0 + dc.\n     b. While (r,c) lies within the grid bounds:\n        i. Let v = input_grid[r][c].\n        ii. If v != 0 and v != 3 then:\n            • Let color = v.\n            • Set fr = r0 + dr, fc = c0 + dc.\n            • While (fr,fc) != (r,c):\n                – If input_grid[fr][fc] == 0 then set output_grid[fr][fc] = color.\n                – fr += dr; fc += dc.\n            • Break the while loop over (r,c).\n        iii. Else:\n            • r += dr; c += dc.\n7. Return output_grid.",
    "045e512c.json": "1. Let N = number of rows, M = number of columns. 2. Find all 4-connected components of non-zero pixels. For each component record its color and its list of (r,c) coordinates. 3. Let the reference component be the one with the most cells. Call its color refColor and its coordinate list refCells. 4. Compute its bounding box: minR = min(r for (r,c) in refCells), maxR = max(r), minC = min(c), maxC = max(c). Compute height = maxR–minR+1, width = maxC–minC+1, and step = max(height,width)+1. 5. Compute refRel = [(r–minR, c–minC) for (r,c) in refCells]. 6. For each other component S of color C with coordinate list sCells:   a. Build a list offsets = [ ].   b. For each (sr,sc) in sCells and each (rr,rc) in refCells compute Off = (sr–rr, sc–rc). If for every (sr2,sc2) in sCells the point (sr2–Off.r, sc2–Off.c) is in refCells, append Off to offsets.   c. Choose (dr,dc) from offsets that maximizes |dr|+|dc|.   d. Compute dirR = sign(dr), dirC = sign(dc), where sign(x)=0 if x=0 else x/|x|.   e. For k=0,1,2,… do:      i. Let placed=false.     ii. For each (dR,dC) in refRel compute tr = minR + dR + dr + k*dirR*step, tc = minC + dC + dc + k*dirC*step.     iii. If 0≤tr<N and 0≤tc<M then set grid[tr][tc]=C and set placed=true.     iv. If placed is false, break the k-loop. 7. Return the modified grid.",
    "72322fa7.json": "1. Let H = number of rows, W = number of columns.\n2. Partition all non-zero cells into connected components using 8-neighbor adjacency.\n3. For each component C with |C| ≥ 3:\n   a. Compute the frequency of each value in C.\n   b. Let center_color = the value in C with frequency 1; let arm_color = the other value in C.\n   c. Let (r0,c0) be the coordinate of the cell in C with value center_color.\n   d. Build pattern Off = { (dr,dc,val) | for each (r,c) in C, dr = r−r0, dc = c−c0, val = grid[r][c] }.\n4. For each pattern Off:\n   For each anchor (r,c) with 0 ≤ r < H and 0 ≤ c < W:\n     a. If for all (dr,dc,val) in Off:\n        i. 0 ≤ r+dr < H and 0 ≤ c+dc < W, and grid[r+dr][c+dc] ∈ {0,val};\n     b. And if there exists at least one (dr,dc,val) in Off with grid[r+dr][c+dc] == val;\n     c. And if there exists at least one (dr,dc,val) in Off with grid[r+dr][c+dc] == 0;\n     Then:\n       For each (dr,dc,val) in Off set grid[r+dr][c+dc] = val.\n5. Return the modified grid.",
    "760b3cac.json": "1. Let G be the input grid of size R rows by C columns with 0-based indices.\n2. Compute B4 = {(r,c) | G[r][c] == 4}.\n3. Compute minRow4 = min(r | (r,c) in B4), minCol4 = min(c | (r,c) in B4), maxCol4 = max(c | (r,c) in B4).\n4. Identify pivotCol4 as the c coordinate of the unique element in B4 with r == minRow4.\n5. If pivotCol4 == minCol4 then set direction = left; else if pivotCol4 == maxCol4 then set direction = right.\n6. Compute B8 = {(r,c) | G[r][c] == 8}.\n7. Compute minCol8 = min(c | (r,c) in B8), maxCol8 = max(c | (r,c) in B8), width8 = maxCol8 - minCol8 + 1.\n8. For each (r,c) in B8:\n   a. Compute rel = c - minCol8.\n   b. Compute mirrorRel = (width8 - 1) - rel.\n   c. If direction == left then newC = minCol8 - width8 + mirrorRel; else (direction == right) newC = maxCol8 + 1 + mirrorRel.\n   d. Set G[r][newC] = 8.\n9. Return G as the output grid.",
    "d4a91cb9.json": "1. Treat grid coordinates as (r, c) with 0-based indices: r=0 is top row, c=0 is leftmost column.\n2. Scan all cells to find the unique cell with value 8; record its position as (r8, c8).\n3. Scan all cells to find the unique cell with value 2; record its position as (r2, c2).\n4. Compute r_start = min(r8, r2), r_end = max(r8, r2), c_start = min(c8, c2), c_end = max(c8, c2).\n5. For each row index r from r_start to r_end inclusive:\n     If r ≠ r8, set cell (r, c8) to value 4.\n6. For each column index c from c_start to c_end inclusive:\n     If c ≠ c2, set cell (r2, c) to value 4.\n7. Leave all other cells unchanged and output the grid with the same dimensions as the input.",
    "1b2d62fb.json": "1. Let G be the input grid of size H rows by W columns. 2. Find the unique column index d such that for every row r (0 ≤ r < H), G[r][d] == 1. 3. Compute pattern width w = d. 4. Create an output grid O of size H rows by w columns and initialize all O[r][c] = 0. 5. For each row r from 0 to H-1 and each column c from 0 to w-1:   a. Let v1 = G[r][c] and v2 = G[r][d+1+c].   b. If v1 == 0 AND v2 == 0 then set O[r][c] = 8; otherwise leave O[r][c] = 0. 6. Return O.",
    "0dfd9992.json": "1. Let R be the number of rows and C be the number of columns of the input grid. Initialize output[r][c] = input[r][c] for all 0≤r<R, 0≤c<C.\\n2. Treat 0 as blank. Determine the horizontal period W as the smallest integer k (1≤k<C) such that for every r in [0,R) and every c in [0,C−k), if input[r][c]≠0 and input[r][c+k]≠0 then input[r][c]==input[r][c+k].\\n3. Determine the vertical period H as the smallest integer k (1≤k<R) such that for every r in [0,R−k) and every c in [0,C), if input[r][c]≠0 and input[r+k][c]≠0 then input[r][c]==input[r+k][c].\\n4. Locate the template tile of size H×W by scanning r0 from 0 to R−H and c0 from 0 to C−W; select the first (r0,c0) for which all cells input[r0+i][c0+j] (0≤i<H, 0≤j<W) are nonzero.\\n5. For each cell (r,c) where input[r][c]==0, compute dr = ((r−r0) % H + H) % H and dc = ((c−c0) % W + W) % W, then set output[r][c] = input[r0+dr][c0+dc].\\n6. Return the output grid.",
    "d5d6de2d.json": "1. Let H = number of rows of input_grid and W = number of columns. Create output_grid of size H×W and set every cell to 0.\n2. Identify all connected components of cells with value 2 in input_grid using 4‐connectivity.\n3. For each component C:\n   a. Compute min_r = minimum row index in C, max_r = maximum row index in C; min_c = minimum column index in C, max_c = maximum column index in C.\n   b. If max_r - min_r < 2 or max_c - min_c < 2 then skip C (no interior).\n   c. For each cell (r,c) on the perimeter of the bounding box defined by min_r,max_r,min_c,max_c (i.e. r=min_r or r=max_r for c in [min_c..max_c], and c=min_c or c=max_c for r in [min_r..max_r]), verify input_grid[r][c] == 2; if any perimeter cell ≠ 2 then skip C.\n   d. For each cell (r,c) strictly inside that box (r in [min_r+1..max_r-1], c in [min_c+1..max_c-1]), verify input_grid[r][c] == 0; if any interior cell ≠ 0 then skip C.\n   e. For each cell (r,c) in the interior region (r in [min_r+1..max_r-1], c in [min_c+1..max_c-1]), set output_grid[r][c] = 3.\n4. Return output_grid as the result.",
    "137eaa0f.json": "1. Let H be number of rows and W be number of columns of the input grid.\n2. Initialize output_grid as a 3×3 grid filled with 0.\n3. Identify list G of all coordinates (r_g, c_g) where input_grid[r_g][c_g] == 5.\n4. For each (r_g, c_g) in G do:\n   a. Initialize set P = {(r_g, c_g)} and queue Q = [(r_g, c_g)].\n   b. While Q is not empty:\n      i. Pop (r, c) from Q.\n      ii. For each dr in [-1,0,1] and each dc in [-1,0,1] with not(dr == 0 and dc == 0):\n          - Let nr = r + dr and nc = c + dc.\n          - If 0 ≤ nr < H and 0 ≤ nc < W and input_grid[nr][nc] != 0 and (nr, nc) not in P then add (nr, nc) to P and append (nr, nc) to Q.\n   c. For each (r, c) in P:\n      i. Let v = input_grid[r][c].\n      ii. Compute dr = r - r_g and dc = c - c_g.\n      iii. Set new_r = 1 + dr and new_c = 1 + dc.\n      iv. Assign output_grid[new_r][new_c] = v.\n5. Return output_grid.",
    "1a07d186.json": "1. Enumerate all non-zero values present in the grid.\n2. For each value C:\n   a. Collect all pixels with value C and group them into connected components (4-adjacency).\n   b. Identify among these components one that lies strictly in a single row or a single column and has size >1. If found, call it PRIMARY_LINE(C) and record its orientation and fixed index (ROW=Y if horizontal, or COL=X if vertical). Otherwise mark C as NO_LINE.\n3. For each C with PRIMARY_LINE(C):\n   a. Leave all PRIMARY_LINE(C) pixels in place.\n   b. For each remaining pixel of value C at (r,c):\n      i. If PRIMARY_LINE(C) is vertical at column X:\n         - If c < X then set target = (r, X-1) else set target = (r, X+1).\n      ii. If PRIMARY_LINE(C) is horizontal at row Y:\n         - If r < Y then set target = (Y-1, c) else set target = (Y+1, c).\n      iii. Set grid[r][c] = 0.\n      iv. Set grid[target] = C.\n4. For each C marked NO_LINE: set every pixel of value C to 0.\n5. Return the grid with the same dimensions.",
    "06df4c85.json": "1. Identify sep_value: scan each row r; if all grid[r][c] equal a non-zero v, set sep_value = v and stop. 2. Find sep_rows = sorted list of row indices r where for all c, grid[r][c] == sep_value; find sep_cols = sorted list of column indices c where for all r, grid[r][c] == sep_value. 3. Build row_intervals and col_intervals:\n   a. row_intervals[0] = [0, sep_rows[0]-1]; for k from 1 to len(sep_rows)-1, row_intervals[k] = [sep_rows[k-1]+1, sep_rows[k]-1]; row_intervals[last+1] = [sep_rows[last]+1, num_rows-1].\n   b. col_intervals similarly from sep_cols and num_cols. 4. For each cell coordinate (i,j), define its pixel region as rows row_intervals[i][0]..row_intervals[i][1] and cols col_intervals[j][0]..col_intervals[j][1]. 5. Determine initial cell_color[i][j]: scan its region; if any pixel p != 0 and p != sep_value, set cell_color[i][j] = p. 6. For each color c in cell_color:\n   a. Horizontal fill: for each row i, let js = [j | cell_color[i][j] == c]; if len(js) >= 2, let j_min = min(js), j_max = max(js); for j in j_min..j_max, set all pixels in region(i,j) to c.\n   b. Vertical fill: for each col j, let is = [i | cell_color[i][j] == c]; if len(is) >= 2, let i_min = min(is), i_max = max(is); for i in i_min..i_max, set all pixels in region(i,j) to c. 7. Return the modified grid.",
    "9d9215db.json": "1. Let N be the grid dimension (assume square).\n2. Parse input. For each non-zero cell, record its row r and column c.\n3. Build: RowsMap: mapping each row r to list of input columns in that row. ColumnsMap: mapping each column c to list of input rows in that column.\n4. Identify r_main: among rows r with exactly two input columns, pick the one minimizing min(r, N-1-r). If none exists, r_main = null.\n5. Identify c_main: among columns c with exactly two input rows, pick the one minimizing min(c, N-1-c). If none exists, c_main = null.\n6. Initialize output grid as a copy of input grid.\n7. Horizontal stripes (rows):\n   For each row r in RowsMap:\n     Let P = sorted list of input columns in this row.\n     Let r_m = N-1-r.\n     If |P|==2 and r==r_main:\n       Let c1=P[0], c2=P[1].\n       Let dist1 = min(c1, N-1-c1), dist2 = min(c2, N-1-c2).\n       If dist1 <= dist2 then\n         c_anchor=c1; c_other=c2;\n       else\n         c_anchor=c2; c_other=c1;\n       c_anchor_m = N-1 - c_anchor;\n       dir = (c_anchor < c_anchor_m ? +2 : -2);\n       For c = c_anchor; ; c += dir:\n         If c==c_anchor or c==c_anchor_m then v = input[r][c_anchor];\n         else v = input[r][c_other];\n         Set output[r][c] = v; Set output[r_m][c] = v;\n         If c == c_anchor_m then break;\n     else:\n       For each c in P:\n         let c_m = N-1 - c;\n         let v = input[r][c];\n         Set output[r][c] = v;\n         Set output[r][c_m] = v;\n         Set output[r_m][c] = v;\n         Set output[r_m][c_m] = v;\n8. Vertical stripes (columns):\n   For each column c in ColumnsMap:\n     Let Q = sorted list of input rows in this column.\n     Let c_m = N-1 - c.\n     If |Q|==2 and c==c_main:\n       Let r1=Q[0], r2=Q[1].\n       Let d1 = min(r1, N-1-r1), d2 = min(r2, N-1-r2).\n       If d1 <= d2 then\n         r_anchor=r1; r_other=r2;\n       else\n         r_anchor=r2; r_other=r1;\n       r_anchor_m = N-1 - r_anchor;\n       dir = (r_anchor < r_anchor_m ? +2 : -2);\n       For r0 = r_anchor; ; r0 += dir:\n         If r0==r_anchor or r0==r_anchor_m then v = input[r_anchor][c];\n         else v = input[r_other][c];\n         Set output[r0][c] = v; Set output[r0][c_m] = v;\n         If r0 == r_anchor_m then break;\n     else:\n       For each r0 in Q:\n         let r_m = N-1 - r0;\n         let v = input[r0][c];\n         Set output[r0][c] = v;\n         Set output[r0][c_m] = v;\n         Set output[r_m][c] = v;\n         Set output[r_m][c_m] = v;\n9. Return the output grid.",
    "746b3537.json": "1. Let G be the input grid of integers with H rows and W columns.\n2. Remove consecutive duplicate rows:\n   a. Initialize an empty list newRows.\n   b. For each row index r from 0 to H-1:\n      i. If r==0 or G[r] differs from newRows[-1], append G[r] to newRows.\n   c. Replace G’s rows with newRows and set H = number of rows in newRows.\n3. Remove consecutive duplicate columns:\n   a. Initialize an empty list newCols.\n   b. For each column index c from 0 to W-1 (using updated W):\n      i. Extract column vector col = [G[r][c] for r in 0..H-1].\n      ii. If c==0 or col differs from newCols[-1], append col to newCols.\n   c. Construct grid G2 of size H×K where K = length of newCols, setting G2[r][k] = newCols[k][r].\n4. Return G2 as the output grid.",
    "6ecd11f4.json": "1. Identify pattern_color:\n   a. Compute frequency of each non-zero integer in the grid.\n   b. Set pattern_color to the integer with the highest frequency.\n2. Locate large pattern region:\n   a. For each row r, let row_has_pattern[r]=True if any cell in row r equals pattern_color.\n   b. Find the longest contiguous sequence of True in row_has_pattern; let region_top and region_bottom be its first and last indices.\n   c. For each column c, let col_has_pattern[c]=True if any cell in rows region_top..region_bottom at column c equals pattern_color.\n   d. Set region_left to the smallest c with col_has_pattern[c]=True and region_right to the largest such c.\n3. Locate small pattern region:\n   a. For each row r>region_bottom, let row_nonzero[r]=True if any cell in row r is non-zero.\n   b. Find the longest contiguous sequence of True in row_nonzero; let small_top and small_bottom be its first and last indices.\n   c. For each column c, let col_nonzero[c]=True if any cell in rows small_top..small_bottom at column c is non-zero.\n   d. Set small_left to the smallest c with col_nonzero[c]=True and small_right to the largest such c.\n4. Define dimensions:\n   h_small = small_bottom - small_top + 1\n   w_small = small_right - small_left + 1\n   H_region = region_bottom - region_top + 1\n   W_region = region_right - region_left + 1\n5. Compute block size:\n   block_height = H_region / h_small  (must be integer)\n   block_width  = W_region / w_small  (must be integer)\n6. Build binary mask M of size h_small×w_small:\n   For i in 0..h_small-1 and j in 0..w_small-1:\n     r0 = region_top   + i * block_height\n     c0 = region_left  + j * block_width\n     If any cell in subgrid [r0..r0+block_height-1][c0..c0+block_width-1] equals pattern_color,\n       set M[i][j]=1\n     Else set M[i][j]=0\n7. Extract small pattern P of size h_small×w_small:\n   P[i][j] = grid[small_top + i][small_left + j] for i in 0..h_small-1, j in 0..w_small-1\n8. Build output grid of size h_small×w_small:\n   For i in 0..h_small-1 and j in 0..w_small-1:\n     If M[i][j]==1 then output[i][j] = P[i][j]\n     Else output[i][j] = 0",
    "d07ae81c.json": "1. Let R be the number of rows and C be the number of columns of the input grid. 2. Copy the input grid to an output grid of the same size. 3. For each position (r,c) with 0 ≤ r < R and 0 ≤ c < C:   a. If none of its orthogonal neighbors (r-1,c), (r+1,c), (r,c-1), (r,c+1) within bounds has value equal to input[r][c], then treat (r,c) as a seed:      i. Let seed_color = input[r][c].      ii. Determine region_color by examining any one orthogonal neighbor of (r,c) inside bounds; set region_color to that neighbor’s input value.      iii. For each diagonal direction (dr,dc) in the list [(-1,-1), (-1,1), (1,-1), (1,1)]:           - Set step = 1.           - Repeat:             * Compute rr = r + dr*step and cc = c + dc*step.             * If rr < 0 or rr ≥ R or cc < 0 or cc ≥ C, break.             * If input[rr][cc] ≠ region_color, break.             * Set output[rr][cc] = seed_color.             * Increment step by 1. 4. Return the output grid.",
    "150deff5.json": "1. Let H = number of rows, W = number of columns. Let Grey = set of all coordinates (r,c) with 0 ≤ r < H, 0 ≤ c < W and grid[r][c] == 5.\n2. Build list Cand of all candidate top-left coordinates for 2×2 blocks: for each (r,c) with 0 ≤ r ≤ H-2 and 0 ≤ c ≤ W-2, if all four cells (r,c), (r,c+1), (r+1,c), (r+1,c+1) are in Grey, add (r,c) to Cand.\n3. Search for the unique subset Squares ⊆ Cand satisfying:\n   a. No two positions in Squares produce overlapping 4-cell blocks.\n   b. Let Covered = ∪_{(r,c)∈Squares} {(r+dr,c+dc) | (dr,dc)∈{(0,0),(0,1),(1,0),(1,1)}}. Let Remain = Grey \\ Covered. Ensure |Remain| % 3 == 0.\n   c. Compute 4-connected components of Remain. Each component comp must have exactly 3 cells and either:\n      – all cells share the same row r0 and their column values form {c0,c0+1,c0+2}, or\n      – all cells share the same column c0 and their row values form {r0,r0+1,r0+2}.\n4. Initialize output grid as a copy of input.\n5. For each (r,c) in Squares, set output[r][c] = output[r][c+1] = output[r+1][c] = output[r+1][c+1] = 8.\n6. For each remaining coordinate (r,c) in Grey not recolored in step 5, set output[r][c] = 2.\n7. Leave all other cells unchanged. Return the output grid.",
    "f15e1fac.json": "1. Copy the input grid to an output grid.\n2. Let H = number of rows, W = number of columns.\n3. Identify seed pixels: record all coordinates (R0,C0) such that input[R0][C0] == 8 and (R0 == 0 or R0 == H-1 or C0 == 0 or C0 == W-1).\n4. Determine stripe direction:\n   - If any seed has R0 == 0 then set dr = 1, dc = 0.\n   - Else if any seed has R0 == H-1 then set dr = -1, dc = 0.\n   - Else if any seed has C0 == 0 then set dr = 0, dc = 1.\n   - Else set dr = 0, dc = -1.\n5. If dr != 0 then perform vertical stripes:\n   5.1. Collect all unique row indices breakRows where input[breakRow][C] == 2 for any C.\n   5.2. Sort breakRows in ascending order if dr == 1 else in descending order if dr == -1.\n   5.3. For each seed (R0,C0):\n       a. Set currC = C0.\n       b. Let N = length of breakRows.\n       c. For each integer i from 0 to N inclusive do:\n           i. If i == 0 then startR = R0 else startR = breakRows[i-1].\n           ii. If i < N then endR = breakRows[i] - dr else endR = (dr == 1 ? H-1 : 0).\n           iii. For R from startR to endR stepping by dr: if 0 <= R < H and 0 <= currC < W then set output[R][currC] = 8.\n           iv. If i < N then:\n                 Let breakR = breakRows[i]; find C_red such that input[breakR][C_red] == 2.\n                 If C_red < currC then currC += 1 else if C_red > currC then currC -= 1.\n6. If dc != 0 then perform horizontal stripes:\n   6.1. Collect all unique column indices breakCols where input[R][breakCol] == 2 for any R.\n   6.2. Sort breakCols in ascending order if dc == 1 else in descending order if dc == -1.\n   6.3. For each seed (R0,C0):\n       a. Set currR = R0.\n       b. Let N = length of breakCols.\n       c. For each integer i from 0 to N inclusive do:\n           i. If i == 0 then startC = C0 else startC = breakCols[i-1].\n           ii. If i < N then endC = breakCols[i] - dc else endC = (dc == 1 ? W-1 : 0).\n           iii. For C from startC to endC stepping by dc: if 0 <= currR < H and 0 <= C < W then set output[currR][C] = 8.\n           iv. If i < N then:\n                 Let breakC = breakCols[i]; find R_red such that input[R_red][breakC] == 2.\n                 If R_red < currR then currR += 1 else if R_red > currR then currR -= 1.\n7. Return the output grid.",
    "57aa92db.json": "1. Identify all 4-connected components of non-zero cells in the input grid. 2. For each component comp: compute the set of distinct pixel values and the count of each. 3. If comp has exactly two distinct values and exactly one of them occurs once, then: let shared_value be the value with count=1 and shape_value be the other; compute bounding box rows [r0..r1] and cols [c0..c1]; let h0 = r1 - r0 + 1 and w0 = c1 - c0 + 1; extract pattern P of size h0 × w0 by P[i][j] = input[r0 + i][c0 + j]; find (rp,cp) such that P[rp][cp] = shared_value; record this pattern entry (P, h0, w0, shape_value, shared_value, rp, cp, comp). 4. Copy input to output_grid. 5. For each recorded pattern: a) For each component C of value = shared_value not equal to pattern’s comp: let sizeY = |C| and countY0 = number of shared_value cells in P; if sizeY mod countY0 ≠ 0 continue; let f2 = sizeY/countY0 and f = floor(sqrt(f2)); if f*f ≠ f2 continue; get C bounding box [rY0..rY1],[cY0..cY1]; if rY1 - rY0 + 1 ≠ f or cY1 - cY0 + 1 ≠ f continue. b) Let CX = all cells of value = shape_value that are 4-adjacent to any cell in C; if CX is empty continue; get CX bounding box [rX0..rX1],[cX0..cX1]. c) Compute rB0 = min(rY0,rX0), rB1 = max(rY1,rX1), cB0 = min(cY0,cX0), cB1 = max(cY1,cX1); let hB = rB1 - rB0 + 1 and wB = cB1 - cB0 + 1; if hB == h0*f and wB == w0*f then rotation = 0 else if hB == w0*f and wB == h0*f then rotation = 90 else continue. d) If rotation == 0 set rpr = rp, cpr = cp; else set rpr = cp, cpr = h0 - 1 - rp; compute origin_row = rY0 - rpr*f and origin_col = cY0 - cpr*f; let map_shape = pixel value of any CX cell and map_shared = shared_value. e) For r in 0..h0-1 and c in 0..w0-1: let v = P[r][c]; if v == 0 continue; if rotation == 0 set rP = r, cP = c; else set rP = c, cP = h0 - 1 - r; let target = (v == shape_value ? map_shape : map_shared); for dr in 0..f-1 and dc in 0..f-1 set output_grid[origin_row + rP*f + dr][origin_col + cP*f + dc] = target. 6. Return output_grid.",
    "4290ef0e.json": "1. Let H and W be the number of rows and columns of the input grid. 2. Compute, for each color value C present in the grid, the bounding box: minRow[C]=minimum row index of C, maxRow[C]=maximum row index, minCol[C], maxCol[C]. 3. Identify the background color B as the unique C for which minRow[C]=0, maxRow[C]=H-1, minCol[C]=0, maxCol[C]=W-1. 4. Let shapeColors be the list of all distinct colors C≠B. 5. For each C in shapeColors:   a. Compute side length S[C]=max(maxRow[C]−minRow[C]+1, maxCol[C]−minCol[C]+1).   b. Compute the number of 4-connected components of color C; if it is 1, set style[C]=\"outline\", else style[C]=\"corner\".   c. Compute thickness[C]=the maximum length of any contiguous run of C in any single row or any single column. 6. Create an output grid of size Smax×Smax where Smax=max_{C≠B} S[C], initializing every cell to B. 7. Sort shapeColors in descending order of S[C]. 8. For each C in that order:   a. Let S=S[C], t=thickness[C], offset=(Smax−S)/2 (an integer).   b. If style[C]==\"outline\":      For i from 0 to t−1:        For c from i to S−1−i:          Set output[offset+i][offset+c]=C and output[offset+S−1−i][offset+c]=C;        For r from i to S−1−i:          Set output[offset+r][offset+i]=C and output[offset+r][offset+S−1−i]=C.   c. If style[C]==\"corner\":      For each (dr,dc) in {(0,0),(0,S−t),(S−t,0),(S−t,S−t)}:        For r from 0 to t−1:          For c from 0 to t−1:            Set output[offset+dr+r][offset+dc+c]=C. 9. Return the output grid.",
    "776ffc46.json": "1. Scan the grid to locate a complete rectangular border of pixels with value 5.  To do this, find indices r1<r2 and c1<c2 such that every cell at (r1, c) for c1≤c≤c2, at (r2, c) for c1≤c≤c2, at (r, c1) for r1≤r≤r2, and at (r, c2) for r1≤r≤r2 has value 5, and no larger rectangle with these properties exists.\n2. Define the interior region of the border as rows r in [r1+1..r2-1] and columns c in [c1+1..c2-1].\n3. Within the interior region, collect all cells (r,c) whose value v≠0 and v≠5.  Let S_ref be this set of coordinates.  Let color_ref be the common value v of these cells.\n4. Compute the bounding box of S_ref: let rr_min = min(r of S_ref), cc_min = min(c of S_ref).  Define the reference mask M_ref = {(r-rr_min, c-cc_min) : (r,c) in S_ref}.\n5. Identify all connected components of non-zero, non-5 cells in the grid using 4-connectivity.  For each component comp with cell set S_comp and color v_comp:\n   a. Compute its bounding box: cr_min = min(r of S_comp), cc_min = min(c of S_comp).\n   b. Compute its mask M_comp = {(r-cr_min, c-cc_min) : (r,c) in S_comp}.\n   c. If M_comp equals M_ref and S_comp is not fully contained inside the interior region (i.e., comp is not the reference shape), then for each (r,c) in S_comp set grid[r][c] = color_ref.\n6. Return the modified grid.",
    "c8cbb738.json": "1. Identify background_color B as the integer value that appears in the majority of cells in the input grid.\n2. For each distinct color value v ≠ B:\n   a. Collect coords_v = list of all (r,c) such that input[r][c] == v. Assert |coords_v| == 4.\n3. For each color v:\n   a. Let min_r = min(r for (r,c) in coords_v), max_r = max(r for (r,c) in coords_v).\n   b. Let min_c = min(c for (r,c) in coords_v), max_c = max(c for (r,c) in coords_v).\n   c. Compute height_v = max_r - min_r + 1, width_v = max_c - min_c + 1.\n   d. For each (r,c) in coords_v compute relative_positions_v = list of (r - min_r + 1, c - min_c + 1).\n4. Let output_height = max(height_v over all v), output_width = max(width_v over all v).\n5. Create output grid of size output_height × output_width and fill every cell with B.\n6. For each color v:\n   a. Compute row_offset = floor((output_height - height_v)/2) + 1.\n   b. Compute col_offset = floor((output_width - width_v)/2) + 1.\n   c. For each (r_rel, c_rel) in relative_positions_v:\n      i. Set output[row_offset + r_rel - 1][col_offset + c_rel - 1] = v.\n7. Return the output grid.",
    "a78176bb.json": "1. Let H be number of rows and W be number of columns.\n2. Identify the diagonal color X and its offset:\n   a. Scan input grid for any cell (r,c) with value not equal to 0 or 5; set X to that value.\n   b. Compute diag_offset = c – r for any cell with value X.\n3. Copy input grid to output grid.\n4. Erase all grey pixels: for each cell (r,c) where input[r][c] == 5, set output[r][c] = 0.\n5. For each side in {+1, –1} do:\n   a. For each diagonal cell (r,c) where input[r][c] == X (i.e. c == r + diag_offset):\n      i. Initialize count = 0.\n      ii. For k = 1,2,… while 0 ≤ c + side*k < W and input[r][c + side*k] == 5, increment count.\n      iii. Record neighbor_count[r] = count.\n   b. Let max_count = maximum of neighbor_count[r] over all diag cells; if max_count == 0, skip this side.\n   c. Choose any r_attach with neighbor_count[r_attach] == max_count; let c_attach = r_attach + diag_offset.\n   d. Compute departure cell (r0, c0):\n      r0 = r_attach;\n      c0 = c_attach + side * (max_count + 2).\n   e. Draw a new diagonal of color X through (r0, c0):\n      i. For k = 0,1,2,… while 0 ≤ r0 + k < H and 0 ≤ c0 + k < W:\n         set output[r0 + k][c0 + k] = X.\n      ii. For k = 1,2,… while 0 ≤ r0 - k < H and 0 ≤ c0 - k < W:\n         set output[r0 - k][c0 - k] = X.\n6. Return the output grid.",
    "e40b9e2f.json": "1. Let grid be the input 2D array of integers, indexed by (r,c) with r=0..H-1, c=0..W-1. 2. Find the largest integer N≥2 such that there exists at least one N×N axis-aligned subgrid all of whose cells have value ≠0. Record its top-left corner (r0,c0) and side length N. 3. Compute the rotation center as:\n   • center_row = r0 + (N-1)/2\n   • center_col = c0 + (N-1)/2\n   (This yields an integer center if N is odd, or a half-integer center if N is even.) 4. Initialize output_grid as a copy of grid. 5. For each cell (r,c) with value v>0 that lies outside the inside square (i.e. r<r0 or r≥r0+N or c< c0 or c≥c0+N):\n   a. Compute dr = r - center_row, dc = c - center_col.\n   b. For k in {0,1,2,3} do:\n      i. If k==0 then dr_k=dr, dc_k=dc.\n      ii. If k==1 then dr_k = -dc, dc_k = dr.\n      iii. If k==2 then dr_k = -dr, dc_k = -dc.\n      iv. If k==3 then dr_k = dc, dc_k = -dr.\n      v. Let r_k = center_row + dr_k, c_k = center_col + dc_k.\n      vi. Round r_k and c_k to the nearest integer indices.\n      vii. Set output_grid[r_k][c_k] = v.\n6. Return output_grid.",
    "0e206a2e.json": "1. Read input grid G of size R×C. 2. Build list of all non-zero cells. 3. Compute connected components by 4-adjacency among non-zero cells. 4. Partition components: shape_components = all components of size >1; anchor_points = all components of size =1, each represented as (r,c,v). 5. Initialize output grid O of size R×C filled with 0. 6. For each component S in shape_components do:   a. Extract list P = {(r_i,c_i,v_i)} of its cells.   b. Compute r_min = min_i r_i, r_max = max_i r_i, c_min = min_i c_i, c_max = max_i c_i.   c. Let H = r_max - r_min + 1, W = c_max - c_min +1.   d. Build list L = {(r_i - r_min, c_i - c_min, v_i)}.   e. Build list A = {(r_a, c_a, v_a)} from anchor_points.   f. Enumerate each isometry: for rot in {0,90,180,270} do for refl in {false,true} do:      i. Define function T on local coords (r,c):         - If rot=0: (r1,c1)=(r,c)         - If rot=90: (r1,c1)=(c, H-1-r)         - If rot=180: (r1,c1)=(H-1-r, W-1-c)         - If rot=270: (r1,c1)=(W-1-c, r)         - If refl=true: c1 = ( ( (rot in {0,180})? W: H ) -1 - c1 ).      ii. Let H2 = (rot in {0,180}? H: W), W2 = (rot in {0,180}? W: H).      iii. For each anchor (r_a,c_a,v_a) in A and each (r0,c0,v0) in L with v0 = v_a do:           - Compute translation t_r = r_a - r1, t_c = c_a - c1, where (r1,c1)=T(r0,c0).           - Test all anchors: for each (r_b,c_b,v_b) in A check existence of (r2,c2,v2) in L with v2=v_b such that T(r2,c2)+(t_r,t_c) = (r_b,c_b).           - If all anchors match, record this transform and translation (rot,refl,t_r,t_c) and break loops.   g. Using found transform and translation, for each (r0,c0,v0) in L do:      - Compute (r1,c1)=T(r0,c0), then (r_out,c_out)=(r1 + t_r, c1 + t_c).      - Set O[r_out][c_out] = v0. 7. Return O.",
    "7447852a.json": "1. Let H be the number of rows and W be the number of columns in the input grid. 2. Create an output grid as a copy of the input grid. 3. For each row index r from 0 to H-1, do:\n   a. Initialize block_index ← 0, in_block ← false.  \n   b. For each column c from 0 to W-1, do:\n      i. If input[r][c] == 0 and in_block == false, then:\n         – in_block ← true\n         – block_index ← block_index + 1\n         – block_start ← c\n      ii. If (input[r][c] != 0 or c == W-1) and in_block == true, then:\n         – If input[r][c] != 0, set block_end ← c-1; else (c==W-1) set block_end ← c\n         – Define offset ← (r == 0 ? 2 : 1)  // row 0 uses offset 2, rows 1 and 2 use offset 1\n         – If block_index % 3 == offset, then for k from block_start to block_end, set output[r][k] ← 4\n         – in_block ← false\n4. Return the output grid.",
    "50846271.json": "1. Let H = number of rows and W = number of columns of the input grid. Make an output grid by copying the input.\n\n2. For each row r from 0 to H-1:\n   a. Let C = sorted list of all column indices c where input[r][c] == 2.\n   b. If C is non-empty, let c_min = C[0], c_max = C[-1], span = c_max - c_min.\n   c. If span >= 2 and (span mod 2) == 0 then:\n      i.   Let half = span / 2 (integer division), let center_c = c_min + half.\n      ii.  // Fill the horizontal arm\n           For c from c_min to c_max inclusive:\n             If output[r][c] != 2 then set output[r][c] = 8.\n      iii. // Fill the vertical arm\n           For rr from (r - half) to (r + half) inclusive:\n             If output[rr][center_c] != 2 then set output[rr][center_c] = 8.\n\n3. Return the output grid.  // All other cells remain unchanged.",
    "6aa20dc0.json": "1. Compute background_color as the integer value that appears most frequently in the input grid.\n2. Identify all 4-connected components of cells where grid[r][c] != background_color.\n3. For each component, compute its bounding box: r_min = min row, r_max = max row, c_min = min column, c_max = max column; let H = r_max - r_min + 1 and W = c_max - c_min + 1.\n4. Select the unique component with H > 1, W > 1, H == W, and component_size == H * W. Let k = H. Extract reference_pattern P of size k×k by P[u][v] = grid[r_min + u][c_min + v] for u,v in [0..k).\n5. Compute seed_colors = { c != background_color | P contains c exactly once }.\n6. Precompute rotated patterns: P0 = P; P90 = rotate P0 90° clockwise; P180 = rotate P90 90°; P270 = rotate P180 90°.\n7. For each seed_color c in seed_colors:\n   a. Find all 4-connected components C of color c that do not intersect the reference_pattern component.\n   b. For each component C:\n      i. Compute its bounding box with top-left (r_min,c_min) and let s = (r_max - r_min + 1) = (c_max - c_min + 1).\n      ii. For each rotated pattern P_r in [P0,P90,P180,P270]:\n         A. Locate the unique (i_ref,j_ref) in P_r where P_r[i_ref][j_ref] == c.\n         B. Compute origin_row = r_min - i_ref * s and origin_col = c_min - j_ref * s.\n         C. If origin_row >= 0, origin_col >= 0, origin_row + k * s <= num_rows, and origin_col + k * s <= num_cols, then:\n            1. For u in 0..k-1, v in 0..k-1, dr in 0..s-1, dc in 0..s-1:\n               let R = origin_row + u * s + dr, C2 = origin_col + v * s + dc.\n               If (u == i_ref and v == j_ref), require grid[R][C2] == c; else require grid[R][C2] == background_color. If any check fails, abort this P_r and try the next.\n            2. If all checks pass, repeat the loops and assign grid[R][C2] = P_r[u][v] for each (u,v,dr,dc). Then break out of the P_r loop.\n8. Return the modified grid as output.",
    "539a4f51.json": "1. Let N = the input grid size (5). Identify the background color B = 0 (the value filling the entire last row and last column).  \n2. Determine the pattern subgrid P as the maximal top-left rectangle excluding B: P = input[0..N-2][0..N-2] (a 4×4 block).  \n3. Set M = 2×N = 10. Create an empty M×M output grid.  \n4. For each output cell at coordinates (i, j) with 0 ≤ i,j < M:  \n   a. Compute r = i mod (N-1) and c = j mod (N-1).  \n   b. Set output[i][j] = P[r][c].  \n5. Return the filled M×M grid.",
    "6855a6e4.json": "1. Copy the input grid into a new grid named output.\n2. Find all connected components of pixel value 2 in output; store them as a list brackets of length 2.\n3. Find all connected components of pixel value 5 in output; store them as a list greys of length 2.\n4. For each bracket component Bi in brackets:\n   a. Compute its bounding box: bi_min_row = min row of Bi, bi_max_row = max row of Bi, bi_min_col = min column of Bi, bi_max_col = max column of Bi.\n   b. Determine which edge of the bounding box is the opening:\n      i. top_full = all cells output[bi_min_row][c]==2 for c from bi_min_col to bi_max_col.\n      ii. bottom_full = all cells output[bi_max_row][c]==2.\n      iii. left_full = all cells output[r][bi_min_col]==2 for r from bi_min_row to bi_max_row.\n      iv. right_full = all cells output[r][bi_max_col]==2.\n      v. If top_full && left_full && right_full && !bottom_full then opening = \"bottom\".\n      vi. Else if bottom_full && left_full && right_full && !top_full then opening = \"top\".\n      vii. Else if top_full && bottom_full && left_full && !right_full then opening = \"right\".\n      viii. Else if top_full && bottom_full && right_full && !left_full then opening = \"left\".\n   c. Select a grey component Gj from greys not yet assigned such that Gj lies entirely outside Bi on the side opposite opening:\n      - opening==\"bottom\": choose Gj with max_row(Gj)<bi_min_row.\n      - opening==\"top\": choose Gj with min_row(Gj)>bi_max_row.\n      - opening==\"right\": choose Gj with max_col(Gj)<bi_min_col.\n      - opening==\"left\": choose Gj with min_col(Gj)>bi_max_col.\n   d. Compute Gj bounding box: gj_min_row, gj_max_row, gj_min_col, gj_max_col; let h = gj_max_row - gj_min_row + 1; let w = gj_max_col - gj_min_col + 1.\n   e. Extract matrix S of size h×w from output at rows [gj_min_row..gj_max_row], cols [gj_min_col..gj_max_col].\n   f. In output, set all cells at rows gj_min_row..gj_max_row and cols gj_min_col..gj_max_col to 0.\n   g. Compute S_flipped by flipping S vertically: for r in [0..h-1], c in [0..w-1], S_flipped[r][c] = S[h-1-r][c].\n   h. Compute insertion top-left (dst_row,dst_col):\n      - If opening==\"bottom\": dst_row = bi_max_row + 1.\n      - If opening==\"top\":    dst_row = bi_min_row - h.\n      - If opening==\"right\":  dst_col = bi_max_col + 1.\n      - If opening==\"left\":   dst_col = bi_min_col - w.\n      - If opening is vertical (\"top\" or \"bottom\"): interior_width = bi_max_col - bi_min_col - 1; dst_col = bi_min_col + 1 + floor((interior_width - w)/2).\n      - If opening is horizontal (\"left\" or \"right\"): interior_height = bi_max_row - bi_min_row - 1; dst_row = bi_min_row + 1 + floor((interior_height - h)/2).\n   i. For each r in [0..h-1] and c in [0..w-1], set output[dst_row + r][dst_col + c] = S_flipped[r][c].\n5. Return output as the transformed grid.",
    "73251a56.json": "1. Let N be the number of rows (equal to the number of columns). 2. Create an output grid of size N×N. 3. For r from 1 to N: 4.   For c from 1 to N: 5.     If input[r][c] != 0 then 6.       output[r][c] = input[r][c] 7.     Else if input[c][r] != 0 then 8.       output[r][c] = input[c][r] 9.     Else 10.      output[r][c] = output[r-1][c-1] 11. Return the output grid.",
    "e509e548.json": "1. Identify all 4-connected components (using up/down/left/right adjacency) of cells with value 3. 2. For each component:   2.1. Compute its bounding box: min_r = minimum row index, max_r = maximum row index, min_c = minimum column index, max_c = maximum column index.   2.2. Build HRows = { r ∈ [min_r..max_r] | ∃c ∈ [min_c..max_c-1] such that both (r,c) and (r,c+1) belong to the component }.   2.3. If |HRows| ≥ 2 then:     a. Build Vfull = { c ∈ [min_c..max_c] | ∃r ∈ [min_r..max_r-1] such that both (r,c) and (r+1,c) belong to the component }.     b. If |Vfull| == 1 and the single cVert in Vfull equals min_c or equals max_c then set fill_value = 6 else set fill_value = 2.   2.4. Else (|HRows| == 1) then:     a. Let r0 = the sole element of HRows.     b. Compute Cs = { c ∈ [min_c..max_c] | (r0,c) belongs to the component }.     c. Let cL = min(Cs) and cR = max(Cs).     d. For each cX in {cL,cR}:        • upX = true if (r0-1, cX) belongs to the component (row above), else false.        • downX = true if (r0+1, cX) belongs to the component (row below), else false.     e. Let uCount = number of cX for which (upX OR downX) is true.     f. Let crossCount = number of cX for which (upX AND downX) is true.     g. If crossCount ≥ 1 then fill_value = 2 else if uCount == 1 then fill_value = 1 else fill_value = 6.   2.5. Replace every cell in the component with fill_value. 3. Leave all other cells unchanged and return the resulting grid.",
    "d22278a0.json": "1. Let M be the number of rows and N be the number of columns. 2. Identify all seed pixels: for each cell (r_s,c_s) where input[r_s][c_s]!=0 record a seed s with color col_s=input[r_s][c_s]. 3. Create an output grid of size M×N initialized to 0. 4. For each seed s do:\n   a. Determine direction vectors ext_dir=(dr_ext,dc_ext) and stripe_dir=(dr_str,dc_str) by testing borders in priority order:\n      i. If r_s==0 then stripe_dir=(1,0) and ext_dir=(0,1) if c_s< N/2 else ext_dir=(0,-1).\n     ii. Else if c_s==0 then stripe_dir=(0,1) and ext_dir=(1,0) if r_s< M/2 else ext_dir=(-1,0).\n    iii. Else if r_s==M-1 then stripe_dir=(-1,0) and ext_dir=(0,1) if c_s< N/2 else ext_dir=(0,-1).\n     iv. Else if c_s==N-1 then stripe_dir=(0,-1) and ext_dir=(1,0) if r_s< M/2 else ext_dir=(-1,0).\n   b. For offset d from 0 to max(M,N) in steps of 2 do:\n      i. Let (r0,c0)=(r_s+dr_ext*d, c_s+dc_ext*d). If (r0,c0) is outside grid break this loop.\n     ii. Let d_seed=d. For each other seed s' compute d_other=|r0-r_s'|+|c0-c_s'|; if d_seed>d_other for any s' break this loop.\n    iii. Draw the contiguous stripe: for k from 0 to d inclusive do:\n           • Let (r,c)=(r0+dr_str*k, c0+dc_str*k). If (r,c) is outside grid continue. Let D_seed=d+k and D_other=|r-r_s'|+|c-c_s'| for each s'; if D_seed≤min(D_other) then set output[r][c]=col_s.\n     iv. Draw the spaced stripe: let k=d+2; while true do:\n           • Let (r,c)=(r0+dr_str*k, c0+dc_str*k). If (r,c) is outside grid break. Compute D_seed and D_other as above; if D_seed≤min(D_other) then set output[r][c]=col_s. Then k+=2.\n5. Return the output grid as the result.",
    "ce602527.json": "1. Read the input grid of integers. 2. Determine the background color B as the value that occupies more than half of all cells. 3. Find all connected components (4-connectivity) of cells whose value C≠B. For each component, record:   a. color C   b. pixel count N   c. bounding box [min_row,max_row]×[min_col,max_col]. 4. Let the list of components be [(C1,N1), (C2,N2), (C3,N3)]. Sort their counts [N1,N2,N3] ascending and let M be the middle (median) count. 5. Identify all components whose Ni==M. If exactly one, that is the target. If two, select the one with the larger color C. 6. For the target component, extract the subgrid spanning its bounding box, preserving all original cell values. 7. Output this subgrid as the result.",
    "f8c80d96.json": "1. Let c be the unique non-zero value in the input grid.\n2. Change every 0 in the grid to 5.\n3. Identify all contiguous runs of c in the input: each run is either strictly horizontal or strictly vertical.  Record each run by its orientation, its fixed coordinate (row for horizontal, column for vertical), and its start and end indices along the run.\n4. Order these runs by following right-angle joins: begin with the longest horizontal run (call it Segment 1, orientation →), then find the vertical run that begins at its right endpoint (Segment 2, orientation ↓), then the horizontal run that begins at that endpoint going left (Segment 3, orientation ←), then the vertical run going up (Segment 4, orientation ↑).  This yields a partial spiral of four segments.\n5. Compute the spacing S between parallel runs: from the two input horizontal runs take the absolute difference of their row indices, or from the two input vertical runs take the absolute difference of their column indices (they should be equal); call this S.\n6. Continue the spiral outward by drawing the next two segments beyond the input:\n   a. Segment 5 (orientation →): from the end of Segment 4, step right by 1, then draw c every S cells (i.e. draw at offset 0, S, 2S, …) until you reach or exceed the right grid boundary.\n   b. Segment 6 (orientation ↓): from the end of Segment 5, step down by 1, then draw c every S cells until you reach or exceed the bottom boundary.\n7. Stop once you can no longer step 1 cell in the next direction without leaving the grid.\n8. Do not overwrite any existing c pixels; only write c into cells currently holding 5.\n9. Return the resulting grid.",
    "ff805c23.json": "1. Let H = number of rows in the input grid, W = number of columns.\n2. Set block_color = 1.\n3. Let S = {(r,c) | input_grid[r][c] == block_color}.\n4. Compute r_min = min{r | (r,*) in S}, r_max = max{r | (r,*) in S}, c_min = min{c | (*,c) in S}, c_max = max{c | (*,c) in S}.\n5. Assert r_max - r_min == c_max - c_min; set k = r_max - r_min + 1.\n6. If r_max + 1 < H then pattern_color = input_grid[r_max+1][c_min] else pattern_color = input_grid[r_min-1][c_min].\n7. Initialize an empty map counts from subgrid pattern to integer.\n8. For i from 0 to H - k:\n     For j from 0 to W - k:\n         Extract subgrid sub of size k×k at rows i..i+k-1 and cols j..j+k-1.\n         If no cell in sub equals block_color AND at least one cell in sub equals pattern_color:\n             Let key = tuple of k tuples, each the row of sub.\n             counts[key] = counts.get(key, 0) + 1.\n9. Let best_key be the key in counts with the maximum counts[key].\n10. Return best_key as the output grid (k rows of k integers)."
}