{
  "task_name": "6d0aefbc",
  "solution_code": "<beginning_of_code>\ndef solve(I):\n    # vertically mirror the grid by reversing the order of each row\n    x1 = [row[::-1] for row in I]\n    <end_of_step>\n    \n    # horizontally concatenate the input grid with the vertically mirrored grid by concatenating corresponding rows\n    O = [I[i] + x1[i] for i in range(len(I))]\n    <end_of_step>\n    \n    # return the output grid\n    return O\n<end_of_code>"
}
{
  "task_name": "1cf80156",
  "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Import numpy and convert input to numpy array for easier manipulation\n    import numpy as np\n    \n    I_np = np.array(I)\n    <end_of_step>\n    \n    # Find rows containing non-zero values and determine min and max of non-zero row indices\n    non_zero_rows = [i for i in range(len(I)) if any(val != 0 for val in I[i])]\n    min_row, max_row = min(non_zero_rows), max(non_zero_rows)\n    <end_of_step>\n    \n    # Find columns containing non-zero values and determine min and max of non-zero column indices\n    non_zero_cols = [j for j in range(len(I[0])) if any(I[i][j] != 0 for i in range(len(I)))]\n    min_col, max_col = min(non_zero_cols), max(non_zero_cols)\n    <end_of_step>\n    \n    # Extract smallest subgrid containing all non-zero values using numpy slicing\n    O = I_np[min_row:max_row+1, min_col:max_col+1].tolist()\n    <end_of_step>\n    \n    # Return the output subgrid\n    return O\n<end_of_code>"
}
{
  "task_name": "00d62c1b",
  "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Define helper function to find a connected component using BFS\n    def find_component(grid, start_row, start_col, visited):\n        height, width = len(grid), len(grid[0])\n        value = grid[start_row][start_col]\n        component = []\n        queue = [(start_row, start_col)]\n        \n        while queue:\n            r, c = queue.pop(0)\n            if (r < 0 or r >= height or c < 0 or c >= width or \n                visited[r][c] or grid[r][c] != value):\n                continue\n            \n            visited[r][c] = True\n            component.append((r, c))\n            \n            # Add the four adjacent neighbors (no diagonals)\n            queue.extend([(r+1, c), (r-1, c), (r, c+1), (r, c-1)])\n                \n        return value, component\n    <end_of_step>\n    \n    # Define helper function to check if a component touches the border\n    def is_border_touching(component, height, width):\n        for r, c in component:\n            if r == 0 or r == height-1 or c == 0 or c == width-1:\n                return True\n        return False\n    <end_of_step>\n    \n    # Copy the input grid and get dimensions\n    output = [row[:] for row in I]\n    height, width = len(I), len(I[0])\n    <end_of_step>\n    \n    # Initialize visited cells tracker\n    visited = [[False for _ in range(width)] for _ in range(height)]\n    <end_of_step>\n    \n    # Find all connected components in the grid\n    components = []\n    for i in range(height):\n        for j in range(width):\n            if not visited[i][j]:\n                value, component = find_component(I, i, j, visited)\n                if component:\n                    components.append((value, component))\n    <end_of_step>\n    \n    # Find all color 0 components that don't touch the border\n    non_border_components = []\n    for value, component in components:\n        if value == 0 and not is_border_touching(component, height, width):\n            non_border_components.append(component)\n    <end_of_step>\n    \n    # Fill all cells in non-border components with value 4\n    for component in non_border_components:\n        for r, c in component:\n            output[r][c] = 4\n    <end_of_step>\n    \n    # Return the transformed grid\n    return output\n<end_of_code>"
}
