{"task_name": "06df4c85", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Import numpys, convert input list to NumPy array and get dimensions\n    import numpy as np\n\n    I_np = np.array(I)\n    h, w = I_np.shape\n    <end_of_step>\n\n    # Find rows/columns consisting of a single color value\n    # These indices identify potential divider lines/columns\n    row_indices = tuple(i for i, r in enumerate(I_np) if len(np.unique(r)) == 1)\n    column_indices = tuple(j for j, c in enumerate(I_np.T) if len(np.unique(c)) == 1)\n    row_indices_set = set(row_indices) # Use sets for faster lookups\n    column_indices_set = set(column_indices)\n    <end_of_step>\n\n    # Define the segmentation boundaries including grid edges, remove duplicates/zero-size segments\n    # These boundaries define the blocks BETWEEN or including the dividers\n    rows = sorted(list(set([0] + list(row_indices) + [h])))\n    cols = sorted(list(set([0] + list(column_indices) + [w])))\n    rows = [r for i, r in enumerate(rows) if i == 0 or r > rows[i-1]]\n    cols = [c for i, c in enumerate(cols) if i == 0 or c > cols[i-1]]\n    <end_of_step>\n\n    # Perform segmentation: Create a segmented grid representing the color of each 'inside' piece\n    seg_h = len(rows) - 1\n    seg_w = len(cols) - 1\n    <end_of_step>\n\n    segmented_grid_np = np.zeros((seg_h, seg_w), dtype=int)\n    for r_idx in range(seg_h):\n        for c_idx in range(seg_w):\n            r1, r2 = rows[r_idx], rows[r_idx+1]\n            c1, c2 = cols[c_idx], cols[c_idx+1]\n\n            # Calculate boundaries for the strict subgrid (excluding dividers)\n            r1_strict = r1 + 1 if r1 in row_indices_set else r1\n            c1_strict = c1 + 1 if c1 in column_indices_set else c1\n\n            # Strict subgrid exists, guaranteed to have one color. Get it.\n            color = I_np[r1_strict, c1_strict]\n            segmented_grid_np[r_idx, c_idx] = color\n    <end_of_step>\n\n    # Apply color filling logic to the segmented grid representing 'inside' colors\n    output_segmented_grid = segmented_grid_np.copy()\n    for r in range(seg_h):\n        for c in range(seg_w):\n            current_color = segmented_grid_np[r, c]\n            if current_color == 0:\n                continue # Skip background\n            <end_of_step>\n\n\n            # Scan right on the segmented grid\n            for c_scan in range(c + 1, seg_w):\n                scan_color = segmented_grid_np[r, c_scan]\n                if scan_color == 0:\n                    continue\n                elif scan_color == current_color:\n                    # Fill the 'output' segmented grid (represents final 'inside' colors)\n                    output_segmented_grid[r, c + 1 : c_scan] = current_color\n                    break\n                else:\n                    break # Different color blocks path\n            <end_of_step>\n\n            # Scan down on the segmented grid\n            for r_scan in range(r + 1, seg_h):\n                scan_color = segmented_grid_np[r_scan, c]\n                if scan_color == 0:\n                    continue\n                elif scan_color == current_color:\n                     # Fill the 'output' segmented grid\n                    output_segmented_grid[r + 1 : r_scan, c] = current_color\n                    break\n                else:\n                    break # Different color blocks path\n    <end_of_step>\n\n    # Reconstruct the final grid, preserving original divider lines\n    O_np = np.zeros_like(I_np) # Start with an empty grid\n    <end_of_step>\n\n    # Pre-calculate segment indices for each cell to avoid repeated searches\n    # Create coordinate grids\n    jj, ii = np.meshgrid(np.arange(w), np.arange(h))\n    <end_of_step>\n\n    # Find segment indices for all cells using searchsorted\n    # 'right' means index `k` where `a[k-1] < v <= a[k]` -> subtract 1 for 0-based index\n    # Need to handle edge case where i/j is exactly h/w (won't happen for valid indices)\n    r_indices = np.searchsorted(rows, ii, side='right') - 1\n    c_indices = np.searchsorted(cols, jj, side='right') - 1\n    <end_of_step>\n\n    # Ensure indices are within bounds of the segmented grid\n    r_indices = np.clip(r_indices, 0, seg_h - 1)\n    c_indices = np.clip(c_indices, 0, seg_w - 1)\n    <end_of_step>\n\n    # Get the final color for each cell based on its segment's final color\n    final_colors = output_segmented_grid[r_indices, c_indices]\n    <end_of_step>\n\n    # Create boolean masks for divider cells using the pre-calculated sets\n    is_divider_row = np.isin(ii, list(row_indices_set)) # isin needs list/array\n    is_divider_col = np.isin(jj, list(column_indices_set))\n    is_divider = is_divider_row | is_divider_col\n    <end_of_step>\n\n    # Fill the output grid: Use original color for dividers, final segment color otherwise\n    O_np = np.where(is_divider, I_np, final_colors)\n    <end_of_step>\n\n    # Convert the final NumPy grid back to a list of lists and return\n    return O_np.tolist()\n<end_of_code>"}
{"task_name": "3e980e27", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Import numpy and convert the input grid to a NumPy array.\n    import numpy as np\n\n    I_np = np.array(I)\n    <end_of_step>\n\n    # calculate the background color, in this case the most common color\n    colors, counts = np.unique(I_np, return_counts=True)\n    background_color = max(zip(counts, colors), key=lambda x: x[0])[1]\n    <end_of_step>\n\n    # find all non-background objects\n    # that is in this case 8-connected components of non-background colors\n    # the objects are stored in a list and each object is a list of tuples\n    # where each tuple is a (color, (row, column)) pair\n    objects = []\n    visited = np.zeros_like(I_np, dtype=bool)\n    height, width = I_np.shape\n\n    for r in range(height):\n        for c in range(width):\n            if not visited[r, c] and I_np[r, c] != background_color:\n                obj = []\n                q = [(r, c)]\n                visited[r, c] = True\n\n                while q:\n                    cr, cc = q.pop(0)\n                    obj.append((I_np[cr, cc], (cr, cc)))\n\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if (dr == 0 and dc == 0) or (not (0 <= cr + dr < height and 0 <= cc + dc < width)):\n                                continue\n                            if not visited[cr + dr, cc + dc] and I_np[cr + dr, cc + dc] != background_color:\n                                visited[cr + dr, cc + dc] = True\n                                q.append((cr + dr, cc + dc))\n\n                objects.append(obj)\n    <end_of_step>\n\n    # extract single cell objects and partition them by color\n    two_single_cells = [obj[0] for obj in objects if len(obj) == 1 and obj[0][0] == 2]\n    three_single_cells = [obj[0] for obj in objects if len(obj) == 1 and obj[0][0] == 3]\n    <end_of_step>\n\n    # extract the up to two objects with more than one cell and partition them by color\n    # set the object to None if there are no objects of that color\n    two_template_objects = [obj for obj in objects if len(obj) > 1 and 2 in [cell[0] for cell in obj]]\n    three_template_objects = [obj for obj in objects if len(obj) > 1 and 3 in [cell[0] for cell in obj]]\n\n    two_template_object = two_template_objects[0] if two_template_objects else None\n    three_template_object = three_template_objects[0] if three_template_objects else None\n    <end_of_step>\n\n    # horizontally flip the two_template_object around it's 2 cell if it exists\n    two_template_two_cell = None\n    flipped_two_template_object = None\n    if two_template_object is not None:\n        two_template_two_cell = [cell for cell in two_template_object if cell[0] == 2][0]\n        flipped_two_template_object = [two_template_two_cell]\n        for cell in two_template_object:\n            if cell != two_template_two_cell:\n                relative_x = cell[1][1] - two_template_two_cell[1][1]\n                flipped_cell= (cell[0], (cell[1][0], two_template_two_cell[1][1] - relative_x))\n                flipped_two_template_object.append(flipped_cell)\n    <end_of_step>\n\n    # extract the three template three cell\n    three_template_three_cell = None\n    if three_template_object is not None:\n        three_template_three_cell = [cell for cell in three_template_object if cell[0] == 3][0]\n    <end_of_step>\n\n    # calculate the offsets of the single sells to their corresponding template\n    # this is done while making sure that the template is not None\n    two_offsets = []\n    if two_template_two_cell is not None:\n        for cell in two_single_cells:\n            two_offsets.append((cell[1][0] - two_template_two_cell[1][0], cell[1][1] - two_template_two_cell[1][1]))\n\n    three_offsets = []\n    if three_template_three_cell is not None:\n        for cell in three_single_cells:\n            three_offsets.append((cell[1][0] - three_template_three_cell[1][0], cell[1][1] - three_template_three_cell[1][1]))\n    <end_of_step>\n\n    # calculate the set that needs to be drawn for the two and three cells\n    cells_to_draw = []\n    if flipped_two_template_object is not None:\n        cells_to_draw.extend(two_template_object)\n        for offset in two_offsets:\n            cells_to_draw.extend([(cell[0], (cell[1][0] + offset[0], cell[1][1] + offset[1])) for cell in flipped_two_template_object])\n\n    if three_template_object is not None:\n        cells_to_draw.extend(three_template_object)\n        for offset in three_offsets:\n            cells_to_draw.extend([(cell[0], (cell[1][0] + offset[0], cell[1][1] + offset[1])) for cell in three_template_object])\n    <end_of_step>\n\n    # draw the cells on an \"empty\" grid i.e. a grid filled with the background color\n    O_np = I_np.copy()\n    O_np.fill(background_color)\n\n    for cell in cells_to_draw:\n        O_np[cell[1]] = cell[0]\n    <end_of_step>\n\n    # convert the output grid back to a list of lists and return it\n    return O_np.tolist()\n<end_of_code>"}
{"task_name": "1f0c79e5", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Import numpy and convert the input grid to a NumPy array and extract shape\n    import numpy as np\n\n    grid = np.array(I)\n    rows, cols = grid.shape\n    <end_of_step>\n\n    # Identify all coordinates containing the special marker (color 2).\n    # These cells will be used later to determine the transformation.\n    special_coords_arr = np.argwhere(grid == 2)\n    special_coords = {tuple(coord) for coord in special_coords_arr}\n    <end_of_step>\n\n    # Create a temporary grid by replacing all occurrences of color 2 with 0.\n    # This helps in analyzing the remaining colors in the grid.\n    temp_grid = grid.copy()\n    temp_grid[temp_grid == 2] = 0\n    <end_of_step>\n\n    # Import Counter from collections\n    # Find the pattern color.\n    # Count all colors in the modified grid and pick the least frequent color.\n    from collections import Counter\n\n    color_counts = Counter(temp_grid.flatten())\n    pattern_color = color_counts.most_common()[-1][0]\n    <end_of_step>\n\n    # Determine the pattern shape.\n    # This shape is the union of:\n    #   - The cells originally marked with color 2.\n    #   - The cells that have the pattern color.\n    pattern_coords_arr = np.argwhere(temp_grid == pattern_color)\n    pattern_coords = {tuple(coord) for coord in pattern_coords_arr}\n    union_shape = special_coords.union(pattern_coords)\n    <end_of_step>\n\n    # Find the top-left corner of the union shape.\n    # This is used to normalize the shape coordinates.\n    union_list = list(union_shape)\n    min_row, min_col = np.min(union_list, axis=0)\n    <end_of_step>\n\n    # Normalize the special marker coordinates.\n    # Adjust them so that the top-left of the union shape becomes (0, 0).\n    normalized_special = {(r - min_row, c - min_col) for r, c in special_coords}\n    <end_of_step>\n\n    # Apply the transformation function f(x) = 2*x - 1 to the normalized special coordinates.\n    # This transformation will guide the direction and magnitude of shifts.\n    transformed_special = {(2 * r - 1, 2 * c - 1) for r, c in normalized_special}\n    <end_of_step>\n\n    # Generate shift offsets.\n    # For each transformed coordinate and for each multiplier (from 0 up to max(grid dimension)),\n    # compute an offset vector by scaling the transformed coordinate.\n    offsets = set()\n    for dr, dc in transformed_special:\n        for k in range(max(rows, cols)):\n            offsets.add((dr * k, dc * k))\n    <end_of_step>\n\n    # Generate the final set of pixels to paint.\n    # Shift the entire union shape by every calculated offset.\n    # In cases of overlapping pixels, the \"pattern_color\" will be used.\n    painted_pixels = {}\n    for r, c in union_shape:\n        for off_r, off_c in offsets:\n            new_r = r + off_r\n            new_c = c + off_c\n            painted_pixels[(new_r, new_c)] = pattern_color\n    <end_of_step>\n\n    # Overlay the painted pixels onto a copy of the original grid.\n    # Only update pixels that fall within the grid boundaries.\n    output_grid = grid.copy()\n    for (r, c), color in painted_pixels.items():\n        if 0 <= r < rows and 0 <= c < cols:\n            output_grid[r, c] = color\n    <end_of_step>\n\n    # Convert the NumPy output grid back to a list of lists and return the result.\n    return output_grid.tolist()\n<end_of_code>"}
{"task_name": "8f2ea7aa", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # The background color is black and calculate number of rows and columns\n    bg_color = 0\n    <end_of_step>\n\n    # The foreground consists of a single object, thus all non-zero cells are one object\n    foreground_pixels = [(r, c) for r, row in enumerate(I) for c, val in enumerate(row) if val != bg_color]\n    <end_of_step>\n\n    # Convert the input grid (list of lists) to a NumPy array for efficient processing.\n    import numpy as np\n\n    I_np = np.array(I)\n    <end_of_step>\n\n\n    # Determine the minimum bounding box that encloses all identified foreground pixels.\n    # Extract the row and column coordinates.\n    rows, cols = zip(*foreground_pixels)\n    # Find the minimum and maximum row and column indices.\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    <end_of_step>\n\n    # Extract the smallest rectangular subgrid from the original input array that contains all foreground pixels.\n    x_sub = I_np[min_row: max_row + 1, min_col: max_col + 1]\n    <end_of_step>\n\n    # Upscale the extracted subgrid so that its dimensions match the original grid.\n    # np.kron uses the Kronecker product: each element of x_sub is replaced by a block of size factor x factor.\n    # The scaling factor is determined by dividing the original grid size by the subgrid's height under the observed fact that the object's bounding box is always quadratic.\n    factor = len(I) // (max_row - min_row + 1)\n    x_upscaled = np.kron(x_sub, np.ones((factor, factor), dtype=int))\n    <end_of_step>\n\n    # Create a tiling of the extracted subgrid by repeating it 'factor' times in both dimensions.\n    x_tiled = np.tile(x_sub, (factor, factor))\n    <end_of_step>\n\n    # Perform a cell-wise comparison between the upscaled grid (x_upscaled) and the tiled grid (x_tiled).\n    # If the values at a given position are the same in both grids, retain that value.\n    # Otherwise, set the value the background color.\n    O_np = np.where(x_upscaled == x_tiled, x_upscaled, bg_color)\n    <end_of_step>\n\n    # Convert the final resulting NumPy array back into the required format (list of lists).\n    O = O_np.tolist()\n    <end_of_step>\n\n    # Return the final computed grid.\n    return O\n<end_of_code>"}
{"task_name": "9aec4887", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Compute the Manhattan distance between two points.\n    # This is the sum of the absolute differences of their row and column indices.\n    def manhattan_distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n    <end_of_step>\n\n    # Compute the bounding box for a set of coordinates.\n    # Returns the minimum row, minimum column, maximum row, and maximum column.\n    def get_bounding_box(coords):\n        if not coords:\n            return None, None, None, None\n        min_r = min(r for r, c in coords)\n        max_r = max(r for r, c in coords)\n        min_c = min(c for r, c in coords)\n        max_c = max(c for r, c in coords)\n        return min_r, min_c, max_r, max_c\n    <end_of_step>\n\n    # Generate a set of points connecting two given points.\n    # This function handles horizontal, vertical, diagonal (slope 1), and anti-diagonal (slope -1) lines.\n    def connect_points(p1, p2):\n        r1, c1 = p1\n        r2, c2 = p2\n        points = set()\n\n        # Draw a horizontal line if the rows are the same.\n        if r1 == r2:\n            for c in range(min(c1, c2), max(c1, c2) + 1):\n                points.add((r1, c))\n        # Draw a vertical line if the columns are the same.\n        elif c1 == c2:\n            for r in range(min(r1, r2), max(r1, r2) + 1):\n                points.add((r, c1))\n        # Draw a diagonal line with a slope of 1.\n        elif abs(r1 - r2) == abs(c1 - c2) and (r1 - r2) * (c1 - c2) > 0:\n            dr = 1 if r2 > r1 else -1\n            dc = 1 if c2 > c1 else -1\n            curr_r, curr_c = r1, c1\n            while True:\n                points.add((curr_r, curr_c))\n                if curr_r == r2 and curr_c == c2:\n                    break\n                curr_r += dr\n                curr_c += dc\n        # Draw an anti-diagonal line with a slope of -1.\n        elif abs(r1 - r2) == abs(c1 - c2) and (r1 - r2) * (c1 - c2) < 0:\n            dr = 1 if r2 > r1 else -1\n            dc = -1 if c2 < c1 else 1\n            curr_r, curr_c = r1, c1\n            while True:\n                points.add((curr_r, curr_c))\n                if curr_r == r2 and curr_c == c2:\n                    break\n                curr_r += dr\n                curr_c += dc\n\n        return points\n    <end_of_step>\n\n    # Convert the input grid to a NumPy array and find connected objects.\n    # The algorithm uses an 8-connected flood fill (including diagonal neighbors) to identify objects.\n    # Background is defined as the most frequent color in the grid.\n    import numpy as np\n    from collections import deque\n\n    I_np = np.array(I, dtype=int)\n    height, width = I_np.shape\n    visited = np.zeros_like(I_np, dtype=bool)\n\n    # Determine the background color by finding the most frequent color.\n    colors, counts = np.unique(I_np, return_counts=True)\n    bg_color = colors[np.argmax(counts)]\n\n    objects_found = []\n    for r in range(height):\n        for c in range(width):\n            if not visited[r, c] and I_np[r, c] != bg_color:\n                obj_coords = set()\n                obj_colors = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n\n                # Use breadth-first search to collect all connected cells that are not the background.\n                while q:\n                    row, col = q.popleft()\n                    color = I_np[row, col]\n                    # Skip background cells just in case they are encountered.\n                    if color == bg_color:\n                        continue\n\n                    obj_coords.add((row, col))\n                    obj_colors.add(color)\n\n                    # Explore all 8 neighbors (including diagonals).\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if dr == 0 and dc == 0:\n                                continue\n                            nr, nc = row + dr, col + dc\n                            if 0 <= nr < height and 0 <= nc < width and not visited[nr, nc]:\n                                if I_np[nr, nc] != bg_color:\n                                    visited[nr, nc] = True\n                                    q.append((nr, nc))\n\n                if obj_coords:\n                    objects_found.append((obj_coords, obj_colors))\n    <end_of_step>\n\n    # Designate one object as the source (with fewer distinct colors) and the other as the target.\n    obj1_coords, obj1_colors = objects_found[0]\n    obj2_coords, obj2_colors = objects_found[1]\n\n    if len(obj1_colors) < len(obj2_colors):\n        source_obj_coords = obj1_coords  # Object with fewer colors becomes the source.\n        target_obj_coords = obj2_coords  # The other object becomes the target.\n    else:\n        source_obj_coords = obj2_coords\n        target_obj_coords = obj1_coords\n    <end_of_step>\n\n    min_r_t, min_c_t, max_r_t, max_c_t = get_bounding_box(target_obj_coords)\n    # Use slicing to extract the subgrid (note that the slice is inclusive of the maximum index).\n    output_grid_np = I_np[min_r_t:max_r_t + 1, min_c_t:max_c_t + 1].copy()\n    <end_of_step>\n\n    min_r_s, min_c_s, _, _ = get_bounding_box(source_obj_coords)\n    normalized_source_coords = set((r - min_r_s, c - min_c_s) for r, c in source_obj_coords)\n    shifted_source_coords = set((r + 1, c + 1) for r, c in normalized_source_coords)\n    <end_of_step>\n\n    # Create a normalized representation of the target object.\n    # Each coordinate is normalized relative to the top-left corner of its bounding box,\n    # and its original color is preserved.\n    normalized_target_obj = {}  # Mapping: normalized coordinate -> original color.\n    for r, c in target_obj_coords:\n        norm_r, norm_c = r - min_r_t, c - min_c_t\n        normalized_target_obj[(norm_r, norm_c)] = I_np[r, c]\n    <end_of_step>\n\n    # For each shifted source coordinate, choose a color based on the nearest point in the normalized target object.\n    # The nearest point is determined using Manhattan distance.\n    object_to_paint = set()  # Set of tuples: (color, (relative_row, relative_col)).\n    target_norm_coords_list = list(normalized_target_obj.keys())\n\n    for rel_r, rel_c in shifted_source_coords:\n        min_dist = float('inf')\n        closest_target_norm_coord = None\n        # Determine the closest normalized target coordinate.\n        for target_norm_coord in target_norm_coords_list:\n            dist = manhattan_distance((rel_r, rel_c), target_norm_coord)\n            if dist < min_dist:\n                min_dist = dist\n                closest_target_norm_coord = target_norm_coord\n        # Retrieve the color from the target based on the nearest coordinate.\n        closest_color = normalized_target_obj[closest_target_norm_coord]\n        object_to_paint.add((closest_color, (rel_r, rel_c)))\n    <end_of_step>\n\n    # Overlay the new object onto the target subgrid canvas.\n    # For each point in the object to paint, update the subgrid with the corresponding color.\n    output_h, output_w = output_grid_np.shape\n    for color, (r, c) in object_to_paint:\n        if 0 <= r < output_h and 0 <= c < output_w:\n            output_grid_np[r, c] = color\n    <end_of_step>\n\n    # Compute the intersection points between the source object's diagonal structure and itself.\n    # First, obtain the bounding box of the shifted source coordinates.\n    # Then, form two diagonal lines by connecting opposite corners of the bounding box.\n    # Finally, take the intersection of these diagonal lines with the shifted source coordinates.\n    min_r_s_shifted, min_c_s_shifted, max_r_s_shifted, max_c_s_shifted = get_bounding_box(shifted_source_coords)\n    # Define the four corners of the bounding box.\n    ul = (min_r_s_shifted, min_c_s_shifted)\n    lr = (max_r_s_shifted, max_c_s_shifted)\n    ur = (min_r_s_shifted, max_c_s_shifted)\n    ll = (max_r_s_shifted, min_c_s_shifted)\n    # Form the main diagonal (from upper-left to lower-right).\n    main_diagonal = connect_points(ul, lr)\n    # Form the anti-diagonal (from upper-right to lower-left).\n    anti_diagonal = connect_points(ur, ll)\n    # Combine both diagonals to form an 'X' shape.\n    x_shape_coords = main_diagonal.union(anti_diagonal)\n    # Keep only those points that are part of the original shifted source coordinates.\n    intersection_coords_rel = shifted_source_coords.intersection(x_shape_coords)\n    <end_of_step>\n\n    # Fill the computed intersection points with a fixed color (8) on the output grid.\n    # The coordinates for these points are relative to the target subgrid.\n    fill_color = 8\n    for r, c in intersection_coords_rel:\n        if 0 <= r < output_h and 0 <= c < output_w:\n            output_grid_np[r, c] = fill_color\n    <end_of_step>\n\n    # Convert the final output grid (a NumPy array) to a list of lists and return it.\n    return output_grid_np.tolist()\n<end_of_code>"}
{"task_name": "5c2c9af4", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Helper function: Determine the least common color in the grid.\n    # This function flattens the grid using numpy and counts the occurrences of each color.\n    import numpy as np\n    from collections import Counter\n\n    def find_least_common_color(grid):\n        return Counter(np.array(grid).flatten()).most_common()[-1][0]\n    <end_of_step>\n\n    # Helper function: Compute the outline of a bounding box defined by two corner points.\n    # It calculates the min and max for rows and columns and then collects the border points.\n    def get_box_outline(p1, p2):\n        r1, c1 = p1; r2, c2 = p2\n        min_r, max_r = min(r1, r2), max(r1, r2)\n        min_c, max_c = min(c1, c2), max(c1, c2)\n        # Collect points on the top and bottom edges\n        outline = {(min_r, c) for c in range(min_c, max_c + 1)} | {(max_r, c) for c in range(min_c, max_c + 1)}\n        # Collect points on the left and right edges (excluding the already added corners)\n        outline |= {(r, min_c) for r in range(min_r + 1, max_r)} | {(r, max_c) for r in range(min_r + 1, max_r)}\n        return outline\n    <end_of_step>\n\n    # Determine the least common color in the input grid.\n    least_color = find_least_common_color(I)\n    <end_of_step>\n\n    # Collect coordinates of all cells that have the least common color.\n    coords = [(r, c) for r, row in enumerate(I) for c, val in enumerate(row) if val == least_color]\n    <end_of_step>\n\n    # Compute the bounding box of the collected coordinates and determine the center.\n    min_r = min(r for r, c in coords)\n    max_r = max(r for r, c in coords)\n    min_c = min(c for r, c in coords)\n    max_c = max(c for r, c in coords)\n    center = (min_r + (max_r - min_r) // 2, min_c + (max_c - min_c) // 2)\n    <end_of_step>\n\n    # Identify the upper-left corner of the bounding box.\n    ul_corner = (min_r, min_c)\n    <end_of_step>\n\n    # Compute the offset vector from the upper-left corner to the center.\n    offset = (center[0] - ul_corner[0], center[1] - ul_corner[1])\n    <end_of_step>\n\n    # Generate pairs of scaled offset vectors using factors from 0 to max grid dimension to ensure the whole grid is filled correctly.\n    # Each pair consists of the offset scaled by i and its negative counterpart.\n    offset_pairs = [((offset[0] * i, offset[1] * i), (-offset[0] * i, -offset[1] * i)) for i in range(max(len(I), len(I[0])) + 1)]\n    <end_of_step>\n\n    # For each pair, compute the box outline and combine all outline points.\n    outline_points = set()\n    for p1, p2 in offset_pairs:\n        outline_points |= get_box_outline(p1, p2)\n    <end_of_step>\n\n    # Shift all the collected outline points by the center coordinate.\n    shifted = {(r + center[0], c + center[1]) for r, c in outline_points}\n    <end_of_step>\n\n    # Create a copy of the input grid and fill in the shifted outline points with the least common color.\n    O = [row[:] for row in I]\n    H, W = len(O), len(O[0])\n\n    for r, c in shifted:\n        if 0 <= r < H and 0 <= c < W:\n            O[r][c] = least_color\n\n    return O\n<end_of_code>"}
{"task_name": "045e512c", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Get grid dimensions.\n    height = len(I)\n    width = len(I[0])\n    <end_of_step>\n\n    # Helper: Determine the background color as the most frequent value in the grid.\n    from collections import Counter\n\n    def find_background_color(grid):\n        counts = Counter(val for row in grid for val in row)\n        return counts.most_common(1)[0][0]\n    <end_of_step>\n\n    # Define 8-connected directions for flood-fill.\n    eight_connected = [(0, 1), (0, -1), (1, 0), (-1, 0),\n                       (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    <end_of_step>\n\n    # Helper: Find connected components (objects) in the grid using BFS.\n    # In this case, the object must only be 8-connected and all cells in an object must have the same color\n    # This function returns a list of \"objects\" which are dictionaries of {'color': int, 'indices': frozenset[(int, int)]}\n    def find_objects(grid):\n        h, w = len(grid), len(grid[0])\n        visited = [[False]*w for _ in range(h)]\n        bg = find_background_color(grid)\n        objects = []\n        for r in range(h):\n            for c in range(w):\n                if not visited[r][c] and grid[r][c] != bg:\n                    color = grid[r][c]\n                    comp = set()\n                    queue = [(r, c)]\n                    visited[r][c] = True\n                    while queue:\n                        cr, cc = queue.pop(0)\n                        comp.add((cr, cc))\n                        for dr, dc in eight_connected:\n                            nr, nc = cr + dr, cc + dc\n                            if 0 <= nr < h and 0 <= nc < w and not visited[nr][nc] and grid[nr][nc] == color:\n                                visited[nr][nc] = True\n                                queue.append((nr, nc))\n                    objects.append({'color': color, 'indices': frozenset(comp)})\n        return objects\n    <end_of_step>\n\n    # Helper: Compute the center (integer division) of a set of indices.\n    def get_center(indices):\n        sr = sum(r for r, _ in indices)\n        sc = sum(c for _, c in indices)\n        n = len(indices)\n        return (sr // n, sc // n)\n    <end_of_step>\n\n    # Helper: Shift a set of indices by a given offset.\n    def shift_indices(indices, offset):\n        dr, dc = offset\n        return frozenset((r + dr, c + dc) for r, c in indices)\n    <end_of_step>\n\n    # Helper: Compute the bounding box of indices (min_row, max_row, min_col, max_col).\n    def get_bounding_box(indices):\n        rows = [r for r, _ in indices]\n        cols = [c for _, c in indices]\n        return min(rows), max(rows), min(cols), max(cols)\n    <end_of_step>\n\n    # Find all objects in the grid.\n    objects = find_objects(I)\n    <end_of_step>\n\n    # Identify the main object (largest by cell count) and its bounding box.\n    main_obj = max(objects, key=lambda obj: len(obj['indices']))\n    main_indices = main_obj['indices']\n    main_center = get_center(main_indices)\n    L_rmin, L_rmax, L_cmin, L_cmax = get_bounding_box(main_indices)\n    <end_of_step>\n\n    # All other objects (which will drive replication).\n    smaller_objs = [obj for obj in objects if obj['indices'] != main_indices]\n    <end_of_step>\n\n    # Set to collect all new cells to paint: each as (color, (row, col)).\n    final_cells = set()\n    <end_of_step>\n\n    # Process each small object.\n    for obj in smaller_objs:\n        obj_indices = obj['indices']\n        obj_color = obj['color']\n        obj_center = get_center(obj_indices)\n        <end_of_step>\n\n        # Compute the bounding box of the small object.\n        S_rmin, S_rmax, S_cmin, S_cmax = get_bounding_box(obj_indices)\n        # For the main object (with bounding box L), a valid translation T must satisfy:\n        #     L_rmin + T_r <= S_rmin   and   L_rmax + T_r >= S_rmax,\n        #     L_cmin + T_c <= S_cmin   and   L_cmax + T_c >= S_cmax.\n        # This yields valid T ranges:\n        valid_T_r_low = S_rmax - L_rmax\n        valid_T_r_high = S_rmin - L_rmin\n        valid_T_c_low = S_cmax - L_cmax\n        valid_T_c_high = S_cmin - L_cmin\n        <end_of_step>\n\n\n        # Choose T based on the relative centers of the small and main objects.\n        d_r = obj_center[0] - main_center[0]\n        d_c = obj_center[1] - main_center[1]\n        T_r = valid_T_r_high if d_r > 0 else (valid_T_r_low if d_r < 0 else 0)\n        T_c = valid_T_c_high if d_c > 0 else (valid_T_c_low if d_c < 0 else 0)\n        <end_of_step>\n        \n\n        # Replicate the main object along multiples of T until it falls completely off-grid.\n        k = 1\n        while True:\n            offset = (k * T_r, k * T_c)\n            shifted = shift_indices(main_indices, offset)\n            # Stop if none of the shifted cells are within the grid.\n            if not any(0 <= r < height and 0 <= c < width for r, c in shifted):\n                break\n            # Paint all cells of this copy with the small object's color.\n            final_cells.update({(obj_color, (r, c)) for r, c in shifted})\n            k += 1\n    <end_of_step>\n\n    # Create the output grid by overlaying the new cells onto a copy of the input.\n    O = I\n    for color, (r, c) in final_cells:\n        if 0 <= r < height and 0 <= c < width:\n            O[r][c] = color\n    <end_of_step>\n\n    return O\n<end_of_code>"}
{"task_name": "08ed6ac7", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # find the most frequent value in the input grid\n    from collections import Counter\n\n    most_common_value = Counter(cell for row in I for cell in row).most_common(1)[0][0]\n    <end_of_step>\n\n    # helper function to find all non-background objects\n    def find_objects(grid, background_value):\n        height, width = len(grid), len(grid[0])\n        visited = [[False] * width for _ in range(height)]\n        objects = []\n\n        for r in range(height):\n            for c in range(width):\n                if not visited[r][c] and grid[r][c] != background_value:\n                    obj = []\n                    queue = [(r, c)]\n                    visited[r][c] = True\n\n                    while queue:\n                        cr, cc = queue.pop(0)\n                        obj.append((cr, cc))\n\n                        for dr in [-1, 0, 1]:\n                            for dc in [-1, 0, 1]:\n                                if (dr == 0 and dc == 0) or not (0 <= cr + dr < height and 0 <= cc + dc < width):\n                                    continue\n                                if not visited[cr + dr][cc + dc] and grid[cr + dr][cc + dc] != background_value:\n                                    visited[cr + dr][cc + dc] = True\n                                    queue.append((cr + dr, cc + dc))\n\n                    objects.append(obj)\n\n        return objects\n\n    objs = find_objects(I, most_common_value)\n    <end_of_step>\n\n    # the colors used to color the objects based on their relative cell counts (sizes)\n    # the first color belongs to the smallest object and the last color belongs to the largest object\n    colors = [4, 3, 2, 1]\n    <end_of_step>\n\n    # sort the objects by size\n    objs.sort(key=len)\n    <end_of_step>\n\n    # copy the input grid and color the objects based on their size\n    O = [[most_common_value] * len(row) for row in I]\n\n    for i, obj in enumerate(objs):\n        color = colors[i]\n        for r, c in obj:\n            O[r][c] = color\n    <end_of_step>\n\n    # return the output grid\n    return O\n<end_of_code>"}
{"task_name": "e3497940", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Import numpy and convert the input tuple of tuples to a NumPy array for efficient slicing and manipulation.\n    import numpy as np\n\n    I_np = np.array(I)\n    height, width = I_np.shape\n    <end_of_step>\n\n    # The line of 5s in the middle is a delimiter, splitting the grid down the middle.\n    # Calculate the midpoint column index for splitting the grid.\n    mid_col = width // 2\n    <end_of_step>\n\n    # Extract the left half of the grid (all rows, columns 0 up to mid_col).\n    left_half = I_np[:, :mid_col].copy()  # Copy to avoid modifying original data.\n    <end_of_step>\n\n    # Extract the right half of the grid (all rows, columns from mid_col to the end).\n    right_half = I_np[:, mid_col+1:]\n    <end_of_step>\n\n    # Mirror the right half horizontally (flip left-to-right).\n    mirrored_right = np.fliplr(right_half)\n    <end_of_step>\n\n    # The background color is zero.\n    bg_color = 0\n    <end_of_step>\n\n    # Overlay the mirrored right half onto the left half.\n    # For each cell in the left half: if its value equals the background color, replace it with the corresponding cell from the mirrored right half.\n    # This ensures that if one side is background and the other is non-background, the non-background value is chosen.\n    O_np = np.where(left_half == bg_color, mirrored_right, left_half)\n    <end_of_step>\n\n    # Convert the final NumPy array back to a list of lists format and return.\n    return O_np.tolist()\n<end_of_code>"}
{"task_name": "e26a3af2", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # determine whether the stripes in the input grid are horizontal or vertical\n    # because of the noise, we simply check the sum of the most frequent value count in the rows vs the columns\n    from collections import Counter\n\n    row_sum = sum(Counter(row).most_common(1)[0][1] for row in I)\n    col_sum = sum(Counter(col).most_common(1)[0][1] for col in zip(*I))\n    <end_of_step>\n\n    # if the sum of the most frequent value in the rows is greater than the sum of the most frequent value in the columns\n    # then the stripes are horizontal\n    if row_sum < col_sum:\n        # transpose the input grid\n        I = [list(row) for row in zip(*I)]\n    <end_of_step>\n\n    # now we can simply check the most frequent value in the rows\n    O = [[max(set(row), key=row.count)] * len(row) for row in I]\n    <end_of_step>\n\n    # if the stripes were vertical, we need to transpose the output grid back\n    if row_sum < col_sum:\n        O = [list(row) for row in zip(*O)]\n    <end_of_step>\n\n    # return the output grid\n    return O\n<end_of_code>"}
{"task_name": "72ca375d", "solution_code": "<beginning_of_code>\ndef solve(I_np):\n    # Import numpy and Counter from collections and convert I to a NumPy array\n    import numpy as np\n    from collections import Counter\n\n    I_np = np.array(I_np, dtype=int)\n\n    most_common_value = Counter(I_np.flatten()).most_common(1)[0][0]\n    <end_of_step>\n\n    # helper function to find all non-background objects\n    # objects is a list containing the objects\n    # each object is a tuple (color, [(row, column), ...])\n    def find_objects(grid, background_value):\n        h, w = grid.shape\n        visited = np.zeros_like(grid, dtype=bool)\n        objects = []\n\n        for r in range(h):\n            for c in range(w):\n                # Check if the cell is not visited and not the background color\n                if not visited[r, c] and grid[r, c] != background_value:\n                    obj_coords = []\n                    queue = [(r, c)]\n                    visited[r, c] = True\n                    color = grid[r, c]  # Get the color of the current object\n\n                    while queue:\n                        cr, cc = queue.pop(0)\n                        obj_coords.append((cr, cc))\n                        <end_of_step>\n\n                        # Explore neighbors (including diagonals)\n                        for dr in [-1, 0, 1]:\n                            for dc in [-1, 0, 1]:\n                                # Skip the center cell itself\n                                if dr == 0 and dc == 0:\n                                    continue\n\n                                nr, nc = cr + dr, cc + dc\n\n                                # Check bounds\n                                if 0 <= nr < h and 0 <= nc < w:\n                                    # Check if the neighbor is part of the same object (same color) and not visited\n                                    if not visited[nr, nc] and grid[nr, nc] == color:\n                                        visited[nr, nc] = True\n                                        queue.append((nr, nc))\n\n                    objects.append((color, obj_coords))  # Store color and coordinates\n\n        return objects\n\n    objs = find_objects(I_np, most_common_value)\n    <end_of_step>\n\n    # go through the objects and find the symmetric object (there always is one)\n    symmetric_object_coords = []\n    for color, coords in objs:\n\n        rows, cols = zip(*coords)\n        min_r, max_r = min(rows), max(rows)\n        min_c, max_c = min(cols), max(cols)\n        obj_h = max_r - min_r + 1\n        obj_w = max_c - min_c + 1\n\n        # Create a set of relative coordinates for quick lookups\n        relative_coords = set((r - min_r, c - min_c) for r, c in coords)\n        <end_of_step>\n\n        # Check for horizontal symmetry\n        is_horizontally_symmetric = True\n        for r_rel, c_rel in relative_coords:\n            if (r_rel, obj_w - 1 - c_rel) not in relative_coords:\n                is_horizontally_symmetric = False\n                break\n\n        # An object is considered symmetric if it has either horizontal or vertical symmetry\n        if is_horizontally_symmetric:\n            symmetric_object_coords = coords  # Keep track of coords separately for bbox\n            break  # Found the first symmetric object, stop searching\n    <end_of_step>\n\n    # find the bounding box of that object and return the corresponding subgrid\n    rows, cols = zip(*symmetric_object_coords)\n    min_r, max_r = min(rows), max(rows)\n    min_c, max_c = min(cols), max(cols)\n    <end_of_step>\n\n    # Extract the subgrid using numpy slicing\n    output_grid = I_np[min_r:max_r + 1, min_c:max_c + 1]\n    <end_of_step>\n\n    # Convert back to list of lists and return\n    return output_grid.tolist()\n<end_of_code>"}
{"task_name": "28e73c20", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # get the size of the square grid and copy the grid\n    n = len(I)\n    O = [row[:] for row in I]\n    <end_of_step>\n\n    # different directions in clockwise order\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    <end_of_step>\n\n    # start at the top left of the grid with direction index 0 and the corresponding direction\n    cx, cy = 0, 0\n    di = 0\n    dx, dy = directions[di]\n    <end_of_step>\n\n    # while True loop to handle the breaking in different cases inside the loop\n    while True:\n        # set current cell to 3: the \"drawing color\"\n        O[cy][cx] = 3\n        <end_of_step>\n\n        # check whether going in the current direction would lead out of bounds and update direction\n        if not (0 <= cy + dy < n) or not (0 <= cx + dx < n):\n            di = (di + 1) % len(directions)\n        <end_of_step>\n\n        # check whether two cells forwards is in bounds and whether it is already filled: turn early to leave one empty cell between spiral passes\n        elif (0 <= cy + 2 * dy < n and 0 <= cx + 2 * dx < n) and O[cy + 2 * dy][cx + 2 * dx] == 3:\n            di = (di + 1) % len(directions)\n        <end_of_step>\n\n        # update the direction according to the direction index\n        dx, dy = directions[di]\n        <end_of_step>\n\n        # check whether we reached the middle of the spiral and break\n        # consider the even and uneven grid size case\n        if O[cy + dy][cx + dx] == 3 or (0 <= cy + 2 * dy < n and 0 <= cx + 2 * dx < n and O[cy + 2 * dy][cx + 2 * dx] == 3):\n            break\n        <end_of_step>\n\n        # update the current coordinates\n        cx += dx\n        cy += dy\n        <end_of_step>\n\n    return O\n<end_of_code>"}
{"task_name": "10fcaaa3", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Find the least common color in the input grid I.\n    # Convert the input list of lists to a NumPy array.\n    # Then, flatten the array to count all color occurrences easily.\n    # min() behavior on (count, color) tuples will pick the smallest color value among those tied.\n    import numpy as np\n\n    I_np = np.array(I)\n    colors, counts = np.unique(I_np, return_counts=True)\n    least_common_color = min(zip(counts, colors), key=lambda x: x[0])[1]\n    <end_of_step>\n\n    # Create a 2x2 tiled grid from the input grid.\n    # First, concatenate the input grid with itself horizontally (doubling width).\n    # Then, concatenate the resulting grid with itself vertically (doubling height).\n    horizontally_doubled_grid = np.concatenate((I_np, I_np), axis=1)\n    tiled_grid = np.concatenate((horizontally_doubled_grid, horizontally_doubled_grid), axis=0)\n    tiled_grid_height, tiled_grid_width = tiled_grid.shape\n    <end_of_step>\n\n    # Find the coordinates of all cells containing the least common color in the tiled grid.\n    # Use np.where to get the row and column indices where the grid equals the least_common_color.\n    # Zip these indices into a set of (row, col) tuples.\n    rows, cols = np.where(tiled_grid == least_common_color)\n    least_color_indices = set(zip(rows, cols))\n    <end_of_step>\n\n    # Find all unique diagonal neighbors for all cells identified in least_color_indices.\n    # Iterate through each coordinate (r, c) found in the previous step.\n    # For each, calculate the four diagonal neighbors: (r-1, c-1), (r-1, c+1), (r+1, c-1), (r+1, c+1).\n    # Add all calculated neighbor coordinates to a set to store only unique locations.\n    diagonal_neighbor_indices = set()\n    for r, c in least_color_indices:\n        neighbors = [\n            (r - 1, c - 1), (r - 1, c + 1),\n            (r + 1, c - 1), (r + 1, c + 1)\n        ]\n        diagonal_neighbor_indices.update(neighbors)\n    <end_of_step>\n\n    # Fill diagonal neighbors with 8 if they are background color.\n    # First, determine the background color of the tiled_grid (most common color).\n    # Similar to Step 1, but find the color with the *maximum* count. max() on (count, color) tuples\n    colors_tiled, counts_tiled = np.unique(tiled_grid, return_counts=True)\n    background_color = max(zip(counts_tiled, colors_tiled), key=lambda x: x[0])[1]\n\n    # Create a copy of the tiled grid to modify.\n    output_grid = np.copy(tiled_grid)\n    <end_of_step>\n\n    # Iterate through the calculated diagonal neighbor indices.\n    # For each neighbor coordinate (nr, nc):\n    #   - Check if it's within the grid boundaries.\n    #   - Check if the color at that location in the *original* tiled_grid is the background color.\n    #   - If both are true, set the color in the output_grid at (nr, nc) to 8.\n    for nr, nc in diagonal_neighbor_indices:\n        if 0 <= nr < tiled_grid_height and 0 <= nc < tiled_grid_width:\n            if tiled_grid[nr, nc] == background_color:\n                output_grid[nr, nc] = 8\n    <end_of_step>\n\n    # Return the final modified grid.\n    # Convert the NumPy array back to a list of lists format.\n    O = output_grid.tolist()\n    <end_of_step>\n\n    return O\n<end_of_code>"}
{"task_name": "150deff5", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # dimensions of grid\n    # output grid initialized with background 0's\n    # used mask to mark which foreground cells have been covered\n    R, C = len(I), len(I[0])\n    O = [[0 for _ in range(C)] for _ in range(R)]\n    used = [[False for _ in range(C)] for _ in range(R)]\n    <end_of_step>\n\n    # Define the pieces and their rotations.\n    # Each piece is a tuple: (list of (dr, dc) offsets, value to fill)\n    pieces = [\n        # 2x2 block (value 8) -- only one orientation\n        ([(0, 0), (0, 1), (1, 0), (1, 1)], 8),\n        # 1x3 bar (value 2) horizontal\n        ([(0, 0), (0, 1), (0, 2)], 2),\n        # 1x3 bar (value 2) vertical (rotation)\n        ([(0, 0), (1, 0), (2, 0)], 2)\n    ]\n    <end_of_step>\n\n    # Helper function to check if placement is valid.\n    def can_place(r0, c0, shape):\n        for dr, dc in shape:\n            r, c = r0 + dr, c0 + dc\n            if r < 0 or r >= R or c < 0 or c >= C:\n                return False\n            if I[r][c] != 5 or used[r][c]:\n                return False\n        return True\n    <end_of_step>\n\n    # Place a piece (mark cells in used and fill output grid)\n    def place(r0, c0, shape, val):\n        for dr, dc in shape:\n            r, c = r0 + dr, c0 + dc\n            used[r][c] = True\n            O[r][c] = val\n    <end_of_step>\n\n    # Remove a placed piece (backtrack)\n    def remove(r0, c0, shape):\n        for dr, dc in shape:\n            r, c = r0 + dr, c0 + dc\n            used[r][c] = False\n            O[r][c] = 0\n    <end_of_step>\n\n    # Find the next foreground cell that hasn't been covered\n    def find_next():\n        for r in range(R):\n            for c in range(C):\n                if I[r][c] == 5 and not used[r][c]:\n                    return r, c\n        return None\n    <end_of_step>\n\n    # Backtracking function to tile the foreground exactly.\n    def backtrack():\n        nxt = find_next()\n        if nxt is None:\n            return True  # all foreground cells are covered\n        r, c = nxt\n        # Try to place each piece in such a way that one of its cells covers (r, c)\n        for shape, val in pieces:\n            # For each cell in the piece shape, consider aligning that cell with (r, c)\n            for (dr_anchor, dc_anchor) in shape:\n                # Compute top-left anchor for the piece placement\n                r0, c0 = r - dr_anchor, c - dc_anchor\n                # Check if piece placed at (r0, c0) is valid\n                if can_place(r0, c0, shape):\n                    place(r0, c0, shape, val)\n                    if backtrack():\n                        return True\n                    remove(r0, c0, shape)\n        return False\n    <end_of_step>\n\n    # Run the backtracking tiling.\n    backtrack()\n    <end_of_step>\n\n    # return the tiled output grid\n    return O\n<end_of_code>"}
{"task_name": "228f6490", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Identify connected components (objects) in the input grid.\n    # We traverse every cell that is not background (in this case not 0) and use a DFS to collect all cells\n    # of the same color that are 4-connected. For each object, we also compute its bounding box and\n    # create a binary mask relative to that bounding box.\n    rows = len(I)\n    cols = len(I[0]) if rows else 0\n    visited = [[False] * cols for _ in range(rows)]\n    components = []  # will hold dictionaries with keys: 'color', 'cells', 'bbox', 'mask'\n    <end_of_step>\n\n    for i in range(rows):\n        for j in range(cols):\n            if I[i][j] != 0 and not visited[i][j]:\n                color = I[i][j]\n                stack = [(i, j)]\n                comp_cells = []\n                while stack:\n                    r, c = stack.pop()\n                    if not visited[r][c]:\n                        visited[r][c] = True\n                        comp_cells.append((r, c))\n                        # Check 4-connected neighbors\n                        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                            nr, nc = r + dr, c + dc\n                            if 0 <= nr < rows and 0 <= nc < cols:\n                                if not visited[nr][nc] and I[nr][nc] == color:\n                                    stack.append((nr, nc))\n                <end_of_step>\n\n                # Compute bounding box of the component\n                rmin = min(r for r, c in comp_cells)\n                rmax = max(r for r, c in comp_cells)\n                cmin = min(c for r, c in comp_cells)\n                cmax = max(c for r, c in comp_cells)\n                height = rmax - rmin + 1\n                width = cmax - cmin + 1\n                # Create a binary mask for the bounding box: True if the cell is part of the component.\n                mask = [[False] * width for _ in range(height)]\n                for r, c in comp_cells:\n                    mask[r - rmin][c - cmin] = True\n                components.append({\n                    'color': color,\n                    'cells': comp_cells,\n                    'bbox': (rmin, rmax, cmin, cmax),\n                    'mask': mask\n                })\n    <end_of_step>\n\n    # Separate the objects into two groups:\n    # (a) Objects of color 5 (which are rectangular with a hole) and\n    # (b) Other objects (the potential hole-fillers).\n    comp5 = [comp for comp in components if comp['color'] == 5]\n    comp_other = [comp for comp in components if comp['color'] != 5]\n    <end_of_step>\n\n    # For each color 5 object, determine its \"hole\" region.\n    # Since these objects are rectangular, their bounding box is completely covered by\n    # the object except where there is a hole. We compute the candidate hole cells (cells in the\n    # bounding box not belonging to the object) and then remove any cells that are connected to the\n    # bounding box border (they would not be enclosed).\n    from collections import deque\n\n    for comp in comp5:\n        rmin, rmax, cmin, cmax = comp['bbox']\n        height = rmax - rmin + 1\n        width = cmax - cmin + 1\n        # Create candidate mask: True if the cell (in the bounding box) is NOT part of the object.\n        candidate = [[not comp['mask'][i][j] for j in range(width)] for i in range(height)]\n        # Prepare a visited matrix for flood fill over candidate cells.\n        visited_cand = [[False] * width for _ in range(height)]\n        q = deque()\n        # Add all candidate cells on the border of the bounding box.\n        for i in range(height):\n            for j in range(width):\n                if (i == 0 or i == height - 1 or j == 0 or j == width - 1) and candidate[i][j]:\n                    q.append((i, j))\n                    visited_cand[i][j] = True\n        <end_of_step>\n\n        # Flood fill to mark candidate cells connected to the border.\n        while q:\n            i, j = q.popleft()\n            for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < height and 0 <= nj < width:\n                    if candidate[ni][nj] and not visited_cand[ni][nj]:\n                        visited_cand[ni][nj] = True\n                        q.append((ni, nj))\n        # The hole is defined as candidate cells that were NOT reached by the flood fill.\n        hole = [[candidate[i][j] and not visited_cand[i][j] for j in range(width)] for i in range(height)]\n        # Determine if a hole exists; if so, compute a normalized mask for the hole shape.\n        hole_cells = [(i, j) for i in range(height) for j in range(width) if hole[i][j]]\n        <end_of_step>\n\n        if not hole_cells:\n            comp['hole_mask'] = None  # No hole found\n        else:\n            # Compute the bounding box of the hole within the color 5 object's bounding box.\n            hi_min = min(i for i, j in hole_cells)\n            hi_max = max(i for i, j in hole_cells)\n            hj_min = min(j for i, j in hole_cells)\n            hj_max = max(j for i, j in hole_cells)\n            hole_height = hi_max - hi_min + 1\n            hole_width = hj_max - hj_min + 1\n            # Normalize the hole mask: create a smaller mask that captures the shape.\n            norm_hole = [[False] * hole_width for _ in range(hole_height)]\n            for i in range(hi_min, hi_max + 1):\n                for j in range(hj_min, hj_max + 1):\n                    norm_hole[i - hi_min][j - hj_min] = hole[i][j]\n            comp['hole_mask'] = norm_hole\n            comp['hole_bbox'] = (hi_min, hi_max, hj_min, hj_max)\n    <end_of_step>\n\n    # For each non-color-5 object (the potential hole-filler), compute its normalized mask.\n    # The normalized mask is the object's binary mask cropped to its own bounding box.\n    for comp in comp_other:\n        rmin, rmax, cmin, cmax = comp['bbox']\n        height = rmax - rmin + 1\n        width = cmax - cmin + 1\n        # The object's mask (already computed) is exactly its normalized mask.\n        comp['norm_mask'] = comp['mask']\n        comp['norm_bbox'] = (0, height - 1, 0, width - 1)\n    <end_of_step>\n\n    # Exclude non-color-5 objects if there are multiple objects of the same color.\n    # Compute the frequency of each color among non-color-5 objects.\n    from collections import Counter\n\n    color_count = Counter(comp['color'] for comp in comp_other)\n    <end_of_step>\n\n    # Match each hole in a color 5 object with a non-color-5 object whose shape fits exactly.\n    # Only consider objects that are unique in their color (i.e. appear exactly once).\n    move_mapping = []  # will store tuples: (hole_global_coords, filler_object_cells, filler_color)\n    used = set()  # to mark non-5 objects that have been moved already\n    for comp5_obj in comp5:\n        if comp5_obj['hole_mask'] is None:\n            continue  # skip if no hole was found\n        hole_mask = comp5_obj['hole_mask']\n        hole_h = len(hole_mask)\n        hole_w = len(hole_mask[0])\n        # Try to find a matching non-5 component that is unique by color.\n        for idx, comp in enumerate(comp_other):\n            # Only consider this object if it is the sole object of its color.\n            if color_count[comp['color']] > 1:\n                continue\n            if idx in used:\n                continue\n            norm_mask = comp['norm_mask']\n            h = len(norm_mask)\n            w = len(norm_mask[0])\n            if h == hole_h and w == hole_w:\n                match = True\n                for i in range(h):\n                    for j in range(w):\n                        if norm_mask[i][j] != hole_mask[i][j]:\n                            match = False\n                            break\n                    if not match:\n                        break\n                if match:\n                    # Compute the global coordinates of the hole in the grid.\n                    hi_min, hi_max, hj_min, hj_max = comp5_obj['hole_bbox']\n                    r_offset, _, c_offset, _ = comp5_obj['bbox']\n                    hole_global = [(r_offset + i, c_offset + j)\n                                   for i in range(hi_min, hi_max + 1)\n                                   for j in range(hj_min, hj_max + 1)\n                                   if comp5_obj['hole_mask'][i - hi_min][j - hj_min]]\n                    move_mapping.append((hole_global, comp['cells'], comp['color']))\n                    used.add(idx)\n                    break\n    <end_of_step>\n\n    # Create the output grid by first copying the input grid.\n    # Then, for each matched pair (hole and filler object), we \"move\" the filler into the hole.\n    # This is done by filling the hole cells with the filler object's color and turning the filler\u2019s\n    # original cells into background (0).\n    O = [row[:] for row in I]\n    for hole_coords, filler_cells, filler_color in move_mapping:\n        # Fill the hole with the filler object's color.\n        for r, c in hole_coords:\n            O[r][c] = filler_color\n        # Erase the filler object from its original location.\n        for r, c in filler_cells:\n            O[r][c] = 0\n    <end_of_step>\n\n    # Return the output grid\n    return O\n<end_of_code>"}
{"task_name": "00d62c1b", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Define helper function to find a connected component using BFS\n    # Every cell in a component has the same value\n    # The function returns the value and a frozen set of coordinates in the component\n    def find_component(grid, start_row, start_col, vis):\n        h, w = len(grid), len(grid[0])\n        val = grid[start_row][start_col]\n        comp = set()\n        queue = [(start_row, start_col)]\n\n        while queue:\n            r, c = queue.pop(0)\n            if r < 0 or r >= h or c < 0 or c >= w or vis[r][c] or grid[r][c] != val:\n                continue\n\n            vis[r][c] = True\n            comp.add((r, c))\n\n            # Add the four adjacent neighbors (no diagonals) i.e. 4-connectedness\n            queue.extend([(r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1)])\n\n        return val, comp\n    <end_of_step>\n\n    # Define helper function to check if a component touches the border\n    def is_border_touching(comp, h, w):\n        for r, c in comp:\n            if r == 0 or r == h - 1 or c == 0 or c == w - 1:\n                return True\n        return False\n    <end_of_step>\n\n    # Copy the input grid and get dimensions\n    output = [row[:] for row in I]\n    height, width = len(I), len(I[0])\n    <end_of_step>\n\n    # Initialize visited cells tracker\n    visited = [[False for _ in range(width)] for _ in range(height)]\n    <end_of_step>\n\n    # Find all connected components in the grid and store them in a set\n    components = []\n    for i in range(height):\n        for j in range(width):\n            if not visited[i][j]:\n                value, component = find_component(I, i, j, visited)\n                components.append((value, component))\n    <end_of_step>\n\n    # Find all color 0 components that don't touch the border\n    non_border_components = []\n    for value, component in components:\n        if value == 0 and not is_border_touching(component, height, width):\n            non_border_components.append(component)\n    <end_of_step>\n\n    # Fill all cells in non-border components with value 4\n    for component in non_border_components:\n        for row, column in component:\n            output[row][column] = 4\n    <end_of_step>\n\n    # Return the transformed grid\n    return output\n<end_of_code>"}
{"task_name": "1cf80156", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Import numpy and convert input to numpy array for easier manipulation\n    import numpy as np\n\n    I_np = np.array(I)\n    <end_of_step>\n\n    # Find rows containing non-zero values and determine min and max of non-zero row indices\n    non_zero_rows = [i for i in range(len(I)) if any(val != 0 for val in I[i])]\n    min_row, max_row = min(non_zero_rows), max(non_zero_rows)\n    <end_of_step>\n\n    # Find columns containing non-zero values and determine min and max of non-zero column indices\n    non_zero_cols = [j for j in range(len(I[0])) if any(I[i][j] != 0 for i in range(len(I)))]\n    min_col, max_col = min(non_zero_cols), max(non_zero_cols)\n    <end_of_step>\n\n    # Extract smallest subgrid containing all non-zero values using numpy slicing i.e. the bounding box\n    O = I_np[min_row:max_row + 1, min_col:max_col + 1].tolist()\n    <end_of_step>\n\n    # Return the output subgrid\n    return O\n<end_of_code>"}
{"task_name": "63613498", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Extract the 3x3 top\u2010left subgrid as the reference region.\n    # We will only consider this 3x3 region to extract the reference object.\n    ref_rows = 3\n    ref_cols = 3\n    <end_of_step>\n\n    # Define a helper function to perform a DFS to collect a connected component.\n    # The DFS will only traverse cells within the specified row and column bounds,\n    # and will only consider non-zero cells (i.e. part of an object).\n    def dfs(grid, start_i, start_j, visited, rmin, rmax, cmin, cmax):\n        comp = []  # list to store coordinates of the connected component\n        stack = [(start_i, start_j)]\n        while stack:\n            i, j = stack.pop()\n            if (i, j) in visited:\n                continue\n            visited.add((i, j))\n            # Only process cells that are within bounds and non-zero.\n            if not (rmin <= i <= rmax and cmin <= j <= cmax):\n                continue\n            if grid[i][j] == 0:\n                continue\n            comp.append((i, j))\n            # Check the four 4-connected neighbors (up, down, left, right).\n            for di, dj in [(1,0), (-1,0), (0,1), (0,-1)]:\n                ni, nj = i + di, j + dj\n                if rmin <= ni <= rmax and cmin <= nj <= cmax:\n                    if (ni, nj) not in visited and grid[ni][nj] != 0:\n                        stack.append((ni, nj))\n        return comp\n    <end_of_step>\n\n    # Find the reference object within the 3x3 subgrid.\n    # We look for the first non-zero cell and perform DFS within the 3x3 bounds.\n    ref_visited = set()\n    ref_comp = []\n    found_ref = False\n    for i in range(ref_rows):\n        for j in range(ref_cols):\n            if I[i][j] != 0 and (i, j) not in ref_visited:\n                ref_comp = dfs(I, i, j, ref_visited, 0, ref_rows - 1, 0, ref_cols - 1)\n                found_ref = True\n                break\n        if found_ref:\n            break\n    <end_of_step>\n\n    # Normalize the reference component's shape.\n    # We compute the relative positions of the cells in the reference object,\n    # by subtracting the minimum row and column indices.\n    min_ref_i = min(i for i, j in ref_comp)\n    min_ref_j = min(j for i, j in ref_comp)\n    ref_shape = set((i - min_ref_i, j - min_ref_j) for i, j in ref_comp)\n    <end_of_step>\n\n    # Scan the entire grid to identify all connected components of non-zero cells.\n    # We will compare the normalized shape of each component to the reference shape.\n    # We must ignore the reference object (which is contained in the top-left 3x3 subgrid).\n    n_rows = len(I)\n    n_cols = len(I[0]) if n_rows > 0 else 0\n    full_visited = set()\n    match_comp = None  # This will store the coordinates of the matched object\n\n    for i in range(n_rows):\n        for j in range(n_cols):\n            if I[i][j] != 0 and (i, j) not in full_visited:\n                # Perform DFS over the entire grid to get the connected component.\n                comp = dfs(I, i, j, full_visited, 0, n_rows - 1, 0, n_cols - 1)\n                # Skip the component if it is exactly the reference object\n                # (i.e. if all its cells lie within the top-left 3x3 region).\n                if all(i < ref_rows and j < ref_cols for i, j in comp):\n                    continue\n                # Also skip the component if it is the delimiter of the 3x3 region\n                # This is exactly the object for which always at least on coordinate of a cell is 3\n                if all(i == ref_rows or j == ref_cols for i, j in comp):\n                    continue\n                # If the size of the component does not match, it cannot be a match.\n                if len(comp) != len(ref_shape):\n                    continue\n                # Normalize the component's shape.\n                min_i = min(x for x, y in comp)\n                min_j = min(y for x, y in comp)\n                comp_shape = set((x - min_i, y - min_j) for x, y in comp)\n                # Compare the shape with the reference shape.\n                if comp_shape == ref_shape:\n                    match_comp = comp\n                    break\n        if match_comp is not None:\n            break\n    <end_of_step>\n\n    # Change the color of the matched object to 5.\n    # Since there is always exactly one match, we update all cells in the matched component.\n    if match_comp is not None:\n        for i, j in match_comp:\n            I[i][j] = 5\n    <end_of_step>\n\n    # Return the modified grid as the output.\n    return I\n<end_of_code>"}
{"task_name": "3631a71a", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Convert input tuple of tuples to numpy array for efficient operations\n    import numpy as np\n\n    I_np = np.array(I)\n    rows, columns = I_np.shape\n    <end_of_step>\n\n    # Create grid x2 by replacing NINE (9) with ZERO (0) in the input grid I.\n    x1_np = np.where(I_np == 9, 0, I_np)\n    <end_of_step>\n\n    # Create grid x2 by transposing grid x1.\n    x2_np = np.transpose(x1_np)\n    <end_of_step>\n\n    # Create grid x3 by taking the element-wise maximum of x1 and x2.\n    # This combines the grid and its transpose by keeping the larger value at each cell.\n    x3_np = np.maximum(x1_np, x2_np)\n    <end_of_step>\n\n    # Crop grid x3, removing the outer 2 rows and columns.\n    # This makes sure the center of symmetry is in the center of x4_np\n    x4_np = x3_np[2:rows, 2:columns]\n    <end_of_step>\n\n    # Create grid x5 by horizontally mirroring (flipping left-to-right) grid x4.\n    x5_np = np.fliplr(x4_np)\n    <end_of_step>\n\n    # Create grid x6 by vertically mirroring (flipping up-to-down) grid x4.\n    x6_np = np.flipud(x4_np)\n    <end_of_step>\n\n    # Create grid x7 by taking the anti-diagonal transpose of grid x4.\n    x7_np = x4_np[::-1, ::-1].T\n    <end_of_step>\n\n    # Create grid x7 by taking the element-wise maximum of x4, x5 and x6.\n    # This combined the original and mirrored version of the subgrid.\n    x8_np = np.maximum(x7_np, np.maximum(x6_np, np.maximum(x4_np, x5_np)))\n    <end_of_step>\n\n    # Combine x3 and x7 by taking the element wise maximum of x7 and the corresponding subgrid of x3\n    O_np = x3_np.copy()\n    O_np[-(columns-2):, -(rows-2):] = np.maximum(O_np[-(columns-2):, -(rows-2):], x8_np)\n    <end_of_step>\n\n    # Convert the final numpy array back to a list of lists for the return value.\n    O = O_np.tolist()\n    <end_of_step>\n\n    return O\n<end_of_code>"}
{"task_name": "4290ef0e", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Convert the input grid to a NumPy array and determine the background color.\n    # The background is defined as the most frequent cell value in the grid.\n    import numpy as np\n    I_np = np.array(I)\n    colors, counts = np.unique(I_np, return_counts=True)\n    bg_color = max(zip(counts, colors), key=lambda x: x[0])[1]\n    <end_of_step>\n\n    # Group non-background cells by their color.\n    # For each cell that is not the background, record its coordinates.\n    # The result is a list of tuples (color, set_of_coordinates).\n    from collections import defaultdict\n\n    def get_fg_partitions(grid, bg):\n        parts = defaultdict(set)\n        for r, row in enumerate(grid):\n            for c, cell in enumerate(row):\n                if cell != bg:\n                    parts[cell].add((r, c))\n        return list(parts.items())\n\n    fg_partitions = get_fg_partitions(I, bg_color)\n    num_partitions = len(fg_partitions)\n    <end_of_step>\n\n    # Identify connected regions (components) of non-background cells.\n    # Cells are considered connected if they share an edge (4-neighbor connectivity)\n    # and have the same color. This function uses breadth-first search (BFS) to find groups.\n    from collections import deque\n\n    def get_connected_components(grid, diagonals, bg):\n        H, W = len(grid), len(grid[0]) if grid else 0\n        if H == 0 or W == 0:\n            return []\n        visited = np.zeros((H, W), dtype=bool)\n        components = []\n        for r in range(H):\n            for c in range(W):\n                if visited[r, c]:\n                    continue\n                # Skip cells that match the background color.\n                if bg is not None and grid[r][c] == bg:\n                    visited[r, c] = True\n                    continue\n                color = grid[r][c]\n                comp = set()\n                q = deque([(r, c)])\n                visited[r, c] = True\n                while q:\n                    cr, cc = q.popleft()\n                    comp.add((cr, cc))\n                    # Determine neighbor positions based on whether diagonal connectivity is allowed.\n                    if diagonals:\n                        neighbors = [(cr + dr, cc + dc)\n                                     for dr in (-1, 0, 1) for dc in (-1, 0, 1)\n                                     if not (dr == 0 and dc == 0)]\n                    else:\n                        neighbors = [(cr + 1, cc), (cr - 1, cc), (cr, cc + 1), (cr, cc - 1)]\n                    # Add valid neighbors that have the same color.\n                    for nr, nc in neighbors:\n                        if 0 <= nr < H and 0 <= nc < W and not visited[nr, nc] and grid[nr][nc] == color:\n                            visited[nr, nc] = True\n                            q.append((nr, nc))\n                components.append((color, comp))\n        return components\n\n    components = get_connected_components(I, diagonals=False, bg=bg_color)\n    <end_of_step>\n\n    # Calculate the dimensions of the bounding box for a given set of coordinates.\n    # This function returns the height and width needed to cover all points in the set.\n    def get_coords_dims(coords):\n        rows = [r for r, _ in coords]\n        cols = [c for _, c in coords]\n        return (max(rows) - min(rows) + 1, max(cols) - min(cols) + 1)\n    <end_of_step>\n\n    # Compute the minimum Manhattan distance between any two points from two sets of coordinates.\n    # This distance is the sum of the absolute differences in row and column indices.\n    def min_manhattan_distance(coords1, coords2):\n        return min(abs(r1 - r2) + abs(c1 - c2) for r1, c1 in coords1 for r2, c2 in coords2)\n    <end_of_step>\n\n    # For each foreground partition, compute a metric to determine its processing order.\n    # The metric is based on:\n    #   - The maximum width of connected components for that color (scaled by 2).\n    #   - The minimum Manhattan distance between distinct connected components (adjusted).\n    # A lower (more negative) metric indicates a higher priority.\n    sort_keys = {}\n    for i, (color, coords) in enumerate(fg_partitions):\n        # Select connected components that match the partition's color.\n        same_color_comps = [comp for c, comp in components if c == color]\n        if same_color_comps:\n            # Compute the maximum horizontal span (width) among the connected components.\n            max_width = max(get_coords_dims(comp)[1] for comp in same_color_comps)\n            width_term = 2 * max_width\n            # If there are multiple components, compute the minimum Manhattan distance between any two of them.\n            if len(same_color_comps) > 1:\n                dists = [min_manhattan_distance(same_color_comps[i], same_color_comps[j])\n                         for i in range(len(same_color_comps))\n                         for j in range(i + 1, len(same_color_comps))]\n                min_dist = min(dists) if dists else 0\n            else:\n                min_dist = 0\n            dist_term = (min_dist - 1) if min_dist > 0 else -2\n            metric = width_term + dist_term\n        else:\n            metric = 0\n        sort_keys[i] = -metric  # Invert the metric so that a lower value means higher priority.\n    <end_of_step>\n\n    # Sort the foreground partitions based on the computed metric.\n    # This order will be used in subsequent processing steps.\n    sorted_indices = sorted(sort_keys, key=sort_keys.get)\n    sorted_partitions = [fg_partitions[i] for i in sorted_indices]\n    <end_of_step>\n\n    # Define a function to compute the center of mass for a set of coordinates.\n    # The center is computed as the integer average of the row and column indices.\n    def center_of_mass(coords):\n        total_r = sum(r for r, _ in coords)\n        total_c = sum(c for _, c in coords)\n        n = len(coords)\n        return (total_r // n, total_c // n)\n    <end_of_step>\n\n    # Create a function to generate mirrored variants of a set of coordinates.\n    # The function supports various mirror modes:\n    # 'h' for horizontal (vertical flip), 'v' for vertical (horizontal flip),\n    # 'd' for diagonal (swap row and column offsets from the top-left),\n    # and 'c' for counter-diagonal (a composite transformation).\n    def mirror_coords(coords, mode):\n        if not coords:\n            return set()\n        min_r = min(r for r, _ in coords)\n        max_r = max(r for r, _ in coords)\n        min_c = min(c for _, c in coords)\n        max_c = max(c for _, c in coords)\n        if mode == 'h':  # Horizontal mirror: flip the coordinates over a horizontal axis.\n            axis = min_r + max_r\n            return {(axis - r, c) for r, c in coords}\n        elif mode == 'v':  # Vertical mirror: flip the coordinates over a vertical axis.\n            axis = min_c + max_c\n            return {(r, axis - c) for r, c in coords}\n        elif mode == 'd':  # Diagonal mirror: swap row and column displacements relative to the top-left corner.\n            anchor_r, anchor_c = min_r, min_c\n            return {(c - anchor_c + anchor_r, r - anchor_r + anchor_c) for r, c in coords}\n        elif mode == 'c':  # Counter-diagonal mirror: a composite transformation combining vertical and diagonal flips.\n            return mirror_coords(mirror_coords(mirror_coords(coords, 'v'), 'd'), 'v')\n        else:\n            return coords\n    <end_of_step>\n\n    # For each sorted foreground partition, generate mirrored variants.\n    # Select the variant whose center of mass is closest to the top-left corner as the canonical representation.\n    canonical_objects = []\n    for color, coords in sorted_partitions:\n        variants = []\n        for mode in ['v', 'd', 'c', 'h']:\n            mirrored = mirror_coords(coords, mode)\n            variants.append((mirrored, center_of_mass(mirrored)))\n        best_variant = min(variants, key=lambda x: x[1])[0]\n        canonical_objects.append((color, best_variant))\n    <end_of_step>\n\n    # Determine the size of the output pattern.\n    # If any foreground partition consists of a single cell, use the number of partitions;\n    # otherwise, add one to the number of partitions. The output canvas dimension is derived from this value.\n    N = num_partitions if any(len(coords) == 1 for _, coords in fg_partitions) else num_partitions + 1\n    out_dim = 2 * N - 1\n    <end_of_step>\n\n    # Define a function to translate a set of coordinates so that its minimum row and column become 0.\n    # This normalization aligns the top-left of the coordinate set with the origin (0,0).\n    def normalize_coords(coords):\n        if not coords:\n            return set()\n        min_r = min(r for r, _ in coords)\n        min_c = min(c for _, c in coords)\n        return {(r - min_r, c - min_c) for r, c in coords}\n    <end_of_step>\n\n    # Define a function to shift a set of coordinates by a specified (row, column) offset.\n    def shift_coords(coords, delta):\n        dr, dc = delta\n        return {(r + dr, c + dc) for r, c in coords}\n    <end_of_step>\n\n    # Normalize all canonical objects and merge them into one pattern.\n    # Each object is shifted diagonally by an increasing offset so that they do not overlap.\n    norm_objects = [(color, normalize_coords(coords)) for color, coords in canonical_objects]\n    merged_pattern = set()\n    for k, (color, coords) in enumerate(norm_objects):\n        shifted_coords = shift_coords(coords, (k, k))\n        for pt in shifted_coords:\n            merged_pattern.add((color, pt))\n    <end_of_step>\n\n    # Create an output canvas and define a function to apply the merged pattern onto it.\n    # The pattern is painted onto the canvas by replacing cells with the corresponding color,\n    # and the painting is repeated after each rotation to create a symmetric design.\n    def paint_merged_pattern(canvas, pattern_cells):\n        out = canvas.copy()\n        H, W = out.shape\n        for color, (r, c) in pattern_cells:\n            if 0 <= r < H and 0 <= c < W:\n                out[r, c] = color\n        return out\n    <end_of_step>\n\n    # Initialize the canvas with the background color.\n    # Paint the merged pattern and then perform three iterations of 90\u00b0 clockwise rotations.\n    # After each rotation, repaint the merged pattern to build the final symmetric design.\n    canvas = np.full((out_dim, out_dim), bg_color, dtype=int)\n    current_canvas = paint_merged_pattern(canvas, merged_pattern)\n    for _ in range(3):\n        current_canvas = np.rot90(current_canvas, k=-1)  # Rotate the canvas 90\u00b0 clockwise.\n        current_canvas = paint_merged_pattern(current_canvas, merged_pattern)\n    final_canvas = current_canvas\n    <end_of_step>\n\n    # Convert the final canvas (a NumPy array) into a list of lists to match the expected output format.\n    return final_canvas.tolist()\n<end_of_code>"}
{"task_name": "0ca9ddb6", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # define a set of tuple of the following format (value, (x, y))\n    # these cells are to be drawn in at the end\n    # the cells do not need to be in bounds as the in bounds check will be done in the draw function\n    # the cells will be drawn on top of the original grid\n    cells_to_draw = set()\n    <end_of_step>\n\n    # Get grid dimensions and define relative neighbor offsets\n    rows = len(I)\n    cols = len(I[0])\n    diagonal_offsets = [(-1, -1), (-1, 1), (1, -1), (1, 1)]\n    orthogonal_offsets = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    <end_of_step>\n\n    # Iterate through the grid *once* to find cells and determine neighbors\n    for r in range(rows):\n        for c in range(cols):\n            cell_value = I[r][c]\n\n            if cell_value == 2:\n                # Add the 4 diagonal neighbors for cells with value 2\n                # The drawn cells get value 4\n                value_to_draw = 4\n                offsets = diagonal_offsets\n            <end_of_step>\n\n            elif cell_value == 1:\n                # Add the 4 non-diagonal neighbors for cells with value 1\n                # The drawn cells get value 7\n                value_to_draw = 7\n                offsets = orthogonal_offsets\n            <end_of_step>\n\n            else:\n                # Skip other values\n                continue\n            <end_of_step>\n\n            # Calculate neighbor coordinates and add them to the set\n            for dr, dc in offsets:\n                neighbor_r, neighbor_c = r + dr, c + dc\n                cells_to_draw.add((value_to_draw, (neighbor_r, neighbor_c)))\n    <end_of_step>\n\n    # draw the cells on a copy of I\n    O = [row[:] for row in I]\n\n    for value, (x, y) in cells_to_draw:\n        # check if the cell coordinates are in bounds before drawing\n        if 0 <= x < rows and 0 <= y < cols:\n            O[x][y] = value\n    <end_of_step>\n\n    return O\n<end_of_code>"}
{"task_name": "6d0aefbc", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # horizontally mirror the grid by reversing the order of each row\n    x1 = [row[::-1] for row in I]\n    <end_of_step>\n\n    # horizontally concatenate the input grid with the horizontally mirrored grid by concatenating corresponding rows\n    O = [I[i] + x1[i] for i in range(len(I))]\n    <end_of_step>\n\n    # return the output grid\n    return O\n<end_of_code>"}
{"task_name": "27a28665", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # the background is 0\n    bg_color = 0\n    <end_of_step>\n\n    # define patterns fot pattern matching logic\n    # the values in the patterns represent true/false (1/0)\n    # unique input grid pattern 1\n    pattern1 = [\n        [1, 1, 0],\n        [1, 0, 1],\n        [0, 1, 0]\n    ]\n    <end_of_step>\n\n    # unique input grid pattern 2\n    pattern2 = [\n        [1, 0, 1],\n        [0, 1, 0],\n        [1, 0, 1]\n    ]\n    <end_of_step>\n\n    # unique input grid pattern 3\n    pattern3 = [\n        [0, 1, 1],\n        [0, 1, 1],\n        [1, 0, 0]\n    ]\n    <end_of_step>\n\n    # unique input grid pattern 4\n    pattern4 = [\n        [0, 1, 0],\n        [1, 1, 1],\n        [0, 1, 0]\n    ]\n    <end_of_step>\n\n    # convert the input grid to (1/0) based on the cells being non-background or background\n    binary_grid = [[1 if cell != bg_color else 0 for cell in row] for row in I]\n    <end_of_step>\n\n    # check which pattern matches the input grid\n    # if the input grid matches a pattern, return the corresponding output\n    # if the input grid matches a pattern1, return 1\n    if binary_grid == pattern1:\n        return [[1]]\n    <end_of_step>\n\n    # if the input grid matches a pattern2, return 2\n    elif binary_grid == pattern2:\n        return [[2]]\n    <end_of_step>\n\n    # if the input grid matches a pattern3, return 3\n    elif binary_grid == pattern3:\n        return [[3]]\n    <end_of_step>\n\n    # if the input grid matches a pattern4, return 6\n    elif binary_grid == pattern4:\n        return [[6]]\n    <end_of_step>\n\n    # default to background color if no pattern matches, but looking at the inputs, always one pattern matches\n    return [[bg_color]]\n<end_of_code>"}
