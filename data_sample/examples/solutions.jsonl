{"task_name": "6d0aefbc", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # vertically mirror the grid by reversing the order of each row\n    x1 = [row[::-1] for row in I]\n    <end_of_step>\n    \n    # horizontally concatenate the input grid with the vertically mirrored grid by concatenating corresponding rows\n    O = [I[i] + x1[i] for i in range(len(I))]\n    <end_of_step>\n    \n    # return the output grid\n    return O\n<end_of_code>"}
{"task_name": "1cf80156", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Import numpy and convert input to numpy array for easier manipulation\n    import numpy as np\n    \n    I_np = np.array(I)\n    <end_of_step>\n    \n    # Find rows containing non-zero values and determine min and max of non-zero row indices\n    non_zero_rows = [i for i in range(len(I)) if any(val != 0 for val in I[i])]\n    min_row, max_row = min(non_zero_rows), max(non_zero_rows)\n    <end_of_step>\n    \n    # Find columns containing non-zero values and determine min and max of non-zero column indices\n    non_zero_cols = [j for j in range(len(I[0])) if any(I[i][j] != 0 for i in range(len(I)))]\n    min_col, max_col = min(non_zero_cols), max(non_zero_cols)\n    <end_of_step>\n    \n    # Extract smallest subgrid containing all non-zero values using numpy slicing\n    O = I_np[min_row:max_row+1, min_col:max_col+1].tolist()\n    <end_of_step>\n    \n    # Return the output subgrid\n    return O\n<end_of_code>"}
{"task_name": "00d62c1b", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Define helper function to find a connected component using BFS\n    def find_component(grid, start_row, start_col, visited):\n        height, width = len(grid), len(grid[0])\n        value = grid[start_row][start_col]\n        component = []\n        queue = [(start_row, start_col)]\n        \n        while queue:\n            r, c = queue.pop(0)\n            if (r < 0 or r >= height or c < 0 or c >= width or \n                visited[r][c] or grid[r][c] != value):\n                continue\n            \n            visited[r][c] = True\n            component.append((r, c))\n            \n            # Add the four adjacent neighbors (no diagonals)\n            queue.extend([(r+1, c), (r-1, c), (r, c+1), (r, c-1)])\n                \n        return value, component\n    <end_of_step>\n    \n    # Define helper function to check if a component touches the border\n    def is_border_touching(component, height, width):\n        for r, c in component:\n            if r == 0 or r == height-1 or c == 0 or c == width-1:\n                return True\n        return False\n    <end_of_step>\n    \n    # Copy the input grid and get dimensions\n    output = [row[:] for row in I]\n    height, width = len(I), len(I[0])\n    <end_of_step>\n    \n    # Initialize visited cells tracker\n    visited = [[False for _ in range(width)] for _ in range(height)]\n    <end_of_step>\n    \n    # Find all connected components in the grid\n    components = []\n    for i in range(height):\n        for j in range(width):\n            if not visited[i][j]:\n                value, component = find_component(I, i, j, visited)\n                if component:\n                    components.append((value, component))\n    <end_of_step>\n    \n    # Find all color 0 components that don't touch the border\n    non_border_components = []\n    for value, component in components:\n        if value == 0 and not is_border_touching(component, height, width):\n            non_border_components.append(component)\n    <end_of_step>\n    \n    # Fill all cells in non-border components with value 4\n    for component in non_border_components:\n        for r, c in component:\n            output[r][c] = 4\n    <end_of_step>\n    \n    # Return the transformed grid\n    return output\n<end_of_code>"}
{"task_name": "e3497940", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Import numpy and convert the input tuple of tuples to a NumPy array for efficient slicing and manipulation.\n    import numpy as np\n\n    I_np = np.array(I)\n    height, width = I_np.shape\n    <end_of_step>\n\n    # The line of 5s in the middle is a delimiter, splitting the grid down the middle.\n    # Calculate the midpoint column index for splitting the grid.\n    mid_col = width // 2\n    <end_of_step>\n\n    # Extract the left half of the grid (all rows, columns 0 up to mid_col).\n    left_half = I_np[:, :mid_col].copy()  # Copy to avoid modifying original data.\n    <end_of_step>\n\n    # Extract the right half of the grid (all rows, columns from mid_col to the end).\n    right_half = I_np[:, mid_col+1:]\n    <end_of_step>\n\n    # Mirror the right half horizontally (flip left-to-right).\n    mirrored_right = np.fliplr(right_half)\n    <end_of_step>\n\n    # The background color is zero.\n    bg_color = 0\n    <end_of_step>\n\n    # Overlay the mirrored right half onto the left half.\n    # For each cell in the left half: if its value equals the background color, replace it with the corresponding cell from the mirrored right half.\n    # This ensures that if one side is background and the other is non-background, the non-background value is chosen.\n    O_np = np.where(left_half == bg_color, mirrored_right, left_half)\n    <end_of_step>\n\n    # Convert the final NumPy array back to a list of lists format and return.\n    return O_np.tolist()\n<end_of_code>"}
{"task_name": "8f2ea7aa", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # The background color is black and calculate number of rows and columns\n    bg_color = 0\n    <end_of_step>\n\n    # The foreground consists of a single object, thus all non-zero cells are one object\n    foreground_pixels = [(r, c) for r, row in enumerate(I) for c, val in enumerate(row) if val != bg_color]\n    <end_of_step>\n\n    # Convert the input grid (list of lists) to a NumPy array for efficient processing.\n    import numpy as np\n\n    I_np = np.array(I)\n    <end_of_step>\n\n\n    # Determine the minimum bounding box that encloses all identified foreground pixels.\n    # Extract the row and column coordinates.\n    rows, cols = zip(*foreground_pixels)\n    # Find the minimum and maximum row and column indices.\n    min_row, max_row = min(rows), max(rows)\n    min_col, max_col = min(cols), max(cols)\n    <end_of_step>\n\n    # Extract the smallest rectangular subgrid from the original input array that contains all foreground pixels.\n    x_sub = I_np[min_row: max_row + 1, min_col: max_col + 1]\n    <end_of_step>\n\n    # Upscale the extracted subgrid so that its dimensions match the original grid.\n    # np.kron uses the Kronecker product: each element of x_sub is replaced by a block of size factor x factor.\n    # The scaling factor is determined by dividing the original grid size by the subgrid's height under the observed fact that the object's bounding box is always quadratic.\n    factor = len(I) // (max_row - min_row + 1)\n    x_upscaled = np.kron(x_sub, np.ones((factor, factor), dtype=int))\n    <end_of_step>\n\n    # Create a tiling of the extracted subgrid by repeating it 'factor' times in both dimensions.\n    x_tiled = np.tile(x_sub, (factor, factor))\n    <end_of_step>\n\n    # Perform a cell-wise comparison between the upscaled grid (x_upscaled) and the tiled grid (x_tiled).\n    # If the values at a given position are the same in both grids, retain that value.\n    # Otherwise, set the value the background color.\n    O_np = np.where(x_upscaled == x_tiled, x_upscaled, bg_color)\n    <end_of_step>\n\n    # Convert the final resulting NumPy array back into the required format (list of lists).\n    O = O_np.tolist()\n    <end_of_step>\n\n    # Return the final computed grid.\n    return O\n<end_of_code>"}
{"task_name": "3e980e27", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # Import numpy and convert the input grid to a NumPy array.\n    import numpy as np\n\n    I_np = np.array(I)\n    <end_of_step>\n\n    # calculate the background color, in this case the most common color\n    colors, counts = np.unique(I_np, return_counts=True)\n    background_color = max(zip(counts, colors), key=lambda x: x[0])[1]\n    <end_of_step>\n\n    # find all non-background objects\n    # that is in this case 8-connected components of non-background colors\n    # the objects are stored in a list and each object is a list of tuples\n    # where each tuple is a (color, (row, column)) pair\n    objects = []\n    visited = np.zeros_like(I_np, dtype=bool)\n    height, width = I_np.shape\n\n    for r in range(height):\n        for c in range(width):\n            if not visited[r, c] and I_np[r, c] != background_color:\n                obj = []\n                q = [(r, c)]\n                visited[r, c] = True\n\n                while q:\n                    cr, cc = q.pop(0)\n                    obj.append((I_np[cr, cc], (cr, cc)))\n\n                    for dr in [-1, 0, 1]:\n                        for dc in [-1, 0, 1]:\n                            if (dr == 0 and dc == 0) or (not (0 <= cr + dr < height and 0 <= cc + dc < width)):\n                                continue\n                            if not visited[cr + dr, cc + dc] and I_np[cr + dr, cc + dc] != background_color:\n                                visited[cr + dr, cc + dc] = True\n                                q.append((cr + dr, cc + dc))\n\n                objects.append(obj)\n    <end_of_step>\n\n    # extract single cell objects and partition them by color\n    two_single_cells = [obj[0] for obj in objects if len(obj) == 1 and obj[0][0] == 2]\n    three_single_cells = [obj[0] for obj in objects if len(obj) == 1 and obj[0][0] == 3]\n    <end_of_step>\n\n    # extract the up to two objects with more than one cell and partition them by color\n    # set the object to None if there are no objects of that color\n    two_template_objects = [obj for obj in objects if len(obj) > 1 and 2 in [cell[0] for cell in obj]]\n    three_template_objects = [obj for obj in objects if len(obj) > 1 and 3 in [cell[0] for cell in obj]]\n\n    two_template_object = two_template_objects[0] if two_template_objects else None\n    three_template_object = three_template_objects[0] if three_template_objects else None\n    <end_of_step>\n\n    # horizontally flip the two_template_object around it's 2 cell if it exists\n    two_template_two_cell = None\n    flipped_two_template_object = None\n    if two_template_object is not None:\n        two_template_two_cell = [cell for cell in two_template_object if cell[0] == 2][0]\n        flipped_two_template_object = [two_template_two_cell]\n        for cell in two_template_object:\n            if cell != two_template_two_cell:\n                relative_x = cell[1][1] - two_template_two_cell[1][1]\n                flipped_cell= (cell[0], (cell[1][0], two_template_two_cell[1][1] - relative_x))\n                flipped_two_template_object.append(flipped_cell)\n    <end_of_step>\n\n    # extract the three template three cell\n    three_template_three_cell = None\n    if three_template_object is not None:\n        three_template_three_cell = [cell for cell in three_template_object if cell[0] == 3][0]\n    <end_of_step>\n\n    # calculate the offsets of the single sells to their corresponding template\n    # this is done while making sure that the template is not None\n    two_offsets = []\n    if two_template_two_cell is not None:\n        for cell in two_single_cells:\n            two_offsets.append((cell[1][0] - two_template_two_cell[1][0], cell[1][1] - two_template_two_cell[1][1]))\n\n    three_offsets = []\n    if three_template_three_cell is not None:\n        for cell in three_single_cells:\n            three_offsets.append((cell[1][0] - three_template_three_cell[1][0], cell[1][1] - three_template_three_cell[1][1]))\n    <end_of_step>\n\n    # calculate the set that needs to be drawn for the two and three cells\n    cells_to_draw = []\n    if flipped_two_template_object is not None:\n        cells_to_draw.extend(two_template_object)\n        for offset in two_offsets:\n            cells_to_draw.extend([(cell[0], (cell[1][0] + offset[0], cell[1][1] + offset[1])) for cell in flipped_two_template_object])\n\n    if three_template_object is not None:\n        cells_to_draw.extend(three_template_object)\n        for offset in three_offsets:\n            cells_to_draw.extend([(cell[0], (cell[1][0] + offset[0], cell[1][1] + offset[1])) for cell in three_template_object])\n    <end_of_step>\n\n    # draw the cells on an \"empty\" grid i.e. a grid filled with the background color\n    O_np = I_np.copy()\n    O_np.fill(background_color)\n\n    for cell in cells_to_draw:\n        O_np[cell[1]] = cell[0]\n    <end_of_step>\n\n    # convert the output grid back to a list of lists and return it\n    return O_np.tolist()\n<end_of_code>"}
{"task_name": "28e73c20", "solution_code": "<beginning_of_code>\ndef solve(I):\n    # get the size of the square grid and copy the grid\n    n = len(I)\n    O = [row[:] for row in I]\n    <end_of_step>\n\n    # different directions in clockwise order\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    <end_of_step>\n\n    # start at the top left of the grid with direction index 0 and the corresponding direction\n    cx, cy = 0, 0\n    di = 0\n    dx, dy = directions[di]\n    <end_of_step>\n\n    # while True loop to handle the breaking in different cases inside the loop\n    while True:\n        # set current cell to 3: the \"drawing color\"\n        O[cy][cx] = 3\n        <end_of_step>\n\n        # check whether going in the current direction would lead out of bounds and update direction\n        if not (0 <= cy + dy < n) or not (0 <= cx + dx < n):\n            di = (di + 1) % len(directions)\n        <end_of_step>\n\n        # check whether two cells forwards is in bounds and whether it is already filled: turn early to leave one empty cell between spiral passes\n        elif (0 <= cy + 2 * dy < n and 0 <= cx + 2 * dx < n) and O[cy + 2 * dy][cx + 2 * dx] == 3:\n            di = (di + 1) % len(directions)\n        <end_of_step>\n\n        # update the direction according to the direction index\n        dx, dy = directions[di]\n        <end_of_step>\n\n        # check whether we reached the middle of the spiral and break\n        # consider the even and uneven grid size case\n        if O[cy + dy][cx + dx] == 3 or (0 <= cy + 2 * dy < n and 0 <= cx + 2 * dx < n and O[cy + 2 * dy][cx + 2 * dx] == 3):\n            break\n        <end_of_step>\n\n        # update the current coordinates\n        cx += dx\n        cy += dy\n        <end_of_step>\n\n    return O\n<end_of_code>"}
